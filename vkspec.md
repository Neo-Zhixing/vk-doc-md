[{generated}/specattribs.adoc]({generated}/specattribs.adoc)



# Vulkan^®^ {revnumber} - A Specification {apititle}

The Khronos\<sup>®\</sup> Vulkan  Working Group
:data-uri:
:icons: font
:toc2:
:toclevels: 2
:numbered:
:source-highlighter: rouge
:rouge-style: github
:docinfo: shared-header
:docinfodir: {config}/vulkan
:title-logo-image:&#x20;
:attribute-missing: warn





# Preamble

Copyright 2014-2023 The Khronos Group Inc.

This Specification is protected by copyright laws and contains material
proprietary to Khronos. Except as described by these terms, it or any
components may not be reproduced, republished, distributed, transmitted,
displayed, broadcast or otherwise exploited in any manner without the
express prior written permission of Khronos.

Khronos grants a conditional copyright license to use and reproduce the
unmodified Specification for any purpose, without fee or royalty, EXCEPT no
licenses to any patent, trademark or other intellectual property rights are
granted under these terms.

Khronos makes no, and expressly disclaims any, representations or
warranties, express or implied, regarding this Specification, including,
without limitation: merchantability, fitness for a particular purpose,
non-infringement of any intellectual property, correctness, accuracy,
completeness, timeliness, and reliability. Under no circumstances will
Khronos, or any of its Promoters, Contributors or Members, or their
respective partners, officers, directors, employees, agents or
representatives be liable for any damages, whether direct, indirect, special
or consequential damages for lost revenues, lost profits, or otherwise,
arising from or in connection with these materials.

This document contains extensions which are not ratified by Khronos, and as
such is not a ratified Specification, though it contains text from (and is a
superset of) the ratified Vulkan Specification. The ratified versions
of the Vulkan Specification can be found at <https://registry.khronos.org/vulkan/specs/1.3/html/vkspec.html> (core only)
and <https://registry.khronos.org/vulkan/specs/1.3-khr-extensions/html/vkspec.html> (core with all ratified extensions)
.

This Specification contains substantially unmodified functionality from, and
is a successor to, Khronos specifications including
OpenGL, OpenGL ES and OpenCL.

The Khronos Intellectual Property Rights Policy defines the terms 'Scope',
'Compliant Portion', and 'Necessary Patent Claims'.

Some parts of this Specification are purely informative and so are EXCLUDED
the Scope of this Specification. The  section of
the  defines how these parts of the Specification are
identified.

Where this Specification uses technical terminology, defined in the Glossary or otherwise,
that refer to enabling technologies that are not expressly set forth in this
Specification, those enabling technologies are EXCLUDED from the Scope of
this Specification. For clarity, enabling technologies not disclosed with
particularity in this Specification (e.g. semiconductor manufacturing
technology, hardware architecture, processor architecture or
microarchitecture, memory architecture, compiler technology, object oriented
technology, basic operating system technology, compression technology,
algorithms, and so on) are NOT to be considered expressly set forth; only
those application program interfaces and data structures disclosed with
particularity are included in the Scope of this Specification.

For purposes of the Khronos Intellectual Property Rights Policy as it
relates to the definition of Necessary Patent Claims, all recommended or
optional features, behaviors and functionality set forth in this
Specification, if implemented, are considered to be included as Compliant
Portions.

Where this Specification identifies specific sections of external
references, only those specifically identified sections define
normative
functionality. The Khronos Intellectual Property Rights Policy excludes
external references to materials and associated enabling technology not
created by Khronos from the Scope of this Specification, and any licenses
that may be required to implement such referenced materials and associated
technologies must be obtained separately and may involve royalty payments.

Khronos and Vulkan are registered trademarks, and SPIR-V is a trademark of
The Khronos Group Inc. OpenCL is a trademark of Apple Inc., used under
license by Khronos. OpenGL is a registered trademark and the OpenGL ES logo
is a trademark of Hewlett Packard Enterprise, used under license by Khronos.
ASTC is a trademark of ARM Holdings PLC. All other product names,
trademarks, and/or company names are used solely for identification and
belong to their respective owners.





# Introduction

This document, referred to as the
> Vulkan Specification or just the > Specification hereafter, describes
the Vulkan
Application Programming Interface (API).
Vulkan is a [C99](http://www.open-std.org/jtc1/sc22/wg14/www/standards) API
designed for explicit control of low-level graphics and compute
functionality.

The canonical version of the Specification is available in the official
[Vulkan Registry](https://registry.khronos.org/vulkan/)
(<https://registry.khronos.org/vulkan/>).
The source files used to generate the Vulkan specification are stored in the
[Vulkan Documentation Repository](https://github.com/KhronosGroup/Vulkan-Docs)
(<https://github.com/KhronosGroup/Vulkan-Docs>).

The source repository additionally has a public issue tracker and allows the
submission of pull requests that improve the specification.



## Document Conventions

The Vulkan specification is intended for use by both implementors of the API
and application developers seeking to make use of the API, forming a
contract between these parties.
Specification text may address either party; typically the intended audience
can be inferred from context, though some sections are defined to address
only one of these parties.
(For example,  sections only address application
developers).
Any requirements, prohibitions, recommendations or options defined by
normative terminology are imposed
only on the audience of that text.


::note
Structure and enumerated types defined in extensions that were promoted to
core in a later version of Vulkan are now defined in terms of the equivalent
Vulkan core interfaces.
This affects the Vulkan Specification, the Vulkan header files, and the
corresponding XML Registry.
::




### Informative Language

Some language in the specification is purely informative, intended to give
background or suggestions to implementors or developers.

If an entire chapter or section contains only informative language, its
title will be suffixed with > (Informative).

All NOTEs are implicitly informative.





### Normative Terminology

Within this specification, the key words *must*, *required*, *should*,
*recommended*, *may*, and *optional* are to be interpreted as described in
[RFC 2119 - Key words for use in RFCs to
Indicate Requirement Levels](https://www.ietf.org/rfc/rfc2119.txt) (<https://www.ietf.org/rfc/rfc2119.txt>).
The additional key word *optionally* is an alternate form of *optional*, for
use where grammatically appropriate.

These key words are highlighted in the specification for clarity.
In text addressing application developers, their use expresses requirements
that apply to application behavior.
In text addressing implementors, their use expresses requirements that apply
to implementations.

In text addressing application developers, the additional key words *can*
and *cannot* are to be interpreted as describing the capabilities of an
application, as follows:



These key words are never used in text addressing implementors.


::note
There is an important distinction between *cannot* and *must not*, as used
in this Specification.
*Cannot* means something the application literally is unable to express or
accomplish through the API, while *must not* means something that the
application is capable of expressing through the API, but that the
consequences of doing so are undefined: and potentially unrecoverable for
the implementation (see ).
::


Unless otherwise noted in the section heading, all sections and appendices
in this document are normative.





### Technical Terminology

The Vulkan Specification makes use of common engineering and graphics terms
such as *Pipeline*, *Shader*, and *Host* to identify and describe Vulkan API
constructs and their attributes, states, and behaviors.
The Glossary defines the basic meanings of these terms in the
context of the Specification.
The Specification text provides fuller definitions of the terms and may
elaborate, extend, or clarify the Glossary definitions.
When a term defined in the Glossary is used in normative
language within the Specification, the definitions within the Specification
govern and supersede any meanings the terms may have in other technical
contexts (i.e. outside the Specification).





### Normative References

References to external documents are considered normative references if the
Specification uses any of the normative terms defined in
&#x20;to refer to them or their
requirements, either as a whole or in part.

The following documents are referenced by normative sections of the
specification:

IEEE.
August, 2008.
*IEEE Standard for Floating-Point Arithmetic*.
IEEE Std 754-2008.
<https://dx.doi.org/10.1109/IEEESTD.2008.4610935> .

[data-format](#data-format) Andrew Garrard.
*Khronos Data Format Specification, version 1.3*.
<https://registry.khronos.org/DataFormat/specs/1.3/dataformat.1.3.html> .

[spirv-extended](#spirv-extended) John Kessenich.
*SPIR-V Extended Instructions for GLSL, Version 1.00* (February 10, 2016).
<https://registry.khronos.org/spir-v/> .

[spirv-spec](#spirv-spec) John Kessenich, Boaz Ouriel, and Raun Krisch.
*SPIR-V Specification, Version 1.5, Revision 3, Unified* (April 24, 2020).
<https://registry.khronos.org/spir-v/> .

ITU-T.
*H.264 Advanced Video Coding for Generic Audiovisual Services* (August,
2021\).
<https://www.itu.int/rec/T-REC-H.264-202108-I/> .

ITU-T.
*H.265 High Efficiency Video Coding* (August, 2021).
<https://www.itu.int/rec/T-REC-H.265-202108-I/> .

[vulkan-registry](#vulkan-registry) Jon Leech.
*The Khronos Vulkan API Registry* (February 26, 2023).
<https://registry.khronos.org/vulkan/specs/1.3/registry.html> .

[vulkan-styleguide](#vulkan-styleguide) Jon Leech and Tobias Hector.
*Vulkan Documentation and Extensions: Procedures and Conventions* (February
26, 2023).
<https://registry.khronos.org/vulkan/specs/1.3/styleguide.html> .

*Architecture of the Vulkan Loader Interfaces* (October, 2021).
<https://github.com/KhronosGroup/Vulkan-Loader/blob/master/docs/LoaderInterfaceArchitecture.md>
.









# Fundamentals

This chapter introduces fundamental concepts including the Vulkan
architecture and execution model, API syntax, queues, pipeline
configurations, numeric representation, state and state queries, and the
different types of objects and shaders.
It provides a framework for interpreting more specific descriptions of
commands and behavior in the remainder of the Specification.



## Host and Device Environment

The Vulkan Specification assumes and requires: the following properties of
the host environment with respect to Vulkan implementations:

- The host :normative{type="must"} have runtime support for 8, 16, 32 and 64-bit signed and
  unsigned twos-complement integers, all addressable at the granularity of
  their size in bytes.

- The host :normative{type="must"} have runtime support for 32- and 64-bit floating-point
  types satisfying the range and precision constraints in the
  Floating Point Computation section.

- The representation and endianness of these types on the host :normative{type="must"} match
  the representation and endianness of the same types on every physical
  device supported.


::note
Since a variety of data types and structures in Vulkan :normative{type="may"} be accessible by
both host and physical device operations, the implementation :normative{type="should"} be able
to access such data efficiently in both paths in order to facilitate writing
portable and performant applications.
::






## Execution Model

This section outlines the execution model of a Vulkan system.

Vulkan exposes one or more *devices*, each of which exposes one or more
*queues* which :normative{type="may"} process work asynchronously to one another.
The set of queues supported by a device is partitioned into *families*.
Each family supports one or more types of functionality and :normative{type="may"} contain
multiple queues with similar characteristics.
Queues within a single family are considered *compatible* with one another,
and work produced for a family of queues :normative{type="can"} be executed on any queue
within that family.
This specification defines the following types of functionality that queues
:normative{type="may"} support: graphics, compute,
sparse memory management,
and transfer.


::note
A single device :normative{type="may"} report multiple similar queue families rather than, or
as well as, reporting multiple members of one or more of those families.
This indicates that while members of those families have similar
capabilities, they are *not* directly compatible with one another.
::


Device memory is explicitly managed by the application.
Each device :normative{type="may"} advertise one or more heaps, representing different areas
of memory.
Memory heaps are either device-local or host-local, but are always visible
to the device.
Further detail about memory heaps is exposed via memory types available on
that heap.
Examples of memory areas that :normative{type="may"} be available on an implementation
include:

- *device-local* is memory that is physically connected to the device.

- *device-local, host visible* is device-local memory that is visible to
  the host.

- *host-local, host visible* is memory that is local to the host and
  visible to the device and host.

On other architectures, there :normative{type="may"} only be a single heap that :normative{type="can"} be used
for any purpose.



### Queue Operation

Vulkan queues provide an interface to the execution engines of a device.
Commands for these execution engines are recorded into command buffers ahead
of execution time, and then submitted to a queue for execution.
Once submitted to a queue, command buffers will begin and complete execution
without further application intervention, though the order of this execution
is dependent on a number of implicit and explicit
ordering constraints.

Work is submitted to queues using *queue submission commands* that typically
take the form `vkQueue*` (e.g. [vkQueueSubmit](/man/vkQueueSubmit)
, [vkQueueBindSparse](/man/vkQueueBindSparse)
), and :normative{type="can"} take a list of semaphores upon which to wait before work begins
and a list of semaphores to signal once work has completed.
The work itself, as well as signaling and waiting on the semaphores are all
*queue operations*.
Queue submission commands return control to the application once queue
operations have been submitted - they do not wait for completion.

There are no implicit ordering constraints between queue operations on
different queues, or between queues and the host, so these :normative{type="may"} operate in
any order with respect to each other.
Explicit ordering constraints between different queues or with the host :normative{type="can"}
be expressed with semaphores and
fences.

Command buffer submissions to a single queue respect
submission order and other
implicit ordering guarantees, but otherwise
:normative{type="may"} overlap or execute out of order.
Other types of batches and queue submissions against a single queue
(e.g. sparse memory binding)
have no implicit ordering constraints with any other queue submission or
batch.
Additional explicit ordering constraints between queue submissions and
individual batches can be expressed with
semaphores and
fences.

Before a fence or semaphore is signaled, it is guaranteed that any
previously submitted queue operations have completed execution, and that
memory writes from those queue operations are
available to future
queue operations.
Waiting on a signaled semaphore or fence guarantees that previous writes
that are available are also
visible to subsequent
commands.

Command buffer boundaries, both between primary command buffers of the same
or different batches or submissions as well as between primary and secondary
command buffers, do not introduce any additional ordering constraints.
In other words, submitting the set of command buffers (which :normative{type="can"} include
executing secondary command buffers) between any semaphore or fence
operations execute the recorded commands as if they had all been recorded
into a single primary command buffer, except that the current state is
reset on each boundary.
Explicit ordering constraints :normative{type="can"} be expressed with explicit synchronization primitives.

There are a few implicit ordering guarantees
between commands within a command buffer, but only covering a subset of
execution.
Additional explicit ordering constraints can be expressed with the various
explicit synchronization primitives.


::note
Implementations have significant freedom to overlap execution of work
submitted to a queue, and this is common due to deep pipelining and
parallelism in Vulkan devices.
::


Commands recorded in command buffers can perform actions, set state that
persists across commands, synchronize other commands, or indirectly launch
other commands, with some commands fulfilling several of these roles.
The > Command Properties section for each such command lists which of
these roles the command takes.
State setting commands update the *current state* of the command buffer.
Some commands that perform actions (e.g. draw/dispatch) do so based on the
current state set cumulatively since the start of the command buffer.
The work involved in performing action commands is often allowed to overlap
or to be reordered, but doing so :normative{type="must"} not alter the state to be used by
each action command.
In general, action commands are those commands that alter framebuffer
attachments, read/write buffer or image memory, or write to query pools.

Synchronization commands introduce explicit
execution and memory dependencies between
two sets of action commands, where the second set of commands depends on the
first set of commands.
These dependencies enforce both that the execution of certain
pipeline stages in the later set occurs
after the execution of certain stages in the source set, and that the
effects of memory accesses
performed by certain pipeline stages occur in order and are visible to each
other.
When not enforced by an explicit dependency or implicit ordering guarantees, action commands :normative{type="may"} overlap execution or
execute out of order, and :normative{type="may"} not see the side effects of each other’s
memory accesses.







## Object Model

The devices, queues, and other entities in Vulkan are represented by Vulkan
objects.
At the API level, all objects are referred to by handles.
There are two classes of handles, dispatchable and non-dispatchable.
*Dispatchable* handle types are a pointer to an opaque type.
This pointer :normative{type="may"} be used by layers as part of intercepting API commands,
and thus each API command takes a dispatchable type as its first parameter.
Each object of a dispatchable type :normative{type="must"} have a unique handle value during
its lifetime.

*Non-dispatchable* handle types are a 64-bit integer type whose meaning is
implementation-dependent.
Non-dispatchable
handles :normative{type="may"} encode object information directly in the handle rather than
acting as a reference to an underlying object, and thus :normative{type="may"} not have unique
handle values.
If handle values are not unique, then destroying one such handle :normative{type="must"} not
cause identical handles of other types to become invalid, and :normative{type="must"} not
cause identical handles of the same type to become invalid if that handle
value has been created more times than it has been destroyed.

All objects created or allocated from a `VkDevice` (i.e. with a
`VkDevice` as the first parameter) are private to that device, and :normative{type="must"}
not be used on other devices.



### Object Lifetime

Objects are created or allocated by `vkCreate*` and `vkAllocate*`
commands, respectively.
Once an object is created or allocated, its > structure is considered to
be immutable, though the contents of certain object types is still free to
change.
Objects are destroyed or freed by `vkDestroy*` and `vkFree*`
commands, respectively.

Objects that are allocated (rather than created) take resources from an
existing pool object or memory heap, and when freed return resources to that
pool or heap.
While object creation and destruction are generally expected to be
low-frequency occurrences during runtime, allocating and freeing objects
:normative{type="can"} occur at high frequency.
Pool objects help accommodate improved performance of the allocations and
frees.

It is an application’s responsibility to track the lifetime of Vulkan
objects, and not to destroy them while they are still in use.

The ownership of application-owned memory is immediately acquired by any
Vulkan command it is passed
into.
Ownership of such memory :normative{type="must"} be released back to the application at the
end of the duration of the command,
so that the application :normative{type="can"} alter or free this memory as soon as all the
commands that acquired it have returned.

The following object types are consumed when they are passed into a Vulkan
command and not further accessed by the objects they are used to create.
They :normative{type="must"} not be destroyed in the duration of any API command they are
passed into:

- `VkShaderModule`

- `VkPipelineCache`

A `VkRenderPass`
object passed as a parameter to create another object is not further
accessed by that object after the duration of the command it is passed into.
A `VkRenderPass` used in a command buffer follows the rules described
below.

A `VkPipelineLayout` object :normative{type="must"} not be destroyed while any command
buffer that uses it is in the recording state.

`VkDescriptorSetLayout` objects :normative{type="may"} be accessed by commands that
operate on descriptor sets allocated using that layout, and those descriptor
sets :normative{type="must"} not be updated with [vkUpdateDescriptorSets](/man/vkUpdateDescriptorSets) after the
descriptor set layout has been destroyed.
Otherwise, a `VkDescriptorSetLayout` object passed as a parameter to
create another object is not further accessed by that object after the
duration of the command it is passed into.

The application :normative{type="must"} not destroy any other type of Vulkan object until all
uses of that object by the device (such as via command buffer execution)
have completed.

The following Vulkan objects :normative{type="must"} not be destroyed while any command
buffers using the object are in the pending
state:

- `VkEvent`

- `VkQueryPool`

- `VkBuffer`

- `VkBufferView`

- `VkImage`

- `VkImageView`

- `VkPipeline`

- `VkSampler`

- `VkDescriptorPool`

- `VkFramebuffer`

- `VkRenderPass`

- `VkCommandBuffer`

- `VkCommandPool`

- `VkDeviceMemory`

- `VkDescriptorSet`

Destroying these objects will move any command buffers that are in the
recording or executable state, and are using
those objects, to the invalid state.

The following Vulkan objects :normative{type="must"} not be destroyed while any queue is
executing commands that use the object:

- `VkFence`

- `VkSemaphore`

- `VkCommandBuffer`

- `VkCommandPool`

In general, objects :normative{type="can"} be destroyed or freed in any order, even if the
object being freed is involved in the use of another object (e.g. use of a
resource in a view, use of a view in a descriptor set,
use of an object in a command buffer, binding of a memory allocation to a
resource), as long as any object that uses the freed object is not further
used in any way except to be destroyed or to be reset in such a way that it
no longer uses the other object (such as resetting a command buffer).
If the object has been reset, then it :normative{type="can"} be used as if it never used the
freed object.
An exception to this is when there is a parent/child relationship between
objects.
In this case, the application :normative{type="must"} not destroy a parent object before its
children, except when the parent is explicitly defined to free its children
when it is destroyed (e.g. for pool objects, as defined below).

`VkCommandPool` objects are parents of `VkCommandBuffer` objects.
`VkDescriptorPool` objects are parents of `VkDescriptorSet` objects.
`VkDevice` objects are parents of many object types (all that take a
`VkDevice` as a parameter to their creation).

The following Vulkan objects have specific restrictions for when they :normative{type="can"}
be destroyed:

- `VkQueue` objects :normative{type="cannot"} be explicitly destroyed.
  Instead, they are implicitly destroyed when the `VkDevice` object
  they are retrieved from is destroyed.

- Destroying a pool object implicitly frees all objects allocated from
  that pool.
  Specifically, destroying `VkCommandPool` frees all
  `VkCommandBuffer` objects that were allocated from it, and
  destroying `VkDescriptorPool` frees all `VkDescriptorSet`
  objects that were allocated from it.

- `VkDevice` objects :normative{type="can"} be destroyed when all `VkQueue` objects
  retrieved from them are idle, and all objects created from them have
  been destroyed.





  * This includes the following objects:





    * `VkFence`

    * `VkSemaphore`

    * `VkEvent`

    * `VkQueryPool`

    * `VkBuffer`

    * `VkBufferView`

    * `VkImage`

    * `VkImageView`

    * `VkShaderModule`

    * `VkPipelineCache`

    * `VkPipeline`

    * `VkPipelineLayout`

    * `VkSampler`

    * `VkDescriptorSetLayout`

    * `VkDescriptorPool`

    * `VkFramebuffer`

    * `VkRenderPass`

    * `VkCommandPool`

    * `VkCommandBuffer`

    * `VkDeviceMemory`

- `VkPhysicalDevice` objects :normative{type="cannot"} be explicitly destroyed.
  Instead, they are implicitly destroyed when the `VkInstance` object
  they are retrieved from is destroyed.

- `VkInstance` objects :normative{type="can"} be destroyed once all `VkDevice`
  objects created from any of its `VkPhysicalDevice` objects have been
  destroyed.







## Application Binary Interface

The mechanism by which Vulkan is made available to applications is platform-
or implementation- defined.
On many platforms the C interface described in this Specification is
provided by a shared library.
Since shared libraries can be changed independently of the applications that
use them, they present particular compatibility challenges, and this
Specification places some requirements on them.

Shared library implementations :normative{type="must"} use the default Application Binary
Interface (ABI) of the standard C compiler for the platform, or provide
customized API headers that cause application code to use the
implementation’s non-default ABI.
An ABI in this context means the size, alignment, and layout of C data
types; the procedure calling convention; and the naming convention for
shared library symbols corresponding to C functions.
Customizing the calling convention for a platform is usually accomplished by
defining calling
convention macros appropriately in `vk_platform.h`.

On platforms where Vulkan is provided as a shared library, library symbols
beginning with > vk and followed by a digit or uppercase letter are
reserved for use by the implementation.
Applications which use Vulkan :normative{type="must"} not provide definitions of these
symbols.
This allows the Vulkan shared library to be updated with additional symbols
for new API versions or extensions without causing symbol conflicts with
existing applications.

Shared library implementations :normative{type="should"} provide library symbols for commands
in the highest version of this Specification they support, and for
Window System Integration
extensions relevant to the platform.
They :normative{type="may"} also provide library symbols for commands defined by additional
extensions.


::note
These requirements and recommendations are intended to allow implementors to
take advantage of platform-specific conventions for SDKs, ABIs, library
versioning mechanisms, etc.
while still minimizing the code changes necessary to port applications or
libraries between platforms.
Platform vendors, or providers of the *de facto* standard Vulkan shared
library for a platform, are encouraged to document what symbols the shared
library provides and how it will be versioned when new symbols are added.

Applications :normative{type="should"} only rely on shared library symbols for commands in the
minimum core version required by the application.
[vkGetInstanceProcAddr](/man/vkGetInstanceProcAddr) and [vkGetDeviceProcAddr](/man/vkGetDeviceProcAddr) :normative{type="should"} be used to
obtain function pointers for commands in core versions beyond the
application’s minimum required version.
::






## Command Syntax and Duration

The Specification describes Vulkan commands as functions or procedures using
C99 syntax.
Language bindings for other languages such as C++ and JavaScript :normative{type="may"} allow
for stricter parameter passing, or object-oriented interfaces.

Vulkan uses the standard C types for the base type of scalar parameters
(e.g. types from `<stdint.h>`), with exceptions described below, or
elsewhere in the text when appropriate:

[VkBool32](/man/VkBool32) represents boolean `True` and `False` values, since C does
not have a sufficiently portable built-in boolean type:

[{generated}/api/basetypes/VkBool32.adoc]({generated}/api/basetypes/VkBool32.adoc)

`VK_TRUE` represents a boolean *True* (unsigned integer 1) value, and
`VK_FALSE` a boolean *False* (unsigned integer 0) value.

All values returned from a Vulkan implementation in a [VkBool32](/man/VkBool32) will
be either `VK_TRUE` or `VK_FALSE`.

Applications :normative{type="must"} not pass any other values than `VK_TRUE` or
`VK_FALSE` into a Vulkan implementation where a [VkBool32](/man/VkBool32) is
expected.

`VK_TRUE` is a constant representing a [VkBool32](/man/VkBool32) *True* value.

[{generated}/api/enums/VK\_TRUE.adoc]({generated}/api/enums/VK_TRUE.adoc)

`VK_FALSE` is a constant representing a [VkBool32](/man/VkBool32) *False* value.

[{generated}/api/enums/VK\_FALSE.adoc]({generated}/api/enums/VK_FALSE.adoc)

[VkDeviceSize](/man/VkDeviceSize) represents device memory size and offset values:

[{generated}/api/basetypes/VkDeviceSize.adoc]({generated}/api/basetypes/VkDeviceSize.adoc)

Commands that create Vulkan objects are of the form `vkCreate*` and take
`Vk*CreateInfo` structures with the parameters needed to create the
object.
These Vulkan objects are destroyed with commands of the form
`vkDestroy*`.

The last in-parameter to each command that creates or destroys a Vulkan
object is `pAllocator`.
The `pAllocator` parameter :normative{type="can"} be set to a non-`NULL` value such that
allocations for the given object are delegated to an application provided
callback; refer to the Memory Allocation chapter for
further details.

Commands that allocate Vulkan objects owned by pool objects are of the form
`vkAllocate*`, and take `Vk*AllocateInfo` structures.
These Vulkan objects are freed with commands of the form `vkFree*`.
These objects do not take allocators; if host memory is needed, they will
use the allocator that was specified when their parent pool was created.

Commands are recorded into a command buffer by calling API commands of the
form `vkCmd*`.
Each such command :normative{type="may"} have different restrictions on where it :normative{type="can"} be used:
in a primary and/or secondary command buffer, inside and/or outside a render
pass, and in one or more of the supported queue types.
These restrictions are documented together with the definition of each such
command.

The *duration* of a Vulkan command refers to the interval between calling
the command and its return to the caller.



### Lifetime of Retrieved Results

Information is retrieved from the implementation with commands of the form
`vkGet*` and `vkEnumerate*`.

Unless otherwise specified for an individual command, the results are
*invariant*; that is, they will remain unchanged when retrieved again by
calling the same command with the same parameters, so long as those
parameters themselves all remain valid.







## Threading Behavior

Vulkan is intended to provide scalable performance when used on multiple
host threads.
All commands support being called concurrently from multiple threads, but
certain parameters, or components of parameters are defined to be
*externally synchronized*.
This means that the caller :normative{type="must"} guarantee that no more than one thread is
using such a parameter at a given time.

More precisely, Vulkan commands use simple stores to update the state of
Vulkan objects.
A parameter declared as externally synchronized :normative{type="may"} have its contents
updated at any time during the host execution of the command.
If two commands operate on the same object and at least one of the commands
declares the object to be externally synchronized, then the caller :normative{type="must"}
guarantee not only that the commands do not execute simultaneously, but also
that the two commands are separated by an appropriate memory barrier (if
needed).


::note
Memory barriers are particularly relevant for hosts based on the ARM CPU
architecture, which is more weakly ordered than many developers are
accustomed to from x86/x64 programming.
Fortunately, most higher-level synchronization primitives (like the pthread
library) perform memory barriers as a part of mutual exclusion, so mutexing
Vulkan objects via these primitives will have the desired effect.
::


Similarly the application :normative{type="must"} avoid any potential data hazard of
application-owned memory that has its
ownership temporarily acquired
by a Vulkan command.
While the ownership of application-owned memory remains acquired by a
command the implementation :normative{type="may"} read the memory at any point, and it :normative{type="may"}
write non-`const` qualified memory at any point.
Parameters referring to non-`const` qualified application-owned memory
are not marked explicitly as *externally synchronized* in the Specification.

Many object types are *immutable*, meaning the objects :normative{type="cannot"} change once
they have been created.
These types of objects never need external synchronization, except that they
:normative{type="must"} not be destroyed while they are in use on another thread.
In certain special cases mutable object parameters are internally
synchronized, making external synchronization unnecessary.
Any command parameters that are not labeled as externally synchronized are
either not mutated by the command or are internally synchronized.
Additionally, certain objects related to a command’s parameters (e.g.
command pools and descriptor pools) :normative{type="may"} be affected by a command, and :normative{type="must"}
also be externally synchronized.
These implicit parameters are documented as described below.

Parameters of commands that are externally synchronized are listed below.

[{generated}/hostsynctable/parameters.adoc]({generated}/hostsynctable/parameters.adoc)

There are also a few instances where a command :normative{type="can"} take in a user allocated
list whose contents are externally synchronized parameters.
In these cases, the caller :normative{type="must"} guarantee that at most one thread is using
a given element within the list at a given time.
These parameters are listed below.

[{generated}/hostsynctable/parameterlists.adoc]({generated}/hostsynctable/parameterlists.adoc)

In addition, there are some implicit parameters that need to be externally
synchronized.
For example, when a `commandBuffer` parameter needs to be externally
synchronized, it implies that the `commandPool` from which that command
buffer was allocated also needs to be externally synchronized.
The implicit parameters and their associated object are listed below.

[{generated}/hostsynctable/implicit.adoc]({generated}/hostsynctable/implicit.adoc)





## Valid Usage

Valid usage defines a set of conditions which :normative{type="must"} be met in order to
achieve well-defined runtime behavior in an application.
These conditions depend only on Vulkan state, and the parameters or objects
whose usage is constrained by the condition.

The core layer assumes applications are using the API correctly.
Except as documented elsewhere in the Specification, the behavior of the
core layer to an application using the API incorrectly is undefined:, and
:normative{type="may"} include program termination.
However, implementations :normative{type="must"} ensure that incorrect usage by an application
does not affect the integrity of the operating system, the Vulkan
implementation, or other Vulkan client applications in the system.
In particular, any guarantees made by an operating system about whether
memory from one process :normative{type="can"} be visible to another process or not :normative{type="must"} not
be violated by a Vulkan implementation for *any memory allocation*.
Vulkan implementations are not :normative{type="required"} to make additional security or
integrity guarantees beyond those provided by the OS unless explicitly
directed by the application’s use of a particular feature or extension.


::note
For instance, if an operating system guarantees that data in all its memory
allocations are set to zero when newly allocated, the Vulkan implementation
:normative{type="must"} make the same guarantees for any allocations it controls (e.g.
[VkDeviceMemory](/man/VkDeviceMemory)).

Similarly, if an operating system guarantees that use-after-free of host
allocations will not result in values written by another process becoming
visible, the same guarantees :normative{type="must"} be made by the Vulkan implementation for
device memory.
::


Some valid usage conditions have dependencies on runtime limits or feature
availability.
It is possible to validate these conditions against Vulkan’s minimum
supported values for these limits and features, or some subset of other
known values.

Valid usage conditions do not cover conditions where well-defined behavior
(including returning an error code) exists.

Valid usage conditions :normative{type="should"} apply to the command or structure where
complete information about the condition would be known during execution of
an application.
This is such that a validation layer or linter :normative{type="can"} be written directly
against these statements at the point they are specified.


::note
This does lead to some non-obvious places for valid usage statements.
For instance, the valid values for a structure might depend on a separate
value in the calling command.
In this case, the structure itself will not reference this valid usage as it
is impossible to determine validity from the structure that it is invalid -
instead this valid usage would be attached to the calling command.

Another example is draw state - the state setters are independent, and can
cause a legitimately invalid state configuration between draw calls; so the
valid usage statements are attached to the place where all state needs to be
valid - at the drawing command.
::


Valid usage conditions are described in a block labelled > Valid Usage
following each command or structure they apply to.



### Usage Validation

Vulkan is a layered API.
The lowest layer is the core Vulkan layer, as defined by this Specification.
The application :normative{type="can"} use additional layers above the core for debugging,
validation, and other purposes.

One of the core principles of Vulkan is that building and submitting command
buffers :normative{type="should"} be highly efficient.
Thus error checking and validation of state in the core layer is minimal,
although more rigorous validation :normative{type="can"} be enabled through the use of layers.

Validation of correct API usage is left to validation layers.
Applications :normative{type="should"} be developed with validation layers enabled, to help
catch and eliminate errors.
Once validated, released applications :normative{type="should"} not enable validation layers
by default.





### Implicit Valid Usage

Some valid usage conditions apply to all commands and structures in the API,
unless explicitly denoted otherwise for a specific command or structure.
These conditions are considered *implicit*, and are described in a block
labelled > Valid Usage (Implicit) following each command or structure they
apply to.
Implicit valid usage conditions are described in detail below.



#### Valid Usage for Object Handles

Any input parameter to a command that is an object handle :normative{type="must"} be a valid
object handle, unless otherwise specified.
An object handle is valid if:

- It has been created or allocated by a previous, successful call to the
  API.
  Such calls are noted in the Specification.

- It has not been deleted or freed by a previous call to the API.
  Such calls are noted in the Specification.

- Any objects used by that object, either as part of creation or
  execution, :normative{type="must"} also be valid.

The reserved values [VK\_NULL\_HANDLE](/man/VK_NULL_HANDLE) and `NULL` :normative{type="can"} be used in place of
valid non-dispatchable handles and dispatchable handles, respectively, when
*explicitly called out in the Specification*.
Any command that creates an object successfully :normative{type="must"} not return these
values.
It is valid to pass these values to `vkDestroy*` or `vkFree*`
commands, which will silently ignore these values.





#### Valid Usage for Pointers

Any parameter that is a pointer :normative{type="must"} be a *valid pointer* only if it is
explicitly called out by a Valid Usage statement.

A pointer is > valid if it points at memory containing values of the
number and type(s) expected by the command, and all fundamental types
accessed through the pointer (e.g. as elements of an array or as members of
a structure) satisfy the alignment requirements of the host processor.





#### Valid Usage for Strings

Any parameter that is a pointer to `char` :normative{type="must"} be a finite sequence of
values terminated by a null character, or if *explicitly called out in the
Specification*, :normative{type="can"} be `NULL`.





#### Valid Usage for Enumerated Types

Any parameter of an enumerated type :normative{type="must"} be a valid enumerant for that
type.
Use of an enumerant is valid if the following conditions are true:

- The enumerant is defined as part of the enumerated type.

- The enumerant is not a value suffixed with `_MAX_ENUM`.





  * This value exists only to ensure that C `enum` types are 32 bits in
    size and :normative{type="must"} not be used by applications.

- If the enumerant is used in a function that has a [VkInstance](/man/VkInstance) as
  its first parameter and either:





  * it was added by a core version that is supported
    and the value of [VkApplicationInfo](/man/VkApplicationInfo)::`apiVersion` is greater
    than or equal to the version that added it; or

  * it was added by an instance extension that was enabled
    for the instance.

- If the enumerant is used in a function that has a [VkPhysicalDevice](/man/VkPhysicalDevice)
  object as its first parameter and either:





  * it was added by a core version that is supported by that device (as
    reported by [VkPhysicalDeviceProperties](/man/VkPhysicalDeviceProperties)::`apiVersion`);

  * it was added by an instance extension that was enabled
    for the instance; or

  * it was added by a device extension that is supported by
    that device.

- If the enumerant is used in a function that has any other dispatchable
  object as its first parameter and either:





  * it was added by a core version that is supported for the device (as
    reported by [VkPhysicalDeviceProperties](/man/VkPhysicalDeviceProperties)::`apiVersion`); or

  * it was added by a device extension that was enabled for
    the device.

Any enumerated type returned from a query command or otherwise output from
Vulkan to the application :normative{type="must"} not have a reserved value.
Reserved values are values not defined by any extension for that enumerated
type.


::note
In some special cases, an enumerant is only meaningful if a feature defined
by an extension is also enabled, as well as the extension itself.
The global > valid enumerant rule described here does not address such
cases.
::



::note
This language is intended to accommodate cases such as > hidden extensions
known only to driver internals, or layers enabling extensions without
knowledge of the application, without allowing return of values not defined
by any extension.
::



::note
Application developers are encouraged to be careful when using `switch`
statements with Vulkan API enums.
This is because new extensions can add new values to existing enums.
Using a `default:` statement within a `switch` may avoid future compilation
issues.
::






#### Valid Usage for Flags

A collection of flags is represented by a bitmask using the type
[VkFlags](/man/VkFlags):

[{generated}/api/basetypes/VkFlags.adoc]({generated}/api/basetypes/VkFlags.adoc)

Bitmasks are passed to many commands and structures to compactly represent
options, but [VkFlags](/man/VkFlags) is not used directly in the API.
Instead, a `Vk*Flags` type which is an alias of [VkFlags](/man/VkFlags), and
whose name matches the corresponding `Vk*FlagBits` that are valid for
that type, is used.

Any `Vk*Flags` member or parameter used in the API as an input :normative{type="must"} be
a valid combination of bit flags.
A valid combination is either zero or the bitwise OR of valid bit flags.

An individual bit flag is valid for a `Vk*Flags` type if it would be a
valid enumerant when used with the
equivalent `Vk*FlagBits` type, where the bits type is obtained by taking
the flag type and replacing the trailing `Flags` with `FlagBits`.
For example, a flag value of type [VkColorComponentFlags](/man/VkColorComponentFlags) :normative{type="must"} contain
only bit flags defined by [VkColorComponentFlagBits](/man/VkColorComponentFlagBits).

Any `Vk*Flags` member or parameter returned from a query command or
otherwise output from Vulkan to the application :normative{type="may"} contain bit flags
undefined: in its corresponding `Vk*FlagBits` type.
An application :normative{type="cannot"} rely on the state of these unspecified bits.

Only the low-order 31 bits (bit positions zero through 30) are available for
use as flag bits.


::note
This restriction is due to poorly defined behavior by C compilers given a C
enumerant value of `0x80000000`.
In some cases adding this enumerant value may increase the size of the
underlying `Vk*FlagBits` type, breaking the ABI.
::






#### Valid Usage for Structure Types

Any parameter that is a structure containing a `sType` member :normative{type="must"} have
a value of `sType` which is a valid [VkStructureType](/man/VkStructureType) value matching
the type of the structure.





#### Valid Usage for Structure Pointer Chains

Any parameter that is a structure containing a `void*` `pNext` member
:normative{type="must"} have a value of `pNext` that is either `NULL`, or is a pointer to
a valid *extending structure*, containing `sType` and `pNext`
members as described in the Vulkan Documentation and
Extensions document in the section > Extending Structures.
The set of structures connected by `pNext` pointers is referred to as a
*`pNext` chain*.

Each structure included in the `pNext` chain :normative{type="must"} be defined at runtime
by either:

- a core version which is supported

- an extension which is enabled

Each type of extending structure :normative{type="must"} not appear more than once in a
`pNext` chain, including any
aliases.
This general rule may be explicitly overridden for specific structures.

Any component of the implementation (the loader, any enabled layers, and
drivers) :normative{type="must"} skip over, without processing (other than reading the
`sType` and `pNext` members) any extending structures in the chain
not defined by core versions or extensions supported by that component.

As a convenience to implementations and layers needing to iterate through a
structure pointer chain, the Vulkan API provides two *base structures*.
These structures allow for some type safety, and can be used by Vulkan API
functions that operate on generic inputs and outputs.

The `VkBaseInStructure` structure is defined as:

[{generated}/api/structs/VkBaseInStructure.adoc]({generated}/api/structs/VkBaseInStructure.adoc)

- `sType` is the structure type of the structure being iterated
  through.

- `pNext` is `NULL` or a pointer to the next structure in a structure
  chain.

`VkBaseInStructure` can be used to facilitate iterating through a
read-only structure pointer chain.

The `VkBaseOutStructure` structure is defined as:

[{generated}/api/structs/VkBaseOutStructure.adoc]({generated}/api/structs/VkBaseOutStructure.adoc)

- `sType` is the structure type of the structure being iterated
  through.

- `pNext` is `NULL` or a pointer to the next structure in a structure
  chain.

`VkBaseOutStructure` can be used to facilitate iterating through a
structure pointer chain that returns data back to the application.





#### Valid Usage for Nested Structures

The above conditions also apply recursively to members of structures
provided as input to a command, either as a direct argument to the command,
or themselves a member of another structure.

Specifics on valid usage of each command are covered in their individual
sections.





#### Valid Usage for Extensions

Instance-level functionality or behavior added by an instance
extension to the API :normative{type="must"} not be used unless that extension is supported
by the instance as determined by
[vkEnumerateInstanceExtensionProperties](/man/vkEnumerateInstanceExtensionProperties), and that extension is enabled
in [VkInstanceCreateInfo](/man/VkInstanceCreateInfo).

Physical-device-level functionality or behavior added by an instance extension to the API :normative{type="must"} not be used unless that extension is
supported by the instance as determined by
[vkEnumerateInstanceExtensionProperties](/man/vkEnumerateInstanceExtensionProperties), and that extension is enabled
in [VkInstanceCreateInfo](/man/VkInstanceCreateInfo).

Device-level functionality added by a device extension that
is dispatched from a [VkDevice](/man/VkDevice), or from a child object of a
[VkDevice](/man/VkDevice) :normative{type="must"} not be used unless that extension is supported by the
device as determined by [vkEnumerateDeviceExtensionProperties](/man/vkEnumerateDeviceExtensionProperties), and that
extension is enabled in [VkDeviceCreateInfo](/man/VkDeviceCreateInfo).





#### Valid Usage for Newer Core Versions

Physical-device-level functionality or behavior added by a new
core version of the API :normative{type="must"} not be used unless it is supported by the
physical device as determined by
[VkPhysicalDeviceProperties](/man/VkPhysicalDeviceProperties)::`apiVersion` and the specified version
of [VkApplicationInfo](/man/VkApplicationInfo)::`apiVersion`.

Device-level functionality or behavior added by a new core
version of the API :normative{type="must"} not be used unless it is supported by the device
as determined by [VkPhysicalDeviceProperties](/man/VkPhysicalDeviceProperties)::`apiVersion` and the
specified version of [VkApplicationInfo](/man/VkApplicationInfo)::`apiVersion`.









## `VkResult` Return Codes

While the core Vulkan API is not designed to capture incorrect usage, some
circumstances still require return codes.
Commands in Vulkan return their status via return codes that are in one of
two categories:

- Successful completion codes are returned when a command needs to
  communicate success or status information.
  All successful completion codes are non-negative values.

- Run time error codes are returned when a command needs to communicate a
  failure that could only be detected at runtime.
  All runtime error codes are negative values.

All return codes in Vulkan are reported via [VkResult](/man/VkResult) return values.
The possible codes are:

[{generated}/api/enums/VkResult.adoc]({generated}/api/enums/VkResult.adoc)

- `VK_SUCCESS` Command successfully completed

- `VK_NOT_READY` A fence or query has not yet completed

- `VK_TIMEOUT` A wait operation has not completed in the specified
  time

- `VK_EVENT_SET` An event is signaled

- `VK_EVENT_RESET` An event is unsignaled

- `VK_INCOMPLETE` A return array was too small for the result

- `VK_ERROR_OUT_OF_HOST_MEMORY` A host memory allocation has failed.

- `VK_ERROR_OUT_OF_DEVICE_MEMORY` A device memory allocation has
  failed.

- `VK_ERROR_INITIALIZATION_FAILED` Initialization of an object could
  not be completed for implementation-specific reasons.

- `VK_ERROR_DEVICE_LOST` The logical or physical device has been lost.
  See Lost Device

- `VK_ERROR_MEMORY_MAP_FAILED` Mapping of a memory object has failed.

- `VK_ERROR_LAYER_NOT_PRESENT` A requested layer is not present or
  could not be loaded.

- `VK_ERROR_EXTENSION_NOT_PRESENT` A requested extension is not
  supported.

- `VK_ERROR_FEATURE_NOT_PRESENT` A requested feature is not supported.

- `VK_ERROR_INCOMPATIBLE_DRIVER` The requested version of Vulkan is
  not supported by the driver or is otherwise incompatible for
  implementation-specific reasons.

- `VK_ERROR_TOO_MANY_OBJECTS` Too many objects of the type have
  already been created.

- `VK_ERROR_FORMAT_NOT_SUPPORTED` A requested format is not supported
  on this device.

- `VK_ERROR_FRAGMENTED_POOL` A pool allocation has failed due to
  fragmentation of the pool’s memory.
  This :normative{type="must"} only be returned if no attempt to allocate host or device
  memory was made to accommodate the new allocation.

- `VK_ERROR_UNKNOWN` An unknown error has occurred; either the
  application has provided invalid input, or an implementation failure has
  occurred.

If a command returns a runtime error, unless otherwise specified any output
parameters will have undefined: contents, except that if the output
parameter is a structure with `sType` and `pNext` fields, those
fields will be unmodified.
Any structures chained from `pNext` will also have undefined: contents,
except that `sType` and `pNext` will be unmodified.

`VK_ERROR_OUT_OF_*_MEMORY` errors do not modify any currently existing
Vulkan objects.
Objects that have already been successfully created :normative{type="can"} still be used by
the application.


::note
As a general rule, `Free`, `Release`, and `Reset` commands do
not return `VK_ERROR_OUT_OF_HOST_MEMORY`, while any other command with a
return code :normative{type="may"} return it.
Any exceptions from this rule are described for those commands.
::


`VK_ERROR_UNKNOWN` will be returned by an implementation when an
unexpected error occurs that cannot be attributed to valid behavior of the
application and implementation.
Under these conditions, it :normative{type="may"} be returned from any command returning a
[VkResult](/man/VkResult).


::note
`VK_ERROR_UNKNOWN` is not expected to ever be returned if the
application behavior is valid, and if the implementation is bug-free.
If `VK_ERROR_UNKNOWN` is received, the application should be checked
against the latest validation layers to verify correct behavior as much as
possible.
If no issues are identified it could be an implementation issue, and the
implementor should be contacted for support.
::


Performance-critical commands generally do not have return codes.
If a runtime error occurs in such commands, the implementation will defer
reporting the error until a specified point.
For commands that record into command buffers (`vkCmd*`) runtime errors
are reported by `vkEndCommandBuffer`.





## Numeric Representation and Computation

Implementations normally perform computations in floating-point, and :normative{type="must"}
meet the range and precision requirements defined under > Floating-Point
> Computation below.

These requirements only apply to computations performed in Vulkan operations
outside of shader execution, such as texture image specification and
sampling, and per-fragment operations.
Range and precision requirements during shader execution differ and are
specified by the Precision and Operation of
SPIR-V Instructions section.

In some cases, the representation and/or precision of operations is
implicitly limited by the specified format of vertex or texel data consumed
by Vulkan.
Specific floating-point formats are described later in this section.



### Floating-Point Computation

Most floating-point computation is performed in SPIR-V shader modules.
The properties of computation within shaders are constrained as defined by
the Precision and Operation of SPIR-V
Instructions section.

Some floating-point computation is performed outside of shaders, such as
viewport and depth range calculations.
For these computations, we do not specify how floating-point numbers are to
be represented, or the details of how operations on them are performed, but
only place minimal requirements on representation and precision as described
in the remainder of this section.

We require simply that numbers’ floating-point parts contain enough bits
and that their exponent fields are large enough so that individual results
of floating-point operations are accurate to about 1 part in 10\<sup>5\</sup>.
The maximum representable magnitude for all floating-point values :normative{type="must"} be
at least 2\<sup>32\</sup>.



Occasionally, further requirements will be specified.
Most single-precision floating-point formats meet these requirements.

The special values Inf and -Inf encode values with magnitudes
too large to be represented; the special value NaN encodes > Not A
> Number values resulting from undefined: arithmetic operations such as
0 / 0.
Implementations :normative{type="may"} support Inf and NaN in their floating-point
computations.
Any computation which does not support either Inf or NaN, for
which that value is an input or output will yield an undefined: value.





### Floating-Point Format Conversions

When a value is converted to a defined floating-point representation, finite
values falling between two representable finite values are rounded to one or
the other.
The rounding mode is not defined.
Finite values whose magnitude is larger than that of any representable
finite value may be rounded either to the closest representable finite value
or to the appropriately signed infinity.
For unsigned destination formats any negative values are converted to zero.
Positive infinity is converted to positive infinity; negative infinity is
converted to negative infinity in signed formats and to zero in unsigned
formats; and any NaN is converted to a NaN.





### 16-Bit Floating-Point Numbers

16-bit floating point numbers are defined in the > 16-bit floating point
> numbers section of the Khronos Data Format Specification.





### Unsigned 11-Bit Floating-Point Numbers

Unsigned 11-bit floating point numbers are defined in the > Unsigned 11-bit
> floating point numbers section of the Khronos Data Format
Specification.





### Unsigned 10-Bit Floating-Point Numbers

Unsigned 10-bit floating point numbers are defined in the > Unsigned 10-bit
> floating point numbers section of the Khronos Data Format
Specification.





### General Requirements

Any representable floating-point value in the appropriate format is legal as
input to a Vulkan command that requires floating-point data.
The result of providing a value that is not a floating-point number to such
a command is unspecified, but :normative{type="must"} not lead to Vulkan interruption or
termination.
For example, providing a negative zero (where applicable) or a denormalized
number to a Vulkan command :normative{type="must"} yield deterministic results, while
providing a NaN or Inf yields unspecified results.

Some calculations require division.
In such cases (including implied divisions performed by vector
normalization), division by zero produces an unspecified result but :normative{type="must"}
not lead to Vulkan interruption or termination.







## Fixed-Point Data Conversions

When generic vertex attributes and pixel color or depth *components* are
represented as integers, they are often (but not always) considered to be
*normalized*.
Normalized integer values are treated specially when being converted to and
from floating-point values, and are usually referred to as *normalized
fixed-point*.

In the remainder of this section, b denotes the bit width of the
fixed-point integer representation.
When the integer is one of the types defined by the API, b is the bit
width of that type.
When the integer comes from an image containing color
or depth component texels, b is the number of bits allocated to that
component in its specified image format.

The signed and unsigned fixed-point representations are assumed to be
b-bit binary two’s-complement integers and binary unsigned integers,
respectively.



### Conversion From Normalized Fixed-Point to Floating-Point

Unsigned normalized fixed-point integers represent numbers in the range
\[0,1].
The conversion from an unsigned normalized fixed-point value c to the
corresponding floating-point value f is defined as



Signed normalized fixed-point integers represent numbers in the range
\[-1,1].
The conversion from a signed normalized fixed-point value c to the
corresponding floating-point value f is performed using



Only the range \[-2\<sup>b-1\</sup> +  1, 2\<sup>b-1\</sup> - 1] is used to represent
signed fixed-point values in the range \[-1,1].
For example, if b = 8, then the integer value -127 corresponds
to -1.0 and the value 127 corresponds to 1.0.
This equation is used everywhere that signed normalized fixed-point values
are converted to floating-point.

Note that while zero is exactly expressible in this representation, one
value (-128 in the example) is outside the representable range, and
implementations :normative{type="must"} clamp it to -1.0.
Where the value is subject to further processing by the implementation, e.g.
during texture filtering, values less than -1.0 :normative{type="may"} be used but the
result :normative{type="must"} be clamped before the value is returned to shaders.





### Conversion From Floating-Point to Normalized Fixed-Point

The conversion from a floating-point value f to the corresponding
unsigned normalized fixed-point value c is defined by first clamping
f to the range \[0,1], then computing



where convertFloatToUint(r,b) returns one of the two unsigned binary
integer values with exactly b bits which are closest to the
floating-point value r.
Implementations :normative{type="should"} round to nearest.
If r is equal to an integer, then that integer value :normative{type="must"} be
returned.
In particular, if f is equal to 0.0 or 1.0, then c :normative{type="must"} be
assigned 0 or 2\<sup>b\</sup> - 1, respectively.

The conversion from a floating-point value f to the corresponding
signed normalized fixed-point value c is performed by clamping f
to the range \[-1,1], then computing



where convertFloatToInt(r,b) returns one of the two signed
two’s-complement binary integer values with exactly b bits which are
closest to the floating-point value r.
Implementations :normative{type="should"} round to nearest.
If r is equal to an integer, then that integer value :normative{type="must"} be
returned.
In particular, if f is equal to -1.0, 0.0, or 1.0, then c :normative{type="must"}
be assigned -(2\<sup>b-1\</sup> - 1), 0, or 2\<sup>b-1\</sup> - 1, respectively.

This equation is used everywhere that floating-point values are converted to
signed normalized fixed-point.







## Common Object Types

Some types of Vulkan objects are used in many different structures and
command parameters, and are described here.
These types include *offsets*, *extents*, and *rectangles*.



### Offsets

Offsets are used to describe a pixel location within an image or
framebuffer, as an (x,y) location for two-dimensional images, or an (x,y,z)
location for three-dimensional images.

A two-dimensional offset is defined by the structure:

[{generated}/api/structs/VkOffset2D.adoc]({generated}/api/structs/VkOffset2D.adoc)

- `x` is the x offset.

- `y` is the y offset.

A three-dimensional offset is defined by the structure:

[{generated}/api/structs/VkOffset3D.adoc]({generated}/api/structs/VkOffset3D.adoc)

- `x` is the x offset.

- `y` is the y offset.

- `z` is the z offset.





### Extents

Extents are used to describe the size of a rectangular region of pixels
within an image or framebuffer, as (width,height) for two-dimensional
images, or as (width,height,depth) for three-dimensional images.

A two-dimensional extent is defined by the structure:

[{generated}/api/structs/VkExtent2D.adoc]({generated}/api/structs/VkExtent2D.adoc)

- `width` is the width of the extent.

- `height` is the height of the extent.

A three-dimensional extent is defined by the structure:

[{generated}/api/structs/VkExtent3D.adoc]({generated}/api/structs/VkExtent3D.adoc)

- `width` is the width of the extent.

- `height` is the height of the extent.

- `depth` is the depth of the extent.





### Rectangles

Rectangles are used to describe a specified rectangular region of pixels
within an image or framebuffer.
Rectangles include both an offset and an extent of the same dimensionality,
as described above.
Two-dimensional rectangles are defined by the structure

[{generated}/api/structs/VkRect2D.adoc]({generated}/api/structs/VkRect2D.adoc)

- `offset` is a [VkOffset2D](/man/VkOffset2D) specifying the rectangle offset.

- `extent` is a [VkExtent2D](/man/VkExtent2D) specifying the rectangle extent.





### Structure Types

Each value corresponds to a particular structure with a `sType` member
with a matching name.
As a general rule, the name of each [VkStructureType](/man/VkStructureType) value is obtained
by taking the name of the structure, stripping the leading `Vk`,
prefixing each capital letter with `_`, converting the entire resulting
string to upper case, and prefixing it with `VK_STRUCTURE_TYPE_`.
For example, structures of type [VkImageCreateInfo](/man/VkImageCreateInfo) correspond to a
[VkStructureType](/man/VkStructureType) value of `VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO`,
and thus a structure of this type :normative{type="must"} have its `sType` member set to
this value before it is passed to the API.

The values `VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO` and
`VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO` are reserved for internal
use by the loader, and do not have corresponding Vulkan structures in this
Specification.

Structure types supported by the Vulkan API include:

[{generated}/api/enums/VkStructureType.adoc]({generated}/api/enums/VkStructureType.adoc)







## API Name Aliases

A small number of APIs did not follow the naming
conventions when initially defined.
For consistency, when we discover an API name that violates the naming
conventions, we rename it in the Specification, XML, and header files.
For backwards compatibility, the original (incorrect) name is retained as a
> typo alias.
The alias is deprecated and should not be used, but will be retained
indefinitely.


::note
`VK_STENCIL_FRONT_AND_BACK` is an example of a *typo alias*.
It was initially defined as part of [VkStencilFaceFlagBits](/man/VkStencilFaceFlagBits).
Once the naming inconsistency was noticed, it was renamed to
`VK_STENCIL_FACE_FRONT_AND_BACK`, and the old name was aliased to the
correct name.
::








# Initialization

Before using Vulkan, an application :normative{type="must"} initialize it by loading the
Vulkan commands, and creating a `VkInstance` object.



## Command Function Pointers

Vulkan commands are not necessarily exposed by static linking on a platform.
Commands to query function pointers for Vulkan commands are described below.


::note
When extensions are promoted or
otherwise incorporated into another extension or Vulkan core version,
command aliases may be included.
Whilst the behavior of each command alias is identical, the behavior of
retrieving each alias’s function pointer is not.
A function pointer for a given alias can only be retrieved if the extension
or version that introduced that alias is supported and enabled, irrespective
of whether any other alias is available.
::


Function pointers for all Vulkan commands :normative{type="can"} be obtained by calling:

[{generated}/api/protos/vkGetInstanceProcAddr.adoc]({generated}/api/protos/vkGetInstanceProcAddr.adoc)

- `instance` is the instance that the function pointer will be
  compatible with, or `NULL` for commands not dependent on any instance.

- `pName` is the name of the command to obtain.

`vkGetInstanceProcAddr` itself is obtained in a platform- and loader-
specific manner.
Typically, the loader library will export this command as a function symbol,
so applications :normative{type="can"} link against the loader library, or load it dynamically
and look up the symbol using platform-specific APIs.

The table below defines the various use cases for
`vkGetInstanceProcAddr` and expected return value (> fp is > function
> pointer) for each case.
A valid returned function pointer (> fp) :normative{type="must"} not be `NULL`.

The returned function pointer is of type [PFN\_vkVoidFunction](/man/PFN_vkVoidFunction), and :normative{type="must"}
be cast to the type of the command being queried before use.






::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkGetInstanceProcAddr-instance-parameter"}
 If `instance` is not `NULL`, `instance` :normative{type="must"} be a valid [VkInstance](/man/VkInstance) handle
::

::validity-field{name="VUID-vkGetInstanceProcAddr-pName-parameter"}
 `pName` :normative{type="must"} be a null-terminated UTF-8 string
::

::


In order to support systems with multiple Vulkan implementations, the
function pointers returned by [vkGetInstanceProcAddr](/man/vkGetInstanceProcAddr) :normative{type="may"} point to
dispatch code that calls a different real implementation for different
[VkDevice](/man/VkDevice) objects or their child objects.
The overhead of the internal dispatch for [VkDevice](/man/VkDevice) objects can be
avoided by obtaining device-specific function pointers for any commands that
use a device or device-child object as their dispatchable object.
Such function pointers :normative{type="can"} be obtained by calling:

[{generated}/api/protos/vkGetDeviceProcAddr.adoc]({generated}/api/protos/vkGetDeviceProcAddr.adoc)

The table below defines the various use cases for `vkGetDeviceProcAddr`
and expected return value (> fp is > function pointer) for each case.
A valid returned function pointer (> fp) :normative{type="must"} not be `NULL`.

The returned function pointer is of type [PFN\_vkVoidFunction](/man/PFN_vkVoidFunction), and :normative{type="must"}
be cast to the type of the command being queried before use.
The function pointer :normative{type="must"} only be called with a dispatchable object (the
first parameter) that is `device` or a child of `device`.






::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkGetDeviceProcAddr-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkGetDeviceProcAddr-pName-parameter"}
 `pName` :normative{type="must"} be a null-terminated UTF-8 string
::

::


The definition of [PFN\_vkVoidFunction](/man/PFN_vkVoidFunction) is:

[{generated}/api/funcpointers/PFN\_vkVoidFunction.adoc]({generated}/api/funcpointers/PFN_vkVoidFunction.adoc)

This type is returned from command function pointer queries, and :normative{type="must"} be
cast to an actual command function pointer before use.





## Instances

There is no global state in Vulkan and all per-application state is stored
in a `VkInstance` object.
Creating a `VkInstance` object initializes the Vulkan library and allows
the application to pass information about itself to the implementation.

Instances are represented by `VkInstance` handles:

[{generated}/api/handles/VkInstance.adoc]({generated}/api/handles/VkInstance.adoc)

To create an instance object, call:

[{generated}/api/protos/vkCreateInstance.adoc]({generated}/api/protos/vkCreateInstance.adoc)

- `pCreateInfo` is a pointer to a [VkInstanceCreateInfo](/man/VkInstanceCreateInfo) structure
  controlling creation of the instance.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

- `pInstance` points a [VkInstance](/man/VkInstance) handle in which the resulting
  instance is returned.

`vkCreateInstance` verifies that the requested layers exist.
If not, `vkCreateInstance` will return `VK_ERROR_LAYER_NOT_PRESENT`.
Next `vkCreateInstance` verifies that the requested extensions are
supported (e.g. in the implementation or in any enabled instance layer) and
if any requested extension is not supported, `vkCreateInstance` :normative{type="must"}
return `VK_ERROR_EXTENSION_NOT_PRESENT`.
After verifying and enabling the instance layers and extensions the
`VkInstance` object is created and returned to the application.
If a requested extension is only supported by a layer, both the layer and
the extension need to be specified at `vkCreateInstance` time for the
creation to succeed.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCreateInstance-ppEnabledExtensionNames-01388"}

All required
extensions for each extension in the
[VkInstanceCreateInfo](/man/VkInstanceCreateInfo)::`ppEnabledExtensionNames` list :normative{type="must"}
also be present in that list
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCreateInstance-pCreateInfo-parameter"}
 `pCreateInfo` :normative{type="must"} be a valid pointer to a valid [VkInstanceCreateInfo](/man/VkInstanceCreateInfo) structure
::

::validity-field{name="VUID-vkCreateInstance-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkCreateInstance-pInstance-parameter"}
 `pInstance` :normative{type="must"} be a valid pointer to a [VkInstance](/man/VkInstance) handle
::

::




The `VkInstanceCreateInfo` structure is defined as:

[{generated}/api/structs/VkInstanceCreateInfo.adoc]({generated}/api/structs/VkInstanceCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is a bitmask of [VkInstanceCreateFlagBits](/man/VkInstanceCreateFlagBits) indicating
  the behavior of the instance.

- `pApplicationInfo` is `NULL` or a pointer to a
  `VkApplicationInfo` structure.
  If not `NULL`, this information helps implementations recognize behavior
  inherent to classes of applications.
  [VkApplicationInfo](/man/VkApplicationInfo) is defined in detail below.

- `enabledLayerCount` is the number of global layers to enable.

- `ppEnabledLayerNames` is a pointer to an array of
  `enabledLayerCount` null-terminated UTF-8 strings containing the
  names of layers to enable for the created instance.
  The layers are loaded in the order they are listed in this array, with
  the first array element being the closest to the application, and the
  last array element being the closest to the driver.
  See the  section for further details.

- `enabledExtensionCount` is the number of global extensions to
  enable.

- `ppEnabledExtensionNames` is a pointer to an array of
  `enabledExtensionCount` null-terminated UTF-8 strings containing the
  names of extensions to enable.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkInstanceCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO`
::

::validity-field{name="VUID-VkInstanceCreateInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkDebugReportCallbackCreateInfoEXT](/man/VkDebugReportCallbackCreateInfoEXT), [VkDebugUtilsMessengerCreateInfoEXT](/man/VkDebugUtilsMessengerCreateInfoEXT), [VkDirectDriverLoadingListLUNARG](/man/VkDirectDriverLoadingListLUNARG), [VkExportMetalObjectCreateInfoEXT](/man/VkExportMetalObjectCreateInfoEXT), [VkValidationFeaturesEXT](/man/VkValidationFeaturesEXT), or [VkValidationFlagsEXT](/man/VkValidationFlagsEXT)
::

::validity-field{name="VUID-VkInstanceCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique, with the exception of structures of type [VkDebugUtilsMessengerCreateInfoEXT](/man/VkDebugUtilsMessengerCreateInfoEXT) or [VkExportMetalObjectCreateInfoEXT](/man/VkExportMetalObjectCreateInfoEXT)
::

::validity-field{name="VUID-VkInstanceCreateInfo-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkInstanceCreateFlagBits](/man/VkInstanceCreateFlagBits) values
::

::validity-field{name="VUID-VkInstanceCreateInfo-pApplicationInfo-parameter"}
 If `pApplicationInfo` is not `NULL`, `pApplicationInfo` :normative{type="must"} be a valid pointer to a valid [VkApplicationInfo](/man/VkApplicationInfo) structure
::

::validity-field{name="VUID-VkInstanceCreateInfo-ppEnabledLayerNames-parameter"}
 If `enabledLayerCount` is not `0`, `ppEnabledLayerNames` :normative{type="must"} be a valid pointer to an array of `enabledLayerCount` null-terminated UTF-8 strings
::

::validity-field{name="VUID-VkInstanceCreateInfo-ppEnabledExtensionNames-parameter"}
 If `enabledExtensionCount` is not `0`, `ppEnabledExtensionNames` :normative{type="must"} be a valid pointer to an array of `enabledExtensionCount` null-terminated UTF-8 strings
::

::


[{generated}/api/enums/VkInstanceCreateFlagBits.adoc]({generated}/api/enums/VkInstanceCreateFlagBits.adoc)


::note
All bits for this type are defined by extensions, and none of those
extensions are enabled in this build of the specification.
::


[{generated}/api/flags/VkInstanceCreateFlags.adoc]({generated}/api/flags/VkInstanceCreateFlags.adoc)

`VkInstanceCreateFlags` is a bitmask type for setting a mask, but is
currently reserved for future use.

The `VkApplicationInfo` structure is defined as:

[{generated}/api/structs/VkApplicationInfo.adoc]({generated}/api/structs/VkApplicationInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `pApplicationName` is `NULL` or is a pointer to a null-terminated
  UTF-8 string containing the name of the application.

- `applicationVersion` is an unsigned integer variable containing the
  developer-supplied version number of the application.

- `pEngineName` is `NULL` or is a pointer to a null-terminated UTF-8
  string containing the name of the engine (if any) used to create the
  application.

- `engineVersion` is an unsigned integer variable containing the
  developer-supplied version number of the engine used to create the
  application.

- `apiVersion` is the version of the Vulkan API against which the
  application expects to run, encoded as described in
  .
  If `apiVersion` is 0 the implementation :normative{type="must"} ignore it, otherwise
  if the implementation does not support the requested `apiVersion`,
  or an effective substitute for `apiVersion`, it :normative{type="must"} return
  `VK_ERROR_INCOMPATIBLE_DRIVER`.
  The patch version number specified in `apiVersion` is ignored when
  creating an instance object.
  The variant version of the instance :normative{type="must"} match that requested in
  `apiVersion`.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkApplicationInfo-apiVersion-04010"}

If `apiVersion` is not `0`, then it :normative{type="must"} be greater than or equal
to [VK_API_VERSION_1_0](/man/VK_API_VERSION_1_0)
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkApplicationInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_APPLICATION_INFO`
::

::validity-field{name="VUID-VkApplicationInfo-pNext-pNext"}
 `pNext` :normative{type="must"} be `NULL`
::

::validity-field{name="VUID-VkApplicationInfo-pApplicationName-parameter"}
 If `pApplicationName` is not `NULL`, `pApplicationName` :normative{type="must"} be a null-terminated UTF-8 string
::

::validity-field{name="VUID-VkApplicationInfo-pEngineName-parameter"}
 If `pEngineName` is not `NULL`, `pEngineName` :normative{type="must"} be a null-terminated UTF-8 string
::

::


To destroy an instance, call:

[{generated}/api/protos/vkDestroyInstance.adoc]({generated}/api/protos/vkDestroyInstance.adoc)

- `instance` is the handle of the instance to destroy.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkDestroyInstance-instance-00629"}

All child objects created using `instance` :normative{type="must"} have been destroyed
prior to destroying `instance`
::

::validity-field{name="VUID-vkDestroyInstance-instance-00630"}

If `VkAllocationCallbacks` were provided when `instance` was
created, a compatible set of callbacks :normative{type="must"} be provided here
::

::validity-field{name="VUID-vkDestroyInstance-instance-00631"}

If no `VkAllocationCallbacks` were provided when `instance` was
created, `pAllocator` :normative{type="must"} be `NULL`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkDestroyInstance-instance-parameter"}
 If `instance` is not `NULL`, `instance` :normative{type="must"} be a valid [VkInstance](/man/VkInstance) handle
::

::validity-field{name="VUID-vkDestroyInstance-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::










# Devices and Queues

Once Vulkan is initialized, devices and queues are the primary objects used
to interact with a Vulkan implementation.

Vulkan separates the concept of *physical* and *logical* devices.
A physical device usually represents a single complete implementation of
Vulkan (excluding instance-level functionality) available to the host, of
which there are a finite number.
A logical device represents an instance of that implementation with its own
state and resources independent of other logical devices.

Physical devices are represented by `VkPhysicalDevice` handles:

[{generated}/api/handles/VkPhysicalDevice.adoc]({generated}/api/handles/VkPhysicalDevice.adoc)



## Physical Devices

To retrieve a list of physical device objects representing the physical
devices installed in the system, call:

[{generated}/api/protos/vkEnumeratePhysicalDevices.adoc]({generated}/api/protos/vkEnumeratePhysicalDevices.adoc)

- `instance` is a handle to a Vulkan instance previously created with
  [vkCreateInstance](/man/vkCreateInstance).

- `pPhysicalDeviceCount` is a pointer to an integer related to the
  number of physical devices available or queried, as described below.

- `pPhysicalDevices` is either `NULL` or a pointer to an array of
  `VkPhysicalDevice` handles.

If `pPhysicalDevices` is `NULL`, then the number of physical devices
available is returned in `pPhysicalDeviceCount`.
Otherwise, `pPhysicalDeviceCount` :normative{type="must"} point to a variable set by the
user to the number of elements in the `pPhysicalDevices` array, and on
return the variable is overwritten with the number of handles actually
written to `pPhysicalDevices`.
If `pPhysicalDeviceCount` is less than the number of physical devices
available, at most `pPhysicalDeviceCount` structures will be written,
and `VK_INCOMPLETE` will be returned instead of `VK_SUCCESS`, to
indicate that not all the available physical devices were returned.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkEnumeratePhysicalDevices-instance-parameter"}
 `instance` :normative{type="must"} be a valid [VkInstance](/man/VkInstance) handle
::

::validity-field{name="VUID-vkEnumeratePhysicalDevices-pPhysicalDeviceCount-parameter"}
 `pPhysicalDeviceCount` :normative{type="must"} be a valid pointer to a `uint32_t` value
::

::validity-field{name="VUID-vkEnumeratePhysicalDevices-pPhysicalDevices-parameter"}
 If the value referenced by `pPhysicalDeviceCount` is not `0`, and `pPhysicalDevices` is not `NULL`, `pPhysicalDevices` :normative{type="must"} be a valid pointer to an array of `pPhysicalDeviceCount` [VkPhysicalDevice](/man/VkPhysicalDevice) handles
::

::




To query general properties of physical devices once enumerated, call:

[{generated}/api/protos/vkGetPhysicalDeviceProperties.adoc]({generated}/api/protos/vkGetPhysicalDeviceProperties.adoc)

- `physicalDevice` is the handle to the physical device whose
  properties will be queried.

- `pProperties` is a pointer to a [VkPhysicalDeviceProperties](/man/VkPhysicalDeviceProperties)
  structure in which properties are returned.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkGetPhysicalDeviceProperties-physicalDevice-parameter"}
 `physicalDevice` :normative{type="must"} be a valid [VkPhysicalDevice](/man/VkPhysicalDevice) handle
::

::validity-field{name="VUID-vkGetPhysicalDeviceProperties-pProperties-parameter"}
 `pProperties` :normative{type="must"} be a valid pointer to a [VkPhysicalDeviceProperties](/man/VkPhysicalDeviceProperties) structure
::

::


The `VkPhysicalDeviceProperties` structure is defined as:

[{generated}/api/structs/VkPhysicalDeviceProperties.adoc]({generated}/api/structs/VkPhysicalDeviceProperties.adoc)

- `apiVersion` is the version of Vulkan supported by the device,
  encoded as described in .

- `driverVersion` is the vendor-specified version of the driver.

- `vendorID` is a unique identifier for the *vendor* (see below) of
  the physical device.

- `deviceID` is a unique identifier for the physical device among
  devices available from the vendor.

- `deviceType` is a [VkPhysicalDeviceType](/man/VkPhysicalDeviceType) specifying the type of
  device.

- `deviceName` is an array of `VK_MAX_PHYSICAL_DEVICE_NAME_SIZE`

  `char` containing a null-terminated UTF-8 string which is the name of
  the device.

- `pipelineCacheUUID` is an array of `VK_UUID_SIZE` `uint8_t`
  values representing a universally unique identifier for the device.

- `limits` is the [VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits) structure specifying
  device-specific limits of the physical device.
  See Limits for details.

- `sparseProperties` is the [VkPhysicalDeviceSparseProperties](/man/VkPhysicalDeviceSparseProperties)
  structure specifying various sparse related properties of the physical
  device.
  See Sparse Properties for details.


::note
The encoding of `driverVersion` is implementation-defined.
It :normative{type="may"} not use the same encoding as `apiVersion`.
Applications should follow information from the *vendor* on how to extract
the version information from `driverVersion`.
::


The `vendorID` and `deviceID` fields are provided to allow
applications to adapt to device characteristics that are not adequately
exposed by other Vulkan queries.


::note
These :normative{type="may"} include performance profiles, hardware errata, or other
characteristics.
::


The *vendor* identified by `vendorID` is the entity responsible for the
most salient characteristics of the underlying implementation of the
[VkPhysicalDevice](/man/VkPhysicalDevice) being queried.


::note
For example, in the case of a discrete GPU implementation, this :normative{type="should"} be
the GPU chipset vendor.
In the case of a hardware accelerator integrated into a system-on-chip
(SoC), this :normative{type="should"} be the supplier of the silicon IP used to create the
accelerator.
::


If the vendor has a [PCI
vendor ID](https://pcisig.com/membership/member-companies), the low 16 bits of `vendorID` :normative{type="must"} contain that PCI vendor
ID, and the remaining bits :normative{type="must"} be set to zero.
Otherwise, the value returned :normative{type="must"} be a valid Khronos vendor ID, obtained
as described in the Vulkan Documentation and Extensions:
Procedures and Conventions document in the section > Registering a Vendor
> ID with Khronos.
Khronos vendor IDs are allocated starting at 0x10000, to distinguish them
from the PCI vendor ID namespace.
Khronos vendor IDs are symbolically defined in the [VkVendorId](/man/VkVendorId) type.

The vendor is also responsible for the value returned in `deviceID`.
If the implementation is driven primarily by a [PCI
device](https://pcisig.com/) with a [PCI device ID](https://pcisig.com/), the low 16 bits of
`deviceID` :normative{type="must"} contain that PCI device ID, and the remaining bits
:normative{type="must"} be set to zero.
Otherwise, the choice of what values to return :normative{type="may"} be dictated by operating
system or platform policies - but :normative{type="should"} uniquely identify both the device
version and any major configuration options (for example, core count in the
case of multicore devices).


::note
The same device ID :normative{type="should"} be used for all physical implementations of that
device version and configuration.
For example, all uses of a specific silicon IP GPU version and configuration
:normative{type="should"} use the same device ID, even if those uses occur in different SoCs.
::


Khronos vendor IDs which :normative{type="may"} be returned in
[VkPhysicalDeviceProperties](/man/VkPhysicalDeviceProperties)::`vendorID` are:

[{generated}/api/enums/VkVendorId.adoc]({generated}/api/enums/VkVendorId.adoc)


::note
Khronos vendor IDs may be allocated by vendors at any time.
Only the latest canonical versions of this Specification, of the
corresponding `vk.xml` API Registry, and of the corresponding
`vulkan_core.h` header file :normative{type="must"} contain all reserved Khronos vendor IDs.

Only Khronos vendor IDs are given symbolic names at present.
PCI vendor IDs returned by the implementation can be looked up in the
PCI-SIG database.
::


`VK_MAX_PHYSICAL_DEVICE_NAME_SIZE` is the length in `char` values of
an array containing a physical device name string, as returned in
[VkPhysicalDeviceProperties](/man/VkPhysicalDeviceProperties)::`deviceName`.

[{generated}/api/enums/VK\_MAX\_PHYSICAL\_DEVICE\_NAME\_SIZE.adoc]({generated}/api/enums/VK_MAX_PHYSICAL_DEVICE_NAME_SIZE.adoc)

The physical device types which :normative{type="may"} be returned in
[VkPhysicalDeviceProperties](/man/VkPhysicalDeviceProperties)::`deviceType` are:

[{generated}/api/enums/VkPhysicalDeviceType.adoc]({generated}/api/enums/VkPhysicalDeviceType.adoc)

- `VK_PHYSICAL_DEVICE_TYPE_OTHER` - the device does not match any
  other available types.

- `VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU` - the device is typically
  one embedded in or tightly coupled with the host.

- `VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU` - the device is typically a
  separate processor connected to the host via an interlink.

- `VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU` - the device is typically a
  virtual node in a virtualization environment.

- `VK_PHYSICAL_DEVICE_TYPE_CPU` - the device is typically running on
  the same processors as the host.

The physical device type is advertised for informational purposes only, and
does not directly affect the operation of the system.
However, the device type :normative{type="may"} correlate with other advertised properties or
capabilities of the system, such as how many memory heaps there are.

To query properties of queues available on a physical device, call:

[{generated}/api/protos/vkGetPhysicalDeviceQueueFamilyProperties.adoc]({generated}/api/protos/vkGetPhysicalDeviceQueueFamilyProperties.adoc)

- `physicalDevice` is the handle to the physical device whose
  properties will be queried.

- `pQueueFamilyPropertyCount` is a pointer to an integer related to
  the number of queue families available or queried, as described below.

- `pQueueFamilyProperties` is either `NULL` or a pointer to an array
  of [VkQueueFamilyProperties](/man/VkQueueFamilyProperties) structures.

If `pQueueFamilyProperties` is `NULL`, then the number of queue families
available is returned in `pQueueFamilyPropertyCount`.
Implementations :normative{type="must"} support at least one queue family.
Otherwise, `pQueueFamilyPropertyCount` :normative{type="must"} point to a variable set by
the user to the number of elements in the `pQueueFamilyProperties`
array, and on return the variable is overwritten with the number of
structures actually written to `pQueueFamilyProperties`.
If `pQueueFamilyPropertyCount` is less than the number of queue families
available, at most `pQueueFamilyPropertyCount` structures will be
written.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkGetPhysicalDeviceQueueFamilyProperties-physicalDevice-parameter"}
 `physicalDevice` :normative{type="must"} be a valid [VkPhysicalDevice](/man/VkPhysicalDevice) handle
::

::validity-field{name="VUID-vkGetPhysicalDeviceQueueFamilyProperties-pQueueFamilyPropertyCount-parameter"}
 `pQueueFamilyPropertyCount` :normative{type="must"} be a valid pointer to a `uint32_t` value
::

::validity-field{name="VUID-vkGetPhysicalDeviceQueueFamilyProperties-pQueueFamilyProperties-parameter"}
 If the value referenced by `pQueueFamilyPropertyCount` is not `0`, and `pQueueFamilyProperties` is not `NULL`, `pQueueFamilyProperties` :normative{type="must"} be a valid pointer to an array of `pQueueFamilyPropertyCount` [VkQueueFamilyProperties](/man/VkQueueFamilyProperties) structures
::

::


The `VkQueueFamilyProperties` structure is defined as:

[{generated}/api/structs/VkQueueFamilyProperties.adoc]({generated}/api/structs/VkQueueFamilyProperties.adoc)

- `queueFlags` is a bitmask of [VkQueueFlagBits](/man/VkQueueFlagBits) indicating
  capabilities of the queues in this queue family.

- `queueCount` is the unsigned integer count of queues in this queue
  family.
  Each queue family :normative{type="must"} support at least one queue.

- `timestampValidBits` is the unsigned integer count of meaningful
  bits in the timestamps written via
  [vkCmdWriteTimestamp](/man/vkCmdWriteTimestamp).
  The valid range for the count is 36 to 64 bits, or a value of 0,
  indicating no support for timestamps.
  Bits outside the valid range are guaranteed to be zeros.

- `minImageTransferGranularity` is the minimum granularity supported
  for image transfer operations on the queues in this queue family.

The value returned in `minImageTransferGranularity` has a unit of
compressed texel blocks for images having a block-compressed format, and a
unit of texels otherwise.

Possible values of `minImageTransferGranularity` are:

- (0,0,0) specifies that only whole mip levels :normative{type="must"} be transferred
  using the image transfer operations on the corresponding queues.
  In this case, the following restrictions apply to all offset and extent
  parameters of image transfer operations:





  * The `x`, `y`, and `z` members of a [VkOffset3D](/man/VkOffset3D)
    parameter :normative{type="must"} always be zero.

  * The `width`, `height`, and `depth` members of a
    [VkExtent3D](/man/VkExtent3D) parameter :normative{type="must"} always match the width, height, and
    depth of the image subresource corresponding to the parameter,
    respectively.

- (A\<sub>x\</sub>, A\<sub>y\</sub>, A\<sub>z\</sub>) where A\<sub>x\</sub>, A\<sub>y\</sub>, and A\<sub>z\</sub>
  are all integer powers of two.
  In this case the following restrictions apply to all image transfer
  operations:





  * `x`, `y`, and `z` of a [VkOffset3D](/man/VkOffset3D) parameter :normative{type="must"} be
    integer multiples of A\<sub>x\</sub>, A\<sub>y\</sub>, and A\<sub>z\</sub>,
    respectively.

  * `width` of a [VkExtent3D](/man/VkExtent3D) parameter :normative{type="must"} be an integer
    multiple of A\<sub>x\</sub>, or else `x` +  `width` :normative{type="must"}
    equal the width of the image subresource corresponding to the
    parameter.

  * `height` of a [VkExtent3D](/man/VkExtent3D) parameter :normative{type="must"} be an integer
    multiple of A\<sub>y\</sub>, or else `y` +  `height` :normative{type="must"}
    equal the height of the image subresource corresponding to the
    parameter.

  * `depth` of a [VkExtent3D](/man/VkExtent3D) parameter :normative{type="must"} be an integer
    multiple of A\<sub>z\</sub>, or else `z` +  `depth` :normative{type="must"}
    equal the depth of the image subresource corresponding to the
    parameter.

  * If the format of the image corresponding to the parameters is one of
    the block-compressed formats then for the purposes of the above
    calculations the granularity :normative{type="must"} be scaled up by the compressed texel
    block dimensions.

Queues supporting graphics and/or compute operations :normative{type="must"} report
(1,1,1) in `minImageTransferGranularity`, meaning that there are
no additional restrictions on the granularity of image transfer operations
for these queues.
Other queues supporting image transfer operations are only :normative{type="required"} to
support whole mip level transfers, thus `minImageTransferGranularity`
for queues belonging to such queue families :normative{type="may"} be (0,0,0).

The Device Memory section describes memory properties
queried from the physical device.

For physical device feature queries see the Features chapter.

Bits which :normative{type="may"} be set in [VkQueueFamilyProperties](/man/VkQueueFamilyProperties)::`queueFlags`,
indicating capabilities of queues in a queue family are:

[{generated}/api/enums/VkQueueFlagBits.adoc]({generated}/api/enums/VkQueueFlagBits.adoc)

- `VK_QUEUE_GRAPHICS_BIT` specifies that queues in this queue family
  support graphics operations.

- `VK_QUEUE_COMPUTE_BIT` specifies that queues in this queue family
  support compute operations.

- `VK_QUEUE_TRANSFER_BIT` specifies that queues in this queue family
  support transfer operations.

- `VK_QUEUE_SPARSE_BINDING_BIT` specifies that queues in this queue
  family support sparse memory management operations (see
  Sparse Resources).
  If any of the sparse resource features are enabled, then at least one
  queue family :normative{type="must"} support this bit.

If an implementation exposes any queue family that supports graphics
operations, at least one queue family of at least one physical device
exposed by the implementation :normative{type="must"} support both graphics and compute
operations.


::note
All commands that are allowed on a queue that supports transfer operations
are also allowed on a queue that supports either graphics or compute
operations.
Thus, if the capabilities of a queue family include
`VK_QUEUE_GRAPHICS_BIT` or `VK_QUEUE_COMPUTE_BIT`, then reporting
the `VK_QUEUE_TRANSFER_BIT` capability separately for that queue family
is :normative{type="optional"}.
::


For further details see Queues.

[{generated}/api/flags/VkQueueFlags.adoc]({generated}/api/flags/VkQueueFlags.adoc)

`VkQueueFlags` is a bitmask type for setting a mask of zero or more
[VkQueueFlagBits](/man/VkQueueFlagBits).





## Devices

Device objects represent logical connections to physical devices.
Each device exposes a number of *queue families* each having one or more
*queues*.
All queues in a queue family support the same operations.

As described in Physical
Devices, a Vulkan application will first query for all physical devices in
a system.
Each physical device :normative{type="can"} then be queried for its capabilities, including
its queue and queue family properties.
Once an acceptable physical device is identified, an application will create
a corresponding logical device.
The created logical device is then the primary interface to the physical
device.

How to enumerate the physical devices in a system and query those physical
devices for their queue family properties is described in the
Physical Device Enumeration
section above.



### Device Creation

Logical devices are represented by `VkDevice` handles:

[{generated}/api/handles/VkDevice.adoc]({generated}/api/handles/VkDevice.adoc)

A logical device is created as a *connection* to a physical device.
To create a logical device, call:

[{generated}/api/protos/vkCreateDevice.adoc]({generated}/api/protos/vkCreateDevice.adoc)

- `physicalDevice` :normative{type="must"} be one of the device handles returned from a
  call to `vkEnumeratePhysicalDevices` (see
  Physical Device
  Enumeration).

- `pCreateInfo` is a pointer to a [VkDeviceCreateInfo](/man/VkDeviceCreateInfo) structure
  containing information about how to create the device.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

- `pDevice` is a pointer to a handle in which the created
  [VkDevice](/man/VkDevice) is returned.

`vkCreateDevice` verifies that extensions and features requested in the
`ppEnabledExtensionNames` and `pEnabledFeatures` members of
`pCreateInfo`, respectively, are supported by the implementation.
If any requested extension is not supported, `vkCreateDevice` :normative{type="must"}
return `VK_ERROR_EXTENSION_NOT_PRESENT`.
If any requested feature is not supported, `vkCreateDevice` :normative{type="must"} return
`VK_ERROR_FEATURE_NOT_PRESENT`.
Support for extensions :normative{type="can"} be checked before creating a device by querying
[vkEnumerateDeviceExtensionProperties](/man/vkEnumerateDeviceExtensionProperties).
Support for features :normative{type="can"} similarly be checked by querying
[vkGetPhysicalDeviceFeatures](/man/vkGetPhysicalDeviceFeatures).

After verifying and enabling the extensions the `VkDevice` object is
created and returned to the application.

Multiple logical devices :normative{type="can"} be created from the same physical device.
Logical device creation :normative{type="may"} fail due to lack of device-specific resources
(in addition to other errors).
If that occurs, `vkCreateDevice` will return
`VK_ERROR_TOO_MANY_OBJECTS`.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCreateDevice-ppEnabledExtensionNames-01387"}

All required device
extensions for each extension in the
[VkDeviceCreateInfo](/man/VkDeviceCreateInfo)::`ppEnabledExtensionNames` list :normative{type="must"} also
be present in that list
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCreateDevice-physicalDevice-parameter"}
 `physicalDevice` :normative{type="must"} be a valid [VkPhysicalDevice](/man/VkPhysicalDevice) handle
::

::validity-field{name="VUID-vkCreateDevice-pCreateInfo-parameter"}
 `pCreateInfo` :normative{type="must"} be a valid pointer to a valid [VkDeviceCreateInfo](/man/VkDeviceCreateInfo) structure
::

::validity-field{name="VUID-vkCreateDevice-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkCreateDevice-pDevice-parameter"}
 `pDevice` :normative{type="must"} be a valid pointer to a [VkDevice](/man/VkDevice) handle
::

::




The `VkDeviceCreateInfo` structure is defined as:

[{generated}/api/structs/VkDeviceCreateInfo.adoc]({generated}/api/structs/VkDeviceCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is reserved for future use.

- `queueCreateInfoCount` is the unsigned integer size of the
  `pQueueCreateInfos` array.
  Refer to the Queue Creation section
  below for further details.

- `pQueueCreateInfos` is a pointer to an array of
  [VkDeviceQueueCreateInfo](/man/VkDeviceQueueCreateInfo) structures describing the queues that are
  requested to be created along with the logical device.
  Refer to the Queue Creation section
  below for further details.

- `enabledLayerCount` is deprecated and ignored.

- `ppEnabledLayerNames` is deprecated and ignored.
  See .

- `enabledExtensionCount` is the number of device extensions to
  enable.

- `ppEnabledExtensionNames` is a pointer to an array of
  `enabledExtensionCount` null-terminated UTF-8 strings containing the
  names of extensions to enable for the created device.
  See the  section for further details.

- `pEnabledFeatures` is `NULL` or a pointer to a
  [VkPhysicalDeviceFeatures](/man/VkPhysicalDeviceFeatures) structure containing boolean indicators
  of all the features to be enabled.
  Refer to the Features section for further details.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkDeviceCreateInfo-queueFamilyIndex-02802"}

The `queueFamilyIndex` member of each element of
`pQueueCreateInfos` :normative{type="must"} be unique within `pQueueCreateInfos`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkDeviceCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO`
::

::validity-field{name="VUID-VkDeviceCreateInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkDeviceDeviceMemoryReportCreateInfoEXT](/man/VkDeviceDeviceMemoryReportCreateInfoEXT), [VkDeviceDiagnosticsConfigCreateInfoNV](/man/VkDeviceDiagnosticsConfigCreateInfoNV), [VkDeviceGroupDeviceCreateInfo](/man/VkDeviceGroupDeviceCreateInfo), [VkDeviceMemoryOverallocationCreateInfoAMD](/man/VkDeviceMemoryOverallocationCreateInfoAMD), [VkDevicePrivateDataCreateInfo](/man/VkDevicePrivateDataCreateInfo), [VkDeviceQueueShaderCoreControlCreateInfoARM](/man/VkDeviceQueueShaderCoreControlCreateInfoARM), [VkPhysicalDevice16BitStorageFeatures](/man/VkPhysicalDevice16BitStorageFeatures), [VkPhysicalDevice4444FormatsFeaturesEXT](/man/VkPhysicalDevice4444FormatsFeaturesEXT), [VkPhysicalDevice8BitStorageFeatures](/man/VkPhysicalDevice8BitStorageFeatures), [VkPhysicalDeviceASTCDecodeFeaturesEXT](/man/VkPhysicalDeviceASTCDecodeFeaturesEXT), [VkPhysicalDeviceAccelerationStructureFeaturesKHR](/man/VkPhysicalDeviceAccelerationStructureFeaturesKHR), [VkPhysicalDeviceAddressBindingReportFeaturesEXT](/man/VkPhysicalDeviceAddressBindingReportFeaturesEXT), [VkPhysicalDeviceAmigoProfilingFeaturesSEC](/man/VkPhysicalDeviceAmigoProfilingFeaturesSEC), [VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT](/man/VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT), [VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT](/man/VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT), [VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT](/man/VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT), [VkPhysicalDeviceBorderColorSwizzleFeaturesEXT](/man/VkPhysicalDeviceBorderColorSwizzleFeaturesEXT), [VkPhysicalDeviceBufferDeviceAddressFeatures](/man/VkPhysicalDeviceBufferDeviceAddressFeatures), [VkPhysicalDeviceBufferDeviceAddressFeaturesEXT](/man/VkPhysicalDeviceBufferDeviceAddressFeaturesEXT), [VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI](/man/VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI), [VkPhysicalDeviceCoherentMemoryFeaturesAMD](/man/VkPhysicalDeviceCoherentMemoryFeaturesAMD), [VkPhysicalDeviceColorWriteEnableFeaturesEXT](/man/VkPhysicalDeviceColorWriteEnableFeaturesEXT), [VkPhysicalDeviceComputeShaderDerivativesFeaturesNV](/man/VkPhysicalDeviceComputeShaderDerivativesFeaturesNV), [VkPhysicalDeviceConditionalRenderingFeaturesEXT](/man/VkPhysicalDeviceConditionalRenderingFeaturesEXT), [VkPhysicalDeviceCooperativeMatrixFeaturesKHR](/man/VkPhysicalDeviceCooperativeMatrixFeaturesKHR), [VkPhysicalDeviceCooperativeMatrixFeaturesNV](/man/VkPhysicalDeviceCooperativeMatrixFeaturesNV), [VkPhysicalDeviceCopyMemoryIndirectFeaturesNV](/man/VkPhysicalDeviceCopyMemoryIndirectFeaturesNV), [VkPhysicalDeviceCornerSampledImageFeaturesNV](/man/VkPhysicalDeviceCornerSampledImageFeaturesNV), [VkPhysicalDeviceCoverageReductionModeFeaturesNV](/man/VkPhysicalDeviceCoverageReductionModeFeaturesNV), [VkPhysicalDeviceCubicClampFeaturesQCOM](/man/VkPhysicalDeviceCubicClampFeaturesQCOM), [VkPhysicalDeviceCubicWeightsFeaturesQCOM](/man/VkPhysicalDeviceCubicWeightsFeaturesQCOM), [VkPhysicalDeviceCudaKernelLaunchFeaturesNV](/man/VkPhysicalDeviceCudaKernelLaunchFeaturesNV), [VkPhysicalDeviceCustomBorderColorFeaturesEXT](/man/VkPhysicalDeviceCustomBorderColorFeaturesEXT), [VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV](/man/VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV), [VkPhysicalDeviceDepthBiasControlFeaturesEXT](/man/VkPhysicalDeviceDepthBiasControlFeaturesEXT), [VkPhysicalDeviceDepthClampZeroOneFeaturesEXT](/man/VkPhysicalDeviceDepthClampZeroOneFeaturesEXT), [VkPhysicalDeviceDepthClipControlFeaturesEXT](/man/VkPhysicalDeviceDepthClipControlFeaturesEXT), [VkPhysicalDeviceDepthClipEnableFeaturesEXT](/man/VkPhysicalDeviceDepthClipEnableFeaturesEXT), [VkPhysicalDeviceDescriptorBufferFeaturesEXT](/man/VkPhysicalDeviceDescriptorBufferFeaturesEXT), [VkPhysicalDeviceDescriptorIndexingFeatures](/man/VkPhysicalDeviceDescriptorIndexingFeatures), [VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV](/man/VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV), [VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE](/man/VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE), [VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV](/man/VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV), [VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV](/man/VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV), [VkPhysicalDeviceDeviceMemoryReportFeaturesEXT](/man/VkPhysicalDeviceDeviceMemoryReportFeaturesEXT), [VkPhysicalDeviceDiagnosticsConfigFeaturesNV](/man/VkPhysicalDeviceDiagnosticsConfigFeaturesNV), [VkPhysicalDeviceDisplacementMicromapFeaturesNV](/man/VkPhysicalDeviceDisplacementMicromapFeaturesNV), [VkPhysicalDeviceDynamicRenderingFeatures](/man/VkPhysicalDeviceDynamicRenderingFeatures), [VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT](/man/VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT), [VkPhysicalDeviceExclusiveScissorFeaturesNV](/man/VkPhysicalDeviceExclusiveScissorFeaturesNV), [VkPhysicalDeviceExtendedDynamicState2FeaturesEXT](/man/VkPhysicalDeviceExtendedDynamicState2FeaturesEXT), [VkPhysicalDeviceExtendedDynamicState3FeaturesEXT](/man/VkPhysicalDeviceExtendedDynamicState3FeaturesEXT), [VkPhysicalDeviceExtendedDynamicStateFeaturesEXT](/man/VkPhysicalDeviceExtendedDynamicStateFeaturesEXT), [VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV](/man/VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV), [VkPhysicalDeviceExternalFormatResolveFeaturesANDROID](/man/VkPhysicalDeviceExternalFormatResolveFeaturesANDROID), [VkPhysicalDeviceExternalMemoryRDMAFeaturesNV](/man/VkPhysicalDeviceExternalMemoryRDMAFeaturesNV), [VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX](/man/VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX), [VkPhysicalDeviceFaultFeaturesEXT](/man/VkPhysicalDeviceFaultFeaturesEXT), [VkPhysicalDeviceFeatures2](/man/VkPhysicalDeviceFeatures2), [VkPhysicalDeviceFragmentDensityMap2FeaturesEXT](/man/VkPhysicalDeviceFragmentDensityMap2FeaturesEXT), [VkPhysicalDeviceFragmentDensityMapFeaturesEXT](/man/VkPhysicalDeviceFragmentDensityMapFeaturesEXT), [VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM](/man/VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM), [VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR](/man/VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR), [VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT](/man/VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT), [VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV](/man/VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV), [VkPhysicalDeviceFragmentShadingRateFeaturesKHR](/man/VkPhysicalDeviceFragmentShadingRateFeaturesKHR), [VkPhysicalDeviceFrameBoundaryFeaturesEXT](/man/VkPhysicalDeviceFrameBoundaryFeaturesEXT), [VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR](/man/VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR), [VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT](/man/VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT), [VkPhysicalDeviceHostImageCopyFeaturesEXT](/man/VkPhysicalDeviceHostImageCopyFeaturesEXT), [VkPhysicalDeviceHostQueryResetFeatures](/man/VkPhysicalDeviceHostQueryResetFeatures), [VkPhysicalDeviceImage2DViewOf3DFeaturesEXT](/man/VkPhysicalDeviceImage2DViewOf3DFeaturesEXT), [VkPhysicalDeviceImageCompressionControlFeaturesEXT](/man/VkPhysicalDeviceImageCompressionControlFeaturesEXT), [VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT](/man/VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT), [VkPhysicalDeviceImageProcessing2FeaturesQCOM](/man/VkPhysicalDeviceImageProcessing2FeaturesQCOM), [VkPhysicalDeviceImageProcessingFeaturesQCOM](/man/VkPhysicalDeviceImageProcessingFeaturesQCOM), [VkPhysicalDeviceImageRobustnessFeatures](/man/VkPhysicalDeviceImageRobustnessFeatures), [VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT](/man/VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT), [VkPhysicalDeviceImageViewMinLodFeaturesEXT](/man/VkPhysicalDeviceImageViewMinLodFeaturesEXT), [VkPhysicalDeviceImagelessFramebufferFeatures](/man/VkPhysicalDeviceImagelessFramebufferFeatures), [VkPhysicalDeviceIndexTypeUint8FeaturesEXT](/man/VkPhysicalDeviceIndexTypeUint8FeaturesEXT), [VkPhysicalDeviceInheritedViewportScissorFeaturesNV](/man/VkPhysicalDeviceInheritedViewportScissorFeaturesNV), [VkPhysicalDeviceInlineUniformBlockFeatures](/man/VkPhysicalDeviceInlineUniformBlockFeatures), [VkPhysicalDeviceInvocationMaskFeaturesHUAWEI](/man/VkPhysicalDeviceInvocationMaskFeaturesHUAWEI), [VkPhysicalDeviceLegacyDitheringFeaturesEXT](/man/VkPhysicalDeviceLegacyDitheringFeaturesEXT), [VkPhysicalDeviceLineRasterizationFeaturesEXT](/man/VkPhysicalDeviceLineRasterizationFeaturesEXT), [VkPhysicalDeviceLinearColorAttachmentFeaturesNV](/man/VkPhysicalDeviceLinearColorAttachmentFeaturesNV), [VkPhysicalDeviceMaintenance4Features](/man/VkPhysicalDeviceMaintenance4Features), [VkPhysicalDeviceMaintenance5FeaturesKHR](/man/VkPhysicalDeviceMaintenance5FeaturesKHR), [VkPhysicalDeviceMemoryDecompressionFeaturesNV](/man/VkPhysicalDeviceMemoryDecompressionFeaturesNV), [VkPhysicalDeviceMemoryPriorityFeaturesEXT](/man/VkPhysicalDeviceMemoryPriorityFeaturesEXT), [VkPhysicalDeviceMeshShaderFeaturesEXT](/man/VkPhysicalDeviceMeshShaderFeaturesEXT), [VkPhysicalDeviceMeshShaderFeaturesNV](/man/VkPhysicalDeviceMeshShaderFeaturesNV), [VkPhysicalDeviceMultiDrawFeaturesEXT](/man/VkPhysicalDeviceMultiDrawFeaturesEXT), [VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT](/man/VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT), [VkPhysicalDeviceMultiviewFeatures](/man/VkPhysicalDeviceMultiviewFeatures), [VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM](/man/VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM), [VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM](/man/VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM), [VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT](/man/VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT), [VkPhysicalDeviceNestedCommandBufferFeaturesEXT](/man/VkPhysicalDeviceNestedCommandBufferFeaturesEXT), [VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT](/man/VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT), [VkPhysicalDeviceOpacityMicromapFeaturesEXT](/man/VkPhysicalDeviceOpacityMicromapFeaturesEXT), [VkPhysicalDeviceOpticalFlowFeaturesNV](/man/VkPhysicalDeviceOpticalFlowFeaturesNV), [VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT](/man/VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT), [VkPhysicalDevicePerformanceQueryFeaturesKHR](/man/VkPhysicalDevicePerformanceQueryFeaturesKHR), [VkPhysicalDevicePipelineCreationCacheControlFeatures](/man/VkPhysicalDevicePipelineCreationCacheControlFeatures), [VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR](/man/VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR), [VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT](/man/VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT), [VkPhysicalDevicePipelinePropertiesFeaturesEXT](/man/VkPhysicalDevicePipelinePropertiesFeaturesEXT), [VkPhysicalDevicePipelineProtectedAccessFeaturesEXT](/man/VkPhysicalDevicePipelineProtectedAccessFeaturesEXT), [VkPhysicalDevicePipelineRobustnessFeaturesEXT](/man/VkPhysicalDevicePipelineRobustnessFeaturesEXT), [VkPhysicalDevicePortabilitySubsetFeaturesKHR](/man/VkPhysicalDevicePortabilitySubsetFeaturesKHR), [VkPhysicalDevicePresentBarrierFeaturesNV](/man/VkPhysicalDevicePresentBarrierFeaturesNV), [VkPhysicalDevicePresentIdFeaturesKHR](/man/VkPhysicalDevicePresentIdFeaturesKHR), [VkPhysicalDevicePresentWaitFeaturesKHR](/man/VkPhysicalDevicePresentWaitFeaturesKHR), [VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT](/man/VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT), [VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT](/man/VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT), [VkPhysicalDevicePrivateDataFeatures](/man/VkPhysicalDevicePrivateDataFeatures), [VkPhysicalDeviceProtectedMemoryFeatures](/man/VkPhysicalDeviceProtectedMemoryFeatures), [VkPhysicalDeviceProvokingVertexFeaturesEXT](/man/VkPhysicalDeviceProvokingVertexFeaturesEXT), [VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT](/man/VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT), [VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT](/man/VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT), [VkPhysicalDeviceRayQueryFeaturesKHR](/man/VkPhysicalDeviceRayQueryFeaturesKHR), [VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV](/man/VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV), [VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR](/man/VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR), [VkPhysicalDeviceRayTracingMotionBlurFeaturesNV](/man/VkPhysicalDeviceRayTracingMotionBlurFeaturesNV), [VkPhysicalDeviceRayTracingPipelineFeaturesKHR](/man/VkPhysicalDeviceRayTracingPipelineFeaturesKHR), [VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR](/man/VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR), [VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG](/man/VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG), [VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV](/man/VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV), [VkPhysicalDeviceRobustness2FeaturesEXT](/man/VkPhysicalDeviceRobustness2FeaturesEXT), [VkPhysicalDeviceSamplerYcbcrConversionFeatures](/man/VkPhysicalDeviceSamplerYcbcrConversionFeatures), [VkPhysicalDeviceScalarBlockLayoutFeatures](/man/VkPhysicalDeviceScalarBlockLayoutFeatures), [VkPhysicalDeviceSchedulingControlsFeaturesARM](/man/VkPhysicalDeviceSchedulingControlsFeaturesARM), [VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures](/man/VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures), [VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT](/man/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT), [VkPhysicalDeviceShaderAtomicFloatFeaturesEXT](/man/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT), [VkPhysicalDeviceShaderAtomicInt64Features](/man/VkPhysicalDeviceShaderAtomicInt64Features), [VkPhysicalDeviceShaderClockFeaturesKHR](/man/VkPhysicalDeviceShaderClockFeaturesKHR), [VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM](/man/VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM), [VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures](/man/VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures), [VkPhysicalDeviceShaderDrawParametersFeatures](/man/VkPhysicalDeviceShaderDrawParametersFeatures), [VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD](/man/VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD), [VkPhysicalDeviceShaderEnqueueFeaturesAMDX](/man/VkPhysicalDeviceShaderEnqueueFeaturesAMDX), [VkPhysicalDeviceShaderFloat16Int8Features](/man/VkPhysicalDeviceShaderFloat16Int8Features), [VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT](/man/VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT), [VkPhysicalDeviceShaderImageFootprintFeaturesNV](/man/VkPhysicalDeviceShaderImageFootprintFeaturesNV), [VkPhysicalDeviceShaderIntegerDotProductFeatures](/man/VkPhysicalDeviceShaderIntegerDotProductFeatures), [VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL](/man/VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL), [VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT](/man/VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT), [VkPhysicalDeviceShaderObjectFeaturesEXT](/man/VkPhysicalDeviceShaderObjectFeaturesEXT), [VkPhysicalDeviceShaderSMBuiltinsFeaturesNV](/man/VkPhysicalDeviceShaderSMBuiltinsFeaturesNV), [VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures](/man/VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures), [VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR](/man/VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR), [VkPhysicalDeviceShaderTerminateInvocationFeatures](/man/VkPhysicalDeviceShaderTerminateInvocationFeatures), [VkPhysicalDeviceShaderTileImageFeaturesEXT](/man/VkPhysicalDeviceShaderTileImageFeaturesEXT), [VkPhysicalDeviceShadingRateImageFeaturesNV](/man/VkPhysicalDeviceShadingRateImageFeaturesNV), [VkPhysicalDeviceSubgroupSizeControlFeatures](/man/VkPhysicalDeviceSubgroupSizeControlFeatures), [VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT](/man/VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT), [VkPhysicalDeviceSubpassShadingFeaturesHUAWEI](/man/VkPhysicalDeviceSubpassShadingFeaturesHUAWEI), [VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT](/man/VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT), [VkPhysicalDeviceSynchronization2Features](/man/VkPhysicalDeviceSynchronization2Features), [VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT](/man/VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT), [VkPhysicalDeviceTextureCompressionASTCHDRFeatures](/man/VkPhysicalDeviceTextureCompressionASTCHDRFeatures), [VkPhysicalDeviceTilePropertiesFeaturesQCOM](/man/VkPhysicalDeviceTilePropertiesFeaturesQCOM), [VkPhysicalDeviceTimelineSemaphoreFeatures](/man/VkPhysicalDeviceTimelineSemaphoreFeatures), [VkPhysicalDeviceTransformFeedbackFeaturesEXT](/man/VkPhysicalDeviceTransformFeedbackFeaturesEXT), [VkPhysicalDeviceUniformBufferStandardLayoutFeatures](/man/VkPhysicalDeviceUniformBufferStandardLayoutFeatures), [VkPhysicalDeviceVariablePointersFeatures](/man/VkPhysicalDeviceVariablePointersFeatures), [VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT](/man/VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT), [VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT](/man/VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT), [VkPhysicalDeviceVulkan11Features](/man/VkPhysicalDeviceVulkan11Features), [VkPhysicalDeviceVulkan12Features](/man/VkPhysicalDeviceVulkan12Features), [VkPhysicalDeviceVulkan13Features](/man/VkPhysicalDeviceVulkan13Features), [VkPhysicalDeviceVulkanMemoryModelFeatures](/man/VkPhysicalDeviceVulkanMemoryModelFeatures), [VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR](/man/VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR), [VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT](/man/VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT), [VkPhysicalDeviceYcbcrDegammaFeaturesQCOM](/man/VkPhysicalDeviceYcbcrDegammaFeaturesQCOM), [VkPhysicalDeviceYcbcrImageArraysFeaturesEXT](/man/VkPhysicalDeviceYcbcrImageArraysFeaturesEXT), or [VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures](/man/VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures)
::

::validity-field{name="VUID-VkDeviceCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique, with the exception of structures of type [VkDeviceDeviceMemoryReportCreateInfoEXT](/man/VkDeviceDeviceMemoryReportCreateInfoEXT) or [VkDevicePrivateDataCreateInfo](/man/VkDevicePrivateDataCreateInfo)
::

::validity-field{name="VUID-VkDeviceCreateInfo-flags-zerobitmask"}
 `flags` :normative{type="must"} be `0`
::

::validity-field{name="VUID-VkDeviceCreateInfo-pQueueCreateInfos-parameter"}
 `pQueueCreateInfos` :normative{type="must"} be a valid pointer to an array of `queueCreateInfoCount` valid [VkDeviceQueueCreateInfo](/man/VkDeviceQueueCreateInfo) structures
::

::validity-field{name="VUID-VkDeviceCreateInfo-ppEnabledLayerNames-parameter"}
 If `enabledLayerCount` is not `0`, `ppEnabledLayerNames` :normative{type="must"} be a valid pointer to an array of `enabledLayerCount` null-terminated UTF-8 strings
::

::validity-field{name="VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-parameter"}
 If `enabledExtensionCount` is not `0`, `ppEnabledExtensionNames` :normative{type="must"} be a valid pointer to an array of `enabledExtensionCount` null-terminated UTF-8 strings
::

::validity-field{name="VUID-VkDeviceCreateInfo-pEnabledFeatures-parameter"}
 If `pEnabledFeatures` is not `NULL`, `pEnabledFeatures` :normative{type="must"} be a valid pointer to a valid [VkPhysicalDeviceFeatures](/man/VkPhysicalDeviceFeatures) structure
::

::validity-field{name="VUID-VkDeviceCreateInfo-queueCreateInfoCount-arraylength"}
 `queueCreateInfoCount` :normative{type="must"} be greater than `0`
::

::


[{generated}/api/flags/VkDeviceCreateFlags.adoc]({generated}/api/flags/VkDeviceCreateFlags.adoc)

`VkDeviceCreateFlags` is a bitmask type for setting a mask, but is
currently reserved for future use.





### Device Use

The following is a high-level list of `VkDevice` uses along with
references on where to find more information:

- Creation of queues.
  See the Queues section below for further
  details.

- Creation and tracking of various synchronization constructs.
  See Synchronization and Cache Control for further
  details.

- Allocating, freeing, and managing memory.
  See Memory Allocation and Resource Creation for
  further details.

- Creation and destruction of command buffers and command buffer pools.
  See Command Buffers for further details.

- Creation, destruction, and management of graphics state.
  See Pipelines and Resource Descriptors,
  among others, for further details.





### Lost Device

A logical device :normative{type="may"} become *lost* for a number of implementation-specific
reasons, indicating that pending and future command execution :normative{type="may"} fail and
cause resources and backing memory to become undefined:.


::note
Typical reasons for device loss will include things like execution timing
out (to prevent denial of service), power management events, platform
resource management, implementation errors.

Applications not adhering to valid usage may
also result in device loss being reported, however this is not guaranteed.
Even if device loss is reported, the system may be in an unrecoverable
state, and further usage of the API is still considered invalid.
::


When this happens, certain commands will return `VK_ERROR_DEVICE_LOST`.
After any such event, the logical device is considered *lost*.
It is not possible to reset the logical device to a non-lost state, however
the lost state is specific to a logical device (`VkDevice`), and the
corresponding physical device (`VkPhysicalDevice`) :normative{type="may"} be otherwise
unaffected.

In some cases, the physical device :normative{type="may"} also be lost, and attempting to
create a new logical device will fail, returning `VK_ERROR_DEVICE_LOST`.
This is usually indicative of a problem with the underlying implementation,
or its connection to the host.
If the physical device has not been lost, and a new logical device is
successfully created from that physical device, it :normative{type="must"} be in the non-lost
state.


::note
Whilst logical device loss :normative{type="may"} be recoverable, in the case of physical
device loss, it is unlikely that an application will be able to recover
unless additional, unaffected physical devices exist on the system.
The error is largely informational and intended only to inform the user that
a platform issue has occurred, and :normative{type="should"} be investigated further.
For example, underlying hardware :normative{type="may"} have developed a fault or become
physically disconnected from the rest of the system.
In many cases, physical device loss :normative{type="may"} cause other more serious issues
such as the operating system crashing; in which case it :normative{type="may"} not be reported
via the Vulkan API.
::


When a device is lost, its child objects are not implicitly destroyed and
their handles are still valid.
Those objects :normative{type="must"} still be destroyed before their parents or the device
:normative{type="can"} be destroyed (see the Object
Lifetime section).
The host address space corresponding to device memory mapped using
[vkMapMemory](/man/vkMapMemory) is still valid, and host memory accesses to these mapped
regions are still valid, but the contents are undefined:.
It is still legal to call any API command on the device and child objects.

Once a device is lost, command execution :normative{type="may"} fail, and certain commands
that return a [VkResult](/man/VkResult) :normative{type="may"} return `VK_ERROR_DEVICE_LOST`.
These commands can be identified by the inclusion of
`VK_ERROR_DEVICE_LOST` in the Return Codes section for each command.
Commands that do not allow runtime errors :normative{type="must"} still operate correctly for
valid usage and, if applicable, return valid data.

Commands that wait indefinitely for device execution (namely
[vkDeviceWaitIdle](/man/vkDeviceWaitIdle), [vkQueueWaitIdle](/man/vkQueueWaitIdle), [vkWaitForFences](/man/vkWaitForFences)
with a maximum `timeout`, and [vkGetQueryPoolResults](/man/vkGetQueryPoolResults) with the
`VK_QUERY_RESULT_WAIT_BIT` bit set in `flags`) :normative{type="must"} return in
finite time even in the case of a lost device, and return either
`VK_SUCCESS` or `VK_ERROR_DEVICE_LOST`.
For any command that :normative{type="may"} return `VK_ERROR_DEVICE_LOST`, for the purpose
of determining whether a command buffer is in the
pending state, or whether resources are
considered in-use by the device, a return value of
`VK_ERROR_DEVICE_LOST` is equivalent to `VK_SUCCESS`.





### Device Destruction

To destroy a device, call:

[{generated}/api/protos/vkDestroyDevice.adoc]({generated}/api/protos/vkDestroyDevice.adoc)

- `device` is the logical device to destroy.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

To ensure that no work is active on the device, [vkDeviceWaitIdle](/man/vkDeviceWaitIdle) :normative{type="can"}
be used to gate the destruction of the device.
Prior to destroying a device, an application is responsible for
destroying/freeing any Vulkan objects that were created using that device as
the first parameter of the corresponding `vkCreate*` or
`vkAllocate*` command.


::note
The lifetime of each of these objects is bound by the lifetime of the
`VkDevice` object.
Therefore, to avoid resource leaks, it is critical that an application
explicitly free all of these resources prior to calling
`vkDestroyDevice`.
::



::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkDestroyDevice-device-05137"}

All child objects created on `device`
:normative{type="must"} have been destroyed prior to destroying `device`
::

::validity-field{name="VUID-vkDestroyDevice-device-00379"}

If `VkAllocationCallbacks` were provided when `device` was
created, a compatible set of callbacks :normative{type="must"} be provided here
::

::validity-field{name="VUID-vkDestroyDevice-device-00380"}

If no `VkAllocationCallbacks` were provided when `device` was
created, `pAllocator` :normative{type="must"} be `NULL`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkDestroyDevice-device-parameter"}
 If `device` is not `NULL`, `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkDestroyDevice-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::










## Queues



### Queue Family Properties

As discussed in the Physical
Device Enumeration section above, the
[vkGetPhysicalDeviceQueueFamilyProperties](/man/vkGetPhysicalDeviceQueueFamilyProperties) command is used to retrieve
details about the queue families and queues supported by a device.

Each index in the `pQueueFamilyProperties` array returned by
[vkGetPhysicalDeviceQueueFamilyProperties](/man/vkGetPhysicalDeviceQueueFamilyProperties) describes a unique queue
family on that physical device.
These indices are used when creating queues, and they correspond directly
with the `queueFamilyIndex` that is passed to the [vkCreateDevice](/man/vkCreateDevice)
command via the [VkDeviceQueueCreateInfo](/man/VkDeviceQueueCreateInfo) structure as described in the
Queue Creation section below.

Grouping of queue families within a physical device is
implementation-dependent.


::note
The general expectation is that a physical device groups all queues of
matching capabilities into a single family.
However, while implementations :normative{type="should"} do this, it is possible that a
physical device :normative{type="may"} return two separate queue families with the same
capabilities.
::


Once an application has identified a physical device with the queue(s) that
it desires to use, it will create those queues in conjunction with a logical
device.
This is described in the following section.





### Queue Creation

Creating a logical device also creates the queues associated with that
device.
The queues to create are described by a set of [VkDeviceQueueCreateInfo](/man/VkDeviceQueueCreateInfo)
structures that are passed to [vkCreateDevice](/man/vkCreateDevice) in
`pQueueCreateInfos`.

Queues are represented by `VkQueue` handles:

[{generated}/api/handles/VkQueue.adoc]({generated}/api/handles/VkQueue.adoc)

The `VkDeviceQueueCreateInfo` structure is defined as:

[{generated}/api/structs/VkDeviceQueueCreateInfo.adoc]({generated}/api/structs/VkDeviceQueueCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is reserved for future use.

- `queueFamilyIndex` is an unsigned integer indicating the index of
  the queue family in which to create the queues on this device.
  This index corresponds to the index of an element of the
  `pQueueFamilyProperties` array that was returned by
  `vkGetPhysicalDeviceQueueFamilyProperties`.

- `queueCount` is an unsigned integer specifying the number of queues
  to create in the queue family indicated by `queueFamilyIndex`, and
  with the behavior specified by `flags`.

- `pQueuePriorities` is a pointer to an array of `queueCount`
  normalized floating point values, specifying priorities of work that
  will be submitted to each created queue.
  See Queue Priority for more information.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkDeviceQueueCreateInfo-queueFamilyIndex-00381"}
`queueFamilyIndex` :normative{type="must"} be less than
`pQueueFamilyPropertyCount` returned by
`vkGetPhysicalDeviceQueueFamilyProperties`
::

::validity-field{name="VUID-VkDeviceQueueCreateInfo-queueCount-00382"}
`queueCount` :normative{type="must"} be less than or equal to the `queueCount`
member of the `VkQueueFamilyProperties` structure, as returned by
`vkGetPhysicalDeviceQueueFamilyProperties` in the
`pQueueFamilyProperties`[queueFamilyIndex]
::

::validity-field{name="VUID-VkDeviceQueueCreateInfo-pQueuePriorities-00383"}

Each element of `pQueuePriorities` :normative{type="must"} be between `0.0` and `1.0`
inclusive
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkDeviceQueueCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO`
::

::validity-field{name="VUID-VkDeviceQueueCreateInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkDeviceQueueGlobalPriorityCreateInfoKHR](/man/VkDeviceQueueGlobalPriorityCreateInfoKHR) or [VkDeviceQueueShaderCoreControlCreateInfoARM](/man/VkDeviceQueueShaderCoreControlCreateInfoARM)
::

::validity-field{name="VUID-VkDeviceQueueCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkDeviceQueueCreateInfo-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkDeviceQueueCreateFlagBits](/man/VkDeviceQueueCreateFlagBits) values
::

::validity-field{name="VUID-VkDeviceQueueCreateInfo-pQueuePriorities-parameter"}
 `pQueuePriorities` :normative{type="must"} be a valid pointer to an array of `queueCount` `float` values
::

::validity-field{name="VUID-VkDeviceQueueCreateInfo-queueCount-arraylength"}
 `queueCount` :normative{type="must"} be greater than `0`
::

::


[{generated}/api/flags/VkDeviceQueueCreateFlags.adoc]({generated}/api/flags/VkDeviceQueueCreateFlags.adoc)

`VkDeviceQueueCreateFlags` is a bitmask type for setting a mask, but is
currently reserved for future use.

To retrieve a handle to a [VkQueue](/man/VkQueue) object, call:

[{generated}/api/protos/vkGetDeviceQueue.adoc]({generated}/api/protos/vkGetDeviceQueue.adoc)

- `device` is the logical device that owns the queue.

- `queueFamilyIndex` is the index of the queue family to which the
  queue belongs.

- `queueIndex` is the index within this queue family of the queue to
  retrieve.

- `pQueue` is a pointer to a [VkQueue](/man/VkQueue) object that will be filled
  with the handle for the requested queue.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkGetDeviceQueue-queueFamilyIndex-00384"}
`queueFamilyIndex` :normative{type="must"} be one of the queue family indices
specified when `device` was created, via the
[VkDeviceQueueCreateInfo](/man/VkDeviceQueueCreateInfo) structure
::

::validity-field{name="VUID-vkGetDeviceQueue-queueIndex-00385"}
`queueIndex` :normative{type="must"} be less than the value of
[VkDeviceQueueCreateInfo](/man/VkDeviceQueueCreateInfo)::`queueCount` for the queue family
indicated by `queueFamilyIndex` when `device` was created
::

::validity-field{name="VUID-vkGetDeviceQueue-flags-01841"}
[VkDeviceQueueCreateInfo](/man/VkDeviceQueueCreateInfo)::`flags` :normative{type="must"} have been set to zero
when `device` was created
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkGetDeviceQueue-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkGetDeviceQueue-pQueue-parameter"}
 `pQueue` :normative{type="must"} be a valid pointer to a [VkQueue](/man/VkQueue) handle
::

::






### Queue Family Index

The queue family index is used in multiple places in Vulkan in order to tie
operations to a specific family of queues.

When retrieving a handle to the queue via `vkGetDeviceQueue`, the queue
family index is used to select which queue family to retrieve the
`VkQueue` handle from as described in the previous section.

When creating a `VkCommandPool` object (see
Command Pools), a queue family index is specified
in the [VkCommandPoolCreateInfo](/man/VkCommandPoolCreateInfo) structure.
Command buffers from this pool :normative{type="can"} only be submitted on queues
corresponding to this queue family.

When creating `VkImage` (see Images) and
`VkBuffer` (see Buffers) resources, a set of queue
families is included in the [VkImageCreateInfo](/man/VkImageCreateInfo) and
[VkBufferCreateInfo](/man/VkBufferCreateInfo) structures to specify the queue families that :normative{type="can"}
access the resource.

When inserting a [VkBufferMemoryBarrier](/man/VkBufferMemoryBarrier) or [VkImageMemoryBarrier](/man/VkImageMemoryBarrier)
(see ), a source and destination queue
family index is specified to allow the ownership of a buffer or image to be
transferred from one queue family to another.
See the Resource Sharing section for details.





### Queue Priority

Each queue is assigned a priority, as set in the
[VkDeviceQueueCreateInfo](/man/VkDeviceQueueCreateInfo) structures when creating the device.
The priority of each queue is a normalized floating point value between 0.0
and 1.0, which is then translated to a discrete priority level by the
implementation.
Higher values indicate a higher priority, with 0.0 being the lowest priority
and 1.0 being the highest.

Within the same device, queues with higher priority :normative{type="may"} be allotted more
processing time than queues with lower priority.
The implementation makes no guarantees with regards to ordering or
scheduling among queues with the same priority, other than the constraints
defined by any explicit synchronization primitives.
The implementation makes no guarantees with regards to queues across
different devices.

An implementation :normative{type="may"} allow a higher-priority queue to starve a
lower-priority queue on the same `VkDevice` until the higher-priority
queue has no further commands to execute.
The relationship of queue priorities :normative{type="must"} not cause queues on one
`VkDevice` to starve queues on another `VkDevice`.

No specific guarantees are made about higher priority queues receiving more
processing time or better quality of service than lower priority queues.





### Queue Submission

Work is submitted to a queue via *queue submission* commands such as
[vkQueueSubmit](/man/vkQueueSubmit).
Queue submission commands define a set of *queue operations* to be executed
by the underlying physical device, including synchronization with semaphores
and fences.

Submission commands take as parameters a target queue, zero or more
*batches* of work, and an :normative{type="optional"} fence to signal upon completion.
Each batch consists of three distinct parts:

1) Zero or more semaphores to wait on before execution of the rest of the
   batch.





   * If present, these describe a semaphore wait operation.

2) Zero or more work items to execute.





   * If present, these describe a *queue operation* matching the work
     described.

3) Zero or more semaphores to signal upon completion of the work items.





   * If present, these describe a semaphore signal operation.

If a fence is present in a queue submission, it describes a
fence signal operation.

All work described by a queue submission command :normative{type="must"} be submitted to the
queue before the command returns.



#### Sparse Memory Binding

In Vulkan it is possible to sparsely bind memory to buffers and images as
described in the Sparse Resource chapter.
Sparse memory binding is a queue operation.
A queue whose flags include the `VK_QUEUE_SPARSE_BINDING_BIT` :normative{type="must"} be
able to support the mapping of a virtual address to a physical address on
the device.
This causes an update to the page table mappings on the device.
This update :normative{type="must"} be synchronized on a queue to avoid corrupting page table
mappings during execution of graphics commands.
By binding the sparse memory resources on queues, all commands that are
dependent on the updated bindings are synchronized to only execute after the
binding is updated.
See the Synchronization and Cache Control chapter for
how this synchronization is accomplished.







### Queue Destruction

Queues are created along with a logical device during `vkCreateDevice`.
All queues associated with a logical device are destroyed when
`vkDestroyDevice` is called on that device.









# Command Buffers

Command buffers are objects used to record commands which :normative{type="can"} be
subsequently submitted to a device queue for execution.
There are two levels of command buffers - *primary command buffers*, which
:normative{type="can"} execute secondary command buffers, and which are submitted to queues,
and *secondary command buffers*, which :normative{type="can"} be executed by primary command
buffers, and which are not directly submitted to queues.

Command buffers are represented by `VkCommandBuffer` handles:

[{generated}/api/handles/VkCommandBuffer.adoc]({generated}/api/handles/VkCommandBuffer.adoc)

Recorded commands include commands to bind pipelines and descriptor sets to
the command buffer, commands to modify dynamic state, commands to draw (for
graphics rendering), commands to dispatch (for compute), commands to execute
secondary command buffers (for primary command buffers only), commands to
copy buffers and images, and other commands.

Each command buffer manages state independently of other command buffers.
There is no inheritance of state across primary and secondary command
buffers, or between secondary command buffers.
When a command buffer begins recording, all state in that command buffer is
undefined:.
When secondary command buffer(s) are recorded to execute on a primary
command buffer, the secondary command buffer inherits no state from the
primary command buffer, and all state of the primary command buffer is
undefined: after an execute secondary command buffer command is recorded.
There is one exception to this rule - if the primary command buffer is
inside a render pass instance, then the render pass and subpass state is not
disturbed by executing secondary command buffers.
For state dependent commands (such as draws and dispatches), any state
consumed by those commands :normative{type="must"} not be undefined:.

Unless otherwise specified, and without explicit synchronization, the
various commands submitted to a queue via command buffers :normative{type="may"} execute in
arbitrary order relative to each other, and/or concurrently.
Also, the memory side effects of those commands :normative{type="may"} not be directly visible
to other commands without explicit memory dependencies.
This is true within a command buffer, and across command buffers submitted
to a given queue.
See the synchronization chapter for information on
implicit and explicit synchronization between
commands.



## Command Buffer Lifecycle

Each command buffer is always in one of the following states:





Any given command that operates on a command buffer has its own requirements
on what state a command buffer :normative{type="must"} be in, which are detailed in the valid
usage constraints for that command.

Resetting a command buffer is an operation that discards any previously
recorded commands and puts a command buffer in the *initial state*.
Resetting occurs as a result of [vkResetCommandBuffer](/man/vkResetCommandBuffer) or
[vkResetCommandPool](/man/vkResetCommandPool), or as part of [vkBeginCommandBuffer](/man/vkBeginCommandBuffer) (which
additionally puts the command buffer in the *recording state*).

Secondary command buffers :normative{type="can"} be recorded to
a primary command buffer via [vkCmdExecuteCommands](/man/vkCmdExecuteCommands).
This partially ties the lifecycle of the two command buffers together - if
the primary is submitted to a queue, both the primary and any secondaries
recorded to it move to the *pending state*.
Once execution of the primary completes, so it does for any secondary
recorded within it.
After all executions of each command buffer complete, they each move to
their appropriate completion state (either to the *executable state* or the
*invalid state*, as specified above).

If a secondary moves to the *invalid state* or the *initial state*, then all
primary buffers it is recorded in move to the *invalid state*.
A primary moving to any other state does not affect the state of a secondary
recorded in it.


::note
Resetting or freeing a primary command buffer removes the lifecycle linkage
to all secondary command buffers that were recorded into it.
::






## Command Pools

Command pools are opaque objects that command buffer memory is allocated
from, and which allow the implementation to amortize the cost of resource
creation across multiple command buffers.
Command pools are externally synchronized, meaning that a command pool :normative{type="must"}
not be used concurrently in multiple threads.
That includes use via recording commands on any command buffers allocated
from the pool, as well as operations that allocate, free, and reset command
buffers or the pool itself.

Command pools are represented by `VkCommandPool` handles:

[{generated}/api/handles/VkCommandPool.adoc]({generated}/api/handles/VkCommandPool.adoc)

To create a command pool, call:

[{generated}/api/protos/vkCreateCommandPool.adoc]({generated}/api/protos/vkCreateCommandPool.adoc)

- `device` is the logical device that creates the command pool.

- `pCreateInfo` is a pointer to a [VkCommandPoolCreateInfo](/man/VkCommandPoolCreateInfo)
  structure specifying the state of the command pool object.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

- `pCommandPool` is a pointer to a [VkCommandPool](/man/VkCommandPool) handle in which
  the created pool is returned.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCreateCommandPool-queueFamilyIndex-01937"}
`pCreateInfo→queueFamilyIndex` :normative{type="must"} be the index of a queue family
available in the logical device `device`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCreateCommandPool-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkCreateCommandPool-pCreateInfo-parameter"}
 `pCreateInfo` :normative{type="must"} be a valid pointer to a valid [VkCommandPoolCreateInfo](/man/VkCommandPoolCreateInfo) structure
::

::validity-field{name="VUID-vkCreateCommandPool-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkCreateCommandPool-pCommandPool-parameter"}
 `pCommandPool` :normative{type="must"} be a valid pointer to a [VkCommandPool](/man/VkCommandPool) handle
::

::




The `VkCommandPoolCreateInfo` structure is defined as:

[{generated}/api/structs/VkCommandPoolCreateInfo.adoc]({generated}/api/structs/VkCommandPoolCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is a bitmask of [VkCommandPoolCreateFlagBits](/man/VkCommandPoolCreateFlagBits) indicating
  usage behavior for the pool and command buffers allocated from it.

- `queueFamilyIndex` designates a queue family as described in section
  Queue Family Properties.
  All command buffers allocated from this command pool :normative{type="must"} be submitted
  on queues from the same queue family.




::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkCommandPoolCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO`
::

::validity-field{name="VUID-VkCommandPoolCreateInfo-pNext-pNext"}
 `pNext` :normative{type="must"} be `NULL`
::

::validity-field{name="VUID-VkCommandPoolCreateInfo-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkCommandPoolCreateFlagBits](/man/VkCommandPoolCreateFlagBits) values
::

::


Bits which :normative{type="can"} be set in [VkCommandPoolCreateInfo](/man/VkCommandPoolCreateInfo)::`flags`,
specifying usage behavior for a command pool, are:

[{generated}/api/enums/VkCommandPoolCreateFlagBits.adoc]({generated}/api/enums/VkCommandPoolCreateFlagBits.adoc)

- `VK_COMMAND_POOL_CREATE_TRANSIENT_BIT` specifies that command
  buffers allocated from the pool will be short-lived, meaning that they
  will be reset or freed in a relatively short timeframe.
  This flag :normative{type="may"} be used by the implementation to control memory
  allocation behavior within the pool.

- `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT` allows any command
  buffer allocated from a pool to be individually reset to the
  initial state; either by calling
  [vkResetCommandBuffer](/man/vkResetCommandBuffer), or via the implicit reset when calling
  [vkBeginCommandBuffer](/man/vkBeginCommandBuffer).
  If this flag is not set on a pool, then `vkResetCommandBuffer` :normative{type="must"}
  not be called for any command buffer allocated from that pool.

[{generated}/api/flags/VkCommandPoolCreateFlags.adoc]({generated}/api/flags/VkCommandPoolCreateFlags.adoc)

`VkCommandPoolCreateFlags` is a bitmask type for setting a mask of zero
or more [VkCommandPoolCreateFlagBits](/man/VkCommandPoolCreateFlagBits).

To reset a command pool, call:

[{generated}/api/protos/vkResetCommandPool.adoc]({generated}/api/protos/vkResetCommandPool.adoc)

- `device` is the logical device that owns the command pool.

- `commandPool` is the command pool to reset.

- `flags` is a bitmask of [VkCommandPoolResetFlagBits](/man/VkCommandPoolResetFlagBits) controlling
  the reset operation.

Resetting a command pool recycles all of the resources from all of the
command buffers allocated from the command pool back to the command pool.
All command buffers that have been allocated from the command pool are put
in the initial state.

Any primary command buffer allocated from another [VkCommandPool](/man/VkCommandPool) that
is in the recording or executable state and
has a secondary command buffer allocated from `commandPool` recorded
into it, becomes invalid.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkResetCommandPool-commandPool-00040"}

All `VkCommandBuffer` objects allocated from `commandPool` :normative{type="must"}
not be in the pending state
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkResetCommandPool-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkResetCommandPool-commandPool-parameter"}
 `commandPool` :normative{type="must"} be a valid [VkCommandPool](/man/VkCommandPool) handle
::

::validity-field{name="VUID-vkResetCommandPool-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkCommandPoolResetFlagBits](/man/VkCommandPoolResetFlagBits) values
::

::validity-field{name="VUID-vkResetCommandPool-commandPool-parent"}
 `commandPool` :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::






Bits which :normative{type="can"} be set in [vkResetCommandPool](/man/vkResetCommandPool)::`flags`, controlling
the reset operation, are:

[{generated}/api/enums/VkCommandPoolResetFlagBits.adoc]({generated}/api/enums/VkCommandPoolResetFlagBits.adoc)

- `VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT`
  specifies that resetting a command pool recycles all of the resources
  from the command pool back to the system.

[{generated}/api/flags/VkCommandPoolResetFlags.adoc]({generated}/api/flags/VkCommandPoolResetFlags.adoc)

`VkCommandPoolResetFlags` is a bitmask type for setting a mask of zero
or more [VkCommandPoolResetFlagBits](/man/VkCommandPoolResetFlagBits).

To destroy a command pool, call:

[{generated}/api/protos/vkDestroyCommandPool.adoc]({generated}/api/protos/vkDestroyCommandPool.adoc)

- `device` is the logical device that destroys the command pool.

- `commandPool` is the handle of the command pool to destroy.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

When a pool is destroyed, all command buffers allocated from the pool are
freed.

Any primary command buffer allocated from another [VkCommandPool](/man/VkCommandPool) that
is in the recording or executable state and
has a secondary command buffer allocated from `commandPool` recorded
into it, becomes invalid.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkDestroyCommandPool-commandPool-00041"}

All `VkCommandBuffer` objects allocated from `commandPool` :normative{type="must"}
not be in the pending state
::

::validity-field{name="VUID-vkDestroyCommandPool-commandPool-00042"}

If `VkAllocationCallbacks` were provided when `commandPool` was
created, a compatible set of callbacks :normative{type="must"} be provided here
::

::validity-field{name="VUID-vkDestroyCommandPool-commandPool-00043"}

If no `VkAllocationCallbacks` were provided when `commandPool`
was created, `pAllocator` :normative{type="must"} be `NULL`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkDestroyCommandPool-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkDestroyCommandPool-commandPool-parameter"}
 If `commandPool` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `commandPool` :normative{type="must"} be a valid [VkCommandPool](/man/VkCommandPool) handle
::

::validity-field{name="VUID-vkDestroyCommandPool-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkDestroyCommandPool-commandPool-parent"}
 If `commandPool` is a valid handle, it :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::








## Command Buffer Allocation and Management

To allocate command buffers, call:

[{generated}/api/protos/vkAllocateCommandBuffers.adoc]({generated}/api/protos/vkAllocateCommandBuffers.adoc)

- `device` is the logical device that owns the command pool.

- `pAllocateInfo` is a pointer to a [VkCommandBufferAllocateInfo](/man/VkCommandBufferAllocateInfo)
  structure describing parameters of the allocation.

- `pCommandBuffers` is a pointer to an array of [VkCommandBuffer](/man/VkCommandBuffer)
  handles in which the resulting command buffer objects are returned.
  The array :normative{type="must"} be at least the length specified by the
  `commandBufferCount` member of `pAllocateInfo`.
  Each allocated command buffer begins in the initial state.

When command buffers are first allocated, they are in the
initial state.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkAllocateCommandBuffers-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkAllocateCommandBuffers-pAllocateInfo-parameter"}
 `pAllocateInfo` :normative{type="must"} be a valid pointer to a valid [VkCommandBufferAllocateInfo](/man/VkCommandBufferAllocateInfo) structure
::

::validity-field{name="VUID-vkAllocateCommandBuffers-pCommandBuffers-parameter"}
 `pCommandBuffers` :normative{type="must"} be a valid pointer to an array of `pAllocateInfo→commandBufferCount` [VkCommandBuffer](/man/VkCommandBuffer) handles
::

::validity-field{name="VUID-vkAllocateCommandBuffers-pAllocateInfo::commandBufferCount-arraylength"}
 `pAllocateInfo→commandBufferCount` :normative{type="must"} be greater than `0`
::

::






The `VkCommandBufferAllocateInfo` structure is defined as:

[{generated}/api/structs/VkCommandBufferAllocateInfo.adoc]({generated}/api/structs/VkCommandBufferAllocateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `commandPool` is the command pool from which the command buffers are
  allocated.

- `level` is a [VkCommandBufferLevel](/man/VkCommandBufferLevel) value specifying the command
  buffer level.

- `commandBufferCount` is the number of command buffers to allocate
  from the pool.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkCommandBufferAllocateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO`
::

::validity-field{name="VUID-VkCommandBufferAllocateInfo-pNext-pNext"}
 `pNext` :normative{type="must"} be `NULL`
::

::validity-field{name="VUID-VkCommandBufferAllocateInfo-commandPool-parameter"}
 `commandPool` :normative{type="must"} be a valid [VkCommandPool](/man/VkCommandPool) handle
::

::validity-field{name="VUID-VkCommandBufferAllocateInfo-level-parameter"}
 `level` :normative{type="must"} be a valid [VkCommandBufferLevel](/man/VkCommandBufferLevel) value
::

::


Possible values of [VkCommandBufferAllocateInfo](/man/VkCommandBufferAllocateInfo)::`level`,
specifying the command buffer level, are:

[{generated}/api/enums/VkCommandBufferLevel.adoc]({generated}/api/enums/VkCommandBufferLevel.adoc)

- `VK_COMMAND_BUFFER_LEVEL_PRIMARY` specifies a primary command
  buffer.

- `VK_COMMAND_BUFFER_LEVEL_SECONDARY` specifies a secondary command
  buffer.

To reset a command buffer, call:

[{generated}/api/protos/vkResetCommandBuffer.adoc]({generated}/api/protos/vkResetCommandBuffer.adoc)

- `commandBuffer` is the command buffer to reset.
  The command buffer :normative{type="can"} be in any state other than
  pending, and is moved into the
  initial state.

- `flags` is a bitmask of [VkCommandBufferResetFlagBits](/man/VkCommandBufferResetFlagBits)
  controlling the reset operation.

Any primary command buffer that is in the recording or executable state and has `commandBuffer` recorded into
it, becomes invalid.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkResetCommandBuffer-commandBuffer-00045"}
`commandBuffer` :normative{type="must"} not be in the pending state
::

::validity-field{name="VUID-vkResetCommandBuffer-commandBuffer-00046"}
`commandBuffer` :normative{type="must"} have been allocated from a pool that was
created with the `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkResetCommandBuffer-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkResetCommandBuffer-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkCommandBufferResetFlagBits](/man/VkCommandBufferResetFlagBits) values
::

::






Bits which :normative{type="can"} be set in [vkResetCommandBuffer](/man/vkResetCommandBuffer)::`flags`,
controlling the reset operation, are:

[{generated}/api/enums/VkCommandBufferResetFlagBits.adoc]({generated}/api/enums/VkCommandBufferResetFlagBits.adoc)

- `VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT` specifies that most
  or all memory resources currently owned by the command buffer :normative{type="should"} be
  returned to the parent command pool.
  If this flag is not set, then the command buffer :normative{type="may"} hold onto memory
  resources and reuse them when recording commands.
  `commandBuffer` is moved to the initial
  state.

[{generated}/api/flags/VkCommandBufferResetFlags.adoc]({generated}/api/flags/VkCommandBufferResetFlags.adoc)

`VkCommandBufferResetFlags` is a bitmask type for setting a mask of zero
or more [VkCommandBufferResetFlagBits](/man/VkCommandBufferResetFlagBits).

To free command buffers, call:

[{generated}/api/protos/vkFreeCommandBuffers.adoc]({generated}/api/protos/vkFreeCommandBuffers.adoc)

- `device` is the logical device that owns the command pool.

- `commandPool` is the command pool from which the command buffers
  were allocated.

- `commandBufferCount` is the length of the `pCommandBuffers`
  array.

- `pCommandBuffers` is a pointer to an array of handles of command
  buffers to free.

Any primary command buffer that is in the recording or executable state and has any element of `pCommandBuffers`
recorded into it, becomes invalid.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkFreeCommandBuffers-pCommandBuffers-00047"}

All elements of `pCommandBuffers` :normative{type="must"} not be in the
pending state
::

::validity-field{name="VUID-vkFreeCommandBuffers-pCommandBuffers-00048"}
`pCommandBuffers` :normative{type="must"} be a valid pointer to an array of
`commandBufferCount` `VkCommandBuffer` handles, each element of
which :normative{type="must"} either be a valid handle or `NULL`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkFreeCommandBuffers-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkFreeCommandBuffers-commandPool-parameter"}
 `commandPool` :normative{type="must"} be a valid [VkCommandPool](/man/VkCommandPool) handle
::

::validity-field{name="VUID-vkFreeCommandBuffers-commandBufferCount-arraylength"}
 `commandBufferCount` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-vkFreeCommandBuffers-commandPool-parent"}
 `commandPool` :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::validity-field{name="VUID-vkFreeCommandBuffers-pCommandBuffers-parent"}
 Each element of `pCommandBuffers` that is a valid handle :normative{type="must"} have been created, allocated, or retrieved from `commandPool`
::

::








## Command Buffer Recording

To begin recording a command buffer, call:

[{generated}/api/protos/vkBeginCommandBuffer.adoc]({generated}/api/protos/vkBeginCommandBuffer.adoc)

- `commandBuffer` is the handle of the command buffer which is to be
  put in the recording state.

- `pBeginInfo` is a pointer to a [VkCommandBufferBeginInfo](/man/VkCommandBufferBeginInfo)
  structure defining additional information about how the command buffer
  begins recording.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkBeginCommandBuffer-commandBuffer-00049"}
`commandBuffer` :normative{type="must"} not be in the recording or pending state
::

::validity-field{name="VUID-vkBeginCommandBuffer-commandBuffer-00050"}

If `commandBuffer` was allocated from a [VkCommandPool](/man/VkCommandPool) which
did not have the `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT`
flag set, `commandBuffer` :normative{type="must"} be in the
initial state
::

::validity-field{name="VUID-vkBeginCommandBuffer-commandBuffer-00051"}

If `commandBuffer` is a secondary command buffer, the
`pInheritanceInfo` member of `pBeginInfo` :normative{type="must"} be a valid
`VkCommandBufferInheritanceInfo` structure
::

::validity-field{name="VUID-vkBeginCommandBuffer-commandBuffer-00052"}

If `commandBuffer` is a secondary command buffer and either the
`occlusionQueryEnable` member of the `pInheritanceInfo` member
of `pBeginInfo` is `VK_FALSE`, or the
`occlusionQueryPrecise` feature
is not enabled, then `pBeginInfo→pInheritanceInfo→queryFlags`
:normative{type="must"} not contain `VK_QUERY_CONTROL_PRECISE_BIT`
::

::validity-field{name="VUID-vkBeginCommandBuffer-commandBuffer-02840"}

If `commandBuffer` is a primary command buffer, then
`pBeginInfo→flags` :normative{type="must"} not set both the
`VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT` and the
`VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT` flags
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkBeginCommandBuffer-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkBeginCommandBuffer-pBeginInfo-parameter"}
 `pBeginInfo` :normative{type="must"} be a valid pointer to a valid [VkCommandBufferBeginInfo](/man/VkCommandBufferBeginInfo) structure
::

::






The `VkCommandBufferBeginInfo` structure is defined as:

[{generated}/api/structs/VkCommandBufferBeginInfo.adoc]({generated}/api/structs/VkCommandBufferBeginInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is a bitmask of [VkCommandBufferUsageFlagBits](/man/VkCommandBufferUsageFlagBits)
  specifying usage behavior for the command buffer.

- `pInheritanceInfo` is a pointer to a
  [VkCommandBufferInheritanceInfo](/man/VkCommandBufferInheritanceInfo) structure, used if
  `commandBuffer` is a secondary command buffer.
  If this is a primary command buffer, then this value is ignored.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkCommandBufferBeginInfo-flags-09123"}

If `flags` contains
`VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT`, the
[VkCommandPool](/man/VkCommandPool) that `commandBuffer` was allocated from :normative{type="must"}
support graphics operations
::

::validity-field{name="VUID-VkCommandBufferBeginInfo-flags-00055"}

If `flags` contains
`VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT`, the
`framebuffer` member of `pInheritanceInfo` :normative{type="must"} be either
[VK_NULL_HANDLE](/man/VK_NULL_HANDLE), or a valid `VkFramebuffer` that is compatible
with the `renderPass` member of `pInheritanceInfo`
::

::validity-field{name="VUID-VkCommandBufferBeginInfo-flags-06000"}

If `flags` contains
`VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT`
the `renderPass` member of `pInheritanceInfo` :normative{type="must"} be a valid
`VkRenderPass`
::

::validity-field{name="VUID-VkCommandBufferBeginInfo-flags-06001"}

If `flags` contains
`VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT`
the `subpass` member of `pInheritanceInfo` :normative{type="must"} be a valid
subpass index within the `renderPass` member of
`pInheritanceInfo`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkCommandBufferBeginInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO`
::

::validity-field{name="VUID-VkCommandBufferBeginInfo-pNext-pNext"}
 `pNext` :normative{type="must"} be `NULL` or a pointer to a valid instance of [VkDeviceGroupCommandBufferBeginInfo](/man/VkDeviceGroupCommandBufferBeginInfo)
::

::validity-field{name="VUID-VkCommandBufferBeginInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkCommandBufferBeginInfo-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkCommandBufferUsageFlagBits](/man/VkCommandBufferUsageFlagBits) values
::

::


Bits which :normative{type="can"} be set in [VkCommandBufferBeginInfo](/man/VkCommandBufferBeginInfo)::`flags`,
specifying usage behavior for a command buffer, are:

[{generated}/api/enums/VkCommandBufferUsageFlagBits.adoc]({generated}/api/enums/VkCommandBufferUsageFlagBits.adoc)

- `VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT` specifies that each
  recording of the command buffer will only be submitted once, and the
  command buffer will be reset and recorded again between each submission.

- `VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT` specifies that a
  secondary command buffer is considered to be entirely inside a render
  pass.
  If this is a primary command buffer, then this bit is ignored.

- `VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT` specifies that a
  command buffer :normative{type="can"} be resubmitted to any queue of the same queue family
  while it is in the *pending state*, and recorded into multiple primary
  command buffers.

[{generated}/api/flags/VkCommandBufferUsageFlags.adoc]({generated}/api/flags/VkCommandBufferUsageFlags.adoc)

`VkCommandBufferUsageFlags` is a bitmask type for setting a mask of zero
or more [VkCommandBufferUsageFlagBits](/man/VkCommandBufferUsageFlagBits).

If the command buffer is a secondary command buffer, then the
`VkCommandBufferInheritanceInfo` structure defines any state that will
be inherited from the primary command buffer:

[{generated}/api/structs/VkCommandBufferInheritanceInfo.adoc]({generated}/api/structs/VkCommandBufferInheritanceInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `renderPass` is a [VkRenderPass](/man/VkRenderPass) object defining which render
  passes the `VkCommandBuffer` will be compatible with and :normative{type="can"} be executed within.

- `subpass` is the index of the subpass within the render pass
  instance that the `VkCommandBuffer` will be executed within.

- `framebuffer` :normative{type="can"} refer to the [VkFramebuffer](/man/VkFramebuffer) object that the
  `VkCommandBuffer` will be rendering to if it is executed within a
  render pass instance.
  It :normative{type="can"} be [VK\_NULL\_HANDLE](/man/VK_NULL_HANDLE) if the framebuffer is not known.






  ::note


  Specifying the exact framebuffer that the secondary command buffer will be
  executed with :normative{type="may"} result in better performance at command buffer execution
  time.


  ::


- `occlusionQueryEnable` specifies whether the command buffer :normative{type="can"} be
  executed while an occlusion query is active in the primary command
  buffer.
  If this is `VK_TRUE`, then this command buffer :normative{type="can"} be executed
  whether the primary command buffer has an occlusion query active or not.
  If this is `VK_FALSE`, then the primary command buffer :normative{type="must"} not
  have an occlusion query active.

- `queryFlags` specifies the query flags that :normative{type="can"} be used by an
  active occlusion query in the primary command buffer when this secondary
  command buffer is executed.
  If this value includes the `VK_QUERY_CONTROL_PRECISE_BIT` bit, then
  the active query :normative{type="can"} return boolean results or actual sample counts.
  If this bit is not set, then the active query :normative{type="must"} not use the
  `VK_QUERY_CONTROL_PRECISE_BIT` bit.

- `pipelineStatistics` is a bitmask of
  [VkQueryPipelineStatisticFlagBits](/man/VkQueryPipelineStatisticFlagBits) specifying the set of pipeline
  statistics that :normative{type="can"} be counted by an active query in the primary
  command buffer when this secondary command buffer is executed.
  If this value includes a given bit, then this command buffer :normative{type="can"} be
  executed whether the primary command buffer has a pipeline statistics
  query active that includes this bit or not.
  If this value excludes a given bit, then the active pipeline statistics
  query :normative{type="must"} not be from a query pool that counts that statistic.

If the [VkCommandBuffer](/man/VkCommandBuffer) will not be executed within a render pass
instance,
`renderPass`, `subpass`, and `framebuffer` are ignored.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkCommandBufferInheritanceInfo-occlusionQueryEnable-00056"}

If the `inheritedQueries` feature is
not enabled, `occlusionQueryEnable` :normative{type="must"} be `VK_FALSE`
::

::validity-field{name="VUID-VkCommandBufferInheritanceInfo-queryFlags-00057"}

If the `inheritedQueries` feature is
enabled, `queryFlags` :normative{type="must"} be a valid combination of
[VkQueryControlFlagBits](/man/VkQueryControlFlagBits) values
::

::validity-field{name="VUID-VkCommandBufferInheritanceInfo-queryFlags-02788"}

If the `inheritedQueries` feature is
not enabled, `queryFlags` :normative{type="must"} be `0`
::

::validity-field{name="VUID-VkCommandBufferInheritanceInfo-pipelineStatistics-02789"}

If the `pipelineStatisticsQuery` feature is enabled,
`pipelineStatistics` :normative{type="must"} be a valid combination of
[VkQueryPipelineStatisticFlagBits](/man/VkQueryPipelineStatisticFlagBits) values
::

::validity-field{name="VUID-VkCommandBufferInheritanceInfo-pipelineStatistics-00058"}

If the `pipelineStatisticsQuery` feature is not enabled,
`pipelineStatistics` :normative{type="must"} be `0`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkCommandBufferInheritanceInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO`
::

::validity-field{name="VUID-VkCommandBufferInheritanceInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkAttachmentSampleCountInfoAMD](/man/VkAttachmentSampleCountInfoAMD), [VkCommandBufferInheritanceConditionalRenderingInfoEXT](/man/VkCommandBufferInheritanceConditionalRenderingInfoEXT), [VkCommandBufferInheritanceRenderPassTransformInfoQCOM](/man/VkCommandBufferInheritanceRenderPassTransformInfoQCOM), [VkCommandBufferInheritanceRenderingInfo](/man/VkCommandBufferInheritanceRenderingInfo), [VkCommandBufferInheritanceViewportScissorInfoNV](/man/VkCommandBufferInheritanceViewportScissorInfoNV), [VkExternalFormatANDROID](/man/VkExternalFormatANDROID), or [VkMultiviewPerViewAttributesInfoNVX](/man/VkMultiviewPerViewAttributesInfoNVX)
::

::validity-field{name="VUID-VkCommandBufferInheritanceInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkCommandBufferInheritanceInfo-commonparent"}
 Both of `framebuffer`, and `renderPass` that are valid handles of non-ignored parameters :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::



::note
On some implementations, not using the
`VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT` bit enables command
buffers to be patched in-place if needed, rather than creating a copy of the
command buffer.
::


If a command buffer is in the invalid, or
executable state, and the command buffer was allocated from a command pool
with the `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT` flag set,
then `vkBeginCommandBuffer` implicitly resets the command buffer,
behaving as if `vkResetCommandBuffer` had been called with
`VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT` not set.
After the implicit reset, `commandBuffer` is moved to the
recording state.

Once recording starts, an application records a sequence of commands
(`vkCmd*`) to set state in the command buffer, draw, dispatch, and other
commands.

To complete recording of a command buffer, call:

[{generated}/api/protos/vkEndCommandBuffer.adoc]({generated}/api/protos/vkEndCommandBuffer.adoc)

- `commandBuffer` is the command buffer to complete recording.

The command buffer :normative{type="must"} have been in the recording state, and, if successful, is moved to the
executable state.

If there was an error during recording, the application will be notified by
an unsuccessful return code returned by `vkEndCommandBuffer`, and the
command buffer will be moved to the invalid
state.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkEndCommandBuffer-commandBuffer-00059"}
`commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkEndCommandBuffer-commandBuffer-00060"}

If `commandBuffer` is a primary command buffer, there :normative{type="must"} not be
an active render pass instance
::

::validity-field{name="VUID-vkEndCommandBuffer-commandBuffer-00061"}

All queries made active during the
recording of `commandBuffer` :normative{type="must"} have been made inactive
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkEndCommandBuffer-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::






When a command buffer is in the executable state, it :normative{type="can"} be submitted to a
queue for execution.





## Command Buffer Submission


::note
Submission can be a high overhead operation, and applications :normative{type="should"}
attempt to batch work together into as few calls to `vkQueueSubmit`
as possible.
::


To submit command buffers to a queue, call:

[{generated}/api/protos/vkQueueSubmit.adoc]({generated}/api/protos/vkQueueSubmit.adoc)

- `queue` is the queue that the command buffers will be submitted to.

- `submitCount` is the number of elements in the `pSubmits` array.

- `pSubmits` is a pointer to an array of [VkSubmitInfo](/man/VkSubmitInfo)
  structures, each specifying a command buffer submission batch.

- `fence` is an :normative{type="optional"} handle to a fence to be signaled once all
  submitted command buffers have completed execution.
  If `fence` is not [VK\_NULL\_HANDLE](/man/VK_NULL_HANDLE), it defines a
  fence signal operation.

`vkQueueSubmit` is a queue submission
command, with each batch defined by an element of `pSubmits`.
Batches begin execution in the order they appear in `pSubmits`, but :normative{type="may"}
complete out of order.

Fence and semaphore operations submitted with [vkQueueSubmit](/man/vkQueueSubmit) have
additional ordering constraints compared to other submission commands, with
dependencies involving previous and subsequent queue operations.
Information about these additional constraints can be found in the
semaphore and fence sections of the synchronization chapter.

Details on the interaction of `pWaitDstStageMask` with synchronization
are described in the semaphore wait
operation section of the synchronization chapter.

The order that batches appear in `pSubmits` is used to determine
submission order, and thus all the
implicit ordering guarantees that respect it.
Other than these implicit ordering guarantees and any explicit synchronization primitives, these batches :normative{type="may"} overlap or
otherwise execute out of order.

If any command buffer submitted to this queue is in the
executable state, it is moved to the
pending state.
Once execution of all submissions of a command buffer complete, it moves
from the pending state, back to the
executable state.
If a command buffer was recorded with the
`VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT` flag, it instead moves to
the invalid state.

If `vkQueueSubmit` fails, it :normative{type="may"} return
`VK_ERROR_OUT_OF_HOST_MEMORY` or `VK_ERROR_OUT_OF_DEVICE_MEMORY`.
If it does, the implementation :normative{type="must"} ensure that the state and contents of
any resources or synchronization primitives referenced by the submitted
command buffers and any semaphores referenced by `pSubmits` is
unaffected by the call or its failure.
If `vkQueueSubmit` fails in such a way that the implementation is unable
to make that guarantee, the implementation :normative{type="must"} return
`VK_ERROR_DEVICE_LOST`.
See Lost Device.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkQueueSubmit-fence-00063"}

If `fence` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `fence` :normative{type="must"} be
unsignaled
::

::validity-field{name="VUID-vkQueueSubmit-fence-00064"}

If `fence` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `fence` :normative{type="must"} not be
associated with any other queue command that has not yet completed
execution on that queue
::

::validity-field{name="VUID-vkQueueSubmit-pCommandBuffers-00065"}

Any calls to [vkCmdSetEvent](/man/vkCmdSetEvent), [vkCmdResetEvent](/man/vkCmdResetEvent) or
[vkCmdWaitEvents](/man/vkCmdWaitEvents) that have been recorded into any of the command
buffer elements of the `pCommandBuffers` member of any element of
`pSubmits`, :normative{type="must"} not reference any [VkEvent](/man/VkEvent) that is referenced
by any of those commands in a command buffer that has been submitted to
another queue and is still in the *pending state*
::

::validity-field{name="VUID-vkQueueSubmit-pWaitDstStageMask-00066"}

Any stage flag included in any element of the `pWaitDstStageMask`
member of any element of `pSubmits` :normative{type="must"} be a pipeline stage
supported by one of the capabilities of `queue`, as specified in the
table of supported pipeline
stages
::

::validity-field{name="VUID-vkQueueSubmit-pSignalSemaphores-00067"}

Each binary semaphore element of the `pSignalSemaphores` member of
any element of `pSubmits` :normative{type="must"} be unsignaled when the semaphore
signal operation it defines is executed on the device
::

::validity-field{name="VUID-vkQueueSubmit-pWaitSemaphores-00068"}

When a semaphore wait operation referring to a binary semaphore defined
by any element of the `pWaitSemaphores` member of any element of
`pSubmits` executes on `queue`, there :normative{type="must"} be no other queues
waiting on the same semaphore
::

::validity-field{name="VUID-vkQueueSubmit-pWaitSemaphores-03238"}

All elements of the `pWaitSemaphores` member of all elements of
`pSubmits`
:normative{type="must"} reference a semaphore signal operation that has been submitted for
execution and any semaphore
signal operations on which it depends :normative{type="must"} have also been submitted
for execution
::

::validity-field{name="VUID-vkQueueSubmit-pCommandBuffers-00070"}

Each element of the `pCommandBuffers` member of each element of
`pSubmits` :normative{type="must"} be in the pending or
executable state
::

::validity-field{name="VUID-vkQueueSubmit-pCommandBuffers-00071"}

If any element of the `pCommandBuffers` member of any element of
`pSubmits` was not recorded with the
`VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT`, it :normative{type="must"} not be in
the pending state
::

::validity-field{name="VUID-vkQueueSubmit-pCommandBuffers-00072"}

Any secondary command buffers recorded
into any element of the `pCommandBuffers` member of any element of
`pSubmits` :normative{type="must"} be in the pending or
executable state
::

::validity-field{name="VUID-vkQueueSubmit-pCommandBuffers-00073"}

If any secondary command buffers recorded
into any element of the `pCommandBuffers` member of any element of
`pSubmits` was not recorded with the
`VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT`, it :normative{type="must"} not be in
the pending state
::

::validity-field{name="VUID-vkQueueSubmit-pCommandBuffers-00074"}

Each element of the `pCommandBuffers` member of each element of
`pSubmits` :normative{type="must"} have been allocated from a `VkCommandPool` that
was created for the same queue family `queue` belongs to
::

::validity-field{name="VUID-vkQueueSubmit-pSubmits-02207"}

If any element of `pSubmits→pCommandBuffers` includes a
Queue Family Transfer Acquire
Operation, there :normative{type="must"} exist a previously submitted
Queue Family Transfer Release
Operation on a queue in the queue family identified by the acquire
operation, with parameters matching the acquire operation as defined in
the definition of such acquire operations, and which happens-before the acquire operation
::

::validity-field{name="VUID-vkQueueSubmit-pSubmits-02808"}

Any resource created with `VK_SHARING_MODE_EXCLUSIVE` that is read
by an operation specified by `pSubmits` :normative{type="must"} not be owned by any
queue family other than the one which `queue` belongs to, at the
time it is executed
::

::validity-field{name="VUID-vkQueueSubmit-pSubmits-04626"}

Any resource created with `VK_SHARING_MODE_CONCURRENT` that is
accessed by an operation specified by `pSubmits` :normative{type="must"} have included
the queue family of `queue` at resource creation time
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkQueueSubmit-queue-parameter"}
 `queue` :normative{type="must"} be a valid [VkQueue](/man/VkQueue) handle
::

::validity-field{name="VUID-vkQueueSubmit-pSubmits-parameter"}
 If `submitCount` is not `0`, `pSubmits` :normative{type="must"} be a valid pointer to an array of `submitCount` valid [VkSubmitInfo](/man/VkSubmitInfo) structures
::

::validity-field{name="VUID-vkQueueSubmit-fence-parameter"}
 If `fence` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `fence` :normative{type="must"} be a valid [VkFence](/man/VkFence) handle
::

::validity-field{name="VUID-vkQueueSubmit-commonparent"}
 Both of `fence`, and `queue` that are valid handles of non-ignored parameters :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::








The `VkSubmitInfo` structure is defined as:

[{generated}/api/structs/VkSubmitInfo.adoc]({generated}/api/structs/VkSubmitInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `waitSemaphoreCount` is the number of semaphores upon which to wait
  before executing the command buffers for the batch.

- `pWaitSemaphores` is a pointer to an array of [VkSemaphore](/man/VkSemaphore)
  handles upon which to wait before the command buffers for this batch
  begin execution.
  If semaphores to wait on are provided, they define a
  semaphore wait operation.

- `pWaitDstStageMask` is a pointer to an array of pipeline stages at
  which each corresponding semaphore wait will occur.

- `commandBufferCount` is the number of command buffers to execute in
  the batch.

- `pCommandBuffers` is a pointer to an array of [VkCommandBuffer](/man/VkCommandBuffer)
  handles to execute in the batch.

- `signalSemaphoreCount` is the number of semaphores to be signaled
  once the commands specified in `pCommandBuffers` have completed
  execution.

- `pSignalSemaphores` is a pointer to an array of [VkSemaphore](/man/VkSemaphore)
  handles which will be signaled when the command buffers for this batch
  have completed execution.
  If semaphores to be signaled are provided, they define a
  semaphore signal operation.

The order that command buffers appear in `pCommandBuffers` is used to
determine submission order, and thus
all the implicit ordering guarantees that
respect it.
Other than these implicit ordering guarantees and any explicit synchronization primitives, these command buffers :normative{type="may"} overlap or
otherwise execute out of order.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkSubmitInfo-pWaitDstStageMask-04090"}

If the `geometryShader` feature is not
enabled, `pWaitDstStageMask` :normative{type="must"} not contain
`VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT`
::

::validity-field{name="VUID-VkSubmitInfo-pWaitDstStageMask-04091"}

If the `tessellationShader` feature
is not enabled, `pWaitDstStageMask` :normative{type="must"} not contain
`VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT` or
`VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT`
::

::validity-field{name="VUID-VkSubmitInfo-pWaitDstStageMask-04996"}
`pWaitDstStageMask` :normative{type="must"} not be `0`
::

::validity-field{name="VUID-VkSubmitInfo-pCommandBuffers-00075"}

Each element of `pCommandBuffers` :normative{type="must"} not have been allocated with
`VK_COMMAND_BUFFER_LEVEL_SECONDARY`
::

::validity-field{name="VUID-VkSubmitInfo-pWaitDstStageMask-00078"}

Each element of `pWaitDstStageMask` :normative{type="must"} not include
`VK_PIPELINE_STAGE_HOST_BIT`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkSubmitInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_SUBMIT_INFO`
::

::validity-field{name="VUID-VkSubmitInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkAmigoProfilingSubmitInfoSEC](/man/VkAmigoProfilingSubmitInfoSEC), [VkD3D12FenceSubmitInfoKHR](/man/VkD3D12FenceSubmitInfoKHR), [VkDeviceGroupSubmitInfo](/man/VkDeviceGroupSubmitInfo), [VkFrameBoundaryEXT](/man/VkFrameBoundaryEXT), [VkLatencySubmissionPresentIdNV](/man/VkLatencySubmissionPresentIdNV), [VkPerformanceQuerySubmitInfoKHR](/man/VkPerformanceQuerySubmitInfoKHR), [VkProtectedSubmitInfo](/man/VkProtectedSubmitInfo), [VkTimelineSemaphoreSubmitInfo](/man/VkTimelineSemaphoreSubmitInfo), [VkWin32KeyedMutexAcquireReleaseInfoKHR](/man/VkWin32KeyedMutexAcquireReleaseInfoKHR), or [VkWin32KeyedMutexAcquireReleaseInfoNV](/man/VkWin32KeyedMutexAcquireReleaseInfoNV)
::

::validity-field{name="VUID-VkSubmitInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkSubmitInfo-pWaitSemaphores-parameter"}
 If `waitSemaphoreCount` is not `0`, `pWaitSemaphores` :normative{type="must"} be a valid pointer to an array of `waitSemaphoreCount` valid [VkSemaphore](/man/VkSemaphore) handles
::

::validity-field{name="VUID-VkSubmitInfo-pWaitDstStageMask-parameter"}
 If `waitSemaphoreCount` is not `0`, `pWaitDstStageMask` :normative{type="must"} be a valid pointer to an array of `waitSemaphoreCount` valid combinations of [VkPipelineStageFlagBits](/man/VkPipelineStageFlagBits) values
::

::validity-field{name="VUID-VkSubmitInfo-pCommandBuffers-parameter"}
 If `commandBufferCount` is not `0`, `pCommandBuffers` :normative{type="must"} be a valid pointer to an array of `commandBufferCount` valid [VkCommandBuffer](/man/VkCommandBuffer) handles
::

::validity-field{name="VUID-VkSubmitInfo-pSignalSemaphores-parameter"}
 If `signalSemaphoreCount` is not `0`, `pSignalSemaphores` :normative{type="must"} be a valid pointer to an array of `signalSemaphoreCount` valid [VkSemaphore](/man/VkSemaphore) handles
::

::validity-field{name="VUID-VkSubmitInfo-commonparent"}
 Each of the elements of `pCommandBuffers`, the elements of `pSignalSemaphores`, and the elements of `pWaitSemaphores` that are valid handles of non-ignored parameters :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::






## Queue Forward Progress

When using binary semaphores, the application :normative{type="must"} ensure that command
buffer submissions will be able to complete without any subsequent
operations by the application on any queue.
After any call to `vkQueueSubmit` (or other queue operation), for every
queued wait on a semaphore
there :normative{type="must"} be a prior signal of that semaphore that will not be consumed by
a different wait on the semaphore.

If a command buffer submission waits for any events to be signaled, the
application :normative{type="must"} ensure that command buffer submissions will be able to
complete without any subsequent operations by the application.
Events signaled by the host :normative{type="must"} be signaled before the command buffer
waits on those events.


::note
The ability for commands to wait on the host to set an events was originally
added to allow low-latency updates to resources between host and device.
However, to ensure quality of service, implementations would necessarily
detect extended stalls in execution and timeout after a short period.
As this period is not defined in the Vulkan specification, it is impossible
to correctly validate any application with any wait period.
Since the original users of this functionality were highly limited and
platform-specific, this functionality is now considered defunct and should
not be used.
::






## Secondary Command Buffer Execution

Secondary command buffers :normative{type="must"} not be directly submitted to a queue.
To record a secondary command buffer to execute as part of a primary command
buffer, call:

[{generated}/api/protos/vkCmdExecuteCommands.adoc]({generated}/api/protos/vkCmdExecuteCommands.adoc)

- `commandBuffer` is a handle to a primary command buffer that the
  secondary command buffers are executed in.

- `commandBufferCount` is the length of the `pCommandBuffers`
  array.

- `pCommandBuffers` is a pointer to an array of
  `commandBufferCount` secondary command buffer handles, which are
  recorded to execute in the primary command buffer in the order they are
  listed in the array.

If any element of `pCommandBuffers` was not recorded with the
`VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT` flag, and it was recorded
into any other primary command buffer which is currently in the
executable or recording state, that primary
command buffer becomes invalid.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdExecuteCommands-pCommandBuffers-00088"}

Each element of `pCommandBuffers` :normative{type="must"} have been allocated with a
`level` of `VK_COMMAND_BUFFER_LEVEL_SECONDARY`
::

::validity-field{name="VUID-vkCmdExecuteCommands-pCommandBuffers-00089"}

Each element of `pCommandBuffers` :normative{type="must"} be in the
pending or executable state
::

::validity-field{name="VUID-vkCmdExecuteCommands-pCommandBuffers-00091"}

If any element of `pCommandBuffers` was not recorded with the
`VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT` flag, it :normative{type="must"} not be
in the pending state
::

::validity-field{name="VUID-vkCmdExecuteCommands-pCommandBuffers-00092"}

If any element of `pCommandBuffers` was not recorded with the
`VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT` flag, it :normative{type="must"} not
have already been recorded to `commandBuffer`
::

::validity-field{name="VUID-vkCmdExecuteCommands-pCommandBuffers-00093"}

If any element of `pCommandBuffers` was not recorded with the
`VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT` flag, it :normative{type="must"} not
appear more than once in `pCommandBuffers`
::

::validity-field{name="VUID-vkCmdExecuteCommands-pCommandBuffers-00094"}

Each element of `pCommandBuffers` :normative{type="must"} have been allocated from a
`VkCommandPool` that was created for the same queue family as the
`VkCommandPool` from which `commandBuffer` was allocated
::

::validity-field{name="VUID-vkCmdExecuteCommands-pCommandBuffers-00096"}

If `vkCmdExecuteCommands` is being called within a render pass
instance, each element of `pCommandBuffers` :normative{type="must"} have been recorded
with the `VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT`
::

::validity-field{name="VUID-vkCmdExecuteCommands-pCommandBuffers-00099"}

If `vkCmdExecuteCommands` is being called within a render pass
instance, and any element of `pCommandBuffers` was recorded with
[VkCommandBufferInheritanceInfo](/man/VkCommandBufferInheritanceInfo)::`framebuffer` not equal to
[VK_NULL_HANDLE](/man/VK_NULL_HANDLE), that `VkFramebuffer` :normative{type="must"} match the
`VkFramebuffer` used in the current render pass instance
::

::validity-field{name="VUID-vkCmdExecuteCommands-contents-06018"}

If `vkCmdExecuteCommands` is being called within a render pass
instance begun with [vkCmdBeginRenderPass](/man/vkCmdBeginRenderPass), its `contents`
parameter :normative{type="must"} have been set to
`VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS`
::

::validity-field{name="VUID-vkCmdExecuteCommands-pCommandBuffers-06019"}

If `vkCmdExecuteCommands` is being called within a render pass
instance begun with [vkCmdBeginRenderPass](/man/vkCmdBeginRenderPass), each element of
`pCommandBuffers` :normative{type="must"} have been recorded with
[VkCommandBufferInheritanceInfo](/man/VkCommandBufferInheritanceInfo)::`subpass` set to the index of
the subpass which the given command buffer will be executed in
::

::validity-field{name="VUID-vkCmdExecuteCommands-pBeginInfo-06020"}

If `vkCmdExecuteCommands` is being called within a render pass
instance begun with [vkCmdBeginRenderPass](/man/vkCmdBeginRenderPass), the render passes
specified in the `pBeginInfo→pInheritanceInfo→renderPass` members
of the [vkBeginCommandBuffer](/man/vkBeginCommandBuffer) commands used to begin recording each
element of `pCommandBuffers` :normative{type="must"} be
compatible with the current render pass
::

::validity-field{name="VUID-vkCmdExecuteCommands-pCommandBuffers-00100"}

If `vkCmdExecuteCommands` is not being called within a render pass
instance, each element of `pCommandBuffers` :normative{type="must"} not have been
recorded with the `VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT`
::

::validity-field{name="VUID-vkCmdExecuteCommands-commandBuffer-00101"}

If the `inheritedQueries` feature is
not enabled, `commandBuffer` :normative{type="must"} not have any queries
active
::

::validity-field{name="VUID-vkCmdExecuteCommands-commandBuffer-00102"}

If `commandBuffer` has a `VK_QUERY_TYPE_OCCLUSION` query
active, then each element of
`pCommandBuffers` :normative{type="must"} have been recorded with
`VkCommandBufferInheritanceInfo`::`occlusionQueryEnable` set to
`VK_TRUE`
::

::validity-field{name="VUID-vkCmdExecuteCommands-commandBuffer-00103"}

If `commandBuffer` has a `VK_QUERY_TYPE_OCCLUSION` query
active, then each element of
`pCommandBuffers` :normative{type="must"} have been recorded with
`VkCommandBufferInheritanceInfo`::`queryFlags` having all bits
set that are set for the query
::

::validity-field{name="VUID-vkCmdExecuteCommands-commandBuffer-00104"}

If `commandBuffer` has a `VK_QUERY_TYPE_PIPELINE_STATISTICS`
query active, then each element of
`pCommandBuffers` :normative{type="must"} have been recorded with
`VkCommandBufferInheritanceInfo`::`pipelineStatistics` having
all bits set that are set in the `VkQueryPool` the query uses
::

::validity-field{name="VUID-vkCmdExecuteCommands-pCommandBuffers-00105"}

Each element of `pCommandBuffers` :normative{type="must"} not begin any query types
that are active in `commandBuffer`
::

::validity-field{name="VUID-vkCmdExecuteCommands-commandBuffer-07594"}
`commandBuffer` :normative{type="must"} not have any queries other than
`VK_QUERY_TYPE_OCCLUSION` and
`VK_QUERY_TYPE_PIPELINE_STATISTICS`

active
::

::validity-field{name="VUID-vkCmdExecuteCommands-commandBuffer-06533"}

If `vkCmdExecuteCommands` is being called within a render pass
instance and any recorded command in `commandBuffer` in the current
subpass will write to an image subresource as an attachment, commands
recorded in elements of `pCommandBuffers` :normative{type="must"} not read from the
memory backing that image subresource in any other way
::

::validity-field{name="VUID-vkCmdExecuteCommands-commandBuffer-06534"}

If `vkCmdExecuteCommands` is being called within a render pass
instance and any recorded command in `commandBuffer` in the current
subpass will read from an image subresource used as an attachment in any
way other than as an attachment, commands recorded in elements of
`pCommandBuffers` :normative{type="must"} not write to that image subresource as an
attachment
::

::validity-field{name="VUID-vkCmdExecuteCommands-pCommandBuffers-06535"}

If `vkCmdExecuteCommands` is being called within a render pass
instance and any recorded command in a given element of
`pCommandBuffers` will write to an image subresource as an
attachment, commands recorded in elements of `pCommandBuffers` at a
higher index :normative{type="must"} not read from the memory backing that image
subresource in any other way
::

::validity-field{name="VUID-vkCmdExecuteCommands-pCommandBuffers-06536"}

If `vkCmdExecuteCommands` is being called within a render pass
instance and any recorded command in a given element of
`pCommandBuffers` will read from an image subresource used as an
attachment in any way other than as an attachment, commands recorded in
elements of `pCommandBuffers` at a higher index :normative{type="must"} not write to
that image subresource as an attachment
::

::validity-field{name="VUID-vkCmdExecuteCommands-commandBuffer-09375"}
`commandBuffer` :normative{type="must"} not be a secondary command
buffer
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdExecuteCommands-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdExecuteCommands-pCommandBuffers-parameter"}
 `pCommandBuffers` :normative{type="must"} be a valid pointer to an array of `commandBufferCount` valid [VkCommandBuffer](/man/VkCommandBuffer) handles
::

::validity-field{name="VUID-vkCmdExecuteCommands-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdExecuteCommands-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support transfer, graphics, or compute operations
::

::validity-field{name="VUID-vkCmdExecuteCommands-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdExecuteCommands-commandBufferCount-arraylength"}
 `commandBufferCount` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-vkCmdExecuteCommands-commonparent"}
 Both of `commandBuffer`, and the elements of `pCommandBuffers` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::












# Synchronization and Cache Control

Synchronization of access to resources is primarily the responsibility of
the application in Vulkan.
The order of execution of commands with respect to the host and other
commands on the device has few implicit guarantees, and needs to be
explicitly specified.
Memory caches and other optimizations are also explicitly managed, requiring
that the flow of data through the system is largely under application
control.

Whilst some implicit guarantees exist between commands, five explicit
synchronization mechanisms are exposed by Vulkan:





## Execution and Memory Dependencies

An *operation* is an arbitrary amount of work to be executed on the host, a
device, or an external entity such as a presentation engine.
Synchronization commands introduce explicit *execution dependencies*, and
*memory dependencies* between two sets of operations defined by the
command’s two *synchronization scopes*.

The synchronization scopes define which other operations a synchronization
command is able to create execution dependencies with.
Any type of operation that is not in a synchronization command’s
synchronization scopes will not be included in the resulting dependency.
For example, for many synchronization commands, the synchronization scopes
:normative{type="can"} be limited to just operations executing in specific
pipeline stages, which allows other
pipeline stages to be excluded from a dependency.
Other scoping options are possible, depending on the particular command.

An *execution dependency* is a guarantee that for two sets of operations,
the first set :normative{type="must"} *happen-before* the second set.
If an operation happens-before another operation, then the first operation
:normative{type="must"} complete before the second operation is initiated.
More precisely:

- Let *Ops\<sub>1\</sub>* and *Ops\<sub>2\</sub>* be separate sets of operations.

- Let *Sync* be a synchronization command.

- Let *Scope\<sub>1st\</sub>* and *Scope\<sub>2nd\</sub>* be the synchronization scopes of
  *Sync*.

- Let *ScopedOps\<sub>1\</sub>* be the intersection of sets *Ops\<sub>1\</sub>* and
  *Scope\<sub>1st\</sub>*.

- Let *ScopedOps\<sub>2\</sub>* be the intersection of sets *Ops\<sub>2\</sub>* and
  *Scope\<sub>2nd\</sub>*.

- Submitting *Ops\<sub>1\</sub>*, *Sync* and *Ops\<sub>2\</sub>* for execution, in that order,
  will result in execution dependency *ExeDep* between *ScopedOps\<sub>1\</sub>* and
  *ScopedOps\<sub>2\</sub>*.

- Execution dependency *ExeDep* guarantees that *ScopedOps\<sub>1\</sub>*
  happen-before *ScopedOps\<sub>2\</sub>*.

An *execution dependency chain* is a sequence of execution dependencies that
form a happens-before relation between the first dependency’s *ScopedOps\<sub>1\</sub>*
and the final dependency’s *ScopedOps\<sub>2\</sub>*.
For each consecutive pair of execution dependencies, a chain exists if the
intersection of *Scope\<sub>2nd\</sub>* in the first dependency and *Scope\<sub>1st\</sub>* in the
second dependency is not an empty set.
The formation of a single execution dependency from an execution dependency
chain can be described by substituting the following in the description of
execution dependencies:

- Let *Sync* be a set of synchronization commands that generate an
  execution dependency chain.

- Let *Scope\<sub>1st\</sub>* be the first synchronization scope of the first command
  in *Sync*.

- Let *Scope\<sub>2nd\</sub>* be the second synchronization scope of the last command
  in *Sync*.

Execution dependencies alone are not sufficient to guarantee that values
resulting from writes in one set of operations :normative{type="can"} be read from another set
of operations.

Three additional types of operations are used to control memory access.
*Availability operations* cause the values generated by specified memory
write accesses to become *available* to a memory domain for future access.
Any available value remains available until a subsequent write to the same
memory location occurs (whether it is made available or not) or the memory
is freed.
*Memory domain operations* cause writes that are available to a source
memory domain to become available to a destination memory domain (an example
of this is making writes available to the host domain available to the
device domain).
*Visibility operations* cause values available to a memory domain to become
*visible* to specified memory accesses.

A *memory dependency* is an execution dependency which includes availability
and visibility operations such that:

- The first set of operations happens-before the availability operation.

- The availability operation happens-before the visibility operation.

- The visibility operation happens-before the second set of operations.

Once written values are made visible to a particular type of memory access,
they :normative{type="can"} be read or written by that type of memory access.
Most synchronization commands in Vulkan define a memory dependency.

The specific memory accesses that are made available and visible are defined
by the *access scopes* of a memory dependency.
Any type of access that is in a memory dependency’s first access scope and
occurs in *ScopedOps\<sub>1\</sub>* is made available.
Any type of access that is in a memory dependency’s second access scope and
occurs in *ScopedOps\<sub>2\</sub>* has any available writes made visible to it.
Any type of operation that is not in a synchronization command’s access
scopes will not be included in the resulting dependency.

A memory dependency enforces availability and visibility of memory accesses
and execution order between two sets of operations.
Adding to the description of execution dependency chains:

- Let *MemOps\<sub>1\</sub>* be the set of memory accesses performed by
  *ScopedOps\<sub>1\</sub>*.

- Let *MemOps\<sub>2\</sub>* be the set of memory accesses performed by
  *ScopedOps\<sub>2\</sub>*.

- Let *AccessScope\<sub>1st\</sub>* be the first access scope of the first command in
  the *Sync* chain.

- Let *AccessScope\<sub>2nd\</sub>* be the second access scope of the last command in
  the *Sync* chain.

- Let *ScopedMemOps\<sub>1\</sub>* be the intersection of sets *MemOps\<sub>1\</sub>* and
  *AccessScope\<sub>1st\</sub>*.

- Let *ScopedMemOps\<sub>2\</sub>* be the intersection of sets *MemOps\<sub>2\</sub>* and
  *AccessScope\<sub>2nd\</sub>*.

- Submitting *Ops\<sub>1\</sub>*, *Sync*, and *Ops\<sub>2\</sub>* for execution, in that order,
  will result in a memory dependency *MemDep* between *ScopedOps\<sub>1\</sub>* and
  *ScopedOps\<sub>2\</sub>*.

- Memory dependency *MemDep* guarantees that:





  * Memory writes in *ScopedMemOps\<sub>1\</sub>* are made available.

  * Available memory writes, including those from *ScopedMemOps\<sub>1\</sub>*, are
    made visible to *ScopedMemOps\<sub>2\</sub>*.


::note
Execution and memory dependencies are used to solve data hazards, i.e. to
ensure that read and write operations occur in a well-defined order.
Write-after-read hazards can be solved with just an execution dependency,
but read-after-write and write-after-write hazards need appropriate memory
dependencies to be included between them.
If an application does not include dependencies to solve these hazards, the
results and execution orders of memory accesses are undefined:.
::




### Image Layout Transitions

Image subresources :normative{type="can"} be transitioned from one layout to another as part of a memory dependency (e.g. by using an
image memory barrier).
When a layout transition is specified in a memory dependency, it
happens-after the availability operations in the memory dependency, and
happens-before the visibility operations.
Image layout transitions :normative{type="may"} perform read and write accesses on all memory
bound to the image subresource range, so applications :normative{type="must"} ensure that all
memory writes have been made
available before a
layout transition is executed.
Available memory is automatically made visible to a layout transition, and
writes performed by a layout transition are automatically made available.

Layout transitions always apply to a particular image subresource range, and
specify both an old layout and new layout.
The old layout :normative{type="must"} either be `VK_IMAGE_LAYOUT_UNDEFINED`, or match the
current layout of the image subresource range.
If the old layout matches the current layout of the image subresource range,
the transition preserves the contents of that range.
If the old layout is `VK_IMAGE_LAYOUT_UNDEFINED`, the contents of that
range :normative{type="may"} be discarded.


::note
Image layout transitions with `VK_IMAGE_LAYOUT_UNDEFINED` allow the
implementation to discard the image subresource range, which can provide
performance or power benefits.
Tile-based architectures may be able to avoid flushing tile data to memory,
and immediate style renderers may be able to achieve fast metadata clears to
reinitialize frame buffer compression state, or similar.

If the contents of an attachment are not needed after a render pass
completes, then applications :normative{type="should"} use
`VK_ATTACHMENT_STORE_OP_DONT_CARE`.
::



::note
Applications :normative{type="must"} ensure that layout transitions happen-after all
operations accessing the image with the old layout, and happen-before any
operations that will access the image with the new layout.
Layout transitions are potentially read/write operations, so not defining
appropriate memory dependencies to guarantee this will result in a data
race.
::


Image layout transitions interact with memory
aliasing.

Layout transitions that are performed via image memory barriers execute in
their entirety in submission order,
relative to other image layout transitions submitted to the same queue,
including those performed by render passes.
In effect there is an implicit execution dependency from each such layout
transition to all layout transitions previously submitted to the same queue.





### Pipeline Stages

The work performed by an action
command consists of multiple operations, which are performed as a sequence
of logically independent steps known as *pipeline stages*.
The exact pipeline stages executed depend on the particular command that is
used, and current command buffer state when the command was recorded.


::note
Operations performed by synchronization commands (e.g.
availability and
visibility operations) are not executed by a defined pipeline stage.
However other commands can still synchronize with them by using the
synchronization scopes to create a
dependency chain.
::


Execution of operations across pipeline stages :normative{type="must"} adhere to
implicit ordering guarantees, particularly
including pipeline stage order.
Otherwise, execution across pipeline stages :normative{type="may"} overlap or execute out of
order with regards to other stages, unless otherwise enforced by an
execution dependency.

Several of the synchronization commands include pipeline stage parameters,
restricting the synchronization
scopes for that command to just those stages.
This allows fine grained control over the exact execution dependencies and
accesses performed by action commands.
Implementations :normative{type="should"} use these pipeline stages to avoid unnecessary
stalls or cache flushing.

Bits which :normative{type="can"} be set in a [VkPipelineStageFlags](/man/VkPipelineStageFlags) mask, specifying
stages of execution, are:

[{generated}/api/enums/VkPipelineStageFlagBits.adoc]({generated}/api/enums/VkPipelineStageFlagBits.adoc)

- `VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT` specifies the stage of the
  pipeline where `VkDrawIndirect*` / `VkDispatchIndirect*` /
  `VkTraceRaysIndirect*` data structures are consumed.

- `VK_PIPELINE_STAGE_VERTEX_INPUT_BIT` specifies the stage of the
  pipeline where vertex and index buffers are consumed.

- `VK_PIPELINE_STAGE_VERTEX_SHADER_BIT` specifies the vertex shader
  stage.

- `VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT` specifies the
  tessellation control shader stage.

- `VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT` specifies the
  tessellation evaluation shader stage.

- `VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT` specifies the geometry
  shader stage.

- `VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT` specifies the fragment
  shader stage.

- `VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT` specifies the stage of
  the pipeline where early fragment tests (depth and stencil tests before
  fragment shading) are performed.
  This stage also includes render pass load
  operations for framebuffer attachments with a depth/stencil format.

- `VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT` specifies the stage of
  the pipeline where late fragment tests (depth and stencil tests after
  fragment shading) are performed.
  This stage also includes render pass
  store operations for framebuffer attachments with a depth/stencil
  format.

- `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` specifies the stage
  of the pipeline after blending where the final color values are output
  from the pipeline.
  This stage includes blending,
  logic operations, render pass
  load and store operations for color attachments,
  render pass multisample resolve
  operations, and [vkCmdClearAttachments](/man/vkCmdClearAttachments).

- `VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT` specifies the execution of a
  compute shader.

- [synchronization-pipeline-stages-transfer](#synchronization-pipeline-stages-transfer)

  `VK_PIPELINE_STAGE_TRANSFER_BIT` specifies the following commands:





  * All copy commands, including [vkCmdCopyQueryPoolResults](/man/vkCmdCopyQueryPoolResults)

  * [vkCmdBlitImage](/man/vkCmdBlitImage)

  * [vkCmdResolveImage](/man/vkCmdResolveImage)

  * All clear commands, with the exception of
    [vkCmdClearAttachments](/man/vkCmdClearAttachments)

- `VK_PIPELINE_STAGE_HOST_BIT` specifies a pseudo-stage indicating
  execution on the host of reads/writes of device memory.
  This stage is not invoked by any commands recorded in a command buffer.

- `VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT` specifies the execution of all
  graphics pipeline stages, and is equivalent to the logical OR of:





  * `VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT`

  * `VK_PIPELINE_STAGE_VERTEX_INPUT_BIT`

  * `VK_PIPELINE_STAGE_VERTEX_SHADER_BIT`

  * `VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT`

  * `VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT`

  * `VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT`

  * `VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT`

  * `VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT`

  * `VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT`

  * `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT`

- `VK_PIPELINE_STAGE_ALL_COMMANDS_BIT` specifies all operations
  performed by all commands supported on the queue it is used with.

- `VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT` is equivalent to
  `VK_PIPELINE_STAGE_ALL_COMMANDS_BIT` with [VkAccessFlags](/man/VkAccessFlags) set to
  `0` when specified in the second synchronization scope, but specifies no
  stage of execution when specified in the first scope.

- `VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT` is equivalent to
  `VK_PIPELINE_STAGE_ALL_COMMANDS_BIT` with [VkAccessFlags](/man/VkAccessFlags) set to
  `0` when specified in the first synchronization scope, but specifies no
  stage of execution when specified in the second scope.

[{generated}/api/flags/VkPipelineStageFlags.adoc]({generated}/api/flags/VkPipelineStageFlags.adoc)

`VkPipelineStageFlags` is a bitmask type for setting a mask of zero or
more [VkPipelineStageFlagBits](/man/VkPipelineStageFlagBits).

If a synchronization command includes a source stage mask, its first
synchronization scope only includes
execution of the pipeline stages specified in that mask and any
logically earlier stages.
Its first access scope only
includes memory accesses performed by pipeline stages explicitly specified
in the source stage mask.

If a synchronization command includes a destination stage mask, its second
synchronization scope only includes
execution of the pipeline stages specified in that mask and any
logically later stages.
Its second access scope only
includes memory accesses performed by pipeline stages explicitly specified
in the destination stage mask.


::note
Note that access scopes do
not interact with the logically earlier or later stages for either scope -
only the stages the app specifies are considered part of each access scope.
::


Certain pipeline stages are only available on queues that support a
particular set of operations.
The following table lists, for each pipeline stage flag, which queue
capability flag :normative{type="must"} be supported by the queue.
When multiple flags are enumerated in the second column of the table, it
means that the pipeline stage is supported on the queue if it supports any
of the listed capability flags.
For further details on queue capabilities see
Physical Device Enumeration
and Queues.



Pipeline stages that execute as a result of a command logically complete
execution in a specific order, such that completion of a logically later
pipeline stage :normative{type="must"} not happen-before completion of a logically earlier
stage.
This means that including any stage in the source stage mask for a
particular synchronization command also implies that any logically earlier
stages are included in *Scope\<sub>1st\</sub>* for that command.

Similarly, initiation of a logically earlier pipeline stage :normative{type="must"} not
happen-after initiation of a logically later pipeline stage.
Including any given stage in the destination stage mask for a particular
synchronization command also implies that any logically later stages are
included in *Scope\<sub>2nd\</sub>* for that command.


::note
Implementations :normative{type="may"} not support synchronization at every pipeline stage for
every synchronization operation.
If a pipeline stage that an implementation does not support synchronization
for appears in a source stage mask, it :normative{type="may"} substitute any logically later
stage in its place for the first synchronization scope.
If a pipeline stage that an implementation does not support synchronization
for appears in a destination stage mask, it :normative{type="may"} substitute any logically
earlier stage in its place for the second synchronization scope.

For example, if an implementation is unable to signal an event immediately
after vertex shader execution is complete, it :normative{type="may"} instead signal the event
after color attachment output has completed.

If an implementation makes such a substitution, it :normative{type="must"} not affect the
semantics of execution or memory dependencies or image and buffer memory
barriers.
::


[synchronization-pipeline-stages-types](#synchronization-pipeline-stages-types)[synchronization-pipeline-graphics](#synchronization-pipeline-graphics)

Graphics pipelines are executable on queues
supporting `VK_QUEUE_GRAPHICS_BIT`.
Stages executed by graphics pipelines :normative{type="can"} only be specified in commands
recorded for queues supporting `VK_QUEUE_GRAPHICS_BIT`.

The graphics
pipeline executes the following stages, with the logical ordering of the
stages matching the order specified here:

[{generated}/sync/pipelineOrders/graphics\_primitive.adoc]({generated}/sync/pipelineOrders/graphics_primitive.adoc)

For the compute pipeline, the following stages occur in this order:

[{generated}/sync/pipelineOrders/compute.adoc]({generated}/sync/pipelineOrders/compute.adoc)

For the transfer pipeline, the following stages occur in this order:

[{generated}/sync/pipelineOrders/transfer.adoc]({generated}/sync/pipelineOrders/transfer.adoc)

For host operations, only one pipeline stage occurs, so no order is
guaranteed:

[{generated}/sync/pipelineOrders/host.adoc]({generated}/sync/pipelineOrders/host.adoc)





### Access Types

Memory in Vulkan :normative{type="can"} be accessed from within shader invocations and via
some fixed-function stages of the pipeline.
The *access type* is a function of the descriptor type
used, or how a fixed-function stage accesses memory.

Some synchronization commands take sets of access types as parameters to
define the access scopes of
a memory dependency.
If a synchronization command includes a *source access mask*, its first
access scope only includes
accesses via the access types specified in that mask.
Similarly, if a synchronization command includes a *destination access
mask*, its second access
scope only includes accesses via the access types specified in that mask.

Bits which :normative{type="can"} be set in the `srcAccessMask` and `dstAccessMask`
members of [VkSubpassDependency](/man/VkSubpassDependency),
[VkMemoryBarrier](/man/VkMemoryBarrier), [VkBufferMemoryBarrier](/man/VkBufferMemoryBarrier), and
[VkImageMemoryBarrier](/man/VkImageMemoryBarrier), specifying access behavior, are:

[{generated}/api/enums/VkAccessFlagBits.adoc]({generated}/api/enums/VkAccessFlagBits.adoc)

- `VK_ACCESS_MEMORY_READ_BIT` specifies all read accesses.
  It is always valid in any access mask, and is treated as equivalent to
  setting all `READ` access flags that are valid where it is used.

- `VK_ACCESS_MEMORY_WRITE_BIT` specifies all write accesses.
  It is always valid in any access mask, and is treated as equivalent to
  setting all `WRITE` access flags that are valid where it is used.

- `VK_ACCESS_INDIRECT_COMMAND_READ_BIT` specifies read access to
  indirect command data read as part of an indirect
  drawing or dispatching command.
  Such access occurs in the `VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT`
  pipeline stage.

- `VK_ACCESS_INDEX_READ_BIT` specifies read access to an index buffer
  as part of an indexed drawing command, bound by
  [vkCmdBindIndexBuffer](/man/vkCmdBindIndexBuffer).
  Such access occurs in the `VK_PIPELINE_STAGE_VERTEX_INPUT_BIT`
  pipeline stage.

- `VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT` specifies read access to a
  vertex buffer as part of a drawing command, bound by
  [vkCmdBindVertexBuffers](/man/vkCmdBindVertexBuffers).
  Such access occurs in the `VK_PIPELINE_STAGE_VERTEX_INPUT_BIT`
  pipeline stage.

- `VK_ACCESS_UNIFORM_READ_BIT` specifies read access to a
  uniform buffer in any shader pipeline
  stage.

- `VK_ACCESS_INPUT_ATTACHMENT_READ_BIT` specifies read access to an
  input attachment within a render pass during
  fragment shading.
  Such access occurs in the
  `VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT` pipeline stage.

- `VK_ACCESS_SHADER_READ_BIT` specifies read access to a
  uniform texel buffer,
  sampled image,
  storage buffer,
  storage texel buffer, or
  storage image in any shader pipeline
  stage.

- `VK_ACCESS_SHADER_WRITE_BIT` specifies write access to a
  storage buffer,
  storage texel buffer, or
  storage image in any shader pipeline
  stage.

- `VK_ACCESS_COLOR_ATTACHMENT_READ_BIT` specifies read access to a
  &#x20;   color attachment, such as via
  blending,
  &#x20;   logic operations or certain
  &#x20;   render pass load operations.
  &#x20;   Such access occurs in the
  &#x20;   `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.

- `VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT` specifies write access to a
  color or resolve attachment
  during a render pass or via certain render pass
  load and store operations.
  Such access occurs in the
  `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.

- `VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT` specifies read access
  to a depth/stencil attachment, via depth or stencil operations or certain
  render pass load operations.
  Such access occurs in the
  `VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT` or
  `VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT` pipeline stages.

- `VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT` specifies write
  access to a depth/stencil attachment, via
  depth or stencil operations or certain render pass
  load and store operations.
  Such access occurs in the
  `VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT` or
  `VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT` pipeline stages.

- `VK_ACCESS_TRANSFER_READ_BIT` specifies read access to an image or
  buffer in a copy operation.

- `VK_ACCESS_TRANSFER_WRITE_BIT` specifies write access to an image or
  buffer in a clear or copy operation.

- `VK_ACCESS_HOST_READ_BIT` specifies read access by a host operation.
  Accesses of this type are not performed through a resource, but directly
  on memory.
  Such access occurs in the `VK_PIPELINE_STAGE_HOST_BIT` pipeline
  stage.

- `VK_ACCESS_HOST_WRITE_BIT` specifies write access by a host
  operation.
  Accesses of this type are not performed through a resource, but directly
  on memory.
  Such access occurs in the `VK_PIPELINE_STAGE_HOST_BIT` pipeline
  stage.

Certain access types are only performed by a subset of pipeline stages.
Any synchronization command that takes both stage masks and access masks
uses both to define the access
scopes - only the specified access types performed by the specified stages
are included in the access scope.
An application :normative{type="must"} not specify an access flag in a synchronization command
if it does not include a pipeline stage in the corresponding stage mask that
is able to perform accesses of that type.
The following table lists, for each access flag, which pipeline stages :normative{type="can"}
perform that type of access.



[{generated}/api/flags/VkAccessFlags.adoc]({generated}/api/flags/VkAccessFlags.adoc)

`VkAccessFlags` is a bitmask type for setting a mask of zero or more
[VkAccessFlagBits](/man/VkAccessFlagBits).

If a memory object does not have the
`VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` property, then
[vkFlushMappedMemoryRanges](/man/vkFlushMappedMemoryRanges) :normative{type="must"} be called in order to guarantee that
writes to the memory object from the host are made available to the host
domain, where they :normative{type="can"} be further made available to the device domain via a
domain operation.
Similarly, [vkInvalidateMappedMemoryRanges](/man/vkInvalidateMappedMemoryRanges) :normative{type="must"} be called to guarantee
that writes which are available to the host domain are made visible to host
operations.

If the memory object does have the
`VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` property flag, writes to the
memory object from the host are automatically made available to the host
domain.
Similarly, writes made available to the host domain are automatically made
visible to the host.


::note
Queue submission commands automatically
perform a domain operation from
host to device for all writes performed before the command executes, so in
most cases an explicit memory barrier is not needed for this case.
In the few circumstances where a submit does not occur between the host
write and the device read access, writes :normative{type="can"} be made available by using an
explicit memory barrier.
::






### Framebuffer Region Dependencies

Pipeline stages that operate on, or
with respect to, the framebuffer are collectively the *framebuffer-space*
pipeline stages.
These stages are:

- `VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT`

- `VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT`

- `VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT`

- `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT`

For these pipeline stages, an execution or memory dependency from the first
set of operations to the second set :normative{type="can"} either be a single
*framebuffer-global* dependency, or split into multiple *framebuffer-local*
dependencies.
A dependency with non-framebuffer-space pipeline stages is neither
framebuffer-global nor framebuffer-local.

A *framebuffer region* is a set of sample (x, y, layer, sample) coordinates
that is a subset of the entire framebuffer.

Both synchronization scopes of a
framebuffer-local dependency include only the operations performed within
corresponding framebuffer regions (as defined below).
No ordering guarantees are made between different framebuffer regions for a
framebuffer-local dependency.

Both synchronization scopes of a
framebuffer-global dependency include operations on all framebuffer-regions.

If the first synchronization scope includes operations on pixels/fragments
with N samples and the second synchronization scope includes operations on
pixels/fragments with M samples, where N does not equal M, then a
framebuffer region containing all samples at a given (x, y, layer)
coordinate in the first synchronization scope corresponds to a region
containing all samples at the same coordinate in the second synchronization
scope.
In other words, it is a pixel granularity dependency.
If N equals M,
then a framebuffer region containing a single (x, y, layer, sample)
coordinate in the first synchronization scope corresponds to a region
containing the same sample at the same coordinate in the second
synchronization scope.
In other words, it is a sample granularity dependency.


::note
Since fragment shader invocations are not specified to run in any particular
groupings, the size of a framebuffer region is implementation-dependent, not
known to the application, and :normative{type="must"} be assumed to be no larger than
specified above.
::



::note
Practically, the pixel vs. sample granularity dependency means that if an
input attachment has a different number of samples than the pipeline’s
`rasterizationSamples`, then a fragment :normative{type="can"} access any sample in the
input attachment’s pixel even if it only uses framebuffer-local
dependencies.
If the input attachment has the same number of samples, then the fragment
:normative{type="can"} only access the covered samples in its input `SampleMask` (i.e. the
fragment operations happen-after a framebuffer-local dependency for each
sample the fragment covers).
To access samples that are not covered,
a framebuffer-global dependency is required.
::


If a synchronization command includes a `dependencyFlags` parameter, and
specifies the `VK_DEPENDENCY_BY_REGION_BIT` flag, then it defines
framebuffer-local dependencies for the framebuffer-space pipeline stages in
that synchronization command, for all framebuffer regions.
If no `dependencyFlags` parameter is included, or the
`VK_DEPENDENCY_BY_REGION_BIT` flag is not specified, then a
framebuffer-global dependency is specified for those stages.
The `VK_DEPENDENCY_BY_REGION_BIT` flag does not affect the dependencies
between non-framebuffer-space pipeline stages, nor does it affect the
dependencies between framebuffer-space and non-framebuffer-space pipeline
stages.


::note
Framebuffer-local dependencies are more efficient for most architectures;
particularly tile-based architectures - which can keep framebuffer-regions
entirely in on-chip registers and thus avoid external bandwidth across such
a dependency.
Including a framebuffer-global dependency in your rendering will usually
force all implementations to flush data to memory, or to a higher level
cache, breaking any potential locality optimizations.
::








## Implicit Synchronization Guarantees

A small number of implicit ordering guarantees are provided by Vulkan,
ensuring that the order in which commands are submitted is meaningful, and
avoiding unnecessary complexity in common operations.

*Submission order* is a fundamental ordering in Vulkan, giving meaning to
the order in which action and
synchronization commands are recorded and submitted to a single queue.
Explicit and implicit ordering guarantees between commands in Vulkan all
work on the premise that this ordering is meaningful.
This order does not itself define any execution or memory dependencies;
synchronization commands and other orderings within the API use this
ordering to define their scopes.

Submission order for any given set of commands is based on the order in
which they were recorded to command buffers and then submitted.
This order is determined as follows:

1) The initial order is determined by the order in which
   [vkQueueSubmit](/man/vkQueueSubmit)
   commands are executed on the host, for a single queue, from first to
   last.

2) The order in which [VkSubmitInfo](/man/VkSubmitInfo) structures are specified in the
   `pSubmits` parameter of [vkQueueSubmit](/man/vkQueueSubmit),
   from lowest index to highest.

3) The order in which command buffers are specified in the
   `pCommandBuffers` member of [VkSubmitInfo](/man/VkSubmitInfo)
   from lowest index to highest.

4) The order in which commands were recorded to a command buffer on the
   host, from first to last:





   * For commands recorded outside a render pass, this includes all other
     commands recorded outside a render pass, including
     [vkCmdBeginRenderPass](/man/vkCmdBeginRenderPass) and [vkCmdEndRenderPass](/man/vkCmdEndRenderPass) commands; it
     does not directly include commands inside a render pass.

   * For commands recorded inside a render pass, this includes all other
     &#x20;    commands recorded inside the same subpass, including the
     &#x20;    [vkCmdBeginRenderPass](/man/vkCmdBeginRenderPass) and [vkCmdEndRenderPass](/man/vkCmdEndRenderPass) commands that
     &#x20;    delimit the same render pass instance; it does not include commands
     &#x20;    recorded to other subpasses.
     State commands do not execute
     any operations on the device, instead they set the state of the command
     buffer when they execute on the host, in the order that they are recorded.
     Action commands consume the
     current state of the command buffer when they are recorded, and will execute
     state changes on the device as required to match the recorded state.

The order of primitives passing through the
graphics pipeline and
image layout
transitions as part of an image memory barrier provide additional
guarantees based on submission order.

Execution of pipeline stages
within a given command also has a loose ordering, dependent only on a single
command.

*Signal operation order* is a fundamental ordering in Vulkan, giving meaning
to the order in which semaphore and fence signal operations occur when
submitted to a single queue.
The signal operation order for queue operations is determined as follows:

1) The initial order is determined by the order in which
   [vkQueueSubmit](/man/vkQueueSubmit)
   commands are executed on the host, for a single queue, from first to
   last.

2) The order in which [VkSubmitInfo](/man/VkSubmitInfo) structures are specified in the
   `pSubmits` parameter of [vkQueueSubmit](/man/vkQueueSubmit),
   from lowest index to highest.

3) The fence signal operation defined by the `fence` parameter of a
   &#x20;   [vkQueueSubmit](/man/vkQueueSubmit)
   or [vkQueueBindSparse](/man/vkQueueBindSparse)
   &#x20;   command is ordered after all semaphore signal operations defined by that
   &#x20;   command.

Semaphore signal operations defined by a single [VkSubmitInfo](/man/VkSubmitInfo)
or [VkBindSparseInfo](/man/VkBindSparseInfo)
structure are unordered with respect to other semaphore signal operations
defined within the same structure.





## Fences

Fences are a synchronization primitive that :normative{type="can"} be used to insert a
dependency from a queue to the host.
Fences have two states - signaled and unsignaled.
A fence :normative{type="can"} be signaled as part of the execution of a
queue submission command.
Fences :normative{type="can"} be unsignaled on the host with [vkResetFences](/man/vkResetFences).
Fences :normative{type="can"} be waited on by the host with the [vkWaitForFences](/man/vkWaitForFences) command,
and the current state :normative{type="can"} be queried with [vkGetFenceStatus](/man/vkGetFenceStatus).

Fences are represented by `VkFence` handles:

[{generated}/api/handles/VkFence.adoc]({generated}/api/handles/VkFence.adoc)

To create a fence, call:

[{generated}/api/protos/vkCreateFence.adoc]({generated}/api/protos/vkCreateFence.adoc)

- `device` is the logical device that creates the fence.

- `pCreateInfo` is a pointer to a [VkFenceCreateInfo](/man/VkFenceCreateInfo) structure
  containing information about how the fence is to be created.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

- `pFence` is a pointer to a handle in which the resulting fence
  object is returned.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCreateFence-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkCreateFence-pCreateInfo-parameter"}
 `pCreateInfo` :normative{type="must"} be a valid pointer to a valid [VkFenceCreateInfo](/man/VkFenceCreateInfo) structure
::

::validity-field{name="VUID-vkCreateFence-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkCreateFence-pFence-parameter"}
 `pFence` :normative{type="must"} be a valid pointer to a [VkFence](/man/VkFence) handle
::

::




The `VkFenceCreateInfo` structure is defined as:

[{generated}/api/structs/VkFenceCreateInfo.adoc]({generated}/api/structs/VkFenceCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is a bitmask of [VkFenceCreateFlagBits](/man/VkFenceCreateFlagBits) specifying the
  initial state and behavior of the fence.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkFenceCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_FENCE_CREATE_INFO`
::

::validity-field{name="VUID-VkFenceCreateInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkExportFenceCreateInfo](/man/VkExportFenceCreateInfo) or [VkExportFenceWin32HandleInfoKHR](/man/VkExportFenceWin32HandleInfoKHR)
::

::validity-field{name="VUID-VkFenceCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkFenceCreateInfo-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkFenceCreateFlagBits](/man/VkFenceCreateFlagBits) values
::

::


[{generated}/api/enums/VkFenceCreateFlagBits.adoc]({generated}/api/enums/VkFenceCreateFlagBits.adoc)

- `VK_FENCE_CREATE_SIGNALED_BIT` specifies that the fence object is
  created in the signaled state.
  Otherwise, it is created in the unsignaled state.

[{generated}/api/flags/VkFenceCreateFlags.adoc]({generated}/api/flags/VkFenceCreateFlags.adoc)

`VkFenceCreateFlags` is a bitmask type for setting a mask of zero or
more [VkFenceCreateFlagBits](/man/VkFenceCreateFlagBits).

To destroy a fence, call:

[{generated}/api/protos/vkDestroyFence.adoc]({generated}/api/protos/vkDestroyFence.adoc)

- `device` is the logical device that destroys the fence.

- `fence` is the handle of the fence to destroy.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkDestroyFence-fence-01120"}

All queue submission commands that refer
to `fence` :normative{type="must"} have completed execution
::

::validity-field{name="VUID-vkDestroyFence-fence-01121"}

If `VkAllocationCallbacks` were provided when `fence` was
created, a compatible set of callbacks :normative{type="must"} be provided here
::

::validity-field{name="VUID-vkDestroyFence-fence-01122"}

If no `VkAllocationCallbacks` were provided when `fence` was
created, `pAllocator` :normative{type="must"} be `NULL`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkDestroyFence-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkDestroyFence-fence-parameter"}
 If `fence` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `fence` :normative{type="must"} be a valid [VkFence](/man/VkFence) handle
::

::validity-field{name="VUID-vkDestroyFence-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkDestroyFence-fence-parent"}
 If `fence` is a valid handle, it :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::




To query the status of a fence from the host, call:

[{generated}/api/protos/vkGetFenceStatus.adoc]({generated}/api/protos/vkGetFenceStatus.adoc)

- `device` is the logical device that owns the fence.

- `fence` is the handle of the fence to query.

Upon success, `vkGetFenceStatus` returns the status of the fence object,
with the following return codes:



If a queue submission command is pending
execution, then the value returned by this command :normative{type="may"} immediately be out
of date.

If the device has been lost (see Lost Device),
`vkGetFenceStatus` :normative{type="may"} return any of the above status codes.
If the device has been lost and `vkGetFenceStatus` is called repeatedly,
it will eventually return either `VK_SUCCESS` or
`VK_ERROR_DEVICE_LOST`.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkGetFenceStatus-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkGetFenceStatus-fence-parameter"}
 `fence` :normative{type="must"} be a valid [VkFence](/man/VkFence) handle
::

::validity-field{name="VUID-vkGetFenceStatus-fence-parent"}
 `fence` :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::






When a fence is submitted to a queue as part of a
queue submission command, it defines a memory
dependency on the batches that were submitted as part of that command, and
defines a *fence signal operation* which sets the fence to the signaled
state.

The first synchronization scope
includes every batch submitted in the same queue
submission command.
Fence signal operations that are defined by [vkQueueSubmit](/man/vkQueueSubmit)
additionally include in the first synchronization scope all commands that
occur earlier in submission order.
Fence signal operations that are defined by [vkQueueSubmit](/man/vkQueueSubmit)
or [vkQueueBindSparse](/man/vkQueueBindSparse)
additionally include in the first synchronization scope any semaphore and
fence signal operations that occur earlier in
signal operation order.

The second synchronization scope
only includes the fence signal operation.

The first access scope
includes all memory access performed by the device.

The second access scope is
empty.

To wait for one or more fences to enter the signaled state on the host,
call:

[{generated}/api/protos/vkWaitForFences.adoc]({generated}/api/protos/vkWaitForFences.adoc)

- `device` is the logical device that owns the fences.

- `fenceCount` is the number of fences to wait on.

- `pFences` is a pointer to an array of `fenceCount` fence
  handles.

- `waitAll` is the condition that :normative{type="must"} be satisfied to successfully
  unblock the wait.
  If `waitAll` is `VK_TRUE`, then the condition is that all fences
  in `pFences` are signaled.
  Otherwise, the condition is that at least one fence in `pFences` is
  signaled.

- `timeout` is the timeout period in units of nanoseconds.
  `timeout` is adjusted to the closest value allowed by the
  implementation-dependent timeout accuracy, which :normative{type="may"} be substantially
  longer than one nanosecond, and :normative{type="may"} be longer than the requested
  period.

If the condition is satisfied when `vkWaitForFences` is called, then
`vkWaitForFences` returns immediately.
If the condition is not satisfied at the time `vkWaitForFences` is
called, then `vkWaitForFences` will block and wait until the condition
is satisfied or the `timeout` has expired, whichever is sooner.

If `timeout` is zero, then `vkWaitForFences` does not wait, but
simply returns the current state of the fences.
`VK_TIMEOUT` will be returned in this case if the condition is not
satisfied, even though no actual wait was performed.

If the condition is satisfied before the `timeout` has expired,
`vkWaitForFences` returns `VK_SUCCESS`.
Otherwise, `vkWaitForFences` returns `VK_TIMEOUT` after the
`timeout` has expired.

If device loss occurs (see Lost Device) before
the timeout has expired, `vkWaitForFences` :normative{type="must"} return in finite time
with either `VK_SUCCESS` or `VK_ERROR_DEVICE_LOST`.


::note
While we guarantee that `vkWaitForFences` :normative{type="must"} return in finite time,
no guarantees are made that it returns immediately upon device loss.
However, the client can reasonably expect that the delay will be on the
order of seconds and that calling `vkWaitForFences` will not result in a
permanently (or seemingly permanently) dead process.
::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkWaitForFences-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkWaitForFences-pFences-parameter"}
 `pFences` :normative{type="must"} be a valid pointer to an array of `fenceCount` valid [VkFence](/man/VkFence) handles
::

::validity-field{name="VUID-vkWaitForFences-fenceCount-arraylength"}
 `fenceCount` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-vkWaitForFences-pFences-parent"}
 Each element of `pFences` :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::




An execution dependency is defined by waiting for a fence to become
signaled, either via [vkWaitForFences](/man/vkWaitForFences) or by polling on
[vkGetFenceStatus](/man/vkGetFenceStatus).

The first synchronization scope
includes only the fence signal operation.

The second synchronization scope
includes the host operations of [vkWaitForFences](/man/vkWaitForFences) or
[vkGetFenceStatus](/man/vkGetFenceStatus) indicating that the fence has become signaled.


::note
Signaling a fence and waiting on the host does not guarantee that the
results of memory accesses will be visible to the host, as the access scope
of a memory dependency defined by a fence only includes device access.
A memory barrier or other memory
dependency :normative{type="must"} be used to guarantee this.
See the description of host access
types for more information.
::






## Semaphores

Semaphores are a synchronization primitive that :normative{type="can"} be used to insert a
dependency
between queue operations.
Semaphores have two states - signaled and unsignaled.
A semaphore :normative{type="can"} be signaled after execution of a queue operation is
completed, and a queue operation :normative{type="can"} wait for a semaphore to become
signaled before it begins execution.

Semaphores are represented by `VkSemaphore` handles:

[{generated}/api/handles/VkSemaphore.adoc]({generated}/api/handles/VkSemaphore.adoc)

To create a semaphore, call:

[{generated}/api/protos/vkCreateSemaphore.adoc]({generated}/api/protos/vkCreateSemaphore.adoc)

- `device` is the logical device that creates the semaphore.

- `pCreateInfo` is a pointer to a [VkSemaphoreCreateInfo](/man/VkSemaphoreCreateInfo)
  structure containing information about how the semaphore is to be
  created.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

- `pSemaphore` is a pointer to a handle in which the resulting
  semaphore object is returned.

This command creates a *binary semaphore* that has a boolean payload
indicating whether the semaphore is currently signaled or unsignaled.
When created, the semaphore is in the unsignaled state.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCreateSemaphore-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkCreateSemaphore-pCreateInfo-parameter"}
 `pCreateInfo` :normative{type="must"} be a valid pointer to a valid [VkSemaphoreCreateInfo](/man/VkSemaphoreCreateInfo) structure
::

::validity-field{name="VUID-vkCreateSemaphore-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkCreateSemaphore-pSemaphore-parameter"}
 `pSemaphore` :normative{type="must"} be a valid pointer to a [VkSemaphore](/man/VkSemaphore) handle
::

::




The `VkSemaphoreCreateInfo` structure is defined as:

[{generated}/api/structs/VkSemaphoreCreateInfo.adoc]({generated}/api/structs/VkSemaphoreCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is reserved for future use.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkSemaphoreCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO`
::

::validity-field{name="VUID-VkSemaphoreCreateInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkExportMetalObjectCreateInfoEXT](/man/VkExportMetalObjectCreateInfoEXT), [VkExportSemaphoreCreateInfo](/man/VkExportSemaphoreCreateInfo), [VkExportSemaphoreWin32HandleInfoKHR](/man/VkExportSemaphoreWin32HandleInfoKHR), [VkImportMetalSharedEventInfoEXT](/man/VkImportMetalSharedEventInfoEXT), [VkQueryLowLatencySupportNV](/man/VkQueryLowLatencySupportNV), or [VkSemaphoreTypeCreateInfo](/man/VkSemaphoreTypeCreateInfo)
::

::validity-field{name="VUID-VkSemaphoreCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique, with the exception of structures of type [VkExportMetalObjectCreateInfoEXT](/man/VkExportMetalObjectCreateInfoEXT)
::

::validity-field{name="VUID-VkSemaphoreCreateInfo-flags-zerobitmask"}
 `flags` :normative{type="must"} be `0`
::

::


[{generated}/api/flags/VkSemaphoreCreateFlags.adoc]({generated}/api/flags/VkSemaphoreCreateFlags.adoc)

`VkSemaphoreCreateFlags` is a bitmask type for setting a mask, but is
currently reserved for future use.

To destroy a semaphore, call:

[{generated}/api/protos/vkDestroySemaphore.adoc]({generated}/api/protos/vkDestroySemaphore.adoc)

- `device` is the logical device that destroys the semaphore.

- `semaphore` is the handle of the semaphore to destroy.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkDestroySemaphore-semaphore-01137"}

All submitted batches that refer to `semaphore` :normative{type="must"} have completed
execution
::

::validity-field{name="VUID-vkDestroySemaphore-semaphore-01138"}

If `VkAllocationCallbacks` were provided when `semaphore` was
created, a compatible set of callbacks :normative{type="must"} be provided here
::

::validity-field{name="VUID-vkDestroySemaphore-semaphore-01139"}

If no `VkAllocationCallbacks` were provided when `semaphore` was
created, `pAllocator` :normative{type="must"} be `NULL`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkDestroySemaphore-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkDestroySemaphore-semaphore-parameter"}
 If `semaphore` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `semaphore` :normative{type="must"} be a valid [VkSemaphore](/man/VkSemaphore) handle
::

::validity-field{name="VUID-vkDestroySemaphore-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkDestroySemaphore-semaphore-parent"}
 If `semaphore` is a valid handle, it :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::






### Semaphore Signaling

When a batch is submitted to a queue via a queue
submission, and it includes semaphores to be signaled, it defines a memory
dependency on the batch, and defines *semaphore signal operations* which set
the semaphores to the signaled state.

The first synchronization scope
includes every command submitted in the same batch.
Semaphore signal operations that are defined by [vkQueueSubmit](/man/vkQueueSubmit)
additionally include all commands that occur earlier in
submission order.
Semaphore signal operations that are defined by [vkQueueSubmit](/man/vkQueueSubmit)
or [vkQueueBindSparse](/man/vkQueueBindSparse)
additionally include in the first synchronization scope any semaphore and
fence signal operations that occur earlier in
signal operation order.

The second synchronization scope
includes only the semaphore signal operation.

The first access scope
includes all memory access performed by the device.

The second access scope is
empty.





### Semaphore Waiting

When a batch is submitted to a queue via a queue
submission, and it includes semaphores to be waited on, it defines a
memory dependency between prior semaphore signal operations and the batch,
and defines *semaphore wait operations*.

Such semaphore wait operations set the semaphores
to the unsignaled state.

The first synchronization scope includes all semaphore signal operations
that operate on semaphores waited on in the same batch, and that
happen-before the wait completes.

The second synchronization scope
includes every command submitted in the same batch.
In the case of [vkQueueSubmit](/man/vkQueueSubmit), the second synchronization scope is
limited to operations on the pipeline stages determined by the
destination stage mask specified
by the corresponding element of `pWaitDstStageMask`.
Also, in the case of
[vkQueueSubmit](/man/vkQueueSubmit), the second synchronization scope additionally includes
all commands that occur later in
submission order.

The first access scope is
empty.

The second access scope
includes all memory access performed by the device.

The semaphore wait operation happens-after the first set of operations in
the execution dependency, and happens-before the second set of operations in
the execution dependency.


::note
Unlike
fences or events, the act of waiting for a binary semaphore also unsignals
that semaphore.
Applications :normative{type="must"} ensure that between two such wait operations, the
semaphore is signaled again, with execution dependencies used to ensure
these occur in order.
Binary semaphore waits and signals should thus occur in discrete 1:1 pairs.
::






### Semaphore State Requirements for Wait Operations

Before waiting on a semaphore, the application :normative{type="must"} ensure the semaphore is
in a valid state for a wait operation.
Specifically, when a semaphore wait
operation is submitted to a queue:

- A binary semaphore :normative{type="must"} be signaled, or have an associated
  semaphore signal operation that
  is pending execution.

- Any semaphore signal operations
  on which the pending binary semaphore signal operation depends :normative{type="must"}
  also be completed or pending execution.

- There :normative{type="must"} be no other queue waiting on the same binary semaphore when
  the operation executes.







## Events

Events are a synchronization primitive that :normative{type="can"} be used to insert a
fine-grained dependency between commands submitted to the same queue, or
between the host and a queue.
Events :normative{type="must"} not be used to insert a dependency between commands submitted
to different queues.
Events have two states - signaled and unsignaled.
An application :normative{type="can"} signal or unsignal an event either on the host or on the
device.
A device :normative{type="can"} be made to wait for an event to become signaled before
executing further operations.
No command exists to wait for an event to become signaled on the host, but
the current state of an event :normative{type="can"} be queried.

Events are represented by `VkEvent` handles:

[{generated}/api/handles/VkEvent.adoc]({generated}/api/handles/VkEvent.adoc)

To create an event, call:

[{generated}/api/protos/vkCreateEvent.adoc]({generated}/api/protos/vkCreateEvent.adoc)

- `device` is the logical device that creates the event.

- `pCreateInfo` is a pointer to a [VkEventCreateInfo](/man/VkEventCreateInfo) structure
  containing information about how the event is to be created.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

- `pEvent` is a pointer to a handle in which the resulting event
  object is returned.

When created, the event object is in the unsignaled state.




::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCreateEvent-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkCreateEvent-pCreateInfo-parameter"}
 `pCreateInfo` :normative{type="must"} be a valid pointer to a valid [VkEventCreateInfo](/man/VkEventCreateInfo) structure
::

::validity-field{name="VUID-vkCreateEvent-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkCreateEvent-pEvent-parameter"}
 `pEvent` :normative{type="must"} be a valid pointer to a [VkEvent](/man/VkEvent) handle
::

::




The `VkEventCreateInfo` structure is defined as:

[{generated}/api/structs/VkEventCreateInfo.adoc]({generated}/api/structs/VkEventCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is a bitmask of [VkEventCreateFlagBits](/man/VkEventCreateFlagBits) defining
  additional creation parameters.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkEventCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_EVENT_CREATE_INFO`
::

::validity-field{name="VUID-VkEventCreateInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkExportMetalObjectCreateInfoEXT](/man/VkExportMetalObjectCreateInfoEXT) or [VkImportMetalSharedEventInfoEXT](/man/VkImportMetalSharedEventInfoEXT)
::

::validity-field{name="VUID-VkEventCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique, with the exception of structures of type [VkExportMetalObjectCreateInfoEXT](/man/VkExportMetalObjectCreateInfoEXT)
::

::validity-field{name="VUID-VkEventCreateInfo-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkEventCreateFlagBits](/man/VkEventCreateFlagBits) values
::

::


[{generated}/api/enums/VkEventCreateFlagBits.adoc]({generated}/api/enums/VkEventCreateFlagBits.adoc)


::note
All bits for this type are defined by extensions, and none of those
extensions are enabled in this build of the specification.
::


[{generated}/api/flags/VkEventCreateFlags.adoc]({generated}/api/flags/VkEventCreateFlags.adoc)

`VkEventCreateFlags` is a bitmask type for setting a mask of
[VkEventCreateFlagBits](/man/VkEventCreateFlagBits).

To destroy an event, call:

[{generated}/api/protos/vkDestroyEvent.adoc]({generated}/api/protos/vkDestroyEvent.adoc)

- `device` is the logical device that destroys the event.

- `event` is the handle of the event to destroy.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkDestroyEvent-event-01145"}

All submitted commands that refer to `event` :normative{type="must"} have completed
execution
::

::validity-field{name="VUID-vkDestroyEvent-event-01146"}

If `VkAllocationCallbacks` were provided when `event` was
created, a compatible set of callbacks :normative{type="must"} be provided here
::

::validity-field{name="VUID-vkDestroyEvent-event-01147"}

If no `VkAllocationCallbacks` were provided when `event` was
created, `pAllocator` :normative{type="must"} be `NULL`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkDestroyEvent-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkDestroyEvent-event-parameter"}
 If `event` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `event` :normative{type="must"} be a valid [VkEvent](/man/VkEvent) handle
::

::validity-field{name="VUID-vkDestroyEvent-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkDestroyEvent-event-parent"}
 If `event` is a valid handle, it :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::




To query the state of an event from the host, call:

[{generated}/api/protos/vkGetEventStatus.adoc]({generated}/api/protos/vkGetEventStatus.adoc)

- `device` is the logical device that owns the event.

- `event` is the handle of the event to query.

Upon success, `vkGetEventStatus` returns the state of the event object
with the following return codes:



If a `vkCmdSetEvent` or `vkCmdResetEvent` command is in a command
buffer that is in the pending state, then the
value returned by this command :normative{type="may"} immediately be out of date.

The state of an event :normative{type="can"} be updated by the host.
The state of the event is immediately changed, and subsequent calls to
`vkGetEventStatus` will return the new state.
If an event is already in the requested state, then updating it to the same
state has no effect.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkGetEventStatus-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkGetEventStatus-event-parameter"}
 `event` :normative{type="must"} be a valid [VkEvent](/man/VkEvent) handle
::

::validity-field{name="VUID-vkGetEventStatus-event-parent"}
 `event` :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::








The state of an event :normative{type="can"} also be updated on the device by commands
inserted in command buffers.





To wait for one or more events to enter the signaled state on a device,
call:

[{generated}/api/protos/vkCmdWaitEvents.adoc]({generated}/api/protos/vkCmdWaitEvents.adoc)

- `commandBuffer` is the command buffer into which the command is
  recorded.

- `eventCount` is the length of the `pEvents` array.

- `pEvents` is a pointer to an array of event object handles to wait
  on.

- `srcStageMask` is a bitmask of [VkPipelineStageFlagBits](/man/VkPipelineStageFlagBits)
  specifying the source stage mask.

- `dstStageMask` is a bitmask of [VkPipelineStageFlagBits](/man/VkPipelineStageFlagBits)
  specifying the destination stage
  mask.

- `memoryBarrierCount` is the length of the `pMemoryBarriers`
  array.

- `pMemoryBarriers` is a pointer to an array of [VkMemoryBarrier](/man/VkMemoryBarrier)
  structures.

- `bufferMemoryBarrierCount` is the length of the
  `pBufferMemoryBarriers` array.

- `pBufferMemoryBarriers` is a pointer to an array of
  [VkBufferMemoryBarrier](/man/VkBufferMemoryBarrier) structures.

- `imageMemoryBarrierCount` is the length of the
  `pImageMemoryBarriers` array.

- `pImageMemoryBarriers` is a pointer to an array of
  [VkImageMemoryBarrier](/man/VkImageMemoryBarrier) structures.

When `vkCmdWaitEvents` is submitted to a queue, it defines a memory
dependency between prior event signal operations on the same queue or the
host, and subsequent commands.
`vkCmdWaitEvents` :normative{type="must"} not be used to wait on event signal operations
occurring on other queues.

The first synchronization scope only includes event signal operations that
operate on members of `pEvents`, and the operations that happened-before
the event signal operations.
Event signal operations performed by [vkCmdSetEvent](/man/vkCmdSetEvent) that occur earlier
in submission order are included in the
first synchronization scope, if the logically latest pipeline stage in their `stageMask` parameter is
logically earlier than or equal
to the logically latest pipeline
stage in `srcStageMask`.
Event signal operations performed by [vkSetEvent](/man/vkSetEvent) are only included in
the first synchronization scope if `VK_PIPELINE_STAGE_HOST_BIT` is
included in `srcStageMask`.

The second synchronization scope
includes all commands that occur later in
submission order.
The second synchronization scope is limited to operations on the pipeline
stages determined by the destination stage mask specified by `dstStageMask`.

The first access scope is
limited to accesses in the pipeline stages determined by the
source stage mask specified by
`srcStageMask`.
Within that, the first access scope only includes the first access scopes
defined by elements of the `pMemoryBarriers`,
`pBufferMemoryBarriers` and `pImageMemoryBarriers` arrays, which
each define a set of memory barriers.
If no memory barriers are specified, then the first access scope includes no
accesses.

The second access scope is
limited to accesses in the pipeline stages determined by the
destination stage mask specified
by `dstStageMask`.
Within that, the second access scope only includes the second access scopes
defined by elements of the `pMemoryBarriers`,
`pBufferMemoryBarriers` and `pImageMemoryBarriers` arrays, which
each define a set of memory barriers.
If no memory barriers are specified, then the second access scope includes
no accesses.


::note
[vkCmdWaitEvents](/man/vkCmdWaitEvents) is used with [vkCmdSetEvent](/man/vkCmdSetEvent) to define a memory
dependency between two sets of action commands, roughly in the same way as
pipeline barriers, but split into two commands such that work between the
two :normative{type="may"} execute unhindered.

Unlike [vkCmdPipelineBarrier](/man/vkCmdPipelineBarrier), a queue family ownership transfer :normative{type="cannot"} be performed using
[vkCmdWaitEvents](/man/vkCmdWaitEvents).
::



::note
Applications should be careful to avoid race conditions when using events.
There is no direct ordering guarantee between [vkCmdWaitEvents](/man/vkCmdWaitEvents) and
[vkCmdResetEvent](/man/vkCmdResetEvent), or [vkCmdSetEvent](/man/vkCmdSetEvent).
Another execution dependency (e.g. a pipeline barrier or semaphore with
`VK_PIPELINE_STAGE_ALL_COMMANDS_BIT`) is needed to prevent such a race
condition.
::



::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdWaitEvents-srcStageMask-04090"}

If the `geometryShader` feature is not
enabled, `srcStageMask` :normative{type="must"} not contain
`VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT`
::

::validity-field{name="VUID-vkCmdWaitEvents-srcStageMask-04091"}

If the `tessellationShader` feature
is not enabled, `srcStageMask` :normative{type="must"} not contain
`VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT` or
`VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT`
::

::validity-field{name="VUID-vkCmdWaitEvents-srcStageMask-04996"}
`srcStageMask` :normative{type="must"} not be `0`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdWaitEvents-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdWaitEvents-pEvents-parameter"}
 `pEvents` :normative{type="must"} be a valid pointer to an array of `eventCount` valid [VkEvent](/man/VkEvent) handles
::

::validity-field{name="VUID-vkCmdWaitEvents-srcStageMask-parameter"}
 `srcStageMask` :normative{type="must"} be a valid combination of [VkPipelineStageFlagBits](/man/VkPipelineStageFlagBits) values
::

::validity-field{name="VUID-vkCmdWaitEvents-dstStageMask-parameter"}
 `dstStageMask` :normative{type="must"} be a valid combination of [VkPipelineStageFlagBits](/man/VkPipelineStageFlagBits) values
::

::validity-field{name="VUID-vkCmdWaitEvents-pMemoryBarriers-parameter"}
 If `memoryBarrierCount` is not `0`, `pMemoryBarriers` :normative{type="must"} be a valid pointer to an array of `memoryBarrierCount` valid [VkMemoryBarrier](/man/VkMemoryBarrier) structures
::

::validity-field{name="VUID-vkCmdWaitEvents-pBufferMemoryBarriers-parameter"}
 If `bufferMemoryBarrierCount` is not `0`, `pBufferMemoryBarriers` :normative{type="must"} be a valid pointer to an array of `bufferMemoryBarrierCount` valid [VkBufferMemoryBarrier](/man/VkBufferMemoryBarrier) structures
::

::validity-field{name="VUID-vkCmdWaitEvents-pImageMemoryBarriers-parameter"}
 If `imageMemoryBarrierCount` is not `0`, `pImageMemoryBarriers` :normative{type="must"} be a valid pointer to an array of `imageMemoryBarrierCount` valid [VkImageMemoryBarrier](/man/VkImageMemoryBarrier) structures
::

::validity-field{name="VUID-vkCmdWaitEvents-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdWaitEvents-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics, compute, decode, or encode operations
::

::validity-field{name="VUID-vkCmdWaitEvents-eventCount-arraylength"}
 `eventCount` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-vkCmdWaitEvents-commonparent"}
 Both of `commandBuffer`, and the elements of `pEvents` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::










## Pipeline Barriers

To record a pipeline barrier, call:

[{generated}/api/protos/vkCmdPipelineBarrier.adoc]({generated}/api/protos/vkCmdPipelineBarrier.adoc)

- `commandBuffer` is the command buffer into which the command is
  recorded.

- `srcStageMask` is a bitmask of [VkPipelineStageFlagBits](/man/VkPipelineStageFlagBits)
  specifying the source stages.

- `dstStageMask` is a bitmask of [VkPipelineStageFlagBits](/man/VkPipelineStageFlagBits)
  specifying the destination
  stages.

- `dependencyFlags` is a bitmask of [VkDependencyFlagBits](/man/VkDependencyFlagBits)
  specifying how execution and memory dependencies are formed.

- `memoryBarrierCount` is the length of the `pMemoryBarriers`
  array.

- `pMemoryBarriers` is a pointer to an array of [VkMemoryBarrier](/man/VkMemoryBarrier)
  structures.

- `bufferMemoryBarrierCount` is the length of the
  `pBufferMemoryBarriers` array.

- `pBufferMemoryBarriers` is a pointer to an array of
  [VkBufferMemoryBarrier](/man/VkBufferMemoryBarrier) structures.

- `imageMemoryBarrierCount` is the length of the
  `pImageMemoryBarriers` array.

- `pImageMemoryBarriers` is a pointer to an array of
  [VkImageMemoryBarrier](/man/VkImageMemoryBarrier) structures.

When [vkCmdPipelineBarrier](/man/vkCmdPipelineBarrier) is submitted to a queue, it defines a memory
dependency between commands that were submitted to the same queue before it,
and those submitted to the same queue after it.

If [vkCmdPipelineBarrier](/man/vkCmdPipelineBarrier) was recorded outside a render pass instance,
the first synchronization scope
includes all commands that occur earlier in
submission order.
If [vkCmdPipelineBarrier](/man/vkCmdPipelineBarrier) was recorded inside a render pass instance,
the first synchronization scope includes only commands that occur earlier in
submission order within the same
subpass.
In either case, the first synchronization scope is limited to operations on
the pipeline stages determined by the
source stage mask specified by
`srcStageMask`.

If [vkCmdPipelineBarrier](/man/vkCmdPipelineBarrier) was recorded outside a render pass instance,
the second synchronization scope
includes all commands that occur later in
submission order.
If [vkCmdPipelineBarrier](/man/vkCmdPipelineBarrier) was recorded inside a render pass instance,
the second synchronization scope includes only commands that occur later in
submission order within the same
subpass.
In either case, the second synchronization scope is limited to operations on
the pipeline stages determined by the
destination stage mask specified
by `dstStageMask`.

The first access scope is
limited to accesses in the pipeline stages determined by the
source stage mask specified by
`srcStageMask`.
Within that, the first access scope only includes the first access scopes
defined by elements of the `pMemoryBarriers`,
`pBufferMemoryBarriers` and `pImageMemoryBarriers` arrays, which
each define a set of memory barriers.
If no memory barriers are specified, then the first access scope includes no
accesses.

The second access scope is
limited to accesses in the pipeline stages determined by the
destination stage mask specified
by `dstStageMask`.
Within that, the second access scope only includes the second access scopes
defined by elements of the `pMemoryBarriers`,
`pBufferMemoryBarriers` and `pImageMemoryBarriers` arrays, which
each define a set of memory barriers.
If no memory barriers are specified, then the second access scope includes
no accesses.

If `dependencyFlags` includes `VK_DEPENDENCY_BY_REGION_BIT`, then
any dependency between framebuffer-space pipeline stages is
framebuffer-local - otherwise it is
framebuffer-global.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdPipelineBarrier-srcStageMask-04090"}

If the `geometryShader` feature is not
enabled, `srcStageMask` :normative{type="must"} not contain
`VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT`
::

::validity-field{name="VUID-vkCmdPipelineBarrier-srcStageMask-04091"}

If the `tessellationShader` feature
is not enabled, `srcStageMask` :normative{type="must"} not contain
`VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT` or
`VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT`
::

::validity-field{name="VUID-vkCmdPipelineBarrier-srcStageMask-04996"}
`srcStageMask` :normative{type="must"} not be `0`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdPipelineBarrier-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdPipelineBarrier-srcStageMask-parameter"}
 `srcStageMask` :normative{type="must"} be a valid combination of [VkPipelineStageFlagBits](/man/VkPipelineStageFlagBits) values
::

::validity-field{name="VUID-vkCmdPipelineBarrier-dstStageMask-parameter"}
 `dstStageMask` :normative{type="must"} be a valid combination of [VkPipelineStageFlagBits](/man/VkPipelineStageFlagBits) values
::

::validity-field{name="VUID-vkCmdPipelineBarrier-dependencyFlags-parameter"}
 `dependencyFlags` :normative{type="must"} be a valid combination of [VkDependencyFlagBits](/man/VkDependencyFlagBits) values
::

::validity-field{name="VUID-vkCmdPipelineBarrier-pMemoryBarriers-parameter"}
 If `memoryBarrierCount` is not `0`, `pMemoryBarriers` :normative{type="must"} be a valid pointer to an array of `memoryBarrierCount` valid [VkMemoryBarrier](/man/VkMemoryBarrier) structures
::

::validity-field{name="VUID-vkCmdPipelineBarrier-pBufferMemoryBarriers-parameter"}
 If `bufferMemoryBarrierCount` is not `0`, `pBufferMemoryBarriers` :normative{type="must"} be a valid pointer to an array of `bufferMemoryBarrierCount` valid [VkBufferMemoryBarrier](/man/VkBufferMemoryBarrier) structures
::

::validity-field{name="VUID-vkCmdPipelineBarrier-pImageMemoryBarriers-parameter"}
 If `imageMemoryBarrierCount` is not `0`, `pImageMemoryBarriers` :normative{type="must"} be a valid pointer to an array of `imageMemoryBarrierCount` valid [VkImageMemoryBarrier](/man/VkImageMemoryBarrier) structures
::

::validity-field{name="VUID-vkCmdPipelineBarrier-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdPipelineBarrier-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support transfer, graphics, compute, decode, or encode operations
::

::






Bits which :normative{type="can"} be set in `vkCmdPipelineBarrier`::`dependencyFlags`,
specifying how execution and memory dependencies are formed, are:

[{generated}/api/enums/VkDependencyFlagBits.adoc]({generated}/api/enums/VkDependencyFlagBits.adoc)

- `VK_DEPENDENCY_BY_REGION_BIT` specifies that dependencies will be
  framebuffer-local.

[{generated}/api/flags/VkDependencyFlags.adoc]({generated}/api/flags/VkDependencyFlags.adoc)

`VkDependencyFlags` is a bitmask type for setting a mask of zero or more
[VkDependencyFlagBits](/man/VkDependencyFlagBits).





## Memory Barriers

*Memory barriers* are used to explicitly control access to buffer and image
subresource ranges.
Memory barriers are used to transfer
ownership between queue families,
change image layouts, and
define availability
and visibility operations.
They explicitly define the access types
and buffer and image subresource ranges that are included in the
access scopes of a memory
dependency that is created by a synchronization command that includes them.



### Global Memory Barriers

Global memory barriers apply to memory accesses involving all memory objects
that exist at the time of its execution.

The `VkMemoryBarrier` structure is defined as:

[{generated}/api/structs/VkMemoryBarrier.adoc]({generated}/api/structs/VkMemoryBarrier.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `srcAccessMask` is a bitmask of [VkAccessFlagBits](/man/VkAccessFlagBits) specifying a
  source access mask.

- `dstAccessMask` is a bitmask of [VkAccessFlagBits](/man/VkAccessFlagBits) specifying a
  destination access mask.

The first access scope is
limited to access types in the source access
mask specified by `srcAccessMask`.

The second access scope is
limited to access types in the destination
access mask specified by `dstAccessMask`.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkMemoryBarrier-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_MEMORY_BARRIER`
::

::validity-field{name="VUID-VkMemoryBarrier-pNext-pNext"}
 `pNext` :normative{type="must"} be `NULL`
::

::validity-field{name="VUID-VkMemoryBarrier-srcAccessMask-parameter"}
 `srcAccessMask` :normative{type="must"} be a valid combination of [VkAccessFlagBits](/man/VkAccessFlagBits) values
::

::validity-field{name="VUID-VkMemoryBarrier-dstAccessMask-parameter"}
 `dstAccessMask` :normative{type="must"} be a valid combination of [VkAccessFlagBits](/man/VkAccessFlagBits) values
::

::






### Buffer Memory Barriers

Buffer memory barriers only apply to memory accesses involving a specific
buffer range.
That is, a memory dependency formed from a buffer memory barrier is
scoped to access via the
specified buffer range.
Buffer memory barriers :normative{type="can"} also be used to define a
queue family ownership transfer for the
specified buffer range.

The `VkBufferMemoryBarrier` structure is defined as:

[{generated}/api/structs/VkBufferMemoryBarrier.adoc]({generated}/api/structs/VkBufferMemoryBarrier.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `srcAccessMask` is a bitmask of [VkAccessFlagBits](/man/VkAccessFlagBits) specifying a
  source access mask.

- `dstAccessMask` is a bitmask of [VkAccessFlagBits](/man/VkAccessFlagBits) specifying a
  destination access mask.

- `srcQueueFamilyIndex` is the source queue family for a
  queue family ownership transfer.

- `dstQueueFamilyIndex` is the destination queue family for a
  queue family ownership transfer.

- `buffer` is a handle to the buffer whose backing memory is affected
  by the barrier.

- `offset` is an offset in bytes into the backing memory for
  `buffer`; this is relative to the base offset as bound to the buffer
  (see [vkBindBufferMemory](/man/vkBindBufferMemory)).

- `size` is a size in bytes of the affected area of backing memory for
  `buffer`, or `VK_WHOLE_SIZE` to use the range from `offset`
  to the end of the buffer.

The first access scope is
limited to access to memory through the specified buffer range, via access
types in the source access mask specified
by `srcAccessMask`.
If `srcAccessMask` includes `VK_ACCESS_HOST_WRITE_BIT`, a
memory domain
operation is performed where available memory in the host domain is also
made available to the device domain.

The second access scope is
limited to access to memory through the specified buffer range, via access
types in the destination access mask
specified by `dstAccessMask`.
If `dstAccessMask` includes `VK_ACCESS_HOST_WRITE_BIT` or
`VK_ACCESS_HOST_READ_BIT`, a
memory domain
operation is performed where available memory in the device domain is also
made available to the host domain.


::note
When `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` is used, available memory in
host domain is automatically made visible to host domain, and any host write
is automatically made available to host domain.
::


If `srcQueueFamilyIndex` is not equal to `dstQueueFamilyIndex`, and
`srcQueueFamilyIndex` is equal to the current queue family, then the
memory barrier defines a queue
family release operation for the specified buffer range, and the second
access scope includes no access, as if `dstAccessMask` was `0`.

If `dstQueueFamilyIndex` is not equal to `srcQueueFamilyIndex`, and
`dstQueueFamilyIndex` is equal to the current queue family, then the
memory barrier defines a queue
family acquire operation for the specified buffer range, and the first
access scope includes no access, as if `srcAccessMask` was `0`.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkBufferMemoryBarrier-offset-01187"}
`offset` :normative{type="must"} be less than the size of `buffer`
::

::validity-field{name="VUID-VkBufferMemoryBarrier-size-01188"}

If `size` is not equal to `VK_WHOLE_SIZE`, `size` :normative{type="must"} be
greater than `0`
::

::validity-field{name="VUID-VkBufferMemoryBarrier-size-01189"}

If `size` is not equal to `VK_WHOLE_SIZE`, `size` :normative{type="must"} be
less than or equal to than the size of `buffer` minus `offset`
::

::validity-field{name="VUID-VkBufferMemoryBarrier-buffer-01931"}

If `buffer` is non-sparse then it :normative{type="must"} be bound completely and
contiguously to a single `VkDeviceMemory` object
::

::validity-field{name="VUID-VkBufferMemoryBarrier-buffer-09095"}

If `buffer` was created with a sharing mode of
`VK_SHARING_MODE_EXCLUSIVE`, and `srcQueueFamilyIndex` and
`dstQueueFamilyIndex` are not equal, `srcQueueFamilyIndex` :normative{type="must"}
be
a valid queue family
::

::validity-field{name="VUID-VkBufferMemoryBarrier-buffer-09096"}

If `buffer` was created with a sharing mode of
`VK_SHARING_MODE_EXCLUSIVE`, and `srcQueueFamilyIndex` and
`dstQueueFamilyIndex` are not equal, `dstQueueFamilyIndex` :normative{type="must"}
be
a valid queue family
::

::validity-field{name="VUID-VkBufferMemoryBarrier-None-09050"}

If
`buffer` was created with a sharing mode of
`VK_SHARING_MODE_CONCURRENT`, `srcQueueFamilyIndex` :normative{type="must"} be
`VK_QUEUE_FAMILY_IGNORED`
::

::validity-field{name="VUID-VkBufferMemoryBarrier-None-09051"}

If
`buffer` was created with a sharing mode of
`VK_SHARING_MODE_CONCURRENT`, `dstQueueFamilyIndex` :normative{type="must"} be
`VK_QUEUE_FAMILY_IGNORED`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkBufferMemoryBarrier-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER`
::

::validity-field{name="VUID-VkBufferMemoryBarrier-pNext-pNext"}
 `pNext` :normative{type="must"} be `NULL` or a pointer to a valid instance of [VkExternalMemoryAcquireUnmodifiedEXT](/man/VkExternalMemoryAcquireUnmodifiedEXT)
::

::validity-field{name="VUID-VkBufferMemoryBarrier-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkBufferMemoryBarrier-buffer-parameter"}
 `buffer` :normative{type="must"} be a valid [VkBuffer](/man/VkBuffer) handle
::

::


`VK_WHOLE_SIZE` is a special value indicating that the entire remaining
length of a buffer following a given `offset` should be used.
It :normative{type="can"} be specified for [VkBufferMemoryBarrier](/man/VkBufferMemoryBarrier)::`size` and other
structures.

[{generated}/api/enums/VK\_WHOLE\_SIZE.adoc]({generated}/api/enums/VK_WHOLE_SIZE.adoc)





### Image Memory Barriers

Image memory barriers only apply to memory accesses involving a specific
image subresource range.
That is, a memory dependency formed from an image memory barrier is
scoped to access via the
specified image subresource range.
Image memory barriers :normative{type="can"} also be used to define
image layout transitions or a
queue family ownership transfer for the
specified image subresource range.

The `VkImageMemoryBarrier` structure is defined as:

[{generated}/api/structs/VkImageMemoryBarrier.adoc]({generated}/api/structs/VkImageMemoryBarrier.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `srcAccessMask` is a bitmask of [VkAccessFlagBits](/man/VkAccessFlagBits) specifying a
  source access mask.

- `dstAccessMask` is a bitmask of [VkAccessFlagBits](/man/VkAccessFlagBits) specifying a
  destination access mask.

- `oldLayout` is the old layout in an
  image layout transition.

- `newLayout` is the new layout in an
  image layout transition.

- `srcQueueFamilyIndex` is the source queue family for a
  queue family ownership transfer.

- `dstQueueFamilyIndex` is the destination queue family for a
  queue family ownership transfer.

- `image` is a handle to the image affected by this barrier.

- `subresourceRange` describes the image
  subresource range within `image` that is affected by this barrier.

The first access scope is
limited to access to memory through the specified image subresource range,
via access types in the source access mask
specified by `srcAccessMask`.
If `srcAccessMask` includes `VK_ACCESS_HOST_WRITE_BIT`, memory
writes performed by that access type are also made visible, as that access
type is not performed through a resource.

The second access scope is
limited to access to memory through the specified image subresource range,
via access types in the destination access
mask specified by `dstAccessMask`.
If `dstAccessMask` includes `VK_ACCESS_HOST_WRITE_BIT` or
`VK_ACCESS_HOST_READ_BIT`, available memory writes are also made visible
to accesses of those types, as those access types are not performed through
a resource.

If `srcQueueFamilyIndex` is not equal to `dstQueueFamilyIndex`, and
`srcQueueFamilyIndex` is equal to the current queue family, then the
memory barrier defines a queue
family release operation for the specified image subresource range, and
the second access scope includes no access, as if `dstAccessMask` was
`0`.

If `dstQueueFamilyIndex` is not equal to `srcQueueFamilyIndex`, and
`dstQueueFamilyIndex` is equal to the current queue family, then the
memory barrier defines a queue
family acquire operation for the specified image subresource range, and
the first access scope includes no access, as if `srcAccessMask` was
`0`.

`oldLayout` and `newLayout` define an
image layout transition for
the specified image subresource range.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkImageMemoryBarrier-oldLayout-01208"}

If `srcQueueFamilyIndex` and `dstQueueFamilyIndex` define a
queue family ownership transfer or
`oldLayout` and `newLayout` define an
image layout transition,
and `oldLayout` or `newLayout` is
`VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL` then `image` :normative{type="must"}
have been created with `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`
::

::validity-field{name="VUID-VkImageMemoryBarrier-oldLayout-01209"}

If `srcQueueFamilyIndex` and `dstQueueFamilyIndex` define a
queue family ownership transfer or
`oldLayout` and `newLayout` define an
image layout transition,
and `oldLayout` or `newLayout` is
`VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL` then `image`
:normative{type="must"} have been created with
`VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`
::

::validity-field{name="VUID-VkImageMemoryBarrier-oldLayout-01210"}

If `srcQueueFamilyIndex` and `dstQueueFamilyIndex` define a
queue family ownership transfer or
`oldLayout` and `newLayout` define an
image layout transition,
and `oldLayout` or `newLayout` is
`VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL` then `image`
:normative{type="must"} have been created with
`VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`
::

::validity-field{name="VUID-VkImageMemoryBarrier-oldLayout-01211"}

If `srcQueueFamilyIndex` and `dstQueueFamilyIndex` define a
queue family ownership transfer or
`oldLayout` and `newLayout` define an
image layout transition,
and `oldLayout` or `newLayout` is
`VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL` then `image` :normative{type="must"}
have been created with `VK_IMAGE_USAGE_SAMPLED_BIT` or
`VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`
::

::validity-field{name="VUID-VkImageMemoryBarrier-oldLayout-01212"}

If `srcQueueFamilyIndex` and `dstQueueFamilyIndex` define a
queue family ownership transfer or
`oldLayout` and `newLayout` define an
image layout transition,
and `oldLayout` or `newLayout` is
`VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL` then `image` :normative{type="must"} have
been created with `VK_IMAGE_USAGE_TRANSFER_SRC_BIT`
::

::validity-field{name="VUID-VkImageMemoryBarrier-oldLayout-01213"}

If `srcQueueFamilyIndex` and `dstQueueFamilyIndex` define a
queue family ownership transfer or
`oldLayout` and `newLayout` define an
image layout transition,
and `oldLayout` or `newLayout` is
`VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` then `image` :normative{type="must"} have
been created with `VK_IMAGE_USAGE_TRANSFER_DST_BIT`
::

::validity-field{name="VUID-VkImageMemoryBarrier-oldLayout-01197"}

If `srcQueueFamilyIndex` and `dstQueueFamilyIndex` define a
queue family ownership transfer or
`oldLayout` and `newLayout` define an
image layout transition,
`oldLayout` :normative{type="must"} be `VK_IMAGE_LAYOUT_UNDEFINED` or the current
layout of the image subresources affected by the barrier
::

::validity-field{name="VUID-VkImageMemoryBarrier-newLayout-01198"}

If `srcQueueFamilyIndex` and `dstQueueFamilyIndex` define a
queue family ownership transfer or
`oldLayout` and `newLayout` define an
image layout transition,
`newLayout` :normative{type="must"} not be `VK_IMAGE_LAYOUT_UNDEFINED` or
`VK_IMAGE_LAYOUT_PREINITIALIZED`
::

::validity-field{name="VUID-VkImageMemoryBarrier-image-09117"}

If `image` was created with a sharing mode of
`VK_SHARING_MODE_EXCLUSIVE`, and `srcQueueFamilyIndex` and
`dstQueueFamilyIndex` are not equal, `srcQueueFamilyIndex` :normative{type="must"}
be
a valid queue family
::

::validity-field{name="VUID-VkImageMemoryBarrier-image-09118"}

If `image` was created with a sharing mode of
`VK_SHARING_MODE_EXCLUSIVE`, and `srcQueueFamilyIndex` and
`dstQueueFamilyIndex` are not equal, `dstQueueFamilyIndex` :normative{type="must"}
be
a valid queue family
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkImageMemoryBarrier-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER`
::

::validity-field{name="VUID-VkImageMemoryBarrier-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkExternalMemoryAcquireUnmodifiedEXT](/man/VkExternalMemoryAcquireUnmodifiedEXT) or [VkSampleLocationsInfoEXT](/man/VkSampleLocationsInfoEXT)
::

::validity-field{name="VUID-VkImageMemoryBarrier-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkImageMemoryBarrier-oldLayout-parameter"}
 `oldLayout` :normative{type="must"} be a valid [VkImageLayout](/man/VkImageLayout) value
::

::validity-field{name="VUID-VkImageMemoryBarrier-newLayout-parameter"}
 `newLayout` :normative{type="must"} be a valid [VkImageLayout](/man/VkImageLayout) value
::

::validity-field{name="VUID-VkImageMemoryBarrier-image-parameter"}
 `image` :normative{type="must"} be a valid [VkImage](/man/VkImage) handle
::

::validity-field{name="VUID-VkImageMemoryBarrier-subresourceRange-parameter"}
 `subresourceRange` :normative{type="must"} be a valid [VkImageSubresourceRange](/man/VkImageSubresourceRange) structure
::

::






### Queue Family Ownership Transfer

Resources created with a [VkSharingMode](/man/VkSharingMode) of
`VK_SHARING_MODE_EXCLUSIVE` :normative{type="must"} have their ownership explicitly
transferred from one queue family to another in order to access their
content in a well-defined manner on a queue in a different queue family.

The special queue family index `VK_QUEUE_FAMILY_IGNORED` indicates that
a queue family parameter or member is ignored.

[{generated}/api/enums/VK\_QUEUE\_FAMILY\_IGNORED.adoc]({generated}/api/enums/VK_QUEUE_FAMILY_IGNORED.adoc)

If memory dependencies are correctly expressed between uses of such a
resource between two queues in different families, but no ownership transfer
is defined, the contents of that resource are undefined: for any read
accesses performed by the second queue family.


::note
If an application does not need the contents of a resource to remain valid
when transferring from one queue family to another, then the ownership
transfer :normative{type="should"} be skipped.
::


A queue family ownership transfer consists of two distinct parts:

1) Release exclusive ownership from the source queue family

2) Acquire exclusive ownership for the destination queue family

An application :normative{type="must"} ensure that these operations occur in the correct order
by defining an execution dependency between them, e.g. using a semaphore.

[synchronization-queue-transfers-release](#synchronization-queue-transfers-release) A *release operation* is used to
release exclusive ownership of a range of a buffer or image subresource
range.
A release operation is defined by executing a
buffer memory barrier (for a
buffer range) or an image memory
barrier (for an image subresource range) using a pipeline barrier command,
on a queue from the source queue family.
The `srcQueueFamilyIndex` parameter of the barrier :normative{type="must"} be set to the
source queue family index, and the `dstQueueFamilyIndex` parameter to
the destination queue family index.
`dstAccessMask` is ignored for such a barrier, such that no visibility
operation is executed - the value of this mask does not affect the validity
of the barrier.
The release operation happens-after the availability operation, and
happens-before operations specified in the second synchronization scope of
the calling command.

[synchronization-queue-transfers-acquire](#synchronization-queue-transfers-acquire) An *acquire operation* is used
to acquire exclusive ownership of a range of a buffer or image subresource
range.
An acquire operation is defined by executing a
buffer memory barrier (for a
buffer range) or an image memory
barrier (for an image subresource range) using a pipeline barrier command,
on a queue from the destination queue family.
The buffer range or image subresource range specified in an acquire
operation :normative{type="must"} match exactly that of a previous release operation.
The `srcQueueFamilyIndex` parameter of the barrier :normative{type="must"} be set to the
source queue family index, and the `dstQueueFamilyIndex` parameter to
the destination queue family index.
`srcAccessMask` is ignored for such a barrier, such that no availability
operation is executed - the value of this mask does not affect the validity
of the barrier.
The acquire operation happens-after operations in the first synchronization
scope of the calling command, and happens-before the visibility operation.


::note
Whilst it is not invalid to provide destination or source access masks for
memory barriers used for release or acquire operations, respectively, they
have no practical effect.
Access after a release operation has undefined: results, and so visibility
for those accesses has no practical effect.
Similarly, write access before an acquire operation will produce undefined:
results for future access, so availability of those writes has no practical
use.
In an earlier version of the specification, these were required to match on
both sides - but this was subsequently relaxed.
These masks :normative{type="should"} be set to 0.
::


If the transfer is via an image memory barrier, and an
image layout transition is
desired, then the values of `oldLayout` and `newLayout` in the
*release operation*'s memory barrier :normative{type="must"} be equal to values of
`oldLayout` and `newLayout` in the *acquire operation*'s memory
barrier.
Although the image layout transition is submitted twice, it will only be
executed once.
A layout transition specified in this way happens-after the *release
operation* and happens-before the *acquire operation*.

If the values of `srcQueueFamilyIndex` and `dstQueueFamilyIndex` are
equal, no ownership transfer is performed, and the barrier operates as if
they were both set to `VK_QUEUE_FAMILY_IGNORED`.

Queue family ownership transfers :normative{type="may"} perform read and write accesses on all
memory bound to the image subresource or buffer range, so applications :normative{type="must"}
ensure that all memory writes have been made
available before a
queue family ownership transfer is executed.
Available memory is automatically made visible to queue family release and
acquire operations, and writes performed by those operations are
automatically made available.

Once a queue family has acquired ownership of a buffer range or image
subresource range of a `VK_SHARING_MODE_EXCLUSIVE` resource, its
contents are undefined: to other queue families unless ownership is
transferred.
The contents of any portion of another resource which aliases memory that is
bound to the transferred buffer or image subresource range are undefined:
after a release or acquire operation.


::note
Because events :normative{type="cannot"} be used directly for
inter-queue synchronization, and because [vkCmdSetEvent](/man/vkCmdSetEvent) does not have
the queue family index or memory barrier parameters needed by a *release
operation*, the release and acquire operations of a queue family ownership
transfer :normative{type="can"} only be performed using [vkCmdPipelineBarrier](/man/vkCmdPipelineBarrier).
::








## Wait Idle Operations

To wait on the host for the completion of outstanding queue operations for a
given queue, call:

[{generated}/api/protos/vkQueueWaitIdle.adoc]({generated}/api/protos/vkQueueWaitIdle.adoc)

- `queue` is the queue on which to wait.

`vkQueueWaitIdle` is equivalent to having submitted a valid fence to
every previously executed queue submission
command that accepts a fence, then waiting for all of those fences to
signal using [vkWaitForFences](/man/vkWaitForFences) with an infinite timeout and
`waitAll` set to `VK_TRUE`.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkQueueWaitIdle-queue-parameter"}
 `queue` :normative{type="must"} be a valid [VkQueue](/man/VkQueue) handle
::

::








To wait on the host for the completion of outstanding queue operations for
all queues on a given logical device, call:

[{generated}/api/protos/vkDeviceWaitIdle.adoc]({generated}/api/protos/vkDeviceWaitIdle.adoc)

- `device` is the logical device to idle.

`vkDeviceWaitIdle` is equivalent to calling `vkQueueWaitIdle` for
all queues owned by `device`.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkDeviceWaitIdle-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::










## Host Write Ordering Guarantees

When batches of command buffers are submitted to a queue via a
queue submission command, it defines a memory
dependency with prior host operations, and execution of command buffers
submitted to the queue.

The first synchronization scope
includes execution of [vkQueueSubmit](/man/vkQueueSubmit) on the host and anything that
happened-before it, as defined by the host memory model.


::note
Some systems allow writes that do not directly integrate with the host
memory model; these have to be synchronized by the application manually.
One example of this is non-temporal store instructions on x86; to ensure
these happen-before submission, applications should call `_mm_sfence()`.
::


The second synchronization scope
includes all commands submitted in the same queue submission, and all commands that occur later in
submission order.

The first access scope
includes all host writes to mappable device memory that are available to the
host memory domain.

The second access scope
includes all memory access performed by the device.







# Render Pass

Draw commands :normative{type="must"} be recorded within a *render pass
instance*.
Each render pass instance defines a set of image resources, referred to as
*attachments*, used during rendering.

A render pass object represents a collection of attachments, subpasses, and
dependencies between the subpasses, and describes how the attachments are
used over the course of the subpasses.

Render passes are represented by `VkRenderPass` handles:

[{generated}/api/handles/VkRenderPass.adoc]({generated}/api/handles/VkRenderPass.adoc)

An *attachment description* describes the properties of an attachment
including its format, sample count, and how its contents are treated at the
beginning and end of each render pass instance.

A *subpass* represents a phase of rendering that reads and writes a subset
of the attachments in a render pass.
Rendering commands are recorded into a particular subpass of a render pass
instance.

A *subpass description* describes the subset of attachments that is involved
in the execution of a subpass.
Each subpass :normative{type="can"} read from some attachments as *input attachments*, write
to some as *color attachments* or *depth/stencil attachments*,
and perform *multisample resolve operations* to *resolve attachments*.
A subpass description :normative{type="can"} also include a set of *preserve attachments*,
which are attachments that are not read or written by the subpass but whose
contents :normative{type="must"} be preserved throughout the subpass.

A subpass *uses an attachment* if the attachment is a color, depth/stencil,
resolve,
or input attachment for that subpass (as determined by the
`pColorAttachments`, `pDepthStencilAttachment`,
`pResolveAttachments`,
and `pInputAttachments` members of [VkSubpassDescription](/man/VkSubpassDescription),
respectively).
A subpass does not use an attachment if that attachment is preserved by the
subpass.
The *first use of an attachment* is in the lowest numbered subpass that uses
that attachment.
Similarly, the *last use of an attachment* is in the highest numbered
subpass that uses that attachment.

The subpasses in a render pass all render to the same dimensions, and
fragments for pixel (x,y,layer) in one subpass :normative{type="can"} only read attachment
contents written by previous subpasses at that same (x,y,layer) location.


::note
By describing a complete set of subpasses in advance, render passes provide
the implementation an opportunity to optimize the storage and transfer of
attachment data between subpasses.

In practice, this means that subpasses with a simple framebuffer-space
dependency :normative{type="may"} be merged into a single tiled rendering pass, keeping the
attachment data on-chip for the duration of a render pass instance.
However, it is also quite common for a render pass to only contain a single
subpass.
::


*Subpass dependencies* describe execution
and memory dependencies between subpasses.

A *subpass dependency chain* is a sequence of subpass dependencies in a
render pass, where the source subpass of each subpass dependency (after the
first) equals the destination subpass of the previous dependency.

Execution of subpasses :normative{type="may"} overlap or execute out of order with regards to
other subpasses, unless otherwise enforced by an execution dependency.
Each subpass only respects submission
order for commands recorded in the same subpass, and the
[vkCmdBeginRenderPass](/man/vkCmdBeginRenderPass) and [vkCmdEndRenderPass](/man/vkCmdEndRenderPass) commands that
delimit the render pass - commands within other subpasses are not included.
This affects most other implicit ordering
guarantees.

A render pass describes the structure of subpasses and attachments
independent of any specific image views for the attachments.
The specific image views that will be used for the attachments, and their
dimensions, are specified in `VkFramebuffer` objects.
Framebuffers are created with respect to a specific render pass that the
framebuffer is compatible with (see Render Pass
Compatibility).
Collectively, a render pass and a framebuffer define the complete render
target state for one or more subpasses as well as the algorithmic
dependencies between the subpasses.

The various pipeline stages of the drawing commands for a given subpass :normative{type="may"}
execute concurrently and/or out of order, both within and across drawing
commands, whilst still respecting pipeline order.
However for a given (x,y,layer,sample) sample location, certain per-sample
operations are performed in rasterization order.

`VK_ATTACHMENT_UNUSED` is a constant indicating that a render pass
attachment is not used.

[{generated}/api/enums/VK\_ATTACHMENT\_UNUSED.adoc]({generated}/api/enums/VK_ATTACHMENT_UNUSED.adoc)



## Render Pass Creation

To create a render pass, call:

[{generated}/api/protos/vkCreateRenderPass.adoc]({generated}/api/protos/vkCreateRenderPass.adoc)

- `device` is the logical device that creates the render pass.

- `pCreateInfo` is a pointer to a [VkRenderPassCreateInfo](/man/VkRenderPassCreateInfo)
  structure describing the parameters of the render pass.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

- `pRenderPass` is a pointer to a [VkRenderPass](/man/VkRenderPass) handle in which
  the resulting render pass object is returned.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCreateRenderPass-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkCreateRenderPass-pCreateInfo-parameter"}
 `pCreateInfo` :normative{type="must"} be a valid pointer to a valid [VkRenderPassCreateInfo](/man/VkRenderPassCreateInfo) structure
::

::validity-field{name="VUID-vkCreateRenderPass-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkCreateRenderPass-pRenderPass-parameter"}
 `pRenderPass` :normative{type="must"} be a valid pointer to a [VkRenderPass](/man/VkRenderPass) handle
::

::




The `VkRenderPassCreateInfo` structure is defined as:

[{generated}/api/structs/VkRenderPassCreateInfo.adoc]({generated}/api/structs/VkRenderPassCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is reserved for future use.

- `attachmentCount` is the number of attachments used by this render
  pass.

- `pAttachments` is a pointer to an array of `attachmentCount`

  [VkAttachmentDescription](/man/VkAttachmentDescription) structures describing the attachments used
  by the render pass.

- `subpassCount` is the number of subpasses to create.

- `pSubpasses` is a pointer to an array of `subpassCount`

  [VkSubpassDescription](/man/VkSubpassDescription) structures describing each subpass.

- `dependencyCount` is the number of memory dependencies between pairs
  of subpasses.

- `pDependencies` is a pointer to an array of `dependencyCount`

  [VkSubpassDependency](/man/VkSubpassDependency) structures describing dependencies between
  pairs of subpasses.


::note
Care should be taken to avoid a data race here; if any subpasses access
attachments with overlapping memory locations, and one of those accesses is
a write, a subpass dependency needs to be included between them.
::



::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkRenderPassCreateInfo-attachment-00834"}

If the `attachment` member of any element of
`pInputAttachments`, `pColorAttachments`,
`pResolveAttachments` or `pDepthStencilAttachment`, or any
element of `pPreserveAttachments` in any element of `pSubpasses`
is not `VK_ATTACHMENT_UNUSED`, then it :normative{type="must"} be less than
`attachmentCount`
::

::validity-field{name="VUID-VkRenderPassCreateInfo-pAttachments-00836"}

For any member of `pAttachments` with a `loadOp` equal to
`VK_ATTACHMENT_LOAD_OP_CLEAR`, the first use of that attachment
:normative{type="must"} not specify a `layout` equal to
`VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL` or
`VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL`
::

::validity-field{name="VUID-VkRenderPassCreateInfo-pAttachments-02511"}

For any member of `pAttachments` with a `stencilLoadOp` equal to
`VK_ATTACHMENT_LOAD_OP_CLEAR`, the first use of that attachment
:normative{type="must"} not specify a `layout` equal to
`VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL` or
`VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL`
::

::validity-field{name="VUID-VkRenderPassCreateInfo-pDependencies-00837"}

For any element of `pDependencies`, if the `srcSubpass` is not
`VK_SUBPASS_EXTERNAL`, all stage flags included in the
`srcStageMask` member of that dependency :normative{type="must"} be a pipeline stage
supported by the pipeline
identified by the `pipelineBindPoint` member of the source subpass
::

::validity-field{name="VUID-VkRenderPassCreateInfo-pDependencies-00838"}

For any element of `pDependencies`, if the `dstSubpass` is not
`VK_SUBPASS_EXTERNAL`, all stage flags included in the
`dstStageMask` member of that dependency :normative{type="must"} be a pipeline stage
supported by the pipeline
identified by the `pipelineBindPoint` member of the destination
subpass
::

::validity-field{name="VUID-VkRenderPassCreateInfo-pDependencies-06866"}

For any element of `pDependencies`, if its `srcSubpass` is not
`VK_SUBPASS_EXTERNAL`, it :normative{type="must"} be less than `subpassCount`
::

::validity-field{name="VUID-VkRenderPassCreateInfo-pDependencies-06867"}

For any element of `pDependencies`, if its `dstSubpass` is not
`VK_SUBPASS_EXTERNAL`, it :normative{type="must"} be less than `subpassCount`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkRenderPassCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO`
::

::validity-field{name="VUID-VkRenderPassCreateInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkRenderPassFragmentDensityMapCreateInfoEXT](/man/VkRenderPassFragmentDensityMapCreateInfoEXT), [VkRenderPassInputAttachmentAspectCreateInfo](/man/VkRenderPassInputAttachmentAspectCreateInfo), or [VkRenderPassMultiviewCreateInfo](/man/VkRenderPassMultiviewCreateInfo)
::

::validity-field{name="VUID-VkRenderPassCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkRenderPassCreateInfo-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkRenderPassCreateFlagBits](/man/VkRenderPassCreateFlagBits) values
::

::validity-field{name="VUID-VkRenderPassCreateInfo-pAttachments-parameter"}
 If `attachmentCount` is not `0`, `pAttachments` :normative{type="must"} be a valid pointer to an array of `attachmentCount` valid [VkAttachmentDescription](/man/VkAttachmentDescription) structures
::

::validity-field{name="VUID-VkRenderPassCreateInfo-pSubpasses-parameter"}
 `pSubpasses` :normative{type="must"} be a valid pointer to an array of `subpassCount` valid [VkSubpassDescription](/man/VkSubpassDescription) structures
::

::validity-field{name="VUID-VkRenderPassCreateInfo-pDependencies-parameter"}
 If `dependencyCount` is not `0`, `pDependencies` :normative{type="must"} be a valid pointer to an array of `dependencyCount` valid [VkSubpassDependency](/man/VkSubpassDependency) structures
::

::validity-field{name="VUID-VkRenderPassCreateInfo-subpassCount-arraylength"}
 `subpassCount` :normative{type="must"} be greater than `0`
::

::


Bits which :normative{type="can"} be set in [VkRenderPassCreateInfo](/man/VkRenderPassCreateInfo)::`flags`,
describing additional properties of the render pass, are:

[{generated}/api/enums/VkRenderPassCreateFlagBits.adoc]({generated}/api/enums/VkRenderPassCreateFlagBits.adoc)


::note
All bits for this type are defined by extensions, and none of those
extensions are enabled in this build of the specification.
::


[{generated}/api/flags/VkRenderPassCreateFlags.adoc]({generated}/api/flags/VkRenderPassCreateFlags.adoc)

`VkRenderPassCreateFlags` is a bitmask type for setting a mask of zero
or more [VkRenderPassCreateFlagBits](/man/VkRenderPassCreateFlagBits).

The `VkAttachmentDescription` structure is defined as:

[{generated}/api/structs/VkAttachmentDescription.adoc]({generated}/api/structs/VkAttachmentDescription.adoc)

- `flags` is a bitmask of [VkAttachmentDescriptionFlagBits](/man/VkAttachmentDescriptionFlagBits)
  specifying additional properties of the attachment.

- `format` is a [VkFormat](/man/VkFormat) value specifying the format of the
  image view that will be used for the attachment.

- `samples` is a [VkSampleCountFlagBits](/man/VkSampleCountFlagBits) value specifying the
  number of samples of the image.

- `loadOp` is a [VkAttachmentLoadOp](/man/VkAttachmentLoadOp) value specifying how the
  contents of color and depth components of the attachment are treated at
  the beginning of the subpass where it is first used.

- `storeOp` is a [VkAttachmentStoreOp](/man/VkAttachmentStoreOp) value specifying how the
  contents of color and depth components of the attachment are treated at
  the end of the subpass where it is last used.

- `stencilLoadOp` is a [VkAttachmentLoadOp](/man/VkAttachmentLoadOp) value specifying how
  the contents of stencil components of the attachment are treated at the
  beginning of the subpass where it is first used.

- `stencilStoreOp` is a [VkAttachmentStoreOp](/man/VkAttachmentStoreOp) value specifying how
  the contents of stencil components of the attachment are treated at the
  end of the last subpass where it is used.

- `initialLayout` is the layout the attachment image subresource will
  be in when a render pass instance begins.

- `finalLayout` is the layout the attachment image subresource will be
  transitioned to when a render pass instance ends.

If the attachment uses a color format, then `loadOp` and `storeOp`
are used, and `stencilLoadOp` and `stencilStoreOp` are ignored.
If the format has depth and/or stencil components, `loadOp` and
`storeOp` apply only to the depth data, while `stencilLoadOp` and
`stencilStoreOp` define how the stencil data is handled.
`loadOp` and `stencilLoadOp` define the
load operations for the attachment.
`storeOp` and `stencilStoreOp` define the
store operations for the attachment.
If an attachment is not used by any subpass, `loadOp`, `storeOp`,
`stencilStoreOp`, and `stencilLoadOp` will be ignored for that
attachment, and no load or store ops will be performed.
However, any transition specified by `initialLayout` and
`finalLayout` will still be executed.

If `flags` includes `VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT`, then
the attachment is treated as if it shares physical memory with another
attachment in the same render pass.
This information limits the ability of the implementation to reorder certain
operations (like layout transitions and the `loadOp`) such that it is
not improperly reordered against other uses of the same physical memory via
a different attachment.
This is described in more detail below.

If a render pass uses multiple attachments that alias the same device
memory, those attachments :normative{type="must"} each include the
`VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT` bit in their attachment
description flags.
Attachments aliasing the same memory occurs in multiple ways:

- Multiple attachments being assigned the same image view as part of
  framebuffer creation.

- Attachments using distinct image views that correspond to the same image
  subresource of an image.

- Attachments using views of distinct image subresources which are bound
  to overlapping memory ranges.


::note
Render passes :normative{type="must"} include subpass dependencies (either directly or via a
subpass dependency chain) between any two subpasses that operate on the same
attachment or aliasing attachments and those subpass dependencies :normative{type="must"}
include execution and memory dependencies separating uses of the aliases, if
at least one of those subpasses writes to one of the aliases.
These dependencies :normative{type="must"} not include the `VK_DEPENDENCY_BY_REGION_BIT`
if the aliases are views of distinct image subresources which overlap in
memory.
::


Multiple attachments that alias the same memory :normative{type="must"} not be used in a
single subpass.
A given attachment index :normative{type="must"} not be used multiple times in a single
subpass, with one exception: two subpass attachments :normative{type="can"} use the same
attachment index if at least one use is as an input attachment and neither
use is as a resolve or preserve attachment.
In other words, the same view :normative{type="can"} be used simultaneously as an input and
color or depth/stencil attachment, but :normative{type="must"} not be used as multiple color
or depth/stencil attachments nor as resolve or preserve attachments.

If a set of attachments alias each other, then all except the first to be
used in the render pass :normative{type="must"} use an `initialLayout` of
`VK_IMAGE_LAYOUT_UNDEFINED`, since the earlier uses of the other aliases
make their contents undefined:.
Once an alias has been used and a different alias has been used after it,
the first alias :normative{type="must"} not be used in any later subpasses.
However, an application :normative{type="can"} assign the same image view to multiple aliasing
attachment indices, which allows that image view to be used multiple times
even if other aliases are used in between.


::note
Once an attachment needs the `VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT`
bit, there :normative{type="should"} be no additional cost of introducing additional aliases,
and using these additional aliases :normative{type="may"} allow more efficient clearing of the
attachments on multiple uses via `VK_ATTACHMENT_LOAD_OP_CLEAR`.
::



::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkAttachmentDescription-format-06699"}

If `format` includes a color or depth component and `loadOp` is
`VK_ATTACHMENT_LOAD_OP_LOAD`, then `initialLayout` :normative{type="must"} not be
`VK_IMAGE_LAYOUT_UNDEFINED`
::

::validity-field{name="VUID-VkAttachmentDescription-finalLayout-00843"}
`finalLayout` :normative{type="must"} not be `VK_IMAGE_LAYOUT_UNDEFINED` or
`VK_IMAGE_LAYOUT_PREINITIALIZED`
::

::validity-field{name="VUID-VkAttachmentDescription-format-03280"}

If `format` is a color format, `initialLayout` :normative{type="must"} not be
`VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL` or
`VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL`
::

::validity-field{name="VUID-VkAttachmentDescription-format-03281"}

If `format` is a depth/stencil format, `initialLayout` :normative{type="must"} not
be `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL`
::

::validity-field{name="VUID-VkAttachmentDescription-format-03282"}

If `format` is a color format, `finalLayout` :normative{type="must"} not be
`VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL` or
`VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL`
::

::validity-field{name="VUID-VkAttachmentDescription-format-03283"}

If `format` is a depth/stencil format, `finalLayout` :normative{type="must"} not
be `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL`
::

::validity-field{name="VUID-VkAttachmentDescription-samples-08745"}
`samples` :normative{type="must"} be a bit value that is set in
`imageCreateSampleCounts` (as defined in
Image Creation Limits) for the given
`format`
::

::validity-field{name="VUID-VkAttachmentDescription-format-06698"}
`format` :normative{type="must"} not be VK_FORMAT_UNDEFINED
::

::validity-field{name="VUID-VkAttachmentDescription-format-06700"}

If `format` includes a stencil component and `stencilLoadOp` is
`VK_ATTACHMENT_LOAD_OP_LOAD`, then `initialLayout` :normative{type="must"} not be
`VK_IMAGE_LAYOUT_UNDEFINED`
::

::validity-field{name="VUID-VkAttachmentDescription-format-03292"}

If `format` is a depth/stencil format which includes only the
stencil component, `initialLayout` :normative{type="must"} not be
`VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL` or
`VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL`
::

::validity-field{name="VUID-VkAttachmentDescription-format-03293"}

If `format` is a depth/stencil format which includes only the
stencil component, `finalLayout` :normative{type="must"} not be
`VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL` or
`VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL`
::

::validity-field{name="VUID-VkAttachmentDescription-format-06242"}

If `format` is a depth/stencil format which includes both depth and
stencil components, `initialLayout` :normative{type="must"} not be
`VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL` or
`VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL`
::

::validity-field{name="VUID-VkAttachmentDescription-format-06243"}

If `format` is a depth/stencil format which includes both depth and
stencil components, `finalLayout` :normative{type="must"} not be
`VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL` or
`VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkAttachmentDescription-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkAttachmentDescriptionFlagBits](/man/VkAttachmentDescriptionFlagBits) values
::

::validity-field{name="VUID-VkAttachmentDescription-format-parameter"}
 `format` :normative{type="must"} be a valid [VkFormat](/man/VkFormat) value
::

::validity-field{name="VUID-VkAttachmentDescription-samples-parameter"}
 `samples` :normative{type="must"} be a valid [VkSampleCountFlagBits](/man/VkSampleCountFlagBits) value
::

::validity-field{name="VUID-VkAttachmentDescription-loadOp-parameter"}
 `loadOp` :normative{type="must"} be a valid [VkAttachmentLoadOp](/man/VkAttachmentLoadOp) value
::

::validity-field{name="VUID-VkAttachmentDescription-storeOp-parameter"}
 `storeOp` :normative{type="must"} be a valid [VkAttachmentStoreOp](/man/VkAttachmentStoreOp) value
::

::validity-field{name="VUID-VkAttachmentDescription-stencilLoadOp-parameter"}
 `stencilLoadOp` :normative{type="must"} be a valid [VkAttachmentLoadOp](/man/VkAttachmentLoadOp) value
::

::validity-field{name="VUID-VkAttachmentDescription-stencilStoreOp-parameter"}
 `stencilStoreOp` :normative{type="must"} be a valid [VkAttachmentStoreOp](/man/VkAttachmentStoreOp) value
::

::validity-field{name="VUID-VkAttachmentDescription-initialLayout-parameter"}
 `initialLayout` :normative{type="must"} be a valid [VkImageLayout](/man/VkImageLayout) value
::

::validity-field{name="VUID-VkAttachmentDescription-finalLayout-parameter"}
 `finalLayout` :normative{type="must"} be a valid [VkImageLayout](/man/VkImageLayout) value
::

::


Bits which :normative{type="can"} be set in [VkAttachmentDescription](/man/VkAttachmentDescription)::`flags`,
describing additional properties of the attachment, are:

[{generated}/api/enums/VkAttachmentDescriptionFlagBits.adoc]({generated}/api/enums/VkAttachmentDescriptionFlagBits.adoc)

- `VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT` specifies that the
  attachment aliases the same device memory as other attachments.

[{generated}/api/flags/VkAttachmentDescriptionFlags.adoc]({generated}/api/flags/VkAttachmentDescriptionFlags.adoc)

`VkAttachmentDescriptionFlags` is a bitmask type for setting a mask of
zero or more [VkAttachmentDescriptionFlagBits](/man/VkAttachmentDescriptionFlagBits).

The `VkSubpassDescription` structure is defined as:

[{generated}/api/structs/VkSubpassDescription.adoc]({generated}/api/structs/VkSubpassDescription.adoc)

- `flags` is a bitmask of [VkSubpassDescriptionFlagBits](/man/VkSubpassDescriptionFlagBits)
  specifying usage of the subpass.

- `pipelineBindPoint` is a [VkPipelineBindPoint](/man/VkPipelineBindPoint) value specifying
  the pipeline type supported for this subpass.

- `inputAttachmentCount` is the number of input attachments.

- `pInputAttachments` is a pointer to an array of
  [VkAttachmentReference](/man/VkAttachmentReference) structures defining the input attachments
  for this subpass and their layouts.

- `colorAttachmentCount` is the number of color attachments.

- `pColorAttachments` is a pointer to an array of
  `colorAttachmentCount` [VkAttachmentReference](/man/VkAttachmentReference) structures
  defining the color attachments for this subpass and their layouts.

- `pResolveAttachments` is `NULL` or a pointer to an array of
  `colorAttachmentCount` [VkAttachmentReference](/man/VkAttachmentReference) structures
  defining the resolve attachments for this subpass and their layouts.

- `pDepthStencilAttachment` is a pointer to a
  [VkAttachmentReference](/man/VkAttachmentReference) structure specifying the depth/stencil
  attachment for this subpass and its layout.

- `preserveAttachmentCount` is the number of preserved attachments.

- `pPreserveAttachments` is a pointer to an array of
  `preserveAttachmentCount` render pass attachment indices identifying
  attachments that are not used by this subpass, but whose contents :normative{type="must"}
  be preserved throughout the subpass.

Each element of the `pInputAttachments` array corresponds to an input
attachment index in a fragment shader, i.e. if a shader declares an image
variable decorated with a `InputAttachmentIndex` value of *X*, then it
uses the attachment provided in `pInputAttachments`\[*X*].
Input attachments :normative{type="must"} also be bound to the pipeline in a descriptor set.
If the `attachment` member of any element of `pInputAttachments` is
`VK_ATTACHMENT_UNUSED`, the application :normative{type="must"} not read from the
corresponding input attachment index.
Fragment shaders :normative{type="can"} use subpass input variables to access the contents of
an input attachment at the fragment’s (x, y, layer) framebuffer coordinates.

Each element of the `pColorAttachments` array corresponds to an output
location in the shader, i.e. if the shader declares an output variable
decorated with a `Location` value of *X*, then it uses the attachment
provided in `pColorAttachments`\[*X*].
If the `attachment` member of any element of `pColorAttachments` is
`VK_ATTACHMENT_UNUSED`,
then writes to the corresponding location by a fragment shader are
discarded.

If
`pResolveAttachments` is not `NULL`, each of its elements corresponds to
a color attachment (the element in `pColorAttachments` at the same
index), and a multisample resolve
operation is defined for each attachment unless the resolve attachment
index is `VK_ATTACHMENT_UNUSED`.

If `pDepthStencilAttachment` is `NULL`, or if its attachment index is
`VK_ATTACHMENT_UNUSED`, it indicates that no depth/stencil attachment
will be used in the subpass.

The contents of an attachment within the render area become undefined: at
the start of a subpass *S* if all of the following conditions are true:

- The attachment is used as a color, depth/stencil, or resolve attachment
  in any subpass in the render pass.

- There is a subpass *S\<sub>1\</sub>* that uses or preserves the attachment, and a
  subpass dependency from *S\<sub>1\</sub>* to *S*.

- The attachment is not used or preserved in subpass *S*.

Once the contents of an attachment become undefined: in subpass *S*, they
remain undefined: for subpasses in subpass dependency chains starting with
subpass *S* until they are written again.
However, they remain valid for subpasses in other subpass dependency chains
starting with subpass *S\<sub>1\</sub>* if those subpasses use or preserve the
attachment.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkSubpassDescription-attachment-06912"}

If the `attachment` member of an element of `pInputAttachments`
is not `VK_ATTACHMENT_UNUSED`, its `layout` member :normative{type="must"} not be
`VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL` or
`VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL`
::

::validity-field{name="VUID-VkSubpassDescription-attachment-06913"}

If the `attachment` member of an element of `pColorAttachments`
is not `VK_ATTACHMENT_UNUSED`, its `layout` member :normative{type="must"} not be
`VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL` or
`VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`
::

::validity-field{name="VUID-VkSubpassDescription-attachment-06914"}

If the `attachment` member of an element of
`pResolveAttachments` is not `VK_ATTACHMENT_UNUSED`, its
`layout` member :normative{type="must"} not be
`VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL` or
`VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`
::

::validity-field{name="VUID-VkSubpassDescription-attachment-06915"}

If the `attachment` member of `pDepthStencilAttachment` is not
`VK_ATTACHMENT_UNUSED`, ts `layout` member :normative{type="must"} not be
`VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL` or
`VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`
::

::validity-field{name="VUID-VkSubpassDescription-pipelineBindPoint-04952"}
`pipelineBindPoint` :normative{type="must"} be `VK_PIPELINE_BIND_POINT_GRAPHICS`
::

::validity-field{name="VUID-VkSubpassDescription-colorAttachmentCount-00845"}
`colorAttachmentCount` :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxColorAttachments`
::

::validity-field{name="VUID-VkSubpassDescription-loadOp-00846"}

If the first use of an attachment in this render pass is as an input
attachment, and the attachment is not also used as a color or
depth/stencil attachment in the same subpass, then `loadOp` :normative{type="must"}
not be `VK_ATTACHMENT_LOAD_OP_CLEAR`
::

::validity-field{name="VUID-VkSubpassDescription-pResolveAttachments-00847"}

If `pResolveAttachments` is not `NULL`, for each resolve attachment
that is not `VK_ATTACHMENT_UNUSED`, the corresponding color
attachment :normative{type="must"} not be `VK_ATTACHMENT_UNUSED`
::

::validity-field{name="VUID-VkSubpassDescription-pResolveAttachments-00848"}

If `pResolveAttachments` is not `NULL`, for each resolve attachment
that is not `VK_ATTACHMENT_UNUSED`, the corresponding color
attachment :normative{type="must"} not have a sample count of `VK_SAMPLE_COUNT_1_BIT`
::

::validity-field{name="VUID-VkSubpassDescription-pResolveAttachments-00849"}

If `pResolveAttachments` is not `NULL`, each resolve attachment that
is not `VK_ATTACHMENT_UNUSED` :normative{type="must"} have a sample count of
`VK_SAMPLE_COUNT_1_BIT`
::

::validity-field{name="VUID-VkSubpassDescription-pResolveAttachments-00850"}

If `pResolveAttachments` is not `NULL`, each resolve attachment that
is not `VK_ATTACHMENT_UNUSED` :normative{type="must"} have the same [VkFormat](/man/VkFormat) as
its corresponding color attachment
::

::validity-field{name="VUID-VkSubpassDescription-pColorAttachments-09430"}

All attachments in `pColorAttachments` that are not
`VK_ATTACHMENT_UNUSED` :normative{type="must"} have the same sample count
::

::validity-field{name="VUID-VkSubpassDescription-pInputAttachments-02647"}

All attachments in `pInputAttachments` that are not
`VK_ATTACHMENT_UNUSED` :normative{type="must"} have image formats whose
potential format features contain at
least `VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT` or
`VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT`
::

::validity-field{name="VUID-VkSubpassDescription-pColorAttachments-02648"}

All attachments in `pColorAttachments` that are not
`VK_ATTACHMENT_UNUSED` :normative{type="must"} have image formats whose
potential format features contain
`VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT`
::

::validity-field{name="VUID-VkSubpassDescription-pResolveAttachments-02649"}

All attachments in `pResolveAttachments` that are not
`VK_ATTACHMENT_UNUSED` :normative{type="must"} have image formats whose
potential format features contain
`VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT`
::

::validity-field{name="VUID-VkSubpassDescription-pDepthStencilAttachment-02650"}

If `pDepthStencilAttachment` is not `NULL` and the attachment is not
`VK_ATTACHMENT_UNUSED` then it :normative{type="must"} have an image format whose
potential format features contain
`VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT`
::

::validity-field{name="VUID-VkSubpassDescription-pDepthStencilAttachment-01418"}

If `pDepthStencilAttachment` is not `VK_ATTACHMENT_UNUSED` and
any attachments in `pColorAttachments` are not
`VK_ATTACHMENT_UNUSED`, they :normative{type="must"} have the same sample count
::

::validity-field{name="VUID-VkSubpassDescription-attachment-00853"}

Each element of `pPreserveAttachments` :normative{type="must"} not be
`VK_ATTACHMENT_UNUSED`
::

::validity-field{name="VUID-VkSubpassDescription-pPreserveAttachments-00854"}

Each element of `pPreserveAttachments` :normative{type="must"} not also be an element
of any other member of the subpass description
::

::validity-field{name="VUID-VkSubpassDescription-layout-02519"}

If any attachment is used by more than one [VkAttachmentReference](/man/VkAttachmentReference)
member, then each use :normative{type="must"} use the same `layout`
::

::validity-field{name="VUID-VkSubpassDescription-pDepthStencilAttachment-04438"}
`pDepthStencilAttachment` and `pColorAttachments` must not
contain references to the same attachment
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkSubpassDescription-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkSubpassDescriptionFlagBits](/man/VkSubpassDescriptionFlagBits) values
::

::validity-field{name="VUID-VkSubpassDescription-pipelineBindPoint-parameter"}
 `pipelineBindPoint` :normative{type="must"} be a valid [VkPipelineBindPoint](/man/VkPipelineBindPoint) value
::

::validity-field{name="VUID-VkSubpassDescription-pInputAttachments-parameter"}
 If `inputAttachmentCount` is not `0`, `pInputAttachments` :normative{type="must"} be a valid pointer to an array of `inputAttachmentCount` valid [VkAttachmentReference](/man/VkAttachmentReference) structures
::

::validity-field{name="VUID-VkSubpassDescription-pColorAttachments-parameter"}
 If `colorAttachmentCount` is not `0`, `pColorAttachments` :normative{type="must"} be a valid pointer to an array of `colorAttachmentCount` valid [VkAttachmentReference](/man/VkAttachmentReference) structures
::

::validity-field{name="VUID-VkSubpassDescription-pResolveAttachments-parameter"}
 If `colorAttachmentCount` is not `0`, and `pResolveAttachments` is not `NULL`, `pResolveAttachments` :normative{type="must"} be a valid pointer to an array of `colorAttachmentCount` valid [VkAttachmentReference](/man/VkAttachmentReference) structures
::

::validity-field{name="VUID-VkSubpassDescription-pDepthStencilAttachment-parameter"}
 If `pDepthStencilAttachment` is not `NULL`, `pDepthStencilAttachment` :normative{type="must"} be a valid pointer to a valid [VkAttachmentReference](/man/VkAttachmentReference) structure
::

::validity-field{name="VUID-VkSubpassDescription-pPreserveAttachments-parameter"}
 If `preserveAttachmentCount` is not `0`, `pPreserveAttachments` :normative{type="must"} be a valid pointer to an array of `preserveAttachmentCount` `uint32_t` values
::

::


Bits which :normative{type="can"} be set in [VkSubpassDescription](/man/VkSubpassDescription)::`flags`,
specifying usage of the subpass, are:

[{generated}/api/enums/VkSubpassDescriptionFlagBits.adoc]({generated}/api/enums/VkSubpassDescriptionFlagBits.adoc)


::note
All bits for this type are defined by extensions, and none of those
extensions are enabled in this build of the specification.
::


[{generated}/api/flags/VkSubpassDescriptionFlags.adoc]({generated}/api/flags/VkSubpassDescriptionFlags.adoc)

`VkSubpassDescriptionFlags` is a bitmask type for setting a mask of zero
or more [VkSubpassDescriptionFlagBits](/man/VkSubpassDescriptionFlagBits).

The `VkAttachmentReference` structure is defined as:

[{generated}/api/structs/VkAttachmentReference.adoc]({generated}/api/structs/VkAttachmentReference.adoc)

- `attachment` is either an integer value identifying an attachment at
  the corresponding index in
  [VkRenderPassCreateInfo](/man/VkRenderPassCreateInfo)::`pAttachments`, or
  `VK_ATTACHMENT_UNUSED` to signify that this attachment is not used.

- `layout` is a [VkImageLayout](/man/VkImageLayout) value specifying the layout the
  attachment uses during the subpass.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkAttachmentReference-layout-03077"}

If `attachment` is not `VK_ATTACHMENT_UNUSED`, `layout`
:normative{type="must"} not be `VK_IMAGE_LAYOUT_UNDEFINED`,
`VK_IMAGE_LAYOUT_PREINITIALIZED`, or
`VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkAttachmentReference-layout-parameter"}
 `layout` :normative{type="must"} be a valid [VkImageLayout](/man/VkImageLayout) value
::

::


`VK_SUBPASS_EXTERNAL` is a special subpass index value expanding
synchronization scope outside a subpass.
It is described in more detail by [VkSubpassDependency](/man/VkSubpassDependency).

[{generated}/api/enums/VK\_SUBPASS\_EXTERNAL.adoc]({generated}/api/enums/VK_SUBPASS_EXTERNAL.adoc)

The `VkSubpassDependency` structure is defined as:

[{generated}/api/structs/VkSubpassDependency.adoc]({generated}/api/structs/VkSubpassDependency.adoc)

- `srcSubpass` is the subpass index of the first subpass in the
  dependency, or `VK_SUBPASS_EXTERNAL`.

- `dstSubpass` is the subpass index of the second subpass in the
  dependency, or `VK_SUBPASS_EXTERNAL`.

- `srcStageMask` is a bitmask of [VkPipelineStageFlagBits](/man/VkPipelineStageFlagBits)
  specifying the source stage
  mask.

- `dstStageMask` is a bitmask of [VkPipelineStageFlagBits](/man/VkPipelineStageFlagBits)
  specifying the destination
  stage mask

- `srcAccessMask` is a bitmask of [VkAccessFlagBits](/man/VkAccessFlagBits) specifying a
  source access mask.

- `dstAccessMask` is a bitmask of [VkAccessFlagBits](/man/VkAccessFlagBits) specifying a
  destination access mask.

- `dependencyFlags` is a bitmask of [VkDependencyFlagBits](/man/VkDependencyFlagBits).

If `srcSubpass` is equal to `dstSubpass` then the
[VkSubpassDependency](/man/VkSubpassDependency) does not directly define a
dependency.
Instead, it enables pipeline barriers to be used in a render pass instance
within the identified subpass, where the scopes of one pipeline barrier
:normative{type="must"} be a subset of those described by one subpass dependency.
Subpass dependencies specified in this way that include
framebuffer-space stages in the
`srcStageMask` :normative{type="must"} only include
framebuffer-space stages in
`dstStageMask`, and :normative{type="must"} include `VK_DEPENDENCY_BY_REGION_BIT`.

If `srcSubpass` and `dstSubpass` are not equal, when a render pass
instance which includes a subpass dependency is submitted to a queue, it
defines a dependency between the subpasses
identified by `srcSubpass` and `dstSubpass`.

If `srcSubpass` is equal to `VK_SUBPASS_EXTERNAL`, the first
synchronization scope includes
commands that occur earlier in submission
order than the [vkCmdBeginRenderPass](/man/vkCmdBeginRenderPass) used to begin the render pass
instance.
Otherwise, the first set of commands includes all commands submitted as part
of the subpass instance identified by `srcSubpass` and any
load, store, or multisample resolve
operations on attachments used in `srcSubpass`.
In either case, the first synchronization scope is limited to operations on
the pipeline stages determined by the
source stage mask specified by
`srcStageMask`.

If `dstSubpass` is equal to `VK_SUBPASS_EXTERNAL`, the second
synchronization scope includes
commands that occur later in submission
order than the [vkCmdEndRenderPass](/man/vkCmdEndRenderPass) used to end the render pass
instance.
Otherwise, the second set of commands includes all commands submitted as
part of the subpass instance identified by `dstSubpass` and any
load, store, and multisample resolve
operations on attachments used in `dstSubpass`.
In either case, the second synchronization scope is limited to operations on
the pipeline stages determined by the
destination stage mask specified
by `dstStageMask`.

The first access scope is
limited to accesses in the pipeline stages determined by the
source stage mask specified by
`srcStageMask`.
It is also limited to access types in the source access mask specified by `srcAccessMask`.

The second access scope is
limited to accesses in the pipeline stages determined by the
destination stage mask specified
by `dstStageMask`.
It is also limited to access types in the destination access mask specified by `dstAccessMask`.

The availability and
visibility operations defined by a subpass dependency affect the execution
of image layout transitions within the
render pass.


::note
For non-attachment resources, the memory dependency expressed by subpass
dependency is nearly identical to that of a [VkMemoryBarrier](/man/VkMemoryBarrier) (with
matching `srcAccessMask` and `dstAccessMask` parameters) submitted
as a part of a [vkCmdPipelineBarrier](/man/vkCmdPipelineBarrier) (with matching `srcStageMask`
and `dstStageMask` parameters).
The only difference being that its scopes are limited to the identified
subpasses rather than potentially affecting everything before and after.

For attachments however, subpass dependencies work more like a
[VkImageMemoryBarrier](/man/VkImageMemoryBarrier) defined similarly to the [VkMemoryBarrier](/man/VkMemoryBarrier)
above, the queue family indices set to `VK_QUEUE_FAMILY_IGNORED`, and
layouts as follows:

- The equivalent to `oldLayout` is the attachment’s layout according
  to the subpass description for `srcSubpass`.

- The equivalent to `newLayout` is the attachment’s layout according
  to the subpass description for `dstSubpass`.
::



::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkSubpassDependency-srcStageMask-04090"}

If the `geometryShader` feature is not
enabled, `srcStageMask` :normative{type="must"} not contain
`VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT`
::

::validity-field{name="VUID-VkSubpassDependency-srcStageMask-04091"}

If the `tessellationShader` feature
is not enabled, `srcStageMask` :normative{type="must"} not contain
`VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT` or
`VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT`
::

::validity-field{name="VUID-VkSubpassDependency-srcStageMask-04996"}
`srcStageMask` :normative{type="must"} not be `0`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkSubpassDependency-srcStageMask-parameter"}
 `srcStageMask` :normative{type="must"} be a valid combination of [VkPipelineStageFlagBits](/man/VkPipelineStageFlagBits) values
::

::validity-field{name="VUID-VkSubpassDependency-dstStageMask-parameter"}
 `dstStageMask` :normative{type="must"} be a valid combination of [VkPipelineStageFlagBits](/man/VkPipelineStageFlagBits) values
::

::validity-field{name="VUID-VkSubpassDependency-srcAccessMask-parameter"}
 `srcAccessMask` :normative{type="must"} be a valid combination of [VkAccessFlagBits](/man/VkAccessFlagBits) values
::

::validity-field{name="VUID-VkSubpassDependency-dstAccessMask-parameter"}
 `dstAccessMask` :normative{type="must"} be a valid combination of [VkAccessFlagBits](/man/VkAccessFlagBits) values
::

::validity-field{name="VUID-VkSubpassDependency-dependencyFlags-parameter"}
 `dependencyFlags` :normative{type="must"} be a valid combination of [VkDependencyFlagBits](/man/VkDependencyFlagBits) values
::

::


If there is no subpass dependency from `VK_SUBPASS_EXTERNAL` to the
first subpass that uses an attachment, then an implicit subpass dependency
exists from `VK_SUBPASS_EXTERNAL` to the first subpass it is used in.
The implicit subpass dependency only exists if there exists an automatic
layout transition away from `initialLayout`.
The subpass dependency operates as if defined with the following parameters:



Similarly, if there is no subpass dependency from the last subpass that uses
an attachment to `VK_SUBPASS_EXTERNAL`, then an implicit subpass
dependency exists from the last subpass it is used in to
`VK_SUBPASS_EXTERNAL`.
The implicit subpass dependency only exists if there exists an automatic
layout transition into `finalLayout`.
The subpass dependency operates as if defined with the following parameters:



As subpasses :normative{type="may"} overlap or execute out of order with regards to other
subpasses unless a subpass dependency chain describes otherwise, the layout
transitions required between subpasses :normative{type="cannot"} be known to an application.
Instead, an application provides the layout that each attachment :normative{type="must"} be in
at the start and end of a render pass, and the layout it :normative{type="must"} be in during
each subpass it is used in.
The implementation then :normative{type="must"} execute layout transitions between subpasses
in order to guarantee that the images are in the layouts required by each
subpass, and in the final layout at the end of the render pass.

Automatic layout transitions apply to the entire image subresource attached
to the framebuffer.
If
the attachment is a view of a 1D or 2D image, the automatic layout
transitions apply to the number of layers specified by
[VkFramebufferCreateInfo](/man/VkFramebufferCreateInfo)::`layers`.

Automatic layout transitions away from the layout used in a subpass
happen-after the availability operations for all dependencies with that
subpass as the `srcSubpass`.

Automatic layout transitions into the layout used in a subpass happen-before
the visibility operations for all dependencies with that subpass as the
`dstSubpass`.

Automatic layout transitions away from `initialLayout` happen-after the
availability operations for all dependencies with a `srcSubpass` equal
to `VK_SUBPASS_EXTERNAL`, where `dstSubpass` uses the attachment
that will be transitioned.
For attachments created with `VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT`,
automatic layout transitions away from `initialLayout` happen-after the
availability operations for all dependencies with a `srcSubpass` equal
to `VK_SUBPASS_EXTERNAL`, where `dstSubpass` uses any aliased
attachment.

Automatic layout transitions into `finalLayout` happen-before the
visibility operations for all dependencies with a `dstSubpass` equal to
`VK_SUBPASS_EXTERNAL`, where `srcSubpass` uses the attachment that
will be transitioned.
For attachments created with `VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT`,
automatic layout transitions into `finalLayout` happen-before the
visibility operations for all dependencies with a `dstSubpass` equal to
`VK_SUBPASS_EXTERNAL`, where `srcSubpass` uses any aliased
attachment.

If two subpasses use the same attachment, and both subpasses use the
attachment in a read-only layout, no subpass dependency needs to be
specified between those subpasses.
If an implementation treats those layouts separately, it :normative{type="must"} insert an
implicit subpass dependency between those subpasses to separate the uses in
each layout.
The subpass dependency operates as if defined with the following parameters:



To destroy a render pass, call:

[{generated}/api/protos/vkDestroyRenderPass.adoc]({generated}/api/protos/vkDestroyRenderPass.adoc)

- `device` is the logical device that destroys the render pass.

- `renderPass` is the handle of the render pass to destroy.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkDestroyRenderPass-renderPass-00873"}

All submitted commands that refer to `renderPass` :normative{type="must"} have
completed execution
::

::validity-field{name="VUID-vkDestroyRenderPass-renderPass-00874"}

If `VkAllocationCallbacks` were provided when `renderPass` was
created, a compatible set of callbacks :normative{type="must"} be provided here
::

::validity-field{name="VUID-vkDestroyRenderPass-renderPass-00875"}

If no `VkAllocationCallbacks` were provided when `renderPass`
was created, `pAllocator` :normative{type="must"} be `NULL`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkDestroyRenderPass-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkDestroyRenderPass-renderPass-parameter"}
 If `renderPass` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `renderPass` :normative{type="must"} be a valid [VkRenderPass](/man/VkRenderPass) handle
::

::validity-field{name="VUID-vkDestroyRenderPass-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkDestroyRenderPass-renderPass-parent"}
 If `renderPass` is a valid handle, it :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::








## Render Pass Compatibility

Framebuffers and graphics pipelines are created based on a specific render
pass object.
They :normative{type="must"} only be used with that render pass object, or one compatible with
it.

Two attachment references are compatible if they have matching format and
sample count, or are both `VK_ATTACHMENT_UNUSED` or the pointer that
would contain the reference is `NULL`.

Two arrays of attachment references are compatible if all corresponding
pairs of attachments are compatible.
If the arrays are of different lengths, attachment references not present in
the smaller array are treated as `VK_ATTACHMENT_UNUSED`.

Two render passes are compatible if their corresponding color, input,
resolve, and depth/stencil attachment references are compatible and if they
are otherwise identical except for:

- Initial and final image layout in attachment descriptions

- Load and store operations in attachment descriptions

- Image layout in attachment references

As an additional special case, if two render passes have a single subpass,
the resolve attachment reference
compatibility requirements are ignored.

A framebuffer is compatible with a render pass if it was created using the
same render pass or a compatible render pass.





## Framebuffers

Render passes operate in conjunction with *framebuffers*.
Framebuffers represent a collection of specific memory attachments that a
render pass instance uses.

Framebuffers are represented by `VkFramebuffer` handles:

[{generated}/api/handles/VkFramebuffer.adoc]({generated}/api/handles/VkFramebuffer.adoc)

To create a framebuffer, call:

[{generated}/api/protos/vkCreateFramebuffer.adoc]({generated}/api/protos/vkCreateFramebuffer.adoc)

- `device` is the logical device that creates the framebuffer.

- `pCreateInfo` is a pointer to a [VkFramebufferCreateInfo](/man/VkFramebufferCreateInfo)
  structure describing additional information about framebuffer creation.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

- `pFramebuffer` is a pointer to a [VkFramebuffer](/man/VkFramebuffer) handle in which
  the resulting framebuffer object is returned.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCreateFramebuffer-pCreateInfo-02777"}

If `pCreateInfo→flags` does not include
`VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, and `attachmentCount` is
not `0`, each element of `pCreateInfo→pAttachments` :normative{type="must"} have been
created on `device`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCreateFramebuffer-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkCreateFramebuffer-pCreateInfo-parameter"}
 `pCreateInfo` :normative{type="must"} be a valid pointer to a valid [VkFramebufferCreateInfo](/man/VkFramebufferCreateInfo) structure
::

::validity-field{name="VUID-vkCreateFramebuffer-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkCreateFramebuffer-pFramebuffer-parameter"}
 `pFramebuffer` :normative{type="must"} be a valid pointer to a [VkFramebuffer](/man/VkFramebuffer) handle
::

::




The `VkFramebufferCreateInfo` structure is defined as:

[{generated}/api/structs/VkFramebufferCreateInfo.adoc]({generated}/api/structs/VkFramebufferCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is a bitmask of [VkFramebufferCreateFlagBits](/man/VkFramebufferCreateFlagBits)

- `renderPass` is a render pass defining what render passes the
  framebuffer will be compatible with.
  See Render Pass Compatibility for details.

- `attachmentCount` is the number of attachments.

- `pAttachments` is a pointer to an array of [VkImageView](/man/VkImageView)
  handles, each of which will be used as the corresponding attachment in a
  render pass instance.

- `width`, `height` and `layers` define the dimensions of the
  framebuffer.

It is legal for a subpass to use no color or depth/stencil attachments,
either because it has no attachment references or because all of them are
`VK_ATTACHMENT_UNUSED`.
This kind of subpass :normative{type="can"} use shader side effects such as image stores and
atomics to produce an output.
In this case, the subpass continues to use the `width`, `height`,
and `layers` of the framebuffer to define the dimensions of the
rendering area, and the `rasterizationSamples` from each pipeline’s
[VkPipelineMultisampleStateCreateInfo](/man/VkPipelineMultisampleStateCreateInfo) to define the number of samples
used in rasterization; however, if
[VkPhysicalDeviceFeatures](/man/VkPhysicalDeviceFeatures)::`variableMultisampleRate` is
`VK_FALSE`, then all pipelines to be bound with the subpass :normative{type="must"} have
the same value for
[VkPipelineMultisampleStateCreateInfo](/man/VkPipelineMultisampleStateCreateInfo)::`rasterizationSamples`.
In all such cases, `rasterizationSamples` :normative{type="must"} be a bit value that is
set in
[VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits)::`framebufferNoAttachmentsSampleCounts`.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkFramebufferCreateInfo-attachmentCount-00876"}
`attachmentCount` :normative{type="must"} be equal to the attachment count specified
in `renderPass`
::

::validity-field{name="VUID-VkFramebufferCreateInfo-flags-02778"}

If `flags` does not include
`VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT` and `attachmentCount` is
not `0`, `pAttachments` :normative{type="must"} be a valid pointer to an array of
`attachmentCount` valid [VkImageView](/man/VkImageView) handles
::

::validity-field{name="VUID-VkFramebufferCreateInfo-pAttachments-00877"}

If `flags` does not include
`VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of
`pAttachments` that is used as a color attachment or resolve
attachment by `renderPass` :normative{type="must"} have been created with a
`usage` value including `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`
::

::validity-field{name="VUID-VkFramebufferCreateInfo-pAttachments-02633"}

If `flags` does not include
`VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of
`pAttachments` that is used as a depth/stencil attachment by
`renderPass` :normative{type="must"} have been created with a `usage` value
including `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`
::

::validity-field{name="VUID-VkFramebufferCreateInfo-pAttachments-00879"}

If `renderpass` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `flags` does not
include `VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of
`pAttachments` that is used as an input attachment by
`renderPass` :normative{type="must"} have been created with a `usage` value
including `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`
::

::validity-field{name="VUID-VkFramebufferCreateInfo-pAttachments-00880"}

If `flags` does not include
`VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of
`pAttachments` :normative{type="must"} have been created with a [VkFormat](/man/VkFormat) value
that matches the [VkFormat](/man/VkFormat) specified by the corresponding
`VkAttachmentDescription` in `renderPass`
::

::validity-field{name="VUID-VkFramebufferCreateInfo-pAttachments-00881"}

If `flags` does not include
`VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of
`pAttachments` :normative{type="must"} have been created with a `samples` value
that matches the `samples` value specified by the corresponding
`VkAttachmentDescription` in `renderPass`
::

::validity-field{name="VUID-VkFramebufferCreateInfo-flags-04533"}

If `flags` does not include
`VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of
`pAttachments` that is used as an input, color, resolve, or
depth/stencil attachment by `renderPass` :normative{type="must"} have been created
with a [VkImageCreateInfo](/man/VkImageCreateInfo)::`extent.width` greater than or equal
to `width`
::

::validity-field{name="VUID-VkFramebufferCreateInfo-flags-04534"}

If `flags` does not include
`VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of
`pAttachments` that is used as an input, color, resolve, or
depth/stencil attachment by `renderPass` :normative{type="must"} have been created
with a [VkImageCreateInfo](/man/VkImageCreateInfo)::`extent.height` greater than or
equal to `height`
::

::validity-field{name="VUID-VkFramebufferCreateInfo-flags-04535"}

If `flags` does not include
`VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of
`pAttachments` that is used as an input, color, resolve, or
depth/stencil attachment by `renderPass` :normative{type="must"} have been created
with a [VkImageViewCreateInfo](/man/VkImageViewCreateInfo)::`subresourceRange.layerCount`
greater than or equal to `layers`
::

::validity-field{name="VUID-VkFramebufferCreateInfo-pAttachments-00883"}

If `flags` does not include
`VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of
`pAttachments` :normative{type="must"} only specify a single mip level
::

::validity-field{name="VUID-VkFramebufferCreateInfo-pAttachments-00884"}

If `flags` does not include
`VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of
`pAttachments` :normative{type="must"} have been created with the identity swizzle
::

::validity-field{name="VUID-VkFramebufferCreateInfo-width-00885"}
`width` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-VkFramebufferCreateInfo-width-00886"}
`width` :normative{type="must"} be less than or equal to `maxFramebufferWidth`
::

::validity-field{name="VUID-VkFramebufferCreateInfo-height-00887"}
`height` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-VkFramebufferCreateInfo-height-00888"}
`height` :normative{type="must"} be less than or equal to
`maxFramebufferHeight`
::

::validity-field{name="VUID-VkFramebufferCreateInfo-layers-00889"}
`layers` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-VkFramebufferCreateInfo-layers-00890"}
`layers` :normative{type="must"} be less than or equal to
`maxFramebufferLayers`
::

::validity-field{name="VUID-VkFramebufferCreateInfo-flags-04113"}

If `flags` does not include
`VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT`, each element of
`pAttachments` :normative{type="must"} have been created with
[VkImageViewCreateInfo](/man/VkImageViewCreateInfo)::`viewType` not equal to
`VK_IMAGE_VIEW_TYPE_3D`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkFramebufferCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO`
::

::validity-field{name="VUID-VkFramebufferCreateInfo-pNext-pNext"}
 `pNext` :normative{type="must"} be `NULL` or a pointer to a valid instance of [VkFramebufferAttachmentsCreateInfo](/man/VkFramebufferAttachmentsCreateInfo)
::

::validity-field{name="VUID-VkFramebufferCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkFramebufferCreateInfo-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkFramebufferCreateFlagBits](/man/VkFramebufferCreateFlagBits) values
::

::validity-field{name="VUID-VkFramebufferCreateInfo-renderPass-parameter"}
 `renderPass` :normative{type="must"} be a valid [VkRenderPass](/man/VkRenderPass) handle
::

::validity-field{name="VUID-VkFramebufferCreateInfo-commonparent"}
 Both of `renderPass`, and the elements of `pAttachments` that are valid handles of non-ignored parameters :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::


Bits which :normative{type="can"} be set in [VkFramebufferCreateInfo](/man/VkFramebufferCreateInfo)::`flags`,
specifying options for framebuffers, are:

[{generated}/api/enums/VkFramebufferCreateFlagBits.adoc]({generated}/api/enums/VkFramebufferCreateFlagBits.adoc)


::note
All bits for this type are defined by extensions, and none of those
extensions are enabled in this build of the specification.
::


[{generated}/api/flags/VkFramebufferCreateFlags.adoc]({generated}/api/flags/VkFramebufferCreateFlags.adoc)

`VkFramebufferCreateFlags` is a bitmask type for setting a mask of zero
or more [VkFramebufferCreateFlagBits](/man/VkFramebufferCreateFlagBits).

To destroy a framebuffer, call:

[{generated}/api/protos/vkDestroyFramebuffer.adoc]({generated}/api/protos/vkDestroyFramebuffer.adoc)

- `device` is the logical device that destroys the framebuffer.

- `framebuffer` is the handle of the framebuffer to destroy.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkDestroyFramebuffer-framebuffer-00892"}

All submitted commands that refer to `framebuffer` :normative{type="must"} have
completed execution
::

::validity-field{name="VUID-vkDestroyFramebuffer-framebuffer-00893"}

If `VkAllocationCallbacks` were provided when `framebuffer` was
created, a compatible set of callbacks :normative{type="must"} be provided here
::

::validity-field{name="VUID-vkDestroyFramebuffer-framebuffer-00894"}

If no `VkAllocationCallbacks` were provided when `framebuffer`
was created, `pAllocator` :normative{type="must"} be `NULL`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkDestroyFramebuffer-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkDestroyFramebuffer-framebuffer-parameter"}
 If `framebuffer` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `framebuffer` :normative{type="must"} be a valid [VkFramebuffer](/man/VkFramebuffer) handle
::

::validity-field{name="VUID-vkDestroyFramebuffer-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkDestroyFramebuffer-framebuffer-parent"}
 If `framebuffer` is a valid handle, it :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::








## Render Pass Load Operations

Render pass load operations define the initial values of an attachment
during a render pass instance.

Load operations for attachments with a depth/stencil format execute in the
`VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT` pipeline stage.
Load operations for attachments with a color format execute in the
`VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
The load operation for each sample in an attachment happens-before any
recorded command which accesses the sample in that render pass instance via
that attachment or an alias.


::note
Because load operations always happen first, external synchronization with
attachment access only needs to synchronize the load operations with
previous commands; not the operations within the render pass instance.
::


Load operations only update values within the defined render area for the
render pass instance.
However, any writes performed by a load operation (as defined by its access
masks) to a given attachment :normative{type="may"} read and write back any memory locations
within the image subresource bound for that attachment.
For depth/stencil images, writes to one aspect :normative{type="may"} also result in
read-modify-write operations for the other aspect.


::note
As entire subresources could be accessed by load operations, applications
cannot safely access values outside of the render area during a render pass
instance when a load operation that modifies values is used.
::


Load operations that :normative{type="can"} be used for a render pass are:

[{generated}/api/enums/VkAttachmentLoadOp.adoc]({generated}/api/enums/VkAttachmentLoadOp.adoc)

- `VK_ATTACHMENT_LOAD_OP_LOAD` specifies that the previous contents of
  the image within the render area will be preserved as the initial
  values.
  For attachments with a depth/stencil format, this uses the access type
  `VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT`.
  For attachments with a color format, this uses the access type
  `VK_ACCESS_COLOR_ATTACHMENT_READ_BIT`.

- `VK_ATTACHMENT_LOAD_OP_CLEAR` specifies that the contents within the
  render area will be cleared to a uniform value, which is specified when
  a render pass instance is begun.
  For attachments with a depth/stencil format, this uses the access type
  `VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT`.
  For attachments with a color format, this uses the access type
  `VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT`.

- `VK_ATTACHMENT_LOAD_OP_DONT_CARE` specifies that the previous
  contents within the area need not be preserved; the contents of the
  attachment will be undefined: inside the render area.
  For attachments with a depth/stencil format, this uses the access type
  `VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT`.
  For attachments with a color format, this uses the access type
  `VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT`.

During a render pass instance, input and color attachments with color
formats that have a component size of 8, 16, or 32 bits :normative{type="must"} be represented
in the attachment’s format throughout the instance.
Attachments with other floating- or fixed-point color formats, or with depth
components :normative{type="may"} be represented in a format with a precision higher than the
attachment format, but :normative{type="must"} be represented with the same range.
When such a component is loaded via the `loadOp`, it will be converted
into an implementation-dependent format used by the render pass.
Such components :normative{type="must"} be converted from the render pass format, to the
format of the attachment, before they are resolved or stored at the end of a
render pass instance via `storeOp`.
Conversions occur as described in Numeric
Representation and Computation and Fixed-Point
Data Conversions.





## Render Pass Store Operations

Render pass store operations define how values written to an attachment
during a render pass instance are stored to memory.

Store operations for attachments with a depth/stencil format execute in the
`VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT` pipeline stage.
Store operations for attachments with a color format execute in the
`VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
The store operation for each sample in an attachment happens-after any
recorded command which accesses the sample via that attachment or an alias.


::note
Because store operations always happen after other accesses in a render pass
instance, external synchronization with attachment access in an earlier
render pass only needs to synchronize with the store operations; not the
operations within the render pass instance.
::


Store operations only update values within the defined render area for the
render pass instance.
However, any writes performed by a store operation (as defined by its access
masks) to a given attachment :normative{type="may"} read and write back any memory locations
within the image subresource bound for that attachment.
For depth/stencil images writes to one aspect :normative{type="may"} also result in
read-modify-write operations for the other aspect.


::note
As entire subresources could be accessed by store operations, applications
cannot safely access values outside of the render area via aliased resources
during a render pass instance when a store operation that modifies values is
used.
::


Possible values of [VkAttachmentDescription](/man/VkAttachmentDescription)::`storeOp` and
`stencilStoreOp`, specifying how the contents of the attachment are
treated, are:

[{generated}/api/enums/VkAttachmentStoreOp.adoc]({generated}/api/enums/VkAttachmentStoreOp.adoc)

- `VK_ATTACHMENT_STORE_OP_STORE` specifies the contents generated
  during the render pass and within the render area are written to memory.
  For attachments with a depth/stencil format, this uses the access type
  `VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT`.
  For attachments with a color format, this uses the access type
  `VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT`.

- `VK_ATTACHMENT_STORE_OP_DONT_CARE` specifies the contents within the
  render area are not needed after rendering, and :normative{type="may"} be discarded; the
  contents of the attachment will be undefined: inside the render area.
  For attachments with a depth/stencil format, this uses the access type
  `VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT`.
  For attachments with a color format, this uses the access type
  `VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT`.


::note
`VK_ATTACHMENT_STORE_OP_DONT_CARE` :normative{type="can"} cause contents generated during
previous render passes to be discarded before reaching memory, even if no
write to the attachment occurs during the current render pass.
::






## Render Pass Multisample Resolve Operations

Render pass multisample resolve operations combine sample values from a
single pixel in a multisample attachment and store the result to the
corresponding pixel in a single sample attachment.

Multisample resolve operations for attachments execute in the
`VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` pipeline stage.
A final resolve operation for all pixels in the render area happens-after
any recorded command which writes a pixel via the multisample attachment to
be resolved or an explicit alias of it in the subpass that it is specified.
Any single sample attachment specified for use in a multisample resolve
operation :normative{type="may"} have its contents modified at any point once rendering begins
for the render pass instance.
Reads from the multisample attachment can be synchronized with
`VK_ACCESS_COLOR_ATTACHMENT_READ_BIT`.
Access to the single sample attachment can be synchronized with
`VK_ACCESS_COLOR_ATTACHMENT_READ_BIT` and
`VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT`.

When using render pass objects, a subpass dependency specified with the
above pipeline stages and access flags will ensure synchronization with
multisample resolve operations for any attachments that were last accessed
by that subpass.
This allows later subpasses to read resolved values as input attachments.

Resolve operations only update values within the defined render area for the
render pass instance.
However, any writes performed by a resolve operation (as defined by its
access masks) to a given attachment :normative{type="may"} read and write back any memory
locations within the image subresource bound for that attachment.
For depth/stencil images writes to one aspect :normative{type="may"} also result in
read-modify-write operations for the other aspect.


::note
As entire subresources could be accessed by multisample resolve operations,
applications cannot safely access values outside of the render area via
aliased resources during a render pass instance when a multisample resolve
operation is performed.
::


The average value of samples for a given pixel in the multisample attachment
is taken and written to the single sample attachment.





## Render Pass Commands

An application records the commands for a render pass instance one subpass
at a time, by beginning a render pass instance, iterating over the subpasses
to record commands for that subpass, and then ending the render pass
instance.

To begin a render pass instance, call:

[{generated}/api/protos/vkCmdBeginRenderPass.adoc]({generated}/api/protos/vkCmdBeginRenderPass.adoc)

- `commandBuffer` is the command buffer in which to record the
  command.

- `pRenderPassBegin` is a pointer to a [VkRenderPassBeginInfo](/man/VkRenderPassBeginInfo)
  structure specifying the render pass to begin an instance of, and the
  framebuffer the instance uses.

- `contents` is a [VkSubpassContents](/man/VkSubpassContents) value specifying how the
  commands in the first subpass will be provided.

After beginning a render pass instance, the command buffer is ready to
record the commands for the first subpass of that render pass.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdBeginRenderPass-initialLayout-00895"}

If any of the `initialLayout` or `finalLayout` member of the
`VkAttachmentDescription` structures or the `layout` member of
the `VkAttachmentReference` structures specified when creating the
render pass specified in the `renderPass` member of
`pRenderPassBegin` is `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL`
then the corresponding attachment image view of the framebuffer
specified in the `framebuffer` member of `pRenderPassBegin`
:normative{type="must"} have been created with a `usage` value including
`VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`
::

::validity-field{name="VUID-vkCmdBeginRenderPass-initialLayout-01758"}

If any of the `initialLayout` or `finalLayout` member of the
`VkAttachmentDescription` structures or the `layout` member of
the `VkAttachmentReference` structures specified when creating the
render pass specified in the `renderPass` member of
`pRenderPassBegin` is
`VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL`, or
`VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL` then the
corresponding attachment image view of the framebuffer specified in the
`framebuffer` member of `pRenderPassBegin` :normative{type="must"} have been
created with a `usage` value including
`VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`
::

::validity-field{name="VUID-vkCmdBeginRenderPass-initialLayout-00897"}

If any of the `initialLayout` or `finalLayout` member of the
`VkAttachmentDescription` structures or the `layout` member of
the `VkAttachmentReference` structures specified when creating the
render pass specified in the `renderPass` member of
`pRenderPassBegin` is `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`
then the corresponding attachment image view of the framebuffer
specified in the `framebuffer` member of `pRenderPassBegin`
:normative{type="must"} have been created with a `usage` value including
`VK_IMAGE_USAGE_SAMPLED_BIT` or
`VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`
::

::validity-field{name="VUID-vkCmdBeginRenderPass-initialLayout-00898"}

If any of the `initialLayout` or `finalLayout` member of the
`VkAttachmentDescription` structures or the `layout` member of
the `VkAttachmentReference` structures specified when creating the
render pass specified in the `renderPass` member of
`pRenderPassBegin` is `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL`
then the corresponding attachment image view of the framebuffer
specified in the `framebuffer` member of `pRenderPassBegin`
:normative{type="must"} have been created with a `usage` value including
`VK_IMAGE_USAGE_TRANSFER_SRC_BIT`
::

::validity-field{name="VUID-vkCmdBeginRenderPass-initialLayout-00899"}

If any of the `initialLayout` or `finalLayout` member of the
`VkAttachmentDescription` structures or the `layout` member of
the `VkAttachmentReference` structures specified when creating the
render pass specified in the `renderPass` member of
`pRenderPassBegin` is `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`
then the corresponding attachment image view of the framebuffer
specified in the `framebuffer` member of `pRenderPassBegin`
:normative{type="must"} have been created with a `usage` value including
`VK_IMAGE_USAGE_TRANSFER_DST_BIT`
::

::validity-field{name="VUID-vkCmdBeginRenderPass-initialLayout-00900"}

If the `initialLayout` member of any of the
`VkAttachmentDescription` structures specified when creating the
render pass specified in the `renderPass` member of
`pRenderPassBegin` is not `VK_IMAGE_LAYOUT_UNDEFINED`, then each
such `initialLayout` :normative{type="must"} be equal to the current layout of the
corresponding attachment image subresource of the framebuffer specified
in the `framebuffer` member of `pRenderPassBegin`
::

::validity-field{name="VUID-vkCmdBeginRenderPass-srcStageMask-06451"}

The `srcStageMask` members of any element of the `pDependencies`
member of [VkRenderPassCreateInfo](/man/VkRenderPassCreateInfo) used to create `renderPass`
:normative{type="must"} be supported by the capabilities of the queue family identified by
the `queueFamilyIndex` member of the [VkCommandPoolCreateInfo](/man/VkCommandPoolCreateInfo)
used to create the command pool which `commandBuffer` was allocated
from
::

::validity-field{name="VUID-vkCmdBeginRenderPass-dstStageMask-06452"}

The `dstStageMask` members of any element of the `pDependencies`
member of [VkRenderPassCreateInfo](/man/VkRenderPassCreateInfo) used to create `renderPass`
:normative{type="must"} be supported by the capabilities of the queue family identified by
the `queueFamilyIndex` member of the [VkCommandPoolCreateInfo](/man/VkCommandPoolCreateInfo)
used to create the command pool which `commandBuffer` was allocated
from
::

::validity-field{name="VUID-vkCmdBeginRenderPass-framebuffer-02532"}

For any attachment in `framebuffer` that is used by `renderPass`
and is bound to memory locations that are also bound to another
attachment used by `renderPass`, and if at least one of those uses
causes either attachment to be written to, both attachments :normative{type="must"} have
had the `VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT` set
::

::validity-field{name="VUID-vkCmdBeginRenderPass-framebuffer-09045"}

If any attachments specified in `framebuffer` are used by
`renderPass` and are bound to overlapping memory locations, there
:normative{type="must"} be only one that is used as a color attachment, depth/stencil, or
resolve attachment in any subpass
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdBeginRenderPass-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdBeginRenderPass-pRenderPassBegin-parameter"}
 `pRenderPassBegin` :normative{type="must"} be a valid pointer to a valid [VkRenderPassBeginInfo](/man/VkRenderPassBeginInfo) structure
::

::validity-field{name="VUID-vkCmdBeginRenderPass-contents-parameter"}
 `contents` :normative{type="must"} be a valid [VkSubpassContents](/man/VkSubpassContents) value
::

::validity-field{name="VUID-vkCmdBeginRenderPass-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdBeginRenderPass-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics operations
::

::validity-field{name="VUID-vkCmdBeginRenderPass-renderpass"}
 This command :normative{type="must"} only be called outside of a render pass instance
::

::validity-field{name="VUID-vkCmdBeginRenderPass-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdBeginRenderPass-bufferlevel"}
 `commandBuffer` :normative{type="must"} be a primary `VkCommandBuffer`
::

::






The `VkRenderPassBeginInfo` structure is defined as:

[{generated}/api/structs/VkRenderPassBeginInfo.adoc]({generated}/api/structs/VkRenderPassBeginInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `renderPass` is the render pass to begin an instance of.

- `framebuffer` is the framebuffer containing the attachments that are
  used with the render pass.

- `renderArea` is the render area that is affected by the render pass
  instance, and is described in more detail below.

- `clearValueCount` is the number of elements in `pClearValues`.

- `pClearValues` is a pointer to an array of `clearValueCount`

  [VkClearValue](/man/VkClearValue) structures containing clear values for each
  attachment, if the attachment uses a `loadOp` value of
  `VK_ATTACHMENT_LOAD_OP_CLEAR` or if the attachment has a
  depth/stencil format and uses a `stencilLoadOp` value of
  `VK_ATTACHMENT_LOAD_OP_CLEAR`.
  The array is indexed by attachment number.
  Only elements corresponding to cleared attachments are used.
  Other elements of `pClearValues` are ignored.

`renderArea` is the render area that is affected by the render pass
instance.
The effects of attachment load, store and multisample resolve operations are
restricted to the pixels whose x and y coordinates fall within the render
area on all attachments.
The render area extends to all layers of `framebuffer`.
The application :normative{type="must"} ensure (using scissor if necessary) that all rendering
is contained within the render area.
The render area :normative{type="must"} be contained within the framebuffer dimensions.


::note
There :normative{type="may"} be a performance cost for using a render area smaller than the
framebuffer, unless it matches the render area granularity for the render
pass.
::



::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkRenderPassBeginInfo-clearValueCount-00902"}
`clearValueCount` :normative{type="must"} be greater than the largest attachment index
in `renderPass` specifying a `loadOp` (or `stencilLoadOp`,
if the attachment has a depth/stencil format) of
`VK_ATTACHMENT_LOAD_OP_CLEAR`
::

::validity-field{name="VUID-VkRenderPassBeginInfo-clearValueCount-04962"}

If `clearValueCount` is not `0`, `pClearValues` :normative{type="must"} be a valid
pointer to an array of `clearValueCount` [VkClearValue](/man/VkClearValue) unions
::

::validity-field{name="VUID-VkRenderPassBeginInfo-renderPass-00904"}
`renderPass` :normative{type="must"} be compatible with
the `renderPass` member of the [VkFramebufferCreateInfo](/man/VkFramebufferCreateInfo)
structure specified when creating `framebuffer`
::

::validity-field{name="VUID-VkRenderPassBeginInfo-None-08996"}
`renderArea.extent.width` :normative{type="must"} be greater than 0
::

::validity-field{name="VUID-VkRenderPassBeginInfo-None-08997"}
`renderArea.extent.height` :normative{type="must"} be greater than 0
::

::validity-field{name="VUID-VkRenderPassBeginInfo-pNext-02850"}
`renderArea.offset.x` :normative{type="must"} be greater than or equal to 0
::

::validity-field{name="VUID-VkRenderPassBeginInfo-pNext-02851"}
`renderArea.offset.y` :normative{type="must"} be greater than or equal to 0
::

::validity-field{name="VUID-VkRenderPassBeginInfo-pNext-02852"}
`renderArea.offset.x` +  `renderArea.extent.width`
:normative{type="must"} be less than or equal to
[VkFramebufferCreateInfo](/man/VkFramebufferCreateInfo)::`width` the `framebuffer` was
created with
::

::validity-field{name="VUID-VkRenderPassBeginInfo-pNext-02853"}
`renderArea.offset.y` +  `renderArea.extent.height`
:normative{type="must"} be less than or equal to
[VkFramebufferCreateInfo](/man/VkFramebufferCreateInfo)::`height` the `framebuffer` was
created with
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkRenderPassBeginInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO`
::

::validity-field{name="VUID-VkRenderPassBeginInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkDeviceGroupRenderPassBeginInfo](/man/VkDeviceGroupRenderPassBeginInfo), [VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM](/man/VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM), [VkRenderPassAttachmentBeginInfo](/man/VkRenderPassAttachmentBeginInfo), [VkRenderPassSampleLocationsBeginInfoEXT](/man/VkRenderPassSampleLocationsBeginInfoEXT), or [VkRenderPassTransformBeginInfoQCOM](/man/VkRenderPassTransformBeginInfoQCOM)
::

::validity-field{name="VUID-VkRenderPassBeginInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkRenderPassBeginInfo-renderPass-parameter"}
 `renderPass` :normative{type="must"} be a valid [VkRenderPass](/man/VkRenderPass) handle
::

::validity-field{name="VUID-VkRenderPassBeginInfo-framebuffer-parameter"}
 `framebuffer` :normative{type="must"} be a valid [VkFramebuffer](/man/VkFramebuffer) handle
::

::validity-field{name="VUID-VkRenderPassBeginInfo-commonparent"}
 Both of `framebuffer`, and `renderPass` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::


Possible values of [vkCmdBeginRenderPass](/man/vkCmdBeginRenderPass)::`contents`, specifying
how the commands in the first subpass will be provided, are:

[{generated}/api/enums/VkSubpassContents.adoc]({generated}/api/enums/VkSubpassContents.adoc)

- `VK_SUBPASS_CONTENTS_INLINE` specifies that the contents of the
  subpass will be recorded inline in the primary command buffer, and
  secondary command buffers :normative{type="must"} not be executed within the subpass.

- `VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS` specifies that the
  contents are recorded in secondary command buffers that will be called
  from the primary command buffer, and [vkCmdExecuteCommands](/man/vkCmdExecuteCommands) is the
  only valid command in the command buffer until [vkCmdNextSubpass](/man/vkCmdNextSubpass) or
  [vkCmdEndRenderPass](/man/vkCmdEndRenderPass).

To query the render area granularity, call:

[{generated}/api/protos/vkGetRenderAreaGranularity.adoc]({generated}/api/protos/vkGetRenderAreaGranularity.adoc)

- `device` is the logical device that owns the render pass.

- `renderPass` is a handle to a render pass.

- `pGranularity` is a pointer to a [VkExtent2D](/man/VkExtent2D) structure in which
  the granularity is returned.

The conditions leading to an optimal `renderArea` are:

- the `offset.x` member in `renderArea` is a multiple of the
  `width` member of the returned [VkExtent2D](/man/VkExtent2D) (the horizontal
  granularity).

- the `offset.y` member in `renderArea` is a multiple of the
  `height` member of the returned [VkExtent2D](/man/VkExtent2D) (the vertical
  granularity).

- either the `extent.width` member in `renderArea` is a multiple
  of the horizontal granularity or `offset.x`+`extent.width` is
  equal to the `width` of the `framebuffer` in the
  [VkRenderPassBeginInfo](/man/VkRenderPassBeginInfo).

- either the `extent.height` member in `renderArea` is a multiple
  of the vertical granularity or `offset.y`+`extent.height` is
  equal to the `height` of the `framebuffer` in the
  [VkRenderPassBeginInfo](/man/VkRenderPassBeginInfo).

Subpass dependencies are not affected by the render area, and apply to the
entire image subresources attached to the framebuffer as specified in the
description of automatic layout
transitions.
Similarly, pipeline barriers are valid even if their effect extends outside
the render area.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkGetRenderAreaGranularity-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkGetRenderAreaGranularity-renderPass-parameter"}
 `renderPass` :normative{type="must"} be a valid [VkRenderPass](/man/VkRenderPass) handle
::

::validity-field{name="VUID-vkGetRenderAreaGranularity-pGranularity-parameter"}
 `pGranularity` :normative{type="must"} be a valid pointer to a [VkExtent2D](/man/VkExtent2D) structure
::

::validity-field{name="VUID-vkGetRenderAreaGranularity-renderPass-parent"}
 `renderPass` :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::


To transition to the next subpass in the render pass instance after
recording the commands for a subpass, call:

[{generated}/api/protos/vkCmdNextSubpass.adoc]({generated}/api/protos/vkCmdNextSubpass.adoc)

- `commandBuffer` is the command buffer in which to record the
  command.

- `contents` specifies how the commands in the next subpass will be
  provided, in the same fashion as the corresponding parameter of
  [vkCmdBeginRenderPass](/man/vkCmdBeginRenderPass).

The subpass index for a render pass begins at zero when
`vkCmdBeginRenderPass` is recorded, and increments each time
`vkCmdNextSubpass` is recorded.

After transitioning to the next subpass, the application :normative{type="can"} record the
commands for that subpass.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdNextSubpass-None-00909"}

The current subpass index :normative{type="must"} be less than the number of subpasses in
the render pass minus one
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdNextSubpass-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdNextSubpass-contents-parameter"}
 `contents` :normative{type="must"} be a valid [VkSubpassContents](/man/VkSubpassContents) value
::

::validity-field{name="VUID-vkCmdNextSubpass-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdNextSubpass-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics operations
::

::validity-field{name="VUID-vkCmdNextSubpass-renderpass"}
 This command :normative{type="must"} only be called inside of a render pass instance
::

::validity-field{name="VUID-vkCmdNextSubpass-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdNextSubpass-bufferlevel"}
 `commandBuffer` :normative{type="must"} be a primary `VkCommandBuffer`
::

::






To record a command to end a render pass instance after recording the
commands for the last subpass, call:

[{generated}/api/protos/vkCmdEndRenderPass.adoc]({generated}/api/protos/vkCmdEndRenderPass.adoc)

- `commandBuffer` is the command buffer in which to end the current
  render pass instance.

Ending a render pass instance performs any multisample resolve operations on
the final subpass.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdEndRenderPass-None-00910"}

The current subpass index :normative{type="must"} be equal to the number of subpasses in
the render pass minus one
::

::validity-field{name="VUID-vkCmdEndRenderPass-None-07004"}

If `vkCmdBeginQuery`* was called within a subpass of the render
pass, the corresponding `vkCmdEndQuery`* :normative{type="must"} have been called
subsequently within the same subpass
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdEndRenderPass-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdEndRenderPass-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdEndRenderPass-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics operations
::

::validity-field{name="VUID-vkCmdEndRenderPass-renderpass"}
 This command :normative{type="must"} only be called inside of a render pass instance
::

::validity-field{name="VUID-vkCmdEndRenderPass-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdEndRenderPass-bufferlevel"}
 `commandBuffer` :normative{type="must"} be a primary `VkCommandBuffer`
::

::










## Common Render Pass Data Races (Informative)

Due to the complexity of how rendering is performed, there are several ways
an application can accidentally introduce a data race, usually by doing
something that may seem benign but actually cannot be supported.
This section indicates a number of the more common cases as guidelines to
help avoid them.



### Sampling From a Read-only Attachment

Vulkan includes read-only layouts for depth/stencil images, that allow the
images to be both read during a render pass for the purposes of
depth/stencil tests, and read as a non-attachment.

However, because `VK_ATTACHMENT_STORE_OP_STORE` and
`VK_ATTACHMENT_STORE_OP_DONT_CARE` may perform write operations, even if
no recorded command writes to an attachment, reading from an image while
also using it as an attachment with these store operations can result in a
data race.
If the reads from the non-attachment are performed in a fragment shader
where the accessed samples match those covered by the fragment shader, no
data race will occur as store operations are guaranteed to operate after
fragment shader execution for the set of samples the fragment covers.
Notably, input attachments can also be used for this case.
Reading other samples or in any other shader stage can result in unexpected
behavior due to the potential for a data race, and validation errors should
be generated for doing so.
In practice, many applications have shipped reading samples outside of the
covered fragment without any observable issue, but there is no guarantee
that this will always work, and it is not advisable to rely on this in new
or re-worked code bases.





### Non-overlapping Access Between Resources

When relying on non-overlapping accesses between attachments and other
resources, it is important to note that load
and store operations have fairly wide
alignment requirements - potentially affecting entire subresources and
adjacent depth/stencil aspects.
This makes it invalid to access a non-attachment subresource that is
simultaneously being used as an attachment where either access performs a
write operation.





### Depth/Stencil and Input Attachments

When rendering to only the depth OR stencil aspect of an image, an input
attachment accessing the other aspect will
always result in a data race.





### Synchronization Options

There are several synchronization options available to synchronize between
accesses to resources within a render pass.
Some of the options are outlined below:

- A [VkSubpassDependency](/man/VkSubpassDependency) in a render pass object can synchronize
  attachment writes and multisample
  resolve operations from a prior subpass for subsequent input
  attachment reads.

- A [vkCmdPipelineBarrier](/man/vkCmdPipelineBarrier) inside a subpass can synchronize prior
  attachment writes in the subpass with subsequent input attachment reads.









# Shaders

A shader specifies programmable operations that execute for each vertex,
control point, tessellated vertex, primitive, fragment, or workgroup in the
corresponding stage(s) of the graphics and compute pipelines.

Graphics pipelines include vertex shader execution as a result of
primitive assembly, followed, if enabled, by tessellation
control and evaluation shaders operating on patches,
geometry shaders, if enabled, operating on primitives, and fragment shaders,
if present, operating on fragments generated by Rasterization.
In this specification, vertex, tessellation control, tessellation evaluation
and geometry shaders are collectively referred to as
pre-rasterization shader
stages and occur in the logical pipeline before rasterization.
The fragment shader occurs logically after rasterization.

Only the compute shader stage is included in a compute pipeline.
Compute shaders operate on compute invocations in a workgroup.

Shaders :normative{type="can"} read from input variables, and read from and write to output
variables.
Input and output variables :normative{type="can"} be used to transfer data between shader
stages, or to allow the shader to interact with values that exist in the
execution environment.
Similarly, the execution environment provides constants describing
capabilities.

Shader variables are associated with execution environment-provided inputs
and outputs using *built-in* decorations in the shader.
The available decorations for each stage are documented in the following
subsections.



## Shader Modules

*Shader modules* contain *shader code* and one or more entry points.
Shaders are selected from a shader module by specifying an entry point as
part of pipeline creation.
The stages of a pipeline :normative{type="can"} use shaders that come from different modules.
The shader code defining a shader module :normative{type="must"} be in the SPIR-V format, as
described by the Vulkan Environment for SPIR-V appendix.

Shader modules are represented by `VkShaderModule` handles:

[{generated}/api/handles/VkShaderModule.adoc]({generated}/api/handles/VkShaderModule.adoc)

To create a shader module, call:

[{generated}/api/protos/vkCreateShaderModule.adoc]({generated}/api/protos/vkCreateShaderModule.adoc)

- `device` is the logical device that creates the shader module.

- `pCreateInfo` is a pointer to a [VkShaderModuleCreateInfo](/man/VkShaderModuleCreateInfo)
  structure.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

- `pShaderModule` is a pointer to a [VkShaderModule](/man/VkShaderModule) handle in
  which the resulting shader module object is returned.

Once a shader module has been created, any entry points it contains :normative{type="can"} be
used in pipeline shader stages as described in Compute
Pipelines and Graphics Pipelines.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCreateShaderModule-pCreateInfo-06904"}

If `pCreateInfo` is not `NULL`, `pCreateInfo→pNext` :normative{type="must"} be
`NULL`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCreateShaderModule-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkCreateShaderModule-pCreateInfo-parameter"}
 `pCreateInfo` :normative{type="must"} be a valid pointer to a valid [VkShaderModuleCreateInfo](/man/VkShaderModuleCreateInfo) structure
::

::validity-field{name="VUID-vkCreateShaderModule-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkCreateShaderModule-pShaderModule-parameter"}
 `pShaderModule` :normative{type="must"} be a valid pointer to a [VkShaderModule](/man/VkShaderModule) handle
::

::




The `VkShaderModuleCreateInfo` structure is defined as:

[{generated}/api/structs/VkShaderModuleCreateInfo.adoc]({generated}/api/structs/VkShaderModuleCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is reserved for future use.

- `codeSize` is the size, in bytes, of the code pointed to by
  `pCode`.

- `pCode` is a pointer to code that is used to create the shader
  module.
  The type and format of the code is determined from the content of the
  memory addressed by `pCode`.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkShaderModuleCreateInfo-codeSize-08735"}

 `codeSize` :normative{type="must"} be a multiple of 4
::

::validity-field{name="VUID-VkShaderModuleCreateInfo-pCode-08736"}

 `pCode` :normative{type="must"} point to valid SPIR-V code,
formatted and packed as described by the Khronos SPIR-V
Specification
::

::validity-field{name="VUID-VkShaderModuleCreateInfo-pCode-08737"}

 `pCode` :normative{type="must"} adhere to the validation rules
described by the Validation Rules within a
Module section of the SPIR-V Environment
appendix
::

::validity-field{name="VUID-VkShaderModuleCreateInfo-pCode-08738"}

 `pCode` :normative{type="must"} declare the `Shader` capability
for SPIR-V code
::

::validity-field{name="VUID-VkShaderModuleCreateInfo-pCode-08739"}

 `pCode` :normative{type="must"} not declare any capability that is
not supported by the API, as described by the
Capabilities section of the
SPIR-V Environment appendix
::

::validity-field{name="VUID-VkShaderModuleCreateInfo-pCode-08740"}

 and `pCode` declares any of the capabilities
listed in the SPIR-V Environment
appendix, one of the corresponding requirements :normative{type="must"} be satisfied
::

::validity-field{name="VUID-VkShaderModuleCreateInfo-pCode-08741"}

 `pCode` :normative{type="must"} not declare any SPIR-V extension
that is not supported by the API, as described by the
Extension section of the
SPIR-V Environment appendix
::

::validity-field{name="VUID-VkShaderModuleCreateInfo-pCode-08742"}

 and `pCode` declares any of the SPIR-V extensions
listed in the SPIR-V Environment
appendix, one of the corresponding requirements :normative{type="must"} be satisfied
::

::validity-field{name="VUID-VkShaderModuleCreateInfo-codeSize-01085"}
`codeSize` :normative{type="must"} be greater than 0
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkShaderModuleCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO`
::

::validity-field{name="VUID-VkShaderModuleCreateInfo-flags-zerobitmask"}
 `flags` :normative{type="must"} be `0`
::

::validity-field{name="VUID-VkShaderModuleCreateInfo-pCode-parameter"}
 `pCode` :normative{type="must"} be a valid pointer to an array of  `uint32_t` values
::

::


[{generated}/api/flags/VkShaderModuleCreateFlags.adoc]({generated}/api/flags/VkShaderModuleCreateFlags.adoc)

`VkShaderModuleCreateFlags` is a bitmask type for setting a mask, but is
currently reserved for future use.

To destroy a shader module, call:

[{generated}/api/protos/vkDestroyShaderModule.adoc]({generated}/api/protos/vkDestroyShaderModule.adoc)

- `device` is the logical device that destroys the shader module.

- `shaderModule` is the handle of the shader module to destroy.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

A shader module :normative{type="can"} be destroyed while pipelines created using its shaders
are still in use.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkDestroyShaderModule-shaderModule-01092"}

If `VkAllocationCallbacks` were provided when `shaderModule` was
created, a compatible set of callbacks :normative{type="must"} be provided here
::

::validity-field{name="VUID-vkDestroyShaderModule-shaderModule-01093"}

If no `VkAllocationCallbacks` were provided when `shaderModule`
was created, `pAllocator` :normative{type="must"} be `NULL`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkDestroyShaderModule-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkDestroyShaderModule-shaderModule-parameter"}
 If `shaderModule` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `shaderModule` :normative{type="must"} be a valid [VkShaderModule](/man/VkShaderModule) handle
::

::validity-field{name="VUID-vkDestroyShaderModule-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkDestroyShaderModule-shaderModule-parent"}
 If `shaderModule` is a valid handle, it :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::








## Binding Shaders

Before a shader can be used it :normative{type="must"} be first bound to the command buffer.

Calling [vkCmdBindPipeline](/man/vkCmdBindPipeline) binds all stages corresponding to the
[VkPipelineBindPoint](/man/VkPipelineBindPoint).

The following table describes the relationship between shader stages and
pipeline bind points:







## Shader Execution

At each stage of the pipeline, multiple invocations of a shader :normative{type="may"} execute
simultaneously.
Further, invocations of a single shader produced as the result of different
commands :normative{type="may"} execute simultaneously.
The relative execution order of invocations of the same shader type is
undefined:.
Shader invocations :normative{type="may"} complete in a different order than that in which the
primitives they originated from were drawn or dispatched by the application.
However, fragment shader outputs are written to attachments in
rasterization order.

The relative execution order of invocations of different shader types is
largely undefined:.
However, when invoking a shader whose inputs are generated from a previous
pipeline stage, the shader invocations from the previous stage are
guaranteed to have executed far enough to generate input values for all
required inputs.



### Shader Termination

A shader invocation that is *terminated* has finished executing
instructions.

Executing `OpReturn` in the entry point, or executing
`OpTerminateInvocation` in any function will terminate an invocation.
Implementations :normative{type="may"} also terminate a shader invocation when `OpKill` is
executed in any function; otherwise it becomes a
helper invocation.

In addition to the above conditions, helper
invocations are terminated when all non-helper invocations in the same
derivative group either terminate or
become helper invocations via
`OpKill`.

A shader stage for a given command completes execution when all invocations
for that stage have terminated.







## Shader Memory Access Ordering

The order in which image or buffer memory is read or written by shaders is
largely undefined:.
For some shader types (vertex, tessellation evaluation, and in some cases,
fragment), even the number of shader invocations that :normative{type="may"} perform loads and
stores is undefined:.

In particular, the following rules apply:

- Vertex and
  tessellation evaluation
  shaders will be invoked at least once for each unique vertex, as defined
  in those sections.

- Fragment shaders will be invoked zero or more times,
  as defined in that section.

- The relative execution order of invocations of the same shader type is
  undefined:.
  A store issued by a shader when working on primitive B might complete
  prior to a store for primitive A, even if primitive A is specified prior
  to primitive B. This applies even to fragment shaders; while fragment
  shader outputs are always written to the framebuffer in
  rasterization order, stores executed by fragment
  shader invocations are not.

- The relative execution order of invocations of different shader types is
  largely undefined:.


::note
The above limitations on shader invocation order make some forms of
synchronization between shader invocations within a single set of primitives
unimplementable.
For example, having one invocation poll memory written by another invocation
assumes that the other invocation has been launched and will complete its
writes in finite time.
::


Stores issued to different memory locations within a single shader
invocation :normative{type="may"} not be visible to other invocations, or :normative{type="may"} not become
visible in the order they were performed.

The `OpMemoryBarrier` instruction :normative{type="can"} be used to provide stronger
ordering of reads and writes performed by a single invocation.
`OpMemoryBarrier` guarantees that any memory transactions issued by the
shader invocation prior to the instruction complete prior to the memory
transactions issued after the instruction.
Memory barriers are needed for algorithms that require multiple invocations
to access the same memory and require the operations to be performed in a
partially-defined relative order.
For example, if one shader invocation does a series of writes, followed by
an `OpMemoryBarrier` instruction, followed by another write, then the
results of the series of writes before the barrier become visible to other
shader invocations at a time earlier or equal to when the results of the
final write become visible to those invocations.
In practice it means that another invocation that sees the results of the
final write would also see the previous writes.
Without the memory barrier, the final write :normative{type="may"} be visible before the
previous writes.

Writes that are the result of shader stores through a variable decorated
with `Coherent` automatically have available writes to the same buffer,
buffer view, or image view made visible to them, and are themselves
automatically made available to access by the same buffer, buffer view, or
image view.
Reads that are the result of shader loads through a variable decorated with
`Coherent` automatically have available writes to the same buffer, buffer
view, or image view made visible to them.
The order that coherent writes to different locations become available is
undefined:, unless enforced by a memory barrier instruction or other memory
dependency.


::note
Explicit memory dependencies :normative{type="must"} still be used to guarantee availability
and visibility for access via other buffers, buffer views, or image views.
::


The built-in atomic memory transaction instructions :normative{type="can"} be used to read and
write a given memory address atomically.
While built-in atomic functions issued by multiple shader invocations are
executed in undefined: order relative to each other, these functions perform
both a read and a write of a memory address and guarantee that no other
memory transaction will write to the underlying memory between the read and
write.
Atomic operations ensure automatic availability and visibility for writes
and reads in the same way as those to `Coherent` variables.


::note
Memory accesses performed on different resource descriptors with the same
memory backing :normative{type="may"} not be well-defined even with the `Coherent`
decoration or via atomics, due to things such as image layouts or ownership
of the resource - as described in the Synchronization and
Cache Control chapter.
::



::note
Atomics allow shaders to use shared global addresses for mutual exclusion or
as counters, among other uses.
::


The SPIR-V *SubgroupMemory*, *CrossWorkgroupMemory*, and
*AtomicCounterMemory* memory semantics are ignored.
Sequentially consistent atomics and barriers are not supported and
*SequentiallyConsistent* is treated as *AcquireRelease*.
*SequentiallyConsistent* :normative{type="should"} not be used.





## Shader Inputs and Outputs

Data is passed into and out of shaders using variables with input or output
storage class, respectively.
User-defined inputs and outputs are connected between stages by matching
their `Location` decorations.
Additionally, data :normative{type="can"} be provided by or communicated to special functions
provided by the execution environment using `BuiltIn` decorations.

In many cases, the same `BuiltIn` decoration :normative{type="can"} be used in multiple
shader stages with similar meaning.
The specific behavior of variables decorated as `BuiltIn` is documented
in the following sections.





## Vertex Shaders

Each vertex shader invocation operates on one vertex and its associated
vertex attribute data, and outputs one vertex and
associated data.
Graphics pipelines :normative{type="must"} include a vertex shader, and the vertex shader
stage is always the first shader stage in the graphics pipeline.



### Vertex Shader Execution

A vertex shader :normative{type="must"} be executed at least once for each vertex specified by
a drawing command.
During execution, the shader is presented with the index of the vertex and
instance for which it has been invoked.
Input variables declared in the vertex shader are filled by the
implementation with the values of vertex attributes associated with the
invocation being executed.

If the same vertex is specified multiple times in a drawing command (e.g. by
including the same index value multiple times in an index buffer) the
implementation :normative{type="may"} reuse the results of vertex shading if it can statically
determine that the vertex shader invocations will produce identical results.


::note
It is implementation-dependent when and if results of vertex shading are
reused, and thus how many times the vertex shader will be executed.
This is true also if the vertex shader contains stores or atomic operations
(see `vertexPipelineStoresAndAtomics`).
::








## Tessellation Control Shaders

The tessellation control shader is used to read an input patch provided by
the application and to produce an output patch.
Each tessellation control shader invocation operates on an input patch
(after all control points in the patch are processed by a vertex shader) and
its associated data, and outputs a single control point of the output patch
and its associated data, and :normative{type="can"} also output additional per-patch data.
The input patch is sized according to the `patchControlPoints` member of
[VkPipelineTessellationStateCreateInfo](/man/VkPipelineTessellationStateCreateInfo), as part of input assembly.

The size of the output patch is controlled by the `OpExecutionMode`

`OutputVertices` specified in the tessellation control or tessellation
evaluation shaders, which :normative{type="must"} be specified in at least one of the shaders.
The size of the input and output patches :normative{type="must"} each be greater than zero and
less than or equal to
`VkPhysicalDeviceLimits`::`maxTessellationPatchSize`.



### Tessellation Control Shader Execution

A tessellation control shader is invoked at least once for each *output*
vertex in a patch.

Inputs to the tessellation control shader are generated by the vertex
shader.
Each invocation of the tessellation control shader :normative{type="can"} read the attributes
of any incoming vertices and their associated data.
The invocations corresponding to a given patch execute logically in
parallel, with undefined: relative execution order.
However, the `OpControlBarrier` instruction :normative{type="can"} be used to provide
limited control of the execution order by synchronizing invocations within a
patch, effectively dividing tessellation control shader execution into a set
of phases.
Tessellation control shaders will read undefined: values if one invocation
reads a per-vertex or per-patch output written by another invocation at any
point during the same phase, or if two invocations attempt to write
different values to the same per-patch output in a single phase.







## Tessellation Evaluation Shaders

The Tessellation Evaluation Shader operates on an input patch of control
points and their associated data, and a single input barycentric coordinate
indicating the invocation’s relative position within the subdivided patch,
and outputs a single vertex and its associated data.



### Tessellation Evaluation Shader Execution

A tessellation evaluation shader is invoked at least once for each unique
vertex generated by the tessellator.







## Geometry Shaders

The geometry shader operates on a group of vertices and their associated
data assembled from a single input primitive, and emits zero or more output
primitives and the group of vertices and their associated data required for
each output primitive.



### Geometry Shader Execution

A geometry shader is invoked at least once for each primitive produced by
the tessellation stages, or at least once for each primitive generated by
primitive assembly when tessellation is not in use.
A shader can request that the geometry shader runs multiple
instances.
A geometry shader is invoked at least once for each instance.







## Fragment Shaders

Fragment shaders are invoked as a fragment operation in
a graphics pipeline.
Each fragment shader invocation operates on a single fragment and its
associated data.
With few exceptions, fragment shaders do not have access to any data
associated with other fragments and are considered to execute in isolation
of fragment shader invocations associated with other fragments.





## Compute Shaders

Compute shaders are invoked via [vkCmdDispatch](/man/vkCmdDispatch) and
[vkCmdDispatchIndirect](/man/vkCmdDispatchIndirect) commands.
In general, they have access to similar resources as shader stages executing
as part of a graphics pipeline.

Compute workloads are formed from groups of work items called workgroups and
processed by the compute shader in the current compute pipeline.
A workgroup is a collection of shader invocations that execute the same
shader, potentially in parallel.
Compute shaders execute in *global workgroups* which are divided into a
number of *local workgroups* with a size that :normative{type="can"} be set by assigning a
value to the `LocalSize`
execution mode or via an object decorated by the `WorkgroupSize`
decoration.
An invocation within a local workgroup :normative{type="can"} share data with other members of
the local workgroup through shared variables and issue memory and control
flow barriers to synchronize with other members of the local workgroup.





## Interpolation Decorations

Variables in the `Input` storage class in a fragment shader’s interface
are interpolated from the values specified by the primitive being
rasterized.


::note
Interpolation decorations can be present on input and output variables in
pre-rasterization shaders but have no effect on the interpolation performed.
::


An undecorated input variable will be interpolated with perspective-correct
interpolation according to the primitive type being rasterized.
Lines and
polygons are interpolated in the same
way as the primitive’s clip coordinates.
If the `NoPerspective` decoration is present, linear interpolation is
instead used for lines and
polygons.
For points, as there is only a single vertex, input values are never
interpolated and instead take the value written for the single vertex.

If the `Flat` decoration is present on an input variable, the value is
not interpolated, and instead takes its value directly from the
provoking vertex.
Fragment shader inputs that are signed or unsigned integers, integer
vectors, or any double-precision floating-point type :normative{type="must"} be decorated with
`Flat`.

Interpolation of input variables is performed at an implementation-defined
position within the fragment area being shaded.
The position is further constrained as follows:

- If the `Centroid` decoration is used, the interpolation position used
  for the variable :normative{type="must"} also fall within the bounds of the primitive
  being rasterized.

- If the `Sample` decoration is used, the interpolation position used
  for the variable :normative{type="must"} be at the position of the sample being shaded by
  the current fragment shader invocation.

- If a sample count of 1 is used, the interpolation position :normative{type="must"} be at
  the center of the fragment area.


::note
As `Centroid` restricts the possible interpolation position to the
covered area of the primitive, the position can be forced to vary between
neighboring fragments when it otherwise would not.
Derivatives calculated based on these differing locations can produce
inconsistent results compared to undecorated inputs.
It is recommended that input variables used in derivative calculations are
not decorated with `Centroid`.
::






## Static Use

A SPIR-V module declares a global object in memory using the `OpVariable`
instruction, which results in a pointer `x` to that object.
A specific entry point in a SPIR-V module is said to *statically use* that
object if that entry point’s call tree contains a function containing a
instruction with `x` as an `id` operand.
A shader entry point also *statically uses* any variables explicitly
declared in its interface.





## Scope

A *scope* describes a set of shader invocations, where each such set is a
*scope instance*.
Each invocation belongs to one or more scope instances, but belongs to no
more than one scope instance for each scope.

The operations available between invocations in a given scope instance vary,
with smaller scopes generally able to perform more operations, and with
greater efficiency.



### Cross Device

All invocations executed in a Vulkan instance fall into a single *cross
device scope instance*.

Whilst the `CrossDevice` scope is defined in SPIR-V, it is disallowed in
Vulkan.
API synchronization commands :normative{type="can"} be used to
communicate between devices.





### Device

All invocations executed on a single device form a *device scope instance*.

There is no method to synchronize the execution of these invocations within
SPIR-V, and this :normative{type="can"} only be done with API synchronization primitives.

The scope only extends to the queue family, not the whole device.





### Queue Family

Invocations executed by queues in a given queue family form a *queue family
scope instance*.

This scope is identified in SPIR-V as the
`Device` `Scope`, which :normative{type="can"} be used as a `Memory` `Scope` for
barrier and atomic operations.

There is no method to synchronize the execution of these invocations within
SPIR-V, and this :normative{type="can"} only be done with API synchronization primitives.

Each invocation in a queue family scope instance :normative{type="must"} be in the same
device scope instance.





### Command

Any shader invocations executed as the result of a single command such as
[vkCmdDispatch](/man/vkCmdDispatch) or [vkCmdDraw](/man/vkCmdDraw) form a *command scope instance*.
For indirect drawing commands with `drawCount` greater than one,
invocations from separate draws are in separate command scope instances.

There is no specific `Scope` for communication across invocations in a
command scope instance.
As this has a clear boundary at the API level, coordination here :normative{type="can"} be
performed in the API, rather than in SPIR-V.

Each invocation in a command scope instance :normative{type="must"} be in the same
queue-family scope instance.

For shaders without defined workgroups, this
set of invocations forms an *invocation group* as defined in the
SPIR-V specification.





### Primitive

Any fragment shader invocations executed as the result of rasterization of a
single primitive form a *primitive scope instance*.

There is no specific `Scope` for communication across invocations in a
primitive scope instance.

Any generated helper invocations are
included in this scope instance.

Each invocation in a primitive scope instance :normative{type="must"} be in the same
command scope instance.

Any input variables decorated with `Flat` are uniform within a primitive
scope instance.





### Workgroup

A *local workgroup* is a set of invocations that can synchronize and share
data with each other using memory in the `Workgroup` storage class.

The `Workgroup` `Scope` can be used as both an `Execution`

`Scope` and `Memory` `Scope` for barrier and atomic operations.

Each invocation in a local workgroup :normative{type="must"} be in the same
command scope instance.

Only
compute shaders have defined workgroups - other shader types :normative{type="cannot"} use
workgroup functionality.
For shaders that have defined workgroups, this set of invocations forms an
*invocation group* as defined in the SPIR-V specification.

The amount of storage consumed by the
variables declared with the `Workgroup` storage class is
implementation-dependent.
However, the amount of storage consumed may not exceed the largest block
size that would be obtained if all active
variables declared with `Workgroup` storage class were assigned offsets
in an arbitrary order by successively taking the smallest valid offset
according to the Standard Storage
Buffer Layout rules, and with `Boolean` values considered as 32-bit
integer values for the purpose of this calculation.
(This is equivalent to using the GLSL std430 layout rules.)





### Quad

A *quad scope instance* is formed of four shader invocations.

In a fragment shader, each invocation in a quad scope instance is formed of
invocations in neighboring framebuffer locations (x\<sub>i\</sub>, y\<sub>i\</sub>), where:

- i is the index of the invocation within the scope instance.

- w and h are the number of pixels the fragment covers in the
  x and y axes.

- w and h are identical for all participating invocations.

- (x\<sub>0\</sub>) = (x\<sub>1\</sub> - w) = (x\<sub>2\</sub>) = (x\<sub>3\</sub> - w)

- (y\<sub>0\</sub>) = (y\<sub>1\</sub>) = (y\<sub>2\</sub> - h) = (y\<sub>3\</sub> - h)

- Each invocation has the same layer and sample indices.

The specific set of invocations that make up a quad scope instance in other
shader stages is undefined:.

In a fragment shader, each invocation in a quad scope instance :normative{type="must"} be in
the same primitive scope instance.

For shaders that have defined workgroups, each
invocation in a quad scope instance :normative{type="must"} be in the same
local workgroup.

In other shader stages, each invocation in a quad scope instance :normative{type="must"} be in
the same device scope instance.

Fragment
shaders have defined quad scope instances.





### Invocation

The smallest *scope* is a single invocation; this is represented by the
`Invocation` `Scope` in SPIR-V.

Fragment shader invocations :normative{type="must"} be in a primitive scope instance.

Invocations in shaders that have defined
workgroups :normative{type="must"} be in a local workgroup.

Invocations in shaders that have a defined quad
scope :normative{type="must"} be in a quad scope instance.

All invocations in all stages :normative{type="must"} be in a command
scope instance.







## Derivative Operations

Derivative operations calculate the partial derivative for an expression
P as a function of an invocation’s x and y coordinates.

Derivative operations operate on a set of invocations known as a *derivative
group* as defined in the SPIR-V specification.
A derivative group is equivalent to
the primitive scope instance for a fragment
shader invocation.

Derivatives are calculated assuming that P is piecewise linear and
continuous within the derivative group.
All dynamic instances of explicit derivative instructions (`OpDPdx*`,
`OpDPdy*`, and `OpFwidth*`) :normative{type="must"} be executed in control flow that is
uniform within a derivative group.
For other derivative operations, results are undefined: if a dynamic
instance is executed in control flow that is not uniform within the
derivative group.

Fragment shaders that statically execute derivative operations :normative{type="must"} launch
sufficient invocations to ensure their correct operation; additional
helper invocations are launched for
framebuffer locations not covered by rasterized fragments if necessary.

Derivative operations calculate their results as the difference between the
result of P across invocations in the quad.
For fine derivative operations (`OpDPdxFine` and `OpDPdyFine`), the
values of DPdx(P\<sub>i\</sub>) are calculated as



and the values of DPdy(P\<sub>i\</sub>) are calculated as



where i is the index of each invocation as described in
.

Coarse derivative operations (`OpDPdxCoarse` and `OpDPdyCoarse`),
calculate their results in roughly the same manner, but :normative{type="may"} only calculate
two values instead of four (one for each of DPdx and DPdy),
reusing the same result no matter the originating invocation.
If an implementation does this, it :normative{type="should"} use the fine derivative
calculations described for P\<sub>0\</sub>.


::note
Derivative values are calculated between fragments rather than pixels.
If the fragment shader invocations involved in the calculation cover
multiple pixels, these operations cover a wider area, resulting in larger
derivative values.
This in turn will result in a coarser LOD being selected for image sampling
operations using derivatives.

Applications may want to account for this when using multi-pixel fragments;
if pixel derivatives are desired, applications should use explicit
derivative operations and divide the results by the size of the fragment in
each dimension as follows:



where w and h are the size of the fragments in the quad, and
DPdx(P\<sub>n\</sub>)' and DPdy(P\<sub>n\</sub>)' are the pixel derivatives.
::


The results for `OpDPdx` and `OpDPdy` :normative{type="may"} be calculated as either
fine or coarse derivatives, with implementations favouring the most
efficient approach.
Implementations :normative{type="must"} choose coarse or fine consistently between the two.

Executing `OpFwidthFine`, `OpFwidthCoarse`, or `OpFwidth` is
equivalent to executing the corresponding `OpDPdx*` and `OpDPdy*`
instructions, taking the absolute value of the results, and summing them.

Executing an `OpImage*Sample*ImplicitLod` instruction is equivalent to
executing `OpDPdx`(`Coordinate`) and `OpDPdy`(`Coordinate`), and
passing the results as the `Grad` operands `dx` and `dy`.


::note
It is expected that using the `ImplicitLod` variants of sampling
functions will be substantially more efficient than using the
`ExplicitLod` variants with explicitly generated derivatives.
::






## Helper Invocations

When performing derivative
operations in a fragment shader, additional invocations :normative{type="may"} be spawned in
order to ensure correct results.
These additional invocations are known as *helper invocations* and :normative{type="can"} be
identified by a non-zero value in the `HelperInvocation` built-in.
Stores and atomics performed by helper invocations :normative{type="must"} not have any effect
on memory except for the `Function`, `Private` and `Output` storage
classes, and values returned by atomic instructions in helper invocations
are undefined:.


::note
While storage to `Output` storage class has an effect even in helper
invocations, it does not mean that helper invocations have an effect on the
framebuffer.
`Output` variables in fragment shaders can be read from as well, and they
behave more like `Private` variables for the duration of the shader
invocation.
::


For group operations other than
derivative
operations, helper invocations :normative{type="may"} be treated as inactive even if they
would be considered otherwise active.







# Pipelines

The following figure shows a block diagram of
the Vulkan pipelines.
Some Vulkan commands specify geometric objects to be drawn or computational
work to be performed, while others specify state controlling how objects are
handled by the various pipeline stages, or control data transfer between
memory organized as images and buffers.
Commands are effectively sent through a processing pipeline, either a
*graphics pipeline*,
or a *compute pipeline*.

The first stage of the graphics pipeline
(Input Assembler) assembles vertices to form geometric
primitives such as points, lines, and triangles, based on a requested
primitive topology.
In the next stage (Vertex Shader) vertices :normative{type="can"} be
transformed, computing positions and attributes for each vertex.
If tessellation and/or geometry shaders are
supported, they :normative{type="can"} then generate multiple primitives from a single input
primitive, possibly changing the primitive topology or generating additional
attribute data in the process.

The final resulting primitives are clipped to a
clip volume in preparation for the next stage, Rasterization.
The rasterizer produces a series of *fragments* associated with a region of
the framebuffer, from a two-dimensional description of a point, line
segment, or triangle.
These fragments are processed by fragment operations to
determine whether generated values will be written to the framebuffer.
Fragment shading determines the values to be written to
the framebuffer attachments.
Framebuffer operations then read and write the color and depth/stencil
attachments of the framebuffer for a given subpass of a render
pass instance.
The attachments :normative{type="can"} be used as input attachments in the fragment shader in
a later subpass of the same render pass.

The compute pipeline is a separate pipeline from the
graphics pipeline, which operates on one-, two-, or three-dimensional
workgroups which :normative{type="can"} read from and write to buffer and image memory.

This ordering is meant only as a tool for describing Vulkan, not as a strict
rule of how Vulkan is implemented, and we present it only as a means to
organize the various operations of the pipelines.
Actual ordering guarantees between pipeline stages are explained in detail
in the synchronization chapter.



Each pipeline is controlled by a monolithic object created from a
description of all of the shader stages and any relevant fixed-function
stages.
Linking the whole pipeline together allows the optimization
of shaders based on their input/outputs and eliminates expensive draw time
state validation.

A pipeline object is bound to the current state using
[vkCmdBindPipeline](/man/vkCmdBindPipeline).
Any pipeline object state that is specified as dynamic is not applied to the current state when the pipeline object is
bound, but is instead set by dynamic state setting commands.

No state, including dynamic state, is inherited from one command buffer to
another.

Compute,
and graphics pipelines are each represented by `VkPipeline` handles:

[{generated}/api/handles/VkPipeline.adoc]({generated}/api/handles/VkPipeline.adoc)



## Compute Pipelines

Compute pipelines consist of a single static compute shader stage and the
pipeline layout.

The compute pipeline represents a compute shader and is created by calling
`vkCreateComputePipelines`
with `module` and `pName` selecting an entry point from a shader
module, where that entry point defines a valid compute shader, in the
[VkPipelineShaderStageCreateInfo](/man/VkPipelineShaderStageCreateInfo) structure contained within the
[VkComputePipelineCreateInfo](/man/VkComputePipelineCreateInfo) structure.

To create compute pipelines, call:

[{generated}/api/protos/vkCreateComputePipelines.adoc]({generated}/api/protos/vkCreateComputePipelines.adoc)

- `device` is the logical device that creates the compute pipelines.

- `pipelineCache` is either [VK\_NULL\_HANDLE](/man/VK_NULL_HANDLE), indicating that
  pipeline caching is disabled; or the handle of a valid
  pipeline cache object, in which case use of that
  cache is enabled for the duration of the command.

- `createInfoCount` is the length of the `pCreateInfos` and
  `pPipelines` arrays.

- `pCreateInfos` is a pointer to an array of
  [VkComputePipelineCreateInfo](/man/VkComputePipelineCreateInfo) structures.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

- `pPipelines` is a pointer to an array of [VkPipeline](/man/VkPipeline) handles in
  which the resulting compute pipeline objects are returned.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCreateComputePipelines-flags-00695"}

If the `flags` member of any element of `pCreateInfos` contains
the `VK_PIPELINE_CREATE_DERIVATIVE_BIT` flag, and the
`basePipelineIndex` member of that same element is not `-1`,
`basePipelineIndex` :normative{type="must"} be less than the index into
`pCreateInfos` that corresponds to that element
::

::validity-field{name="VUID-vkCreateComputePipelines-flags-00696"}

If the `flags` member of any element of `pCreateInfos` contains
the `VK_PIPELINE_CREATE_DERIVATIVE_BIT` flag, the base pipeline
:normative{type="must"} have been created with the
`VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT` flag set
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCreateComputePipelines-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkCreateComputePipelines-pipelineCache-parameter"}
 If `pipelineCache` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `pipelineCache` :normative{type="must"} be a valid [VkPipelineCache](/man/VkPipelineCache) handle
::

::validity-field{name="VUID-vkCreateComputePipelines-pCreateInfos-parameter"}
 `pCreateInfos` :normative{type="must"} be a valid pointer to an array of `createInfoCount` valid [VkComputePipelineCreateInfo](/man/VkComputePipelineCreateInfo) structures
::

::validity-field{name="VUID-vkCreateComputePipelines-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkCreateComputePipelines-pPipelines-parameter"}
 `pPipelines` :normative{type="must"} be a valid pointer to an array of `createInfoCount` [VkPipeline](/man/VkPipeline) handles
::

::validity-field{name="VUID-vkCreateComputePipelines-createInfoCount-arraylength"}
 `createInfoCount` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-vkCreateComputePipelines-pipelineCache-parent"}
 If `pipelineCache` is a valid handle, it :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::




The `VkComputePipelineCreateInfo` structure is defined as:

[{generated}/api/structs/VkComputePipelineCreateInfo.adoc]({generated}/api/structs/VkComputePipelineCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is a bitmask of [VkPipelineCreateFlagBits](/man/VkPipelineCreateFlagBits) specifying
  how the pipeline will be generated.

- `stage` is a [VkPipelineShaderStageCreateInfo](/man/VkPipelineShaderStageCreateInfo) structure
  describing the compute shader.

- `layout` is the description of binding locations used by both the
  pipeline and descriptor sets used with the pipeline.

- `basePipelineHandle` is a pipeline to derive from.

- `basePipelineIndex` is an index into the `pCreateInfos`
  parameter to use as a pipeline to derive from.

The parameters `basePipelineHandle` and `basePipelineIndex` are
described in more detail in Pipeline
Derivatives.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkComputePipelineCreateInfo-flags-07984"}

If `flags` contains the `VK_PIPELINE_CREATE_DERIVATIVE_BIT`
flag, and `basePipelineIndex` is -1, `basePipelineHandle` :normative{type="must"}
be a valid compute `VkPipeline` handle
::

::validity-field{name="VUID-VkComputePipelineCreateInfo-flags-07985"}

If `flags` contains the `VK_PIPELINE_CREATE_DERIVATIVE_BIT`
flag, and `basePipelineHandle` is [VK_NULL_HANDLE](/man/VK_NULL_HANDLE),
`basePipelineIndex` :normative{type="must"} be a valid index into the calling
command’s `pCreateInfos` parameter
::

::validity-field{name="VUID-VkComputePipelineCreateInfo-flags-07986"}

If `flags` contains the `VK_PIPELINE_CREATE_DERIVATIVE_BIT`
flag, `basePipelineIndex` :normative{type="must"} be -1 or `basePipelineHandle`
:normative{type="must"} be [VK_NULL_HANDLE](/man/VK_NULL_HANDLE)
::

::validity-field{name="VUID-VkComputePipelineCreateInfo-layout-07987"}

If a push constant block is declared in a shader, a push constant range
in `layout` :normative{type="must"} match both the shader stage and range
::

::validity-field{name="VUID-VkComputePipelineCreateInfo-layout-07988"}

If a resource variables is declared in a
shader, a descriptor slot in `layout` :normative{type="must"} match the shader stage
::

::validity-field{name="VUID-VkComputePipelineCreateInfo-layout-07989"}

If a resource variables is declared in a
shader, a descriptor slot in `layout` :normative{type="must"} match the descriptor
type
::

::validity-field{name="VUID-VkComputePipelineCreateInfo-layout-07991"}

If a resource variables is declared in a shader
as an array, a descriptor slot in `layout` :normative{type="must"} match the
descriptor count
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkComputePipelineCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO`
::

::validity-field{name="VUID-VkComputePipelineCreateInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkPipelineCompilerControlCreateInfoAMD](/man/VkPipelineCompilerControlCreateInfoAMD), [VkPipelineCreateFlags2CreateInfoKHR](/man/VkPipelineCreateFlags2CreateInfoKHR), [VkPipelineCreationFeedbackCreateInfo](/man/VkPipelineCreationFeedbackCreateInfo), [VkPipelineRobustnessCreateInfoEXT](/man/VkPipelineRobustnessCreateInfoEXT), or [VkSubpassShadingPipelineCreateInfoHUAWEI](/man/VkSubpassShadingPipelineCreateInfoHUAWEI)
::

::validity-field{name="VUID-VkComputePipelineCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkComputePipelineCreateInfo-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkPipelineCreateFlagBits](/man/VkPipelineCreateFlagBits) values
::

::validity-field{name="VUID-VkComputePipelineCreateInfo-stage-parameter"}
 `stage` :normative{type="must"} be a valid [VkPipelineShaderStageCreateInfo](/man/VkPipelineShaderStageCreateInfo) structure
::

::validity-field{name="VUID-VkComputePipelineCreateInfo-layout-parameter"}
 `layout` :normative{type="must"} be a valid [VkPipelineLayout](/man/VkPipelineLayout) handle
::

::validity-field{name="VUID-VkComputePipelineCreateInfo-commonparent"}
 Both of `basePipelineHandle`, and `layout` that are valid handles of non-ignored parameters :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::


The `VkPipelineShaderStageCreateInfo` structure is defined as:

[{generated}/api/structs/VkPipelineShaderStageCreateInfo.adoc]({generated}/api/structs/VkPipelineShaderStageCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is a bitmask of [VkPipelineShaderStageCreateFlagBits](/man/VkPipelineShaderStageCreateFlagBits)
  specifying how the pipeline shader stage will be generated.

- `stage` is a [VkShaderStageFlagBits](/man/VkShaderStageFlagBits) value specifying a single
  pipeline stage.

- `module` is a [VkShaderModule](/man/VkShaderModule) object containing the shader code
  for this stage.

- `pName` is a pointer to a null-terminated UTF-8 string specifying
  the entry point name of the shader for this stage.

- `pSpecializationInfo` is a pointer to a [VkSpecializationInfo](/man/VkSpecializationInfo)
  structure, as described in
  Specialization Constants, or
  `NULL`.

The shader code used by the pipeline is defined by `module`.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-stage-00704"}

If the `geometryShader` feature is not
enabled, `stage` :normative{type="must"} not be `VK_SHADER_STAGE_GEOMETRY_BIT`
::

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-stage-00705"}

If the `tessellationShader` feature
is not enabled, `stage` :normative{type="must"} not be
`VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT` or
`VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT`
::

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-stage-00706"}
`stage` :normative{type="must"} not be `VK_SHADER_STAGE_ALL_GRAPHICS`, or
`VK_SHADER_STAGE_ALL`
::

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-pName-00707"}
`pName` :normative{type="must"} be the name of an `OpEntryPoint` in `module`
with an execution model that matches `stage`
::

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-maxClipDistances-00708"}

If the identified entry point includes any variable in its interface
that is declared with the `ClipDistance` `BuiltIn` decoration,
that variable :normative{type="must"} not have an array size greater than
`VkPhysicalDeviceLimits`::`maxClipDistances`
::

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-maxCullDistances-00709"}

If the identified entry point includes any variable in its interface
that is declared with the `CullDistance` `BuiltIn` decoration,
that variable :normative{type="must"} not have an array size greater than
`VkPhysicalDeviceLimits`::`maxCullDistances`
::

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-maxCombinedClipAndCullDistances-00710"}

If the identified entry point includes any variables in its interface
that are declared with the `ClipDistance` or `CullDistance`

`BuiltIn` decoration, those variables :normative{type="must"} not have array sizes
which sum to more than
`VkPhysicalDeviceLimits`::`maxCombinedClipAndCullDistances`
::

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-maxSampleMaskWords-00711"}

If the identified entry point includes any variable in its interface
that is declared with the `SampleMask` `BuiltIn` decoration, that
variable :normative{type="must"} not have an array size greater than
`VkPhysicalDeviceLimits`::`maxSampleMaskWords`
::

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-stage-00713"}

If `stage` is `VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT` or
`VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT`, and the identified
entry point has an `OpExecutionMode` instruction specifying a patch
size with `OutputVertices`, the patch size :normative{type="must"} be greater than `0`
and less than or equal to
`VkPhysicalDeviceLimits`::`maxTessellationPatchSize`
::

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-stage-00714"}

If `stage` is `VK_SHADER_STAGE_GEOMETRY_BIT`, the identified
entry point :normative{type="must"} have an `OpExecutionMode` instruction specifying a
maximum output vertex count that is greater than `0` and less than or
equal to `VkPhysicalDeviceLimits`::`maxGeometryOutputVertices`
::

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-stage-00715"}

If `stage` is `VK_SHADER_STAGE_GEOMETRY_BIT`, the identified
entry point :normative{type="must"} have an `OpExecutionMode` instruction specifying an
invocation count that is greater than `0` and less than or equal to
`VkPhysicalDeviceLimits`::`maxGeometryShaderInvocations`
::

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-stage-02596"}

If `stage` is either `VK_SHADER_STAGE_VERTEX_BIT`,
`VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT`,
`VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT`, or
`VK_SHADER_STAGE_GEOMETRY_BIT`, and the identified entry point
writes to `Layer` for any primitive, it :normative{type="must"} write the same value to
`Layer` for all vertices of a given primitive
::

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-stage-02597"}

If `stage` is either `VK_SHADER_STAGE_VERTEX_BIT`,
`VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT`,
`VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT`, or
`VK_SHADER_STAGE_GEOMETRY_BIT`, and the identified entry point
writes to `ViewportIndex` for any primitive, it :normative{type="must"} write the same
value to `ViewportIndex` for all vertices of a given primitive
::

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-stage-06685"}

If `stage` is `VK_SHADER_STAGE_FRAGMENT_BIT`, and the identified
entry point writes to `FragDepth` in any execution path, all
execution paths that are not exclusive to helper invocations :normative{type="must"}
either discard the fragment, or write or initialize the value of
`FragDepth`
::

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-stage-08771"}
`module` :normative{type="must"} be a valid [VkShaderModule](/man/VkShaderModule)
::

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-pSpecializationInfo-06849"}

The
    shader code used by the pipeline :normative{type="must"} be valid as described by the
    Khronos SPIR-V Specification after applying the
    specializations provided in `pSpecializationInfo`, if any, and then
    converting all specialization constants into fixed constants
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO`
::

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkDebugUtilsObjectNameInfoEXT](/man/VkDebugUtilsObjectNameInfoEXT), [VkPipelineRobustnessCreateInfoEXT](/man/VkPipelineRobustnessCreateInfoEXT), [VkPipelineShaderStageModuleIdentifierCreateInfoEXT](/man/VkPipelineShaderStageModuleIdentifierCreateInfoEXT), [VkPipelineShaderStageNodeCreateInfoAMDX](/man/VkPipelineShaderStageNodeCreateInfoAMDX), [VkPipelineShaderStageRequiredSubgroupSizeCreateInfo](/man/VkPipelineShaderStageRequiredSubgroupSizeCreateInfo), [VkShaderModuleCreateInfo](/man/VkShaderModuleCreateInfo), or [VkShaderModuleValidationCacheCreateInfoEXT](/man/VkShaderModuleValidationCacheCreateInfoEXT)
::

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkPipelineShaderStageCreateFlagBits](/man/VkPipelineShaderStageCreateFlagBits) values
::

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-stage-parameter"}
 `stage` :normative{type="must"} be a valid [VkShaderStageFlagBits](/man/VkShaderStageFlagBits) value
::

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-module-parameter"}
 If `module` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `module` :normative{type="must"} be a valid [VkShaderModule](/man/VkShaderModule) handle
::

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-pName-parameter"}
 `pName` :normative{type="must"} be a null-terminated UTF-8 string
::

::validity-field{name="VUID-VkPipelineShaderStageCreateInfo-pSpecializationInfo-parameter"}
 If `pSpecializationInfo` is not `NULL`, `pSpecializationInfo` :normative{type="must"} be a valid pointer to a valid [VkSpecializationInfo](/man/VkSpecializationInfo) structure
::

::


[{generated}/api/flags/VkPipelineShaderStageCreateFlags.adoc]({generated}/api/flags/VkPipelineShaderStageCreateFlags.adoc)

`VkPipelineShaderStageCreateFlags` is a bitmask type for setting a mask
of zero or more [VkPipelineShaderStageCreateFlagBits](/man/VkPipelineShaderStageCreateFlagBits).

Possible values of the `flags` member of
[VkPipelineShaderStageCreateInfo](/man/VkPipelineShaderStageCreateInfo) specifying how a pipeline shader stage
is created, are:

[{generated}/api/enums/VkPipelineShaderStageCreateFlagBits.adoc]({generated}/api/enums/VkPipelineShaderStageCreateFlagBits.adoc)

Bits which :normative{type="can"} be set by commands and structures, specifying one or more
shader stages, are:

[{generated}/api/enums/VkShaderStageFlagBits.adoc]({generated}/api/enums/VkShaderStageFlagBits.adoc)

- `VK_SHADER_STAGE_VERTEX_BIT` specifies the vertex stage.

- `VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT` specifies the
  tessellation control stage.

- `VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT` specifies the
  tessellation evaluation stage.

- `VK_SHADER_STAGE_GEOMETRY_BIT` specifies the geometry stage.

- `VK_SHADER_STAGE_FRAGMENT_BIT` specifies the fragment stage.

- `VK_SHADER_STAGE_COMPUTE_BIT` specifies the compute stage.

- `VK_SHADER_STAGE_ALL_GRAPHICS` is a combination of bits used as
  shorthand to specify all graphics stages defined above (excluding the
  compute stage).

- `VK_SHADER_STAGE_ALL` is a combination of bits used as shorthand to
  specify all shader stages supported by the device, including all
  additional stages which are introduced by extensions.


::note
`VK_SHADER_STAGE_ALL_GRAPHICS` only includes the original five graphics
stages included in Vulkan 1.0, and not any stages added by extensions.
Thus, it may not have the desired effect in all cases.
::


[{generated}/api/flags/VkShaderStageFlags.adoc]({generated}/api/flags/VkShaderStageFlags.adoc)

`VkShaderStageFlags` is a bitmask type for setting a mask of zero or
more [VkShaderStageFlagBits](/man/VkShaderStageFlagBits).





## Graphics Pipelines

Graphics pipelines consist of multiple shader stages, multiple
fixed-function pipeline stages, and a pipeline layout.

To create graphics pipelines, call:

[{generated}/api/protos/vkCreateGraphicsPipelines.adoc]({generated}/api/protos/vkCreateGraphicsPipelines.adoc)

- `device` is the logical device that creates the graphics pipelines.

- `pipelineCache` is either [VK\_NULL\_HANDLE](/man/VK_NULL_HANDLE), indicating that
  pipeline caching is disabled; or the handle of a valid
  pipeline cache object, in which case use of that
  cache is enabled for the duration of the command.

- `createInfoCount` is the length of the `pCreateInfos` and
  `pPipelines` arrays.

- `pCreateInfos` is a pointer to an array of
  [VkGraphicsPipelineCreateInfo](/man/VkGraphicsPipelineCreateInfo) structures.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

- `pPipelines` is a pointer to an array of [VkPipeline](/man/VkPipeline) handles in
  which the resulting graphics pipeline objects are returned.

The [VkGraphicsPipelineCreateInfo](/man/VkGraphicsPipelineCreateInfo) structure includes an array of
[VkPipelineShaderStageCreateInfo](/man/VkPipelineShaderStageCreateInfo) structures for each of the desired
active shader stages, as well as creation information for all relevant
fixed-function stages, and a pipeline layout.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCreateGraphicsPipelines-flags-00720"}

If the `flags` member of any element of `pCreateInfos` contains
the `VK_PIPELINE_CREATE_DERIVATIVE_BIT` flag, and the
`basePipelineIndex` member of that same element is not `-1`,
`basePipelineIndex` :normative{type="must"} be less than the index into
`pCreateInfos` that corresponds to that element
::

::validity-field{name="VUID-vkCreateGraphicsPipelines-flags-00721"}

If the `flags` member of any element of `pCreateInfos` contains
the `VK_PIPELINE_CREATE_DERIVATIVE_BIT` flag, the base pipeline
:normative{type="must"} have been created with the
`VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT` flag set
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCreateGraphicsPipelines-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkCreateGraphicsPipelines-pipelineCache-parameter"}
 If `pipelineCache` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `pipelineCache` :normative{type="must"} be a valid [VkPipelineCache](/man/VkPipelineCache) handle
::

::validity-field{name="VUID-vkCreateGraphicsPipelines-pCreateInfos-parameter"}
 `pCreateInfos` :normative{type="must"} be a valid pointer to an array of `createInfoCount` valid [VkGraphicsPipelineCreateInfo](/man/VkGraphicsPipelineCreateInfo) structures
::

::validity-field{name="VUID-vkCreateGraphicsPipelines-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkCreateGraphicsPipelines-pPipelines-parameter"}
 `pPipelines` :normative{type="must"} be a valid pointer to an array of `createInfoCount` [VkPipeline](/man/VkPipeline) handles
::

::validity-field{name="VUID-vkCreateGraphicsPipelines-createInfoCount-arraylength"}
 `createInfoCount` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-vkCreateGraphicsPipelines-pipelineCache-parent"}
 If `pipelineCache` is a valid handle, it :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::




The `VkGraphicsPipelineCreateInfo` structure is defined as:

[{generated}/api/structs/VkGraphicsPipelineCreateInfo.adoc]({generated}/api/structs/VkGraphicsPipelineCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is a bitmask of [VkPipelineCreateFlagBits](/man/VkPipelineCreateFlagBits) specifying
  how the pipeline will be generated.

- `stageCount` is the number of entries in the `pStages` array.

- `pStages` is a pointer to an array of `stageCount`

  [VkPipelineShaderStageCreateInfo](/man/VkPipelineShaderStageCreateInfo) structures describing the set of
  the shader stages to be included in the graphics pipeline.

- `pVertexInputState` is a pointer to a
  [VkPipelineVertexInputStateCreateInfo](/man/VkPipelineVertexInputStateCreateInfo) structure.

- `pInputAssemblyState` is a pointer to a
  [VkPipelineInputAssemblyStateCreateInfo](/man/VkPipelineInputAssemblyStateCreateInfo) structure which determines
  input assembly behavior for vertex shading, as described in Drawing Commands.

- `pTessellationState` is a pointer to a
  [VkPipelineTessellationStateCreateInfo](/man/VkPipelineTessellationStateCreateInfo) structure defining
  tessellation state used by tessellation shaders.

- `pViewportState` is a pointer to a
  [VkPipelineViewportStateCreateInfo](/man/VkPipelineViewportStateCreateInfo) structure defining viewport
  state used when rasterization is enabled.

- `pRasterizationState` is a pointer to a
  [VkPipelineRasterizationStateCreateInfo](/man/VkPipelineRasterizationStateCreateInfo) structure defining
  rasterization state.

- `pMultisampleState` is a pointer to a
  [VkPipelineMultisampleStateCreateInfo](/man/VkPipelineMultisampleStateCreateInfo) structure defining
  multisample state used when rasterization is enabled.

- `pDepthStencilState` is a pointer to a
  [VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo) structure defining
  depth/stencil state used when rasterization is enabled for depth or
  stencil attachments accessed during rendering.

- `pColorBlendState` is a pointer to a
  [VkPipelineColorBlendStateCreateInfo](/man/VkPipelineColorBlendStateCreateInfo) structure defining color blend
  state used when rasterization is enabled for any color attachments
  accessed during rendering.

- `pDynamicState` is a pointer to a
  [VkPipelineDynamicStateCreateInfo](/man/VkPipelineDynamicStateCreateInfo) structure defining which
  properties of the pipeline state object are dynamic and :normative{type="can"} be changed
  independently of the pipeline state.
  This :normative{type="can"} be `NULL`, which means no state in the pipeline is considered
  dynamic.

- `layout` is the description of binding locations used by both the
  pipeline and descriptor sets used with the pipeline.

- `renderPass` is a handle to a render pass object describing the
  environment in which the pipeline will be used.
  The pipeline :normative{type="must"} only be used with a render pass instance compatible
  with the one provided.
  See Render Pass Compatibility for more
  information.

- `subpass` is the index of the subpass in the render pass where this
  pipeline will be used.

- `basePipelineHandle` is a pipeline to derive from.

- `basePipelineIndex` is an index into the `pCreateInfos`
  parameter to use as a pipeline to derive from.

The parameters `basePipelineHandle` and `basePipelineIndex` are
described in more detail in Pipeline
Derivatives.

The state required for a graphics pipeline is divided into
vertex input state,
pre-rasterization shader
state, fragment shader
state, and fragment output
state.



- [VkPipelineVertexInputStateCreateInfo](/man/VkPipelineVertexInputStateCreateInfo)

- [VkPipelineInputAssemblyStateCreateInfo](/man/VkPipelineInputAssemblyStateCreateInfo)

This state :normative{type="must"} be specified to create a
complete graphics pipeline.



- [VkPipelineShaderStageCreateInfo](/man/VkPipelineShaderStageCreateInfo) entries for:





  * Vertex shaders

  * Tessellation control shaders

  * Tessellation evaluation shaders

  * Geometry shaders

- Within the [VkPipelineLayout](/man/VkPipelineLayout), the full pipeline layout must be
  specified.

- [VkPipelineViewportStateCreateInfo](/man/VkPipelineViewportStateCreateInfo)

- [VkPipelineRasterizationStateCreateInfo](/man/VkPipelineRasterizationStateCreateInfo)

- [VkPipelineTessellationStateCreateInfo](/man/VkPipelineTessellationStateCreateInfo)

- [VkRenderPass](/man/VkRenderPass) and `subpass` parameter

This state :normative{type="must"} be specified to create a
complete graphics pipeline.



- A [VkPipelineShaderStageCreateInfo](/man/VkPipelineShaderStageCreateInfo) entry for the fragment shader

- Within the [VkPipelineLayout](/man/VkPipelineLayout), the full pipeline layout must be
  specified.

- [VkPipelineMultisampleStateCreateInfo](/man/VkPipelineMultisampleStateCreateInfo)

- [VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo)

- [VkRenderPass](/man/VkRenderPass) and `subpass` parameter

If
`rasterizerDiscardEnable` is set to `VK_FALSE`
this state :normative{type="must"} be specified to create a
complete graphics pipeline.



- [VkPipelineColorBlendStateCreateInfo](/man/VkPipelineColorBlendStateCreateInfo)

- [VkRenderPass](/man/VkRenderPass) and `subpass` parameter

- [VkPipelineMultisampleStateCreateInfo](/man/VkPipelineMultisampleStateCreateInfo)

If
`rasterizerDiscardEnable` is set to `VK_FALSE`
this state :normative{type="must"} be specified to create a
complete graphics pipeline.






::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-flags-07984"}

If `flags` contains the `VK_PIPELINE_CREATE_DERIVATIVE_BIT`
flag, and `basePipelineIndex` is -1, `basePipelineHandle` :normative{type="must"}
be a valid graphics `VkPipeline` handle
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-flags-07985"}

If `flags` contains the `VK_PIPELINE_CREATE_DERIVATIVE_BIT`
flag, and `basePipelineHandle` is [VK_NULL_HANDLE](/man/VK_NULL_HANDLE),
`basePipelineIndex` :normative{type="must"} be a valid index into the calling
command’s `pCreateInfos` parameter
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-flags-07986"}

If `flags` contains the `VK_PIPELINE_CREATE_DERIVATIVE_BIT`
flag, `basePipelineIndex` :normative{type="must"} be -1 or `basePipelineHandle`
:normative{type="must"} be [VK_NULL_HANDLE](/man/VK_NULL_HANDLE)
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-layout-07987"}

If a push constant block is declared in a shader, a push constant range
in `layout` :normative{type="must"} match both the shader stage and range
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-layout-07988"}

If a resource variables is declared in a
shader, a descriptor slot in `layout` :normative{type="must"} match the shader stage
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-layout-07989"}

If a resource variables is declared in a
shader, a descriptor slot in `layout` :normative{type="must"} match the descriptor
type
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-layout-07991"}

If a resource variables is declared in a shader
as an array, a descriptor slot in `layout` :normative{type="must"} match the
descriptor count
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-stage-02096"}

If the pipeline requires pre-rasterization shader state the `stage` member of one element
of `pStages` :normative{type="must"} be `VK_SHADER_STAGE_VERTEX_BIT`
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pStages-00729"}

If the pipeline requires pre-rasterization shader state and `pStages` includes a
tessellation control shader stage, it :normative{type="must"} include a tessellation
evaluation shader stage
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pStages-00730"}

If the pipeline requires pre-rasterization shader state and `pStages` includes a
tessellation evaluation shader stage, it :normative{type="must"} include a tessellation
control shader stage
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pStages-09022"}

If the pipeline requires pre-rasterization shader state and `pStages` includes a
tessellation control shader stage,
`pTessellationState` :normative{type="must"} be a valid pointer to a valid
[VkPipelineTessellationStateCreateInfo](/man/VkPipelineTessellationStateCreateInfo) structure
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pStages-00732"}

If the pipeline requires pre-rasterization shader state and `pStages` includes tessellation
shader stages, the shader code of at least one stage :normative{type="must"} contain an
`OpExecutionMode` instruction specifying the type of subdivision in
the pipeline
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pStages-00733"}

If the pipeline requires pre-rasterization shader state and `pStages` includes tessellation
shader stages, and the shader code of both stages contain an
`OpExecutionMode` instruction specifying the type of subdivision in
the pipeline, they :normative{type="must"} both specify the same subdivision mode
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pStages-00734"}

If the pipeline requires pre-rasterization shader state and `pStages` includes tessellation
shader stages, the shader code of at least one stage :normative{type="must"} contain an
`OpExecutionMode` instruction specifying the output patch size in the
pipeline
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pStages-00735"}

If the pipeline requires pre-rasterization shader state and `pStages` includes tessellation
shader stages, and the shader code of both contain an
`OpExecutionMode` instruction specifying the out patch size in the
pipeline, they :normative{type="must"} both specify the same patch size
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pStages-08888"}

If the pipeline is being created with
pre-rasterization shader
state and vertex input
state and `pStages` includes tessellation shader stages,
the `topology` member of `pInputAssembly` :normative{type="must"} be
`VK_PRIMITIVE_TOPOLOGY_PATCH_LIST`
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-topology-08889"}

If the pipeline is being created with
pre-rasterization shader
state and vertex input
state and the `topology` member of `pInputAssembly` is
`VK_PRIMITIVE_TOPOLOGY_PATCH_LIST`,
then `pStages` :normative{type="must"} include tessellation shader stages
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-TessellationEvaluation-07723"}

If the pipeline is being created with a `TessellationEvaluation`

`Execution` `Model`, no `Geometry` `Execution` `Model`, uses the
`PointMode` `Execution` `Mode`, and
`shaderTessellationAndGeometryPointSize` is enabled, a
`PointSize` decorated variable :normative{type="must"} be written to
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-topology-08773"}

If the pipeline is being created with a `Vertex` `Execution` `Model` and
no `TessellationEvaluation` or `Geometry` `Execution` `Model`, and
the `topology` member of `pInputAssembly` is
`VK_PRIMITIVE_TOPOLOGY_POINT_LIST`,
a `PointSize` decorated variable :normative{type="must"} be written to
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-TessellationEvaluation-07724"}

If the pipeline is being created with a `TessellationEvaluation`

`Execution` `Model`, no `Geometry` `Execution` `Model`, uses the
`PointMode` `Execution` `Mode`, and
`shaderTessellationAndGeometryPointSize` is not enabled, a
`PointSize` decorated variable :normative{type="must"} not be written to
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-shaderTessellationAndGeometryPointSize-08776"}

If the pipeline is being created with a `Geometry` `Execution` `Model`,
uses the `OutputPoints` `Execution` `Mode`, and
`shaderTessellationAndGeometryPointSize` is enabled, a
`PointSize` decorated variable :normative{type="must"} be written to for every vertex
emitted
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-Geometry-07726"}

If the pipeline is being created with a `Geometry` `Execution` `Model`,
uses the `OutputPoints` `Execution` `Mode`, and
`shaderTessellationAndGeometryPointSize` is not enabled, a
`PointSize` decorated variable :normative{type="must"} not be written to
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pStages-00738"}

If the pipeline requires pre-rasterization shader state and `pStages` includes a geometry
shader stage, and does not include any tessellation shader stages, its
shader code :normative{type="must"} contain an `OpExecutionMode` instruction specifying
an input primitive type that is compatible with the primitive topology specified in
`pInputAssembly`
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pStages-00739"}

If the pipeline requires pre-rasterization shader state and `pStages` includes a geometry
shader stage, and also includes tessellation shader stages, its shader
code :normative{type="must"} contain an `OpExecutionMode` instruction specifying an
input primitive type that is compatible
with the primitive topology that is output by the tessellation stages
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pStages-00740"}

If the pipeline requires pre-rasterization shader state and
fragment shader state,
it includes both a fragment shader and a geometry shader, and the
fragment shader code reads from an input variable that is decorated with
`PrimitiveId`, then the geometry shader code :normative{type="must"} write to a
matching output variable, decorated with `PrimitiveId`, in all
execution paths
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-renderPass-06038"}

If `renderPass` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE) and the pipeline is
being created with fragment shader state the fragment shader :normative{type="must"} not read from any
input attachment that is defined as `VK_ATTACHMENT_UNUSED` in
`subpass`
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pStages-00742"}

If the pipeline requires pre-rasterization shader state and multiple pre-rasterization shader
stages are included in `pStages`, the shader code for the entry
points identified by those `pStages` and the rest of the state
identified by this structure :normative{type="must"} adhere to the pipeline linking rules
described in the Shader Interfaces chapter
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-None-04889"}

If the pipeline requires pre-rasterization shader state and
fragment shader state,
the fragment shader and last
pre-rasterization shader
stage and any relevant state :normative{type="must"} adhere to the pipeline linking
rules described in the Shader Interfaces chapter
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-renderPass-06041"}

If `renderPass` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), and the pipeline is
being created with fragment output interface state, then for each color attachment in the
subpass, if the potential format features
of the format of the corresponding attachment description do not contain
`VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT`, then the
`blendEnable` member of the corresponding element of the
`pAttachments` member of `pColorBlendState` :normative{type="must"} be
`VK_FALSE`
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-renderPass-07609"}

If `renderPass` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), and the pipeline is
being created with fragment output interface state, and the `pColorBlendState`
pointer is not `NULL`, and the subpass uses color attachments, the
`attachmentCount` member of `pColorBlendState` :normative{type="must"} be equal to
the `colorAttachmentCount` used to create `subpass`
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04130"}

If the pipeline requires pre-rasterization shader state, and `pViewportState→pViewports`
is not dynamic, then `pViewportState→pViewports` :normative{type="must"} be a valid
pointer to an array of `pViewportState→viewportCount` valid
`VkViewport` structures
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04131"}

If the pipeline requires pre-rasterization shader state, and `pViewportState→pScissors` is
not dynamic, then `pViewportState→pScissors` :normative{type="must"} be a valid
pointer to an array of `pViewportState→scissorCount` `VkRect2D`
structures
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00749"}

If the pipeline requires pre-rasterization shader state, and the `wideLines` feature is not enabled, and no element of the
`pDynamicStates` member of `pDynamicState` is
`VK_DYNAMIC_STATE_LINE_WIDTH`, the `lineWidth` member of
`pRasterizationState` :normative{type="must"} be `1.0`
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-rasterizerDiscardEnable-09024"}

If the pipeline requires pre-rasterization shader state, and
the `rasterizerDiscardEnable` member of `pRasterizationState` is
`VK_FALSE`,
`pViewportState` :normative{type="must"} be a valid pointer to a valid
[VkPipelineViewportStateCreateInfo](/man/VkPipelineViewportStateCreateInfo) structure
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pMultisampleState-09026"}

If the pipeline requires fragment output interface state,
`pMultisampleState` :normative{type="must"} be a valid pointer to a valid
[VkPipelineMultisampleStateCreateInfo](/man/VkPipelineMultisampleStateCreateInfo) structure
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pMultisampleState-09027"}

If `pMultisampleState` is not `NULL` is :normative{type="must"} be a valid pointer to
a valid [VkPipelineMultisampleStateCreateInfo](/man/VkPipelineMultisampleStateCreateInfo) structure
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-alphaToCoverageEnable-08891"}

If the pipeline is being created with
fragment shader state,
the
[VkPipelineMultisampleStateCreateInfo](/man/VkPipelineMultisampleStateCreateInfo)::`alphaToCoverageEnable`
is not ignored and is `VK_TRUE`, then the
Fragment Output Interface :normative{type="must"} contain a
variable for the alpha `Component` word in `Location` 0 at
`Index` 0
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-renderPass-09028"}

If `renderPass` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), the pipeline is being
created with fragment
shader state, and `subpass` uses a depth/stencil attachment, and
`pDepthStencilState` :normative{type="must"} be a valid pointer to a valid
[VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo) structure
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pDepthStencilState-09029"}

If `pDepthStencilState` is not `NULL` it :normative{type="must"} be a valid pointer to
a valid [VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo) structure
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-renderPass-09030"}

If `renderPass` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), the pipeline is being
created with fragment
output interface state, and `subpass` uses color attachments,
`pColorBlendState` :normative{type="must"} be a valid pointer to a valid
[VkPipelineColorBlendStateCreateInfo](/man/VkPipelineColorBlendStateCreateInfo) structure
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00754"}

If the pipeline requires pre-rasterization shader state, the `depthBiasClamp` feature is not enabled, no element of the
`pDynamicStates` member of `pDynamicState` is
`VK_DYNAMIC_STATE_DEPTH_BIAS`, and the `depthBiasEnable` member
of `pRasterizationState` is `VK_TRUE`, the `depthBiasClamp`
member of `pRasterizationState` :normative{type="must"} be `0.0`
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-02510"}

If the pipeline requires fragment shader state,
and no element of the `pDynamicStates` member of `pDynamicState`
is `VK_DYNAMIC_STATE_DEPTH_BOUNDS`, and the
`depthBoundsTestEnable` member of `pDepthStencilState` is
`VK_TRUE`, the `minDepthBounds` and `maxDepthBounds` members
of `pDepthStencilState` :normative{type="must"} be between `0.0` and `1.0`, inclusive
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-subpass-00758"}

If the pipeline requires fragment output interface state, `rasterizationSamples` is not
dynamic, and `subpass` does not use any color and/or depth/stencil
attachments, then the `rasterizationSamples` member of
`pMultisampleState` :normative{type="must"} follow the rules for a
zero-attachment subpass
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-renderPass-06046"}

If `renderPass` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `subpass` :normative{type="must"} be
a valid subpass within `renderPass`
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-layout-01688"}

The number of resources in `layout` accessible to each shader stage
that is used by the pipeline :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxPerStageResources`
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pStages-02097"}

If the pipeline requires vertex input state, and `pVertexInputState` is not dynamic, then
`pVertexInputState` :normative{type="must"} be a valid pointer to a valid
[VkPipelineVertexInputStateCreateInfo](/man/VkPipelineVertexInputStateCreateInfo) structure
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-Input-07904"}

If the pipeline is being created with
vertex input state and
`pVertexInputState` is not dynamic, then all variables with the
`Input` storage class decorated with `Location` in the `Vertex`

`Execution` `Model` `OpEntryPoint` :normative{type="must"} contain a location in
[VkVertexInputAttributeDescription](/man/VkVertexInputAttributeDescription)::`location`
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-Input-08733"}

If the pipeline requires vertex input state and `pVertexInputState` is not dynamic, then
the numeric type associated with all `Input` variables of the
corresponding `Location` in the `Vertex` `Execution` `Model`

`OpEntryPoint` :normative{type="must"} be the same as
[VkVertexInputAttributeDescription](/man/VkVertexInputAttributeDescription)::`format`
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pVertexInputState-08929"}

If the pipeline is being created with
vertex input state and
`pVertexInputState` is not dynamic, and
[VkVertexInputAttributeDescription](/man/VkVertexInputAttributeDescription)::`format` has a 64-bit
component, then the scalar width associated with all `Input`
variables of the corresponding `Location` in the `Vertex`

`Execution` `Model` `OpEntryPoint` :normative{type="must"} be 64-bit
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pVertexInputState-08930"}

If the pipeline is being created with
vertex input state and
`pVertexInputState` is not dynamic, and the scalar width associated
with a `Location` decorated `Input` variable in the `Vertex`

`Execution` `Model` `OpEntryPoint` is 64-bit, then the corresponding
[VkVertexInputAttributeDescription](/man/VkVertexInputAttributeDescription)::`format` :normative{type="must"} have a
64-bit component
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pVertexInputState-09198"}

If the pipeline is being created with
vertex input state and
`pVertexInputState` is not dynamic, and
[VkVertexInputAttributeDescription](/man/VkVertexInputAttributeDescription)::`format` has a 64-bit
component, then all `Input` variables at the corresponding
`Location` in the `Vertex` `Execution` `Model` `OpEntryPoint`
:normative{type="must"} not use components that are not present in the format
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-dynamicPrimitiveTopologyUnrestricted-09031"}

If the pipeline requires vertex input state,
`pInputAssemblyState` :normative{type="must"} be a valid pointer to a valid
[VkPipelineInputAssemblyStateCreateInfo](/man/VkPipelineInputAssemblyStateCreateInfo) structure
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pInputAssemblyState-09032"}

If `pInputAssemblyState` is not `NULL` it :normative{type="must"} be a valid pointer
to a valid [VkPipelineInputAssemblyStateCreateInfo](/man/VkPipelineInputAssemblyStateCreateInfo) structure
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pStages-06600"}

If the pipeline requires pre-rasterization shader state or
fragment shader state,
`pStages` :normative{type="must"} be a valid pointer to an array of `stageCount`
valid [VkPipelineShaderStageCreateInfo](/man/VkPipelineShaderStageCreateInfo) structures
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pRasterizationState-06601"}

If the pipeline requires pre-rasterization shader state, `pRasterizationState` :normative{type="must"} be a
valid pointer to a valid [VkPipelineRasterizationStateCreateInfo](/man/VkPipelineRasterizationStateCreateInfo)
structure
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-layout-06602"}

If the pipeline requires fragment shader state or
pre-rasterization shader
state, `layout` :normative{type="must"} be a valid [VkPipelineLayout](/man/VkPipelineLayout) handle
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-renderPass-06603"}

If pre-rasterization
shader state, fragment
shader state, or fragment output state,
`renderPass` :normative{type="must"} be a valid [VkRenderPass](/man/VkRenderPass) handle
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-stageCount-06604"}

If the pipeline requires pre-rasterization shader state or
fragment shader state,
`stageCount` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-graphicsPipelineLibrary-06606"}
`flags` :normative{type="must"} not include `VK_PIPELINE_CREATE_LIBRARY_BIT_KHR`
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pStages-06894"}

If the pipeline requires pre-rasterization shader state but not
fragment shader state,
elements of `pStages` :normative{type="must"} not have `stage` set to
`VK_SHADER_STAGE_FRAGMENT_BIT`
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pStages-06895"}

If the pipeline requires fragment shader state but not
pre-rasterization shader
state, elements of `pStages` :normative{type="must"} not have `stage` set to a
shader stage which participates in pre-rasterization
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pStages-06896"}

If the pipeline requires pre-rasterization shader state, all elements of `pStages` :normative{type="must"}
have a `stage` set to a shader stage which participates in
fragment shader state or
pre-rasterization shader
state
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-stage-06897"}

If the pipeline requires fragment shader state and/or
pre-rasterization shader
state, any value of `stage` :normative{type="must"} not be set in more than one
element of `pStages`
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-None-08893"}

The pipeline :normative{type="must"} be created with
pre-rasterization shader
state
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pStages-08894"}

If `pStages` includes a vertex shader stage, the pipeline :normative{type="must"} be
created with vertex input
state
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pDynamicState-08896"}

If
`pRasterizationState→rasterizerDiscardEnable` is `VK_FALSE`,
the pipeline :normative{type="must"} be created with
fragment shader state
and fragment output
interface state
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-None-09043"}

If
the format of any color attachment is
`VK_FORMAT_E5B9G9R9_UFLOAT_PACK32`, the `colorWriteMask` member
of the corresponding element of `pColorBlendState→pAttachments`
:normative{type="must"} either include all of `VK_COLOR_COMPONENT_R_BIT`,
`VK_COLOR_COMPONENT_G_BIT`, and `VK_COLOR_COMPONENT_B_BIT`, or
none of them
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO`
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkAttachmentSampleCountInfoAMD](/man/VkAttachmentSampleCountInfoAMD), [VkExternalFormatANDROID](/man/VkExternalFormatANDROID), [VkGraphicsPipelineLibraryCreateInfoEXT](/man/VkGraphicsPipelineLibraryCreateInfoEXT), [VkGraphicsPipelineShaderGroupsCreateInfoNV](/man/VkGraphicsPipelineShaderGroupsCreateInfoNV), [VkMultiviewPerViewAttributesInfoNVX](/man/VkMultiviewPerViewAttributesInfoNVX), [VkPipelineCompilerControlCreateInfoAMD](/man/VkPipelineCompilerControlCreateInfoAMD), [VkPipelineCreateFlags2CreateInfoKHR](/man/VkPipelineCreateFlags2CreateInfoKHR), [VkPipelineCreationFeedbackCreateInfo](/man/VkPipelineCreationFeedbackCreateInfo), [VkPipelineDiscardRectangleStateCreateInfoEXT](/man/VkPipelineDiscardRectangleStateCreateInfoEXT), [VkPipelineFragmentShadingRateEnumStateCreateInfoNV](/man/VkPipelineFragmentShadingRateEnumStateCreateInfoNV), [VkPipelineFragmentShadingRateStateCreateInfoKHR](/man/VkPipelineFragmentShadingRateStateCreateInfoKHR), [VkPipelineLibraryCreateInfoKHR](/man/VkPipelineLibraryCreateInfoKHR), [VkPipelineRenderingCreateInfo](/man/VkPipelineRenderingCreateInfo), [VkPipelineRepresentativeFragmentTestStateCreateInfoNV](/man/VkPipelineRepresentativeFragmentTestStateCreateInfoNV), or [VkPipelineRobustnessCreateInfoEXT](/man/VkPipelineRobustnessCreateInfoEXT)
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkPipelineCreateFlagBits](/man/VkPipelineCreateFlagBits) values
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-pDynamicState-parameter"}
 If `pDynamicState` is not `NULL`, `pDynamicState` :normative{type="must"} be a valid pointer to a valid [VkPipelineDynamicStateCreateInfo](/man/VkPipelineDynamicStateCreateInfo) structure
::

::validity-field{name="VUID-VkGraphicsPipelineCreateInfo-commonparent"}
 Each of `basePipelineHandle`, `layout`, and `renderPass` that are valid handles of non-ignored parameters :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::


Bits which :normative{type="can"} be set in

- [VkGraphicsPipelineCreateInfo](/man/VkGraphicsPipelineCreateInfo)::`flags`

- [VkComputePipelineCreateInfo](/man/VkComputePipelineCreateInfo)::`flags`

specify how a pipeline is created, and are:

[{generated}/api/enums/VkPipelineCreateFlagBits.adoc]({generated}/api/enums/VkPipelineCreateFlagBits.adoc)

- `VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT` specifies that the
  created pipeline will not be optimized.
  Using this flag :normative{type="may"} reduce the time taken to create the pipeline.

- `VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT` specifies that the
  pipeline to be created is allowed to be the parent of a pipeline that
  will be created in a subsequent pipeline creation call.

- `VK_PIPELINE_CREATE_DERIVATIVE_BIT` specifies that the pipeline to
  be created will be a child of a previously created parent pipeline.

It is valid to set both `VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT` and
`VK_PIPELINE_CREATE_DERIVATIVE_BIT`.
This allows a pipeline to be both a parent and possibly a child in a
pipeline hierarchy.
See Pipeline Derivatives for more
information.

[{generated}/api/flags/VkPipelineCreateFlags.adoc]({generated}/api/flags/VkPipelineCreateFlags.adoc)

`VkPipelineCreateFlags` is a bitmask type for setting a mask of zero or
more [VkPipelineCreateFlagBits](/man/VkPipelineCreateFlagBits).

The `VkPipelineDynamicStateCreateInfo` structure is defined as:

[{generated}/api/structs/VkPipelineDynamicStateCreateInfo.adoc]({generated}/api/structs/VkPipelineDynamicStateCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is reserved for future use.

- `dynamicStateCount` is the number of elements in the
  `pDynamicStates` array.

- `pDynamicStates` is a pointer to an array of [VkDynamicState](/man/VkDynamicState)
  values specifying which pieces of pipeline state will use the values
  from dynamic state commands rather than from pipeline state creation
  information.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkPipelineDynamicStateCreateInfo-pDynamicStates-01442"}

Each element of `pDynamicStates` :normative{type="must"} be unique
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkPipelineDynamicStateCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO`
::

::validity-field{name="VUID-VkPipelineDynamicStateCreateInfo-pNext-pNext"}
 `pNext` :normative{type="must"} be `NULL`
::

::validity-field{name="VUID-VkPipelineDynamicStateCreateInfo-flags-zerobitmask"}
 `flags` :normative{type="must"} be `0`
::

::validity-field{name="VUID-VkPipelineDynamicStateCreateInfo-pDynamicStates-parameter"}
 If `dynamicStateCount` is not `0`, `pDynamicStates` :normative{type="must"} be a valid pointer to an array of `dynamicStateCount` valid [VkDynamicState](/man/VkDynamicState) values
::

::


[{generated}/api/flags/VkPipelineDynamicStateCreateFlags.adoc]({generated}/api/flags/VkPipelineDynamicStateCreateFlags.adoc)

`VkPipelineDynamicStateCreateFlags` is a bitmask type for setting a
mask, but is currently reserved for future use.

The source of different pieces of dynamic state is specified by the
[VkPipelineDynamicStateCreateInfo](/man/VkPipelineDynamicStateCreateInfo)::`pDynamicStates` property of the
currently active pipeline, each of whose elements :normative{type="must"} be one of the
values:

[{generated}/api/enums/VkDynamicState.adoc]({generated}/api/enums/VkDynamicState.adoc)

- `VK_DYNAMIC_STATE_VIEWPORT` specifies that the `pViewports`
  state in [VkPipelineViewportStateCreateInfo](/man/VkPipelineViewportStateCreateInfo) will be ignored and
  :normative{type="must"} be set dynamically with [vkCmdSetViewport](/man/vkCmdSetViewport) before any drawing
  commands.
  The number of viewports used by a pipeline is still specified by the
  `viewportCount` member of [VkPipelineViewportStateCreateInfo](/man/VkPipelineViewportStateCreateInfo).

- `VK_DYNAMIC_STATE_SCISSOR` specifies that the `pScissors` state
  in [VkPipelineViewportStateCreateInfo](/man/VkPipelineViewportStateCreateInfo) will be ignored and :normative{type="must"} be
  set dynamically with [vkCmdSetScissor](/man/vkCmdSetScissor) before any drawing commands.
  The number of scissor rectangles used by a pipeline is still specified
  by the `scissorCount` member of
  [VkPipelineViewportStateCreateInfo](/man/VkPipelineViewportStateCreateInfo).

- `VK_DYNAMIC_STATE_LINE_WIDTH` specifies that the `lineWidth`
  state in [VkPipelineRasterizationStateCreateInfo](/man/VkPipelineRasterizationStateCreateInfo) will be ignored
  and :normative{type="must"} be set dynamically with [vkCmdSetLineWidth](/man/vkCmdSetLineWidth) before any
  drawing commands that generate line primitives for the rasterizer.

- `VK_DYNAMIC_STATE_DEPTH_BIAS` specifies that
  the `depthBiasConstantFactor`, `depthBiasClamp` and
  `depthBiasSlopeFactor` states in
  [VkPipelineRasterizationStateCreateInfo](/man/VkPipelineRasterizationStateCreateInfo) will be ignored and :normative{type="must"}
  be set dynamically with either [vkCmdSetDepthBias](/man/vkCmdSetDepthBias)
  before any draws are performed with depth
  bias enabled.

- `VK_DYNAMIC_STATE_BLEND_CONSTANTS` specifies that the
  `blendConstants` state in [VkPipelineColorBlendStateCreateInfo](/man/VkPipelineColorBlendStateCreateInfo)
  will be ignored and :normative{type="must"} be set dynamically with
  [vkCmdSetBlendConstants](/man/vkCmdSetBlendConstants) before any draws are performed with a
  pipeline state with `VkPipelineColorBlendAttachmentState` member
  `blendEnable` set to `VK_TRUE` and any of the blend functions
  using a constant blend color.

- `VK_DYNAMIC_STATE_DEPTH_BOUNDS` specifies that the
  `minDepthBounds` and `maxDepthBounds` states of
  [VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo) will be ignored and :normative{type="must"} be
  set dynamically with [vkCmdSetDepthBounds](/man/vkCmdSetDepthBounds) before any draws are
  performed with a pipeline state with
  [VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo) member
  `depthBoundsTestEnable` set to `VK_TRUE`.

- `VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK` specifies that the
  `compareMask` state in [VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo)
  for both `front` and `back` will be ignored and :normative{type="must"} be set
  dynamically with [vkCmdSetStencilCompareMask](/man/vkCmdSetStencilCompareMask) before any draws are
  performed with a pipeline state with
  [VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo) member
  `stencilTestEnable` set to `VK_TRUE`

- `VK_DYNAMIC_STATE_STENCIL_WRITE_MASK` specifies that the
  `writeMask` state in [VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo) for
  both `front` and `back` will be ignored and :normative{type="must"} be set
  dynamically with [vkCmdSetStencilWriteMask](/man/vkCmdSetStencilWriteMask) before any draws are
  performed with a pipeline state with
  [VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo) member
  `stencilTestEnable` set to `VK_TRUE`

- `VK_DYNAMIC_STATE_STENCIL_REFERENCE` specifies that the
  `reference` state in [VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo) for
  both `front` and `back` will be ignored and :normative{type="must"} be set
  dynamically with [vkCmdSetStencilReference](/man/vkCmdSetStencilReference) before any draws are
  performed with a pipeline state with
  [VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo) member
  `stencilTestEnable` set to `VK_TRUE`



### Valid Combinations of Stages for Graphics Pipelines

If tessellation shader stages are omitted, the tessellation shading and
fixed-function stages of the pipeline are skipped.

If a geometry shader is omitted, the geometry shading stage is skipped.

If a fragment shader is omitted, fragment color outputs have undefined:
values, and the fragment depth value is determined by Fragment
Operations state.
This :normative{type="can"} be useful for depth-only rendering.

Presence of a shader stage in a pipeline is indicated by including a valid
[VkPipelineShaderStageCreateInfo](/man/VkPipelineShaderStageCreateInfo) with `module` and `pName`
selecting an entry point from a shader module, where that entry point is
valid for the stage specified by `stage`.

Presence of some of the fixed-function stages in the pipeline is implicitly
derived from enabled shaders and provided state.
For example, the fixed-function tessellator is always present when the
pipeline has valid Tessellation Control and Tessellation Evaluation shaders.

- Depth/stencil-only rendering in a subpass with no color attachments





  * Active Pipeline Shader Stages





    * Vertex Shader

  * Required: Fixed-Function Pipeline Stages





    * [VkPipelineVertexInputStateCreateInfo](/man/VkPipelineVertexInputStateCreateInfo)

    * [VkPipelineInputAssemblyStateCreateInfo](/man/VkPipelineInputAssemblyStateCreateInfo)

    * [VkPipelineViewportStateCreateInfo](/man/VkPipelineViewportStateCreateInfo)

    * [VkPipelineRasterizationStateCreateInfo](/man/VkPipelineRasterizationStateCreateInfo)

    * [VkPipelineMultisampleStateCreateInfo](/man/VkPipelineMultisampleStateCreateInfo)

    * [VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo)

- Color-only rendering in a subpass with no depth/stencil attachment





  * Active Pipeline Shader Stages





    * Vertex Shader

    * Fragment Shader

  * Required: Fixed-Function Pipeline Stages





    * [VkPipelineVertexInputStateCreateInfo](/man/VkPipelineVertexInputStateCreateInfo)

    * [VkPipelineInputAssemblyStateCreateInfo](/man/VkPipelineInputAssemblyStateCreateInfo)

    * [VkPipelineViewportStateCreateInfo](/man/VkPipelineViewportStateCreateInfo)

    * [VkPipelineRasterizationStateCreateInfo](/man/VkPipelineRasterizationStateCreateInfo)

    * [VkPipelineMultisampleStateCreateInfo](/man/VkPipelineMultisampleStateCreateInfo)

    * [VkPipelineColorBlendStateCreateInfo](/man/VkPipelineColorBlendStateCreateInfo)

- Rendering pipeline with tessellation and geometry shaders





  * Active Pipeline Shader Stages





    * Vertex Shader

    * Tessellation Control Shader

    * Tessellation Evaluation Shader

    * Geometry Shader

    * Fragment Shader

  * Required: Fixed-Function Pipeline Stages





    * [VkPipelineVertexInputStateCreateInfo](/man/VkPipelineVertexInputStateCreateInfo)

    * [VkPipelineInputAssemblyStateCreateInfo](/man/VkPipelineInputAssemblyStateCreateInfo)

    * [VkPipelineTessellationStateCreateInfo](/man/VkPipelineTessellationStateCreateInfo)

    * [VkPipelineViewportStateCreateInfo](/man/VkPipelineViewportStateCreateInfo)

    * [VkPipelineRasterizationStateCreateInfo](/man/VkPipelineRasterizationStateCreateInfo)

    * [VkPipelineMultisampleStateCreateInfo](/man/VkPipelineMultisampleStateCreateInfo)

    * [VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo)

    * [VkPipelineColorBlendStateCreateInfo](/man/VkPipelineColorBlendStateCreateInfo)







## Pipeline Destruction

To destroy a pipeline, call:

[{generated}/api/protos/vkDestroyPipeline.adoc]({generated}/api/protos/vkDestroyPipeline.adoc)

- `device` is the logical device that destroys the pipeline.

- `pipeline` is the handle of the pipeline to destroy.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkDestroyPipeline-pipeline-00765"}

All submitted commands that refer to `pipeline` :normative{type="must"} have completed
execution
::

::validity-field{name="VUID-vkDestroyPipeline-pipeline-00766"}

If `VkAllocationCallbacks` were provided when `pipeline` was
created, a compatible set of callbacks :normative{type="must"} be provided here
::

::validity-field{name="VUID-vkDestroyPipeline-pipeline-00767"}

If no `VkAllocationCallbacks` were provided when `pipeline` was
created, `pAllocator` :normative{type="must"} be `NULL`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkDestroyPipeline-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkDestroyPipeline-pipeline-parameter"}
 If `pipeline` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `pipeline` :normative{type="must"} be a valid [VkPipeline](/man/VkPipeline) handle
::

::validity-field{name="VUID-vkDestroyPipeline-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkDestroyPipeline-pipeline-parent"}
 If `pipeline` is a valid handle, it :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::








## Multiple Pipeline Creation

Multiple pipelines :normative{type="can"} be created simultaneously by passing an array of
[VkGraphicsPipelineCreateInfo](/man/VkGraphicsPipelineCreateInfo),
or [VkComputePipelineCreateInfo](/man/VkComputePipelineCreateInfo) structures into the
[vkCreateGraphicsPipelines](/man/vkCreateGraphicsPipelines),
and [vkCreateComputePipelines](/man/vkCreateComputePipelines) commands, respectively.
Applications :normative{type="can"} group together similar pipelines to be created in a single
call, and implementations are encouraged to look for reuse opportunities
within a group-create.

When an application attempts to create many pipelines in a single command,
it is possible that some subset :normative{type="may"} fail creation.
In that case, the corresponding entries in the `pPipelines` output array
will be filled with [VK\_NULL\_HANDLE](/man/VK_NULL_HANDLE) values.
If any pipeline fails creation despite valid arguments (for example, due to
out of memory errors), the [VkResult](/man/VkResult) code returned by
`vkCreate*Pipelines` will indicate why.
The implementation will attempt to create all pipelines, and only return
[VK\_NULL\_HANDLE](/man/VK_NULL_HANDLE) values for those that actually failed.

If multiple pipelines fail to be created, the [VkResult](/man/VkResult) :normative{type="must"} be the
return value of any of the pipelines which did not return `VK_SUCCESS`.





## Pipeline Derivatives

A pipeline derivative is a child pipeline created from a parent pipeline,
where the child and parent are expected to have much commonality.

The goal of derivative pipelines is that they be cheaper to create using the
parent as a starting point, and that it be more efficient (on either host or
device) to switch/bind between children of the same parent.

A derivative pipeline is created by setting the
`VK_PIPELINE_CREATE_DERIVATIVE_BIT` flag in the
`Vk*PipelineCreateInfo` structure.
If this is set, then exactly one of `basePipelineHandle` or
`basePipelineIndex` members of the structure :normative{type="must"} have a valid
handle/index, and specifies the parent pipeline.
If `basePipelineHandle` is used, the parent pipeline :normative{type="must"} have already
been created.
If `basePipelineIndex` is used, then the parent is being created in the
same command.
[VK\_NULL\_HANDLE](/man/VK_NULL_HANDLE) acts as the invalid handle for
`basePipelineHandle`, and -1 is the invalid index for
`basePipelineIndex`.
If `basePipelineIndex` is used, the base pipeline :normative{type="must"} appear earlier
in the array.
The base pipeline :normative{type="must"} have been created with the
`VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT` flag set.





## Pipeline Cache

Pipeline cache objects allow the result of pipeline construction to be
reused between pipelines and between runs of an application.
Reuse between pipelines is achieved by passing the same pipeline cache
object when creating multiple related pipelines.
Reuse across runs of an application is achieved by retrieving pipeline cache
contents in one run of an application, saving the contents, and using them
to preinitialize a pipeline cache on a subsequent run.
The contents of the pipeline cache objects are managed by the
implementation.
Applications :normative{type="can"} manage the host memory consumed by a pipeline cache object
and control the amount of data retrieved from a pipeline cache object.

Pipeline cache objects are represented by `VkPipelineCache` handles:

[{generated}/api/handles/VkPipelineCache.adoc]({generated}/api/handles/VkPipelineCache.adoc)



### Creating a Pipeline Cache

To create pipeline cache objects, call:

[{generated}/api/protos/vkCreatePipelineCache.adoc]({generated}/api/protos/vkCreatePipelineCache.adoc)

- `device` is the logical device that creates the pipeline cache
  object.

- `pCreateInfo` is a pointer to a [VkPipelineCacheCreateInfo](/man/VkPipelineCacheCreateInfo)
  structure containing initial parameters for the pipeline cache object.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

- `pPipelineCache` is a pointer to a [VkPipelineCache](/man/VkPipelineCache) handle in
  which the resulting pipeline cache object is returned.


::note
Applications :normative{type="can"} track and manage the total host memory size of a pipeline
cache object using the `pAllocator`.
Applications :normative{type="can"} limit the amount of data retrieved from a pipeline cache
object in `vkGetPipelineCacheData`.
Implementations :normative{type="should"} not internally limit the total number of entries
added to a pipeline cache object or the total host memory consumed.
::


Once created, a pipeline cache :normative{type="can"} be passed to the
[vkCreateGraphicsPipelines](/man/vkCreateGraphicsPipelines)
and [vkCreateComputePipelines](/man/vkCreateComputePipelines) commands.
If the pipeline cache passed into these commands is not
[VK\_NULL\_HANDLE](/man/VK_NULL_HANDLE), the implementation will query it for possible reuse
opportunities and update it with new content.
The use of the pipeline cache object in these commands is internally
synchronized, and the same pipeline cache object :normative{type="can"} be used in multiple
threads simultaneously.


::note
Implementations :normative{type="should"} make every effort to limit any critical sections to
the actual accesses to the cache, which is expected to be significantly
shorter than the duration of the `vkCreate*Pipelines` commands.
::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCreatePipelineCache-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkCreatePipelineCache-pCreateInfo-parameter"}
 `pCreateInfo` :normative{type="must"} be a valid pointer to a valid [VkPipelineCacheCreateInfo](/man/VkPipelineCacheCreateInfo) structure
::

::validity-field{name="VUID-vkCreatePipelineCache-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkCreatePipelineCache-pPipelineCache-parameter"}
 `pPipelineCache` :normative{type="must"} be a valid pointer to a [VkPipelineCache](/man/VkPipelineCache) handle
::

::




The `VkPipelineCacheCreateInfo` structure is defined as:

[{generated}/api/structs/VkPipelineCacheCreateInfo.adoc]({generated}/api/structs/VkPipelineCacheCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is reserved for future use.

- `initialDataSize` is the number of bytes in `pInitialData`.
  If `initialDataSize` is zero, the pipeline cache will initially be
  empty.

- `pInitialData` is a pointer to previously retrieved pipeline cache
  data.
  If the pipeline cache data is incompatible (as defined below) with the
  device, the pipeline cache will be initially empty.
  If `initialDataSize` is zero, `pInitialData` is ignored.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkPipelineCacheCreateInfo-initialDataSize-00768"}

If `initialDataSize` is not `0`, it :normative{type="must"} be equal to the size of
`pInitialData`, as returned by `vkGetPipelineCacheData` when
`pInitialData` was originally retrieved
::

::validity-field{name="VUID-VkPipelineCacheCreateInfo-initialDataSize-00769"}

If `initialDataSize` is not `0`, `pInitialData` :normative{type="must"} have been
retrieved from a previous call to `vkGetPipelineCacheData`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkPipelineCacheCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO`
::

::validity-field{name="VUID-VkPipelineCacheCreateInfo-pNext-pNext"}
 `pNext` :normative{type="must"} be `NULL`
::

::validity-field{name="VUID-VkPipelineCacheCreateInfo-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkPipelineCacheCreateFlagBits](/man/VkPipelineCacheCreateFlagBits) values
::

::validity-field{name="VUID-VkPipelineCacheCreateInfo-pInitialData-parameter"}
 If `initialDataSize` is not `0`, `pInitialData` :normative{type="must"} be a valid pointer to an array of `initialDataSize` bytes
::

::


[{generated}/api/flags/VkPipelineCacheCreateFlags.adoc]({generated}/api/flags/VkPipelineCacheCreateFlags.adoc)

`VkPipelineCacheCreateFlags` is a bitmask type for setting a mask, but
is currently reserved for future use.





### Merging Pipeline Caches

Pipeline cache objects :normative{type="can"} be merged using the command:

[{generated}/api/protos/vkMergePipelineCaches.adoc]({generated}/api/protos/vkMergePipelineCaches.adoc)

- `device` is the logical device that owns the pipeline cache objects.

- `dstCache` is the handle of the pipeline cache to merge results
  into.

- `srcCacheCount` is the length of the `pSrcCaches` array.

- `pSrcCaches` is a pointer to an array of pipeline cache handles,
  which will be merged into `dstCache`.
  The previous contents of `dstCache` are included after the merge.


::note
The details of the merge operation are implementation-dependent, but
implementations :normative{type="should"} merge the contents of the specified pipelines and
prune duplicate entries.
::



::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkMergePipelineCaches-dstCache-00770"}
`dstCache` :normative{type="must"} not appear in the list of source caches
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkMergePipelineCaches-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkMergePipelineCaches-dstCache-parameter"}
 `dstCache` :normative{type="must"} be a valid [VkPipelineCache](/man/VkPipelineCache) handle
::

::validity-field{name="VUID-vkMergePipelineCaches-pSrcCaches-parameter"}
 `pSrcCaches` :normative{type="must"} be a valid pointer to an array of `srcCacheCount` valid [VkPipelineCache](/man/VkPipelineCache) handles
::

::validity-field{name="VUID-vkMergePipelineCaches-srcCacheCount-arraylength"}
 `srcCacheCount` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-vkMergePipelineCaches-dstCache-parent"}
 `dstCache` :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::validity-field{name="VUID-vkMergePipelineCaches-pSrcCaches-parent"}
 Each element of `pSrcCaches` :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::










### Retrieving Pipeline Cache Data

Data :normative{type="can"} be retrieved from a pipeline cache object using the command:

[{generated}/api/protos/vkGetPipelineCacheData.adoc]({generated}/api/protos/vkGetPipelineCacheData.adoc)

- `device` is the logical device that owns the pipeline cache.

- `pipelineCache` is the pipeline cache to retrieve data from.

- `pDataSize` is a pointer to a `size_t` value related to the
  amount of data in the pipeline cache, as described below.

- `pData` is either `NULL` or a pointer to a buffer.

If `pData` is `NULL`, then the maximum size of the data that :normative{type="can"} be
retrieved from the pipeline cache, in bytes, is returned in `pDataSize`.
Otherwise, `pDataSize` :normative{type="must"} point to a variable set by the user to the
size of the buffer, in bytes, pointed to by `pData`, and on return the
variable is overwritten with the amount of data actually written to
`pData`.
If `pDataSize` is less than the maximum size that :normative{type="can"} be retrieved by
the pipeline cache, at most `pDataSize` bytes will be written to
`pData`, and `VK_INCOMPLETE` will be returned instead of
`VK_SUCCESS`, to indicate that not all of the pipeline cache was
returned.

Any data written to `pData` is valid and :normative{type="can"} be provided as the
`pInitialData` member of the [VkPipelineCacheCreateInfo](/man/VkPipelineCacheCreateInfo) structure
passed to `vkCreatePipelineCache`.

Two calls to `vkGetPipelineCacheData` with the same parameters :normative{type="must"}
retrieve the same data unless a command that modifies the contents of the
cache is called between them.

The initial bytes written to `pData` :normative{type="must"} be a header as described in
the Pipeline Cache Header section.

If `pDataSize` is less than what is necessary to store this header,
nothing will be written to `pData` and zero will be written to
`pDataSize`.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkGetPipelineCacheData-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkGetPipelineCacheData-pipelineCache-parameter"}
 `pipelineCache` :normative{type="must"} be a valid [VkPipelineCache](/man/VkPipelineCache) handle
::

::validity-field{name="VUID-vkGetPipelineCacheData-pDataSize-parameter"}
 `pDataSize` :normative{type="must"} be a valid pointer to a `size_t` value
::

::validity-field{name="VUID-vkGetPipelineCacheData-pData-parameter"}
 If the value referenced by `pDataSize` is not `0`, and `pData` is not `NULL`, `pData` :normative{type="must"} be a valid pointer to an array of `pDataSize` bytes
::

::validity-field{name="VUID-vkGetPipelineCacheData-pipelineCache-parent"}
 `pipelineCache` :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::








### Pipeline Cache Header

Applications :normative{type="can"} store the data retrieved from the pipeline cache, and use
these data, possibly in a future run of the application, to populate new
pipeline cache objects.
The results of pipeline compiles, however, :normative{type="may"} depend on the vendor ID,
device ID, driver version, and other details of the device.
To enable applications to detect when previously retrieved data is
incompatible with the device, the pipeline cache data :normative{type="must"} begin with a
valid pipeline cache header.


::note
Structures described in this section are not part of the Vulkan API and are
only used to describe the representation of data elements in pipeline cache
data.
Accordingly, the valid usage clauses defined for structures defined in this
section do not define valid usage conditions for APIs accepting pipeline
cache data as input, as providing invalid pipeline cache data as input to
any Vulkan API commands will result
in the provided pipeline cache data being ignored.
::


Version one of the pipeline cache header is defined as:

[{generated}/api/structs/VkPipelineCacheHeaderVersionOne.adoc]({generated}/api/structs/VkPipelineCacheHeaderVersionOne.adoc)

- `headerSize` is the length in bytes of the pipeline cache header.

- `headerVersion` is a [VkPipelineCacheHeaderVersion](/man/VkPipelineCacheHeaderVersion) value
  specifying the version of the header.
  A consumer of the pipeline cache :normative{type="should"} use the cache version to
  interpret the remainder of the cache header.

- `vendorID` is the `VkPhysicalDeviceProperties`::`vendorID`
  of the implementation.

- `deviceID` is the `VkPhysicalDeviceProperties`::`deviceID`
  of the implementation.

- `pipelineCacheUUID` is the
  `VkPhysicalDeviceProperties`::`pipelineCacheUUID` of the
  implementation.

Unlike most structures declared by the Vulkan API, all fields of this
structure are written with the least significant byte first, regardless of
host byte-order.

The C language specification does not define the packing of structure
members.
This layout assumes tight structure member packing, with members laid out in
the order listed in the structure, and the intended size of the structure is
32 bytes.
If a compiler produces code that diverges from that pattern, applications
:normative{type="must"} employ another method to set values at the correct offsets.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkPipelineCacheHeaderVersionOne-headerSize-04967"}
`headerSize` :normative{type="must"} be 32
::

::validity-field{name="VUID-VkPipelineCacheHeaderVersionOne-headerVersion-04968"}
`headerVersion` :normative{type="must"} be `VK_PIPELINE_CACHE_HEADER_VERSION_ONE`
::

::validity-field{name="VUID-VkPipelineCacheHeaderVersionOne-headerSize-08990"}
`headerSize` :normative{type="must"} not exceed the size of the pipeline cache
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkPipelineCacheHeaderVersionOne-headerVersion-parameter"}
 `headerVersion` :normative{type="must"} be a valid [VkPipelineCacheHeaderVersion](/man/VkPipelineCacheHeaderVersion) value
::

::


Possible values of the `headerVersion` value of the pipeline cache
header are:

[{generated}/api/enums/VkPipelineCacheHeaderVersion.adoc]({generated}/api/enums/VkPipelineCacheHeaderVersion.adoc)

- `VK_PIPELINE_CACHE_HEADER_VERSION_ONE` specifies version one of the
  pipeline cache, described by [VkPipelineCacheHeaderVersionOne](/man/VkPipelineCacheHeaderVersionOne).





### Destroying a Pipeline Cache

To destroy a pipeline cache, call:

[{generated}/api/protos/vkDestroyPipelineCache.adoc]({generated}/api/protos/vkDestroyPipelineCache.adoc)

- `device` is the logical device that destroys the pipeline cache
  object.

- `pipelineCache` is the handle of the pipeline cache to destroy.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkDestroyPipelineCache-pipelineCache-00771"}

If `VkAllocationCallbacks` were provided when `pipelineCache`
was created, a compatible set of callbacks :normative{type="must"} be provided here
::

::validity-field{name="VUID-vkDestroyPipelineCache-pipelineCache-00772"}

If no `VkAllocationCallbacks` were provided when `pipelineCache`
was created, `pAllocator` :normative{type="must"} be `NULL`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkDestroyPipelineCache-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkDestroyPipelineCache-pipelineCache-parameter"}
 If `pipelineCache` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `pipelineCache` :normative{type="must"} be a valid [VkPipelineCache](/man/VkPipelineCache) handle
::

::validity-field{name="VUID-vkDestroyPipelineCache-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkDestroyPipelineCache-pipelineCache-parent"}
 If `pipelineCache` is a valid handle, it :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::










## Specialization Constants

Specialization constants are a mechanism whereby constants in a SPIR-V
module :normative{type="can"} have their constant value specified at the time the
`VkPipeline` is created.
This allows a SPIR-V module to have constants that :normative{type="can"} be modified while
executing an application that uses the Vulkan API.


::note
Specialization constants are useful to allow a compute shader to have its
local workgroup size changed at runtime by the user, for example.
::


Each [VkPipelineShaderStageCreateInfo](/man/VkPipelineShaderStageCreateInfo) structure contains a
`pSpecializationInfo` member, which :normative{type="can"} be `NULL` to indicate no
specialization constants, or point to a `VkSpecializationInfo`
structure.

The `VkSpecializationInfo` structure is defined as:

[{generated}/api/structs/VkSpecializationInfo.adoc]({generated}/api/structs/VkSpecializationInfo.adoc)

- `mapEntryCount` is the number of entries in the `pMapEntries`
  array.

- `pMapEntries` is a pointer to an array of
  `VkSpecializationMapEntry` structures, which map constant IDs to
  offsets in `pData`.

- `dataSize` is the byte size of the `pData` buffer.

- `pData` contains the actual constant values to specialize with.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkSpecializationInfo-offset-00773"}

The `offset` member of each element of `pMapEntries` :normative{type="must"} be
less than `dataSize`
::

::validity-field{name="VUID-VkSpecializationInfo-pMapEntries-00774"}

The `size` member of each element of `pMapEntries` :normative{type="must"} be less
than or equal to `dataSize` minus `offset`
::

::validity-field{name="VUID-VkSpecializationInfo-constantID-04911"}

The `constantID` value of each element of `pMapEntries` :normative{type="must"} be
unique within `pMapEntries`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkSpecializationInfo-pMapEntries-parameter"}
 If `mapEntryCount` is not `0`, `pMapEntries` :normative{type="must"} be a valid pointer to an array of `mapEntryCount` valid [VkSpecializationMapEntry](/man/VkSpecializationMapEntry) structures
::

::validity-field{name="VUID-VkSpecializationInfo-pData-parameter"}
 If `dataSize` is not `0`, `pData` :normative{type="must"} be a valid pointer to an array of `dataSize` bytes
::

::


The `VkSpecializationMapEntry` structure is defined as:

[{generated}/api/structs/VkSpecializationMapEntry.adoc]({generated}/api/structs/VkSpecializationMapEntry.adoc)

- `constantID` is the ID of the specialization constant in SPIR-V.

- `offset` is the byte offset of the specialization constant value
  within the supplied data buffer.

- `size` is the byte size of the specialization constant value within
  the supplied data buffer.

If a `constantID` value is not a specialization constant ID used in the
shader, that map entry does not affect the behavior of the pipeline.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkSpecializationMapEntry-constantID-00776"}

For a `constantID` specialization constant declared in a shader,
`size` :normative{type="must"} match the byte size of the `constantID`.
If the specialization constant is of type `boolean`, `size` :normative{type="must"}
be the byte size of [VkBool32](/man/VkBool32)
::

::


In human readable SPIR-V:



From the above we have three specialization constants, one for each of the
x, y & z elements of the WorkgroupSize vector.

Now to specialize the above via the specialization constants mechanism:



Then when calling [vkCreateComputePipelines](/man/vkCreateComputePipelines), and passing the
`VkSpecializationInfo` we defined as the `pSpecializationInfo`
parameter of [VkPipelineShaderStageCreateInfo](/man/VkPipelineShaderStageCreateInfo), we will create a compute
pipeline with the runtime specified local workgroup size.

Another example would be that an application has a SPIR-V module that has
some platform-dependent constants they wish to use.

In human readable SPIR-V:



From the above we have two specialization constants, one is a signed 32-bit
integer and the second is a 32-bit floating-point value.

Now to specialize the above via the specialization constants mechanism:



It is legal for a SPIR-V module with specializations to be compiled into a
pipeline where no specialization information was provided.
SPIR-V specialization constants contain default values such that if a
specialization is not provided, the default value will be used.
In the examples above, it would be valid for an application to only
specialize some of the specialization constants within the SPIR-V module,
and let the other constants use their default values encoded within the
OpSpecConstant declarations.





## Pipeline Binding

Once a pipeline has been created, it :normative{type="can"} be bound to the command buffer
using the command:

[{generated}/api/protos/vkCmdBindPipeline.adoc]({generated}/api/protos/vkCmdBindPipeline.adoc)

- `commandBuffer` is the command buffer that the pipeline will be
  bound to.

- `pipelineBindPoint` is a [VkPipelineBindPoint](/man/VkPipelineBindPoint) value specifying
  to which bind point the pipeline is bound.
  Binding one does not disturb the others.

- `pipeline` is the pipeline to be bound.

Once bound, a pipeline binding affects subsequent commands that interact
with the given pipeline type in the command buffer until a different
pipeline of the same type is bound to the bind
point.
Commands that do not interact with the given pipeline
type :normative{type="must"} not be affected by the pipeline state.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdBindPipeline-pipelineBindPoint-00777"}

If `pipelineBindPoint` is `VK_PIPELINE_BIND_POINT_COMPUTE`, the
`VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"}
support compute operations
::

::validity-field{name="VUID-vkCmdBindPipeline-pipelineBindPoint-00778"}

If `pipelineBindPoint` is `VK_PIPELINE_BIND_POINT_GRAPHICS`, the
`VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"}
support graphics operations
::

::validity-field{name="VUID-vkCmdBindPipeline-pipelineBindPoint-00779"}

If `pipelineBindPoint` is `VK_PIPELINE_BIND_POINT_COMPUTE`,
`pipeline` :normative{type="must"} be a compute pipeline
::

::validity-field{name="VUID-vkCmdBindPipeline-pipelineBindPoint-00780"}

If `pipelineBindPoint` is `VK_PIPELINE_BIND_POINT_GRAPHICS`,
`pipeline` :normative{type="must"} be a graphics pipeline
::

::validity-field{name="VUID-vkCmdBindPipeline-pipeline-00781"}

If the `variableMultisampleRate` feature is not supported, `pipeline`
is a graphics pipeline, the current subpass uses no attachments, and this is not the first call to this function
with a graphics pipeline after transitioning to the current subpass,
then the sample count specified by this pipeline :normative{type="must"} match that set in
the previous pipeline
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdBindPipeline-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdBindPipeline-pipelineBindPoint-parameter"}
 `pipelineBindPoint` :normative{type="must"} be a valid [VkPipelineBindPoint](/man/VkPipelineBindPoint) value
::

::validity-field{name="VUID-vkCmdBindPipeline-pipeline-parameter"}
 `pipeline` :normative{type="must"} be a valid [VkPipeline](/man/VkPipeline) handle
::

::validity-field{name="VUID-vkCmdBindPipeline-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdBindPipeline-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics, or compute operations
::

::validity-field{name="VUID-vkCmdBindPipeline-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdBindPipeline-commonparent"}
 Both of `commandBuffer`, and `pipeline` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::






Possible values of [vkCmdBindPipeline](/man/vkCmdBindPipeline)::`pipelineBindPoint`,
specifying the bind point of a pipeline object, are:

[{generated}/api/enums/VkPipelineBindPoint.adoc]({generated}/api/enums/VkPipelineBindPoint.adoc)

- `VK_PIPELINE_BIND_POINT_COMPUTE` specifies binding as a compute
  pipeline.

- `VK_PIPELINE_BIND_POINT_GRAPHICS` specifies binding as a graphics
  pipeline.





## Dynamic State

When a pipeline object is bound, any pipeline object state that is not
specified as dynamic is applied to the command buffer state.
Pipeline object state that is specified as dynamic is not applied to the
command buffer state at this time.
Instead, dynamic state :normative{type="can"} be modified at any time and persists for the
lifetime of the command buffer, or until modified by another dynamic state
setting command, or made invalid by another pipeline bind with that state
specified as static.

When a pipeline object is bound, the following applies to each state
parameter:

- If the state is not specified as dynamic in the new pipeline object,
  then that command buffer state is overwritten by the state in the new
  pipeline object.
  Before any draw or dispatch call with this pipeline there :normative{type="must"} not have
  been any calls to any of the corresponding dynamic state setting
  commands after this pipeline was bound.

- If the state is specified as dynamic in the new pipeline object, then
  that command buffer state is not disturbed.
  Before any draw or dispatch call with this pipeline there :normative{type="must"} have
  been at least one call to each of the corresponding dynamic state
  setting commands.
  The state-setting commands :normative{type="must"} be recorded after command buffer
  recording was begun, or after the last command binding a pipeline object
  with that state specified as static, whichever was the latter.

- If the state is not included (corresponding pointer in
  [VkGraphicsPipelineCreateInfo](/man/VkGraphicsPipelineCreateInfo) was `NULL` or was ignored) in the new
  pipeline object, then that command buffer state is not disturbed.

Dynamic state that does not affect the result of operations :normative{type="can"} be left
undefined:.


::note
For example, if blending is disabled by the pipeline object state then the
dynamic color blend constants do not need to be specified in the command
buffer, even if this state is specified as dynamic in the pipeline object.
::








# Memory Allocation

Vulkan memory is broken up into two categories, *host memory* and *device
memory*.



## Host Memory

Host memory is memory needed by the Vulkan implementation for
non-device-visible storage.


::note
This memory :normative{type="may"} be used to store the implementation’s representation and
state of Vulkan objects.
::


Vulkan provides applications the opportunity to perform host memory
allocations on behalf of the Vulkan implementation.
If this feature is not used, the implementation will perform its own memory
allocations.
Since most memory allocations are off the critical path, this is not meant
as a performance feature.
Rather, this :normative{type="can"} be useful for certain embedded systems, for debugging
purposes (e.g. putting a guard page after all host allocations), or for
memory allocation logging.

Allocators are provided by the application as a pointer to a
`VkAllocationCallbacks` structure:

[{generated}/api/structs/VkAllocationCallbacks.adoc]({generated}/api/structs/VkAllocationCallbacks.adoc)

- `pUserData` is a value to be interpreted by the implementation of
  the callbacks.
  When any of the callbacks in `VkAllocationCallbacks` are called, the
  Vulkan implementation will pass this value as the first parameter to the
  callback.
  This value :normative{type="can"} vary each time an allocator is passed into a command,
  even when the same object takes an allocator in multiple commands.

- `pfnAllocation` is a [PFN\_vkAllocationFunction](/man/PFN_vkAllocationFunction) pointer to an
  application-defined memory allocation function.

- `pfnReallocation` is a [PFN\_vkReallocationFunction](/man/PFN_vkReallocationFunction) pointer to
  an application-defined memory reallocation function.

- `pfnFree` is a [PFN\_vkFreeFunction](/man/PFN_vkFreeFunction) pointer to an
  application-defined memory free function.

- `pfnInternalAllocation` is a
  [PFN\_vkInternalAllocationNotification](/man/PFN_vkInternalAllocationNotification) pointer to an
  application-defined function that is called by the implementation when
  the implementation makes internal allocations.

- `pfnInternalFree` is a [PFN\_vkInternalFreeNotification](/man/PFN_vkInternalFreeNotification) pointer
  to an application-defined function that is called by the implementation
  when the implementation frees internal allocations.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkAllocationCallbacks-pfnAllocation-00632"}
`pfnAllocation` :normative{type="must"} be a valid pointer to a valid user-defined
[PFN_vkAllocationFunction](/man/PFN_vkAllocationFunction)
::

::validity-field{name="VUID-VkAllocationCallbacks-pfnReallocation-00633"}
`pfnReallocation` :normative{type="must"} be a valid pointer to a valid user-defined
[PFN_vkReallocationFunction](/man/PFN_vkReallocationFunction)
::

::validity-field{name="VUID-VkAllocationCallbacks-pfnFree-00634"}
`pfnFree` :normative{type="must"} be a valid pointer to a valid user-defined
[PFN_vkFreeFunction](/man/PFN_vkFreeFunction)
::

::validity-field{name="VUID-VkAllocationCallbacks-pfnInternalAllocation-00635"}

If either of `pfnInternalAllocation` or `pfnInternalFree` is not
`NULL`, both :normative{type="must"} be valid callbacks
::

::


The type of `pfnAllocation` is:

[{generated}/api/funcpointers/PFN\_vkAllocationFunction.adoc]({generated}/api/funcpointers/PFN_vkAllocationFunction.adoc)

- `pUserData` is the value specified for
  [VkAllocationCallbacks](/man/VkAllocationCallbacks)::`pUserData` in the allocator specified
  by the application.

- `size` is the size in bytes of the requested allocation.

- `alignment` is the requested alignment of the allocation in bytes
  and :normative{type="must"} be a power of two.

- `allocationScope` is a [VkSystemAllocationScope](/man/VkSystemAllocationScope) value
  specifying the allocation scope of the lifetime of the allocation, as
  described here.

If `pfnAllocation` is unable to allocate the requested memory, it :normative{type="must"}
return `NULL`.
If the allocation was successful, it :normative{type="must"} return a valid pointer to memory
allocation containing at least `size` bytes, and with the pointer value
being a multiple of `alignment`.


::note
Correct Vulkan operation :normative{type="cannot"} be assumed if the application does not
follow these rules.

For example, `pfnAllocation` (or `pfnReallocation`) could cause
termination of running Vulkan instance(s) on a failed allocation for
debugging purposes, either directly or indirectly.
In these circumstances, it :normative{type="cannot"} be assumed that any part of any affected
[VkInstance](/man/VkInstance) objects are going to operate correctly (even
[vkDestroyInstance](/man/vkDestroyInstance)), and the application :normative{type="must"} ensure it cleans up
properly via other means (e.g. process termination).
::


If `pfnAllocation` returns `NULL`, and if the implementation is unable
to continue correct processing of the current command without the requested
allocation, it :normative{type="must"} treat this as a runtime error, and generate
`VK_ERROR_OUT_OF_HOST_MEMORY` at the appropriate time for the command in
which the condition was detected, as described in Return Codes.

If the implementation is able to continue correct processing of the current
command without the requested allocation, then it :normative{type="may"} do so, and :normative{type="must"} not
generate `VK_ERROR_OUT_OF_HOST_MEMORY` as a result of this failed
allocation.

The type of `pfnReallocation` is:

[{generated}/api/funcpointers/PFN\_vkReallocationFunction.adoc]({generated}/api/funcpointers/PFN_vkReallocationFunction.adoc)

- `pUserData` is the value specified for
  [VkAllocationCallbacks](/man/VkAllocationCallbacks)::`pUserData` in the allocator specified
  by the application.

- `pOriginal` :normative{type="must"} be either `NULL` or a pointer previously returned
  by `pfnReallocation` or `pfnAllocation` of a compatible
  allocator.

- `size` is the size in bytes of the requested allocation.

- `alignment` is the requested alignment of the allocation in bytes
  and :normative{type="must"} be a power of two.

- `allocationScope` is a [VkSystemAllocationScope](/man/VkSystemAllocationScope) value
  specifying the allocation scope of the lifetime of the allocation, as
  described here.

If the reallocation was successful, `pfnReallocation` :normative{type="must"} return an
allocation with enough space for `size` bytes, and the contents of the
original allocation from bytes zero to min(original size, new size) -
1 :normative{type="must"} be preserved in the returned allocation.
If `size` is larger than the old size, the contents of the additional
space are undefined:.
If satisfying these requirements involves creating a new allocation, then
the old allocation :normative{type="should"} be freed.

If `pOriginal` is `NULL`, then `pfnReallocation` :normative{type="must"} behave
equivalently to a call to [PFN\_vkAllocationFunction](/man/PFN_vkAllocationFunction) with the same
parameter values (without `pOriginal`).

If `size` is zero, then `pfnReallocation` :normative{type="must"} behave equivalently
to a call to [PFN\_vkFreeFunction](/man/PFN_vkFreeFunction) with the same `pUserData`
parameter value, and `pMemory` equal to `pOriginal`.

If `pOriginal` is non-`NULL`, the implementation :normative{type="must"} ensure that
`alignment` is equal to the `alignment` used to originally allocate
`pOriginal`.

If this function fails and `pOriginal` is non-`NULL` the application
:normative{type="must"} not free the old allocation.

`pfnReallocation` :normative{type="must"} follow the same
rules for return values as
`PFN_vkAllocationFunction`.

The type of `pfnFree` is:

[{generated}/api/funcpointers/PFN\_vkFreeFunction.adoc]({generated}/api/funcpointers/PFN_vkFreeFunction.adoc)

- `pUserData` is the value specified for
  [VkAllocationCallbacks](/man/VkAllocationCallbacks)::`pUserData` in the allocator specified
  by the application.

- `pMemory` is the allocation to be freed.

`pMemory` :normative{type="may"} be `NULL`, which the callback :normative{type="must"} handle safely.
If `pMemory` is non-`NULL`, it :normative{type="must"} be a pointer previously allocated
by `pfnAllocation` or `pfnReallocation`.
The application :normative{type="should"} free this memory.

The type of `pfnInternalAllocation` is:

[{generated}/api/funcpointers/PFN\_vkInternalAllocationNotification.adoc]({generated}/api/funcpointers/PFN_vkInternalAllocationNotification.adoc)

- `pUserData` is the value specified for
  [VkAllocationCallbacks](/man/VkAllocationCallbacks)::`pUserData` in the allocator specified
  by the application.

- `size` is the requested size of an allocation.

- `allocationType` is a [VkInternalAllocationType](/man/VkInternalAllocationType) value
  specifying the requested type of an allocation.

- `allocationScope` is a [VkSystemAllocationScope](/man/VkSystemAllocationScope) value
  specifying the allocation scope of the lifetime of the allocation, as
  described here.

This is a purely informational callback.

The type of `pfnInternalFree` is:

[{generated}/api/funcpointers/PFN\_vkInternalFreeNotification.adoc]({generated}/api/funcpointers/PFN_vkInternalFreeNotification.adoc)

- `pUserData` is the value specified for
  [VkAllocationCallbacks](/man/VkAllocationCallbacks)::`pUserData` in the allocator specified
  by the application.

- `size` is the requested size of an allocation.

- `allocationType` is a [VkInternalAllocationType](/man/VkInternalAllocationType) value
  specifying the requested type of an allocation.

- `allocationScope` is a [VkSystemAllocationScope](/man/VkSystemAllocationScope) value
  specifying the allocation scope of the lifetime of the allocation, as
  described here.

Each allocation has an *allocation scope* defining its lifetime and which
object it is associated with.
Possible values passed to the `allocationScope` parameter of the
callback functions specified by [VkAllocationCallbacks](/man/VkAllocationCallbacks), indicating the
allocation scope, are:

[{generated}/api/enums/VkSystemAllocationScope.adoc]({generated}/api/enums/VkSystemAllocationScope.adoc)

- `VK_SYSTEM_ALLOCATION_SCOPE_COMMAND` specifies that the allocation
  is scoped to the duration of the Vulkan command.

- `VK_SYSTEM_ALLOCATION_SCOPE_OBJECT` specifies that the allocation is
  scoped to the lifetime of the Vulkan object that is being created or
  used.

- `VK_SYSTEM_ALLOCATION_SCOPE_CACHE` specifies that the allocation is
  scoped to the lifetime of a `VkPipelineCache`
  object.

- `VK_SYSTEM_ALLOCATION_SCOPE_DEVICE` specifies that the allocation is
  scoped to the lifetime of the Vulkan device.

- `VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE` specifies that the allocation
  is scoped to the lifetime of the Vulkan instance.

Most Vulkan commands operate on a single object, or there is a sole object
that is being created or manipulated.
When an allocation uses an allocation scope of
`VK_SYSTEM_ALLOCATION_SCOPE_OBJECT` or
`VK_SYSTEM_ALLOCATION_SCOPE_CACHE`, the allocation is scoped to the
object being created or manipulated.

When an implementation requires host memory, it will make callbacks to the
application using the most specific allocator and allocation scope
available:

- If an allocation is scoped to the duration of a command, the allocator
  will use the `VK_SYSTEM_ALLOCATION_SCOPE_COMMAND` allocation scope.
  The most specific allocator available is used: if the object being
  created or manipulated has an allocator, that object’s allocator will be
  used, else if the parent `VkDevice` has an allocator it will be
  used, else if the parent `VkInstance` has an allocator it will be
  used.
  Else,

- If an allocation is associated with a
  `VkPipelineCache` object, the allocator will use the
  `VK_SYSTEM_ALLOCATION_SCOPE_CACHE` allocation scope.
  The most specific allocator available is used (cache, else device, else
  instance).
  Else,

- If an allocation is scoped to the lifetime of an object, that object is
  being created or manipulated by the command, and that object’s type is
  not `VkDevice` or `VkInstance`, the allocator will use an
  allocation scope of `VK_SYSTEM_ALLOCATION_SCOPE_OBJECT`.
  The most specific allocator available is used (object, else device, else
  instance).
  Else,

- If an allocation is scoped to the lifetime of a device, the allocator
  will use an allocation scope of `VK_SYSTEM_ALLOCATION_SCOPE_DEVICE`.
  The most specific allocator available is used (device, else instance).
  Else,

- If the allocation is scoped to the lifetime of an instance and the
  instance has an allocator, its allocator will be used with an allocation
  scope of `VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE`.

- Otherwise an implementation will allocate memory through an alternative
  mechanism that is unspecified.

Objects that are allocated from pools do not specify their own allocator.
When an implementation requires host memory for such an object, that memory
is sourced from the object’s parent pool’s allocator.

The application is not expected to handle allocating memory that is intended
for execution by the host due to the complexities of differing security
implementations across multiple platforms.
The implementation will allocate such memory internally and invoke an
application provided informational callback when these *internal
allocations* are allocated and freed.
Upon allocation of executable memory, `pfnInternalAllocation` will be
called.
Upon freeing executable memory, `pfnInternalFree` will be called.
An implementation will only call an informational callback for executable
memory allocations and frees.

The `allocationType` parameter to the `pfnInternalAllocation` and
`pfnInternalFree` functions :normative{type="may"} be one of the following values:

[{generated}/api/enums/VkInternalAllocationType.adoc]({generated}/api/enums/VkInternalAllocationType.adoc)

- `VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE` specifies that the
  allocation is intended for execution by the host.

An implementation :normative{type="must"} only make calls into an application-provided
allocator during the execution of an API command.
An implementation :normative{type="must"} only make calls into an application-provided
allocator from the same thread that called the provoking API command.
The implementation :normative{type="should"} not synchronize calls to any of the callbacks.
If synchronization is needed, the callbacks :normative{type="must"} provide it themselves.
The informational callbacks are subject to the same restrictions as the
allocation callbacks.

If an implementation intends to make calls through a
`VkAllocationCallbacks` structure between the time a `vkCreate*`
command returns and the time a corresponding `vkDestroy*` command
begins, that implementation :normative{type="must"} save a copy of the allocator before the
`vkCreate*` command returns.
The callback functions and any data structures they rely upon :normative{type="must"} remain
valid for the lifetime of the object they are associated with.

If an allocator is provided to a `vkCreate*` command, a *compatible*
allocator :normative{type="must"} be provided to the corresponding `vkDestroy*` command.
Two `VkAllocationCallbacks` structures are compatible if memory
allocated with `pfnAllocation` or `pfnReallocation` in each :normative{type="can"} be
freed with `pfnReallocation` or `pfnFree` in the other.
An allocator :normative{type="must"} not be provided to a `vkDestroy*` command if an
allocator was not provided to the corresponding `vkCreate*` command.

If a non-`NULL` allocator is used, the `pfnAllocation`,
`pfnReallocation` and `pfnFree` members :normative{type="must"} be non-`NULL` and
point to valid implementations of the callbacks.
An application :normative{type="can"} choose to not provide informational callbacks by setting
both `pfnInternalAllocation` and `pfnInternalFree` to `NULL`.
`pfnInternalAllocation` and `pfnInternalFree` :normative{type="must"} either both be
`NULL` or both be non-`NULL`.

If `pfnAllocation` or `pfnReallocation` fail, the implementation
:normative{type="may"} fail object creation and/or generate a
`VK_ERROR_OUT_OF_HOST_MEMORY` error, as appropriate.

Allocation callbacks :normative{type="must"} not call any Vulkan commands.

The following sets of rules define when an implementation is permitted to
call the allocator callbacks.

`pfnAllocation` or `pfnReallocation` :normative{type="may"} be called in the following
situations:

- Allocations scoped to a `VkDevice` or `VkInstance` :normative{type="may"} be
  allocated from any API command.

- Allocations scoped to a command :normative{type="may"} be allocated from any API command.

- Allocations scoped to a `VkPipelineCache` :normative{type="may"} only be allocated
  from:





  * `vkCreatePipelineCache`

  * `vkMergePipelineCaches` for `dstCache`

  * `vkCreateGraphicsPipelines` for `pipelineCache`

  * `vkCreateComputePipelines` for `pipelineCache`

- Allocations scoped to a `VkDescriptorPool` :normative{type="may"} only be allocated
  from:





  * any command that takes the pool as a direct argument

  * `vkAllocateDescriptorSets` for the `descriptorPool` member of
    its `pAllocateInfo` parameter

  * `vkCreateDescriptorPool`

- Allocations scoped to a `VkCommandPool` :normative{type="may"} only be allocated from:





  * any command that takes the pool as a direct argument

  * `vkCreateCommandPool`

  * `vkAllocateCommandBuffers` for the `commandPool` member of its
    `pAllocateInfo` parameter

  * any `vkCmd*` command whose `commandBuffer` was allocated from
    that `VkCommandPool`

- Allocations scoped to any other object :normative{type="may"} only be allocated in that
  object’s `vkCreate*` command.

`pfnFree`, or `pfnReallocation` with zero `size`, :normative{type="may"} be called
in the following situations:

- Allocations scoped to a `VkDevice` or `VkInstance` :normative{type="may"} be freed
  from any API command.

- Allocations scoped to a command :normative{type="must"} be freed by any API command which
  allocates such memory.

- Allocations scoped to a `VkPipelineCache` :normative{type="may"} be freed from
  `vkDestroyPipelineCache`.

- Allocations scoped to a `VkDescriptorPool` :normative{type="may"} be freed from





  * any command that takes the pool as a direct argument

- Allocations scoped to a `VkCommandPool` :normative{type="may"} be freed from:





  * any command that takes the pool as a direct argument

  * `vkResetCommandBuffer` whose `commandBuffer` was allocated from
    that `VkCommandPool`

- Allocations scoped to any other object :normative{type="may"} be freed in that object’s
  `vkDestroy*` command.

- Any command that allocates host memory :normative{type="may"} also free host memory of the
  same scope.





## Device Memory

*Device memory* is memory that is visible to the device — for example the
contents of the image or buffer objects, which :normative{type="can"} be natively used by the
device.



### Device Memory Properties

Memory properties of a physical device describe the memory heaps and memory
types available.

To query memory properties, call:

[{generated}/api/protos/vkGetPhysicalDeviceMemoryProperties.adoc]({generated}/api/protos/vkGetPhysicalDeviceMemoryProperties.adoc)

- `physicalDevice` is the handle to the device to query.

- `pMemoryProperties` is a pointer to a
  [VkPhysicalDeviceMemoryProperties](/man/VkPhysicalDeviceMemoryProperties) structure in which the properties
  are returned.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkGetPhysicalDeviceMemoryProperties-physicalDevice-parameter"}
 `physicalDevice` :normative{type="must"} be a valid [VkPhysicalDevice](/man/VkPhysicalDevice) handle
::

::validity-field{name="VUID-vkGetPhysicalDeviceMemoryProperties-pMemoryProperties-parameter"}
 `pMemoryProperties` :normative{type="must"} be a valid pointer to a [VkPhysicalDeviceMemoryProperties](/man/VkPhysicalDeviceMemoryProperties) structure
::

::


The `VkPhysicalDeviceMemoryProperties` structure is defined as:

[{generated}/api/structs/VkPhysicalDeviceMemoryProperties.adoc]({generated}/api/structs/VkPhysicalDeviceMemoryProperties.adoc)

- `memoryTypeCount` is the number of valid elements in the
  `memoryTypes` array.

- `memoryTypes` is an array of `VK_MAX_MEMORY_TYPES`

  [VkMemoryType](/man/VkMemoryType) structures describing the *memory types* that :normative{type="can"} be
  used to access memory allocated from the heaps specified by
  `memoryHeaps`.

- `memoryHeapCount` is the number of valid elements in the
  `memoryHeaps` array.

- `memoryHeaps` is an array of `VK_MAX_MEMORY_HEAPS`

  [VkMemoryHeap](/man/VkMemoryHeap) structures describing the *memory heaps* from which
  memory :normative{type="can"} be allocated.

The `VkPhysicalDeviceMemoryProperties` structure describes a number of
*memory heaps* as well as a number of *memory types* that :normative{type="can"} be used to
access memory allocated in those heaps.
Each heap describes a memory resource of a particular size, and each memory
type describes a set of memory properties (e.g. host cached vs. uncached)
that :normative{type="can"} be used with a given memory heap.
Allocations using a particular memory type will consume resources from the
heap indicated by that memory type’s heap index.
More than one memory type :normative{type="may"} share each heap, and the heaps and memory
types provide a mechanism to advertise an accurate size of the physical
memory resources while allowing the memory to be used with a variety of
different properties.

The number of memory heaps is given by `memoryHeapCount` and is less
than or equal to `VK_MAX_MEMORY_HEAPS`.
Each heap is described by an element of the `memoryHeaps` array as a
[VkMemoryHeap](/man/VkMemoryHeap) structure.
The number of memory types available across all memory heaps is given by
`memoryTypeCount` and is less than or equal to
`VK_MAX_MEMORY_TYPES`.
Each memory type is described by an element of the `memoryTypes` array
as a [VkMemoryType](/man/VkMemoryType) structure.

At least one heap :normative{type="must"} include `VK_MEMORY_HEAP_DEVICE_LOCAL_BIT` in
[VkMemoryHeap](/man/VkMemoryHeap)::`flags`.
If there are multiple heaps that all have similar performance
characteristics, they :normative{type="may"} all include
`VK_MEMORY_HEAP_DEVICE_LOCAL_BIT`.
In a unified memory architecture (UMA) system there is often only a single
memory heap which is considered to be equally > local to the host and to
the device, and such an implementation :normative{type="must"} advertise the heap as
device-local.

Each memory type returned by [vkGetPhysicalDeviceMemoryProperties](/man/vkGetPhysicalDeviceMemoryProperties) :normative{type="must"}
have its `propertyFlags` set to one of the following values:

- 0

- `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` |\


  `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT`

- `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` |\


  `VK_MEMORY_PROPERTY_HOST_CACHED_BIT`

- `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` |\


  `VK_MEMORY_PROPERTY_HOST_CACHED_BIT` |\


  `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT`

- `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`

- `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` |\


  `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` |\


  `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT`

- `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` |\


  `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` |\


  `VK_MEMORY_PROPERTY_HOST_CACHED_BIT`

- `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` |\


  `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` |\


  `VK_MEMORY_PROPERTY_HOST_CACHED_BIT` |\


  `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT`

- `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` |\


  `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT`

There :normative{type="must"} be at least one memory type with both the
`VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` and
`VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` bits set in its
`propertyFlags`.
There :normative{type="must"} be at least one memory type with the
`VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` bit set in its
`propertyFlags`.

For each pair of elements *X* and *Y* returned in `memoryTypes`, *X*
:normative{type="must"} be placed at a lower index position than *Y* if:

- the set of bit flags returned in the `propertyFlags` member of *X*
  is a strict subset of the set of bit flags returned in the
  `propertyFlags` member of *Y*; or

- the `propertyFlags` members of *X* and *Y* are equal, and *X*
  belongs to a memory heap with greater performance (as determined in an
  implementation-specific manner)


::note
There is no ordering requirement between *X* and *Y* elements for the case
their `propertyFlags` members are not in a subset relation.
That potentially allows more than one possible way to order the same set of
memory types.
Notice that the list of all allowed memory
property flag combinations is written in a valid order.
But if instead `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` was before
`VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` |
`VK_MEMORY_PROPERTY_HOST_COHERENT_BIT`, the list would still be in a
valid order.
::


This ordering requirement enables applications to use a simple search loop
to select the desired memory type along the lines of:



`VK_MAX_MEMORY_TYPES` is the length of an array of [VkMemoryType](/man/VkMemoryType)
structures describing memory types, as returned in
[VkPhysicalDeviceMemoryProperties](/man/VkPhysicalDeviceMemoryProperties)::`memoryTypes`.

[{generated}/api/enums/VK\_MAX\_MEMORY\_TYPES.adoc]({generated}/api/enums/VK_MAX_MEMORY_TYPES.adoc)

`VK_MAX_MEMORY_HEAPS` is the length of an array of [VkMemoryHeap](/man/VkMemoryHeap)
structures describing memory heaps, as returned in
[VkPhysicalDeviceMemoryProperties](/man/VkPhysicalDeviceMemoryProperties)::`memoryHeaps`.

[{generated}/api/enums/VK\_MAX\_MEMORY\_HEAPS.adoc]({generated}/api/enums/VK_MAX_MEMORY_HEAPS.adoc)

The `VkMemoryHeap` structure is defined as:

[{generated}/api/structs/VkMemoryHeap.adoc]({generated}/api/structs/VkMemoryHeap.adoc)

- `size` is the total memory size in bytes in the heap.

- `flags` is a bitmask of [VkMemoryHeapFlagBits](/man/VkMemoryHeapFlagBits) specifying
  attribute flags for the heap.

Bits which :normative{type="may"} be set in [VkMemoryHeap](/man/VkMemoryHeap)::`flags`, indicating
attribute flags for the heap, are:

[{generated}/api/enums/VkMemoryHeapFlagBits.adoc]({generated}/api/enums/VkMemoryHeapFlagBits.adoc)

- `VK_MEMORY_HEAP_DEVICE_LOCAL_BIT` specifies that the heap
  corresponds to device-local memory.
  Device-local memory :normative{type="may"} have different performance characteristics than
  host-local memory, and :normative{type="may"} support different memory property flags.

[{generated}/api/flags/VkMemoryHeapFlags.adoc]({generated}/api/flags/VkMemoryHeapFlags.adoc)

`VkMemoryHeapFlags` is a bitmask type for setting a mask of zero or more
[VkMemoryHeapFlagBits](/man/VkMemoryHeapFlagBits).

The `VkMemoryType` structure is defined as:

[{generated}/api/structs/VkMemoryType.adoc]({generated}/api/structs/VkMemoryType.adoc)

- `heapIndex` describes which memory heap this memory type corresponds
  to, and :normative{type="must"} be less than `memoryHeapCount` from the
  [VkPhysicalDeviceMemoryProperties](/man/VkPhysicalDeviceMemoryProperties) structure.

- `propertyFlags` is a bitmask of [VkMemoryPropertyFlagBits](/man/VkMemoryPropertyFlagBits) of
  properties for this memory type.

Bits which :normative{type="may"} be set in [VkMemoryType](/man/VkMemoryType)::`propertyFlags`,
indicating properties of a memory type, are:

[{generated}/api/enums/VkMemoryPropertyFlagBits.adoc]({generated}/api/enums/VkMemoryPropertyFlagBits.adoc)

- `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` bit specifies that memory
  allocated with this type is the most efficient for device access.
  This property will be set if and only if the memory type belongs to a
  heap with the `VK_MEMORY_HEAP_DEVICE_LOCAL_BIT` set.

- `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` bit specifies that memory
  allocated with this type :normative{type="can"} be mapped for host access using
  [vkMapMemory](/man/vkMapMemory).

- `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` bit specifies that the host
  cache management commands [vkFlushMappedMemoryRanges](/man/vkFlushMappedMemoryRanges) and
  [vkInvalidateMappedMemoryRanges](/man/vkInvalidateMappedMemoryRanges) are not needed to flush host writes
  to the device or make device writes visible to the host, respectively.

- `VK_MEMORY_PROPERTY_HOST_CACHED_BIT` bit specifies that memory
  allocated with this type is cached on the host.
  Host memory accesses to uncached memory are slower than to cached
  memory, however uncached memory is always host coherent.

- `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT` bit specifies that the
  memory type only allows device access to the memory.
  Memory types :normative{type="must"} not have both
  `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT` and
  `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` set.
  Additionally, the object’s backing memory :normative{type="may"} be provided by the
  implementation lazily as specified in Lazily Allocated Memory.

[{generated}/api/flags/VkMemoryPropertyFlags.adoc]({generated}/api/flags/VkMemoryPropertyFlags.adoc)

`VkMemoryPropertyFlags` is a bitmask type for setting a mask of zero or
more [VkMemoryPropertyFlagBits](/man/VkMemoryPropertyFlagBits).





### Device Memory Objects

A Vulkan device operates on data in device memory via memory objects that
are represented in the API by a `VkDeviceMemory` handle:

[{generated}/api/handles/VkDeviceMemory.adoc]({generated}/api/handles/VkDeviceMemory.adoc)





### Device Memory Allocation

To allocate memory objects, call:

[{generated}/api/protos/vkAllocateMemory.adoc]({generated}/api/protos/vkAllocateMemory.adoc)

- `device` is the logical device that owns the memory.

- `pAllocateInfo` is a pointer to a [VkMemoryAllocateInfo](/man/VkMemoryAllocateInfo)
  structure describing parameters of the allocation.
  A successfully returned allocation :normative{type="must"} use the requested parameters — no substitution is permitted by the implementation.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

- `pMemory` is a pointer to a [VkDeviceMemory](/man/VkDeviceMemory) handle in which
  information about the allocated memory is returned.

Allocations returned by `vkAllocateMemory` are guaranteed to meet any
alignment requirement of the implementation.
For example, if an implementation requires 128 byte alignment for images and
64 byte alignment for buffers, the device memory returned through this
mechanism would be 128-byte aligned.
This ensures that applications :normative{type="can"} correctly suballocate objects of
different types (with potentially different alignment requirements) in the
same memory object.

When memory is allocated, its contents are undefined:.

The maximum number of valid memory allocations that :normative{type="can"} exist
simultaneously within a [VkDevice](/man/VkDevice) :normative{type="may"} be restricted by implementation-
or platform-dependent limits.
The `maxMemoryAllocationCount`
feature describes the number of allocations that :normative{type="can"} exist simultaneously
before encountering these internal limits.


::note
For historical reasons, if `maxMemoryAllocationCount` is exceeded, some
implementations may return `VK_ERROR_TOO_MANY_OBJECTS`.
Exceeding this limit will result in undefined: behavior, and an application
should not rely on the use of the returned error code in order to identify
when the limit is reached.
::



::note
Many protected memory implementations involve complex hardware and system
software support, and often have additional and much lower limits on the
number of simultaneous protected memory allocations (from memory types with
the `VK_MEMORY_PROPERTY_PROTECTED_BIT` property) than for non-protected
memory allocations.
These limits can be system-wide, and depend on a variety of factors outside
of the Vulkan implementation, so they cannot be queried in Vulkan.
Applications :normative{type="should"} use as few allocations as possible from such memory
types by suballocating aggressively, and be prepared for allocation failure
even when there is apparently plenty of capacity remaining in the memory
heap.
As a guideline, the Vulkan conformance test suite requires that at least 80
minimum-size allocations can exist concurrently when no other uses of
protected memory are active in the system.
::


Some platforms :normative{type="may"} have a limit on the maximum size of a single allocation.
For example, certain systems :normative{type="may"} fail to create allocations with a size
greater than or equal to 4GB.
Such a limit is implementation-dependent, and if such a failure occurs then
the error `VK_ERROR_OUT_OF_DEVICE_MEMORY` :normative{type="must"} be returned.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkAllocateMemory-pAllocateInfo-01713"}
`pAllocateInfo→allocationSize` :normative{type="must"} be less than or equal to
[VkPhysicalDeviceMemoryProperties](/man/VkPhysicalDeviceMemoryProperties)::`memoryHeaps`[`memindex`].`size`
where `memindex` =
[VkPhysicalDeviceMemoryProperties](/man/VkPhysicalDeviceMemoryProperties)::`memoryTypes`[`pAllocateInfo→memoryTypeIndex`].`heapIndex`
as returned by [vkGetPhysicalDeviceMemoryProperties](/man/vkGetPhysicalDeviceMemoryProperties) for the
[VkPhysicalDevice](/man/VkPhysicalDevice) that `device` was created from
::

::validity-field{name="VUID-vkAllocateMemory-pAllocateInfo-01714"}
`pAllocateInfo→memoryTypeIndex` :normative{type="must"} be less than
[VkPhysicalDeviceMemoryProperties](/man/VkPhysicalDeviceMemoryProperties)::`memoryTypeCount` as
returned by [vkGetPhysicalDeviceMemoryProperties](/man/vkGetPhysicalDeviceMemoryProperties) for the
[VkPhysicalDevice](/man/VkPhysicalDevice) that `device` was created from
::

::validity-field{name="VUID-vkAllocateMemory-maxMemoryAllocationCount-04101"}

There :normative{type="must"} be less than
`VkPhysicalDeviceLimits`::`maxMemoryAllocationCount` device
memory allocations currently allocated on the device
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkAllocateMemory-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkAllocateMemory-pAllocateInfo-parameter"}
 `pAllocateInfo` :normative{type="must"} be a valid pointer to a valid [VkMemoryAllocateInfo](/man/VkMemoryAllocateInfo) structure
::

::validity-field{name="VUID-vkAllocateMemory-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkAllocateMemory-pMemory-parameter"}
 `pMemory` :normative{type="must"} be a valid pointer to a [VkDeviceMemory](/man/VkDeviceMemory) handle
::

::




The `VkMemoryAllocateInfo` structure is defined as:

[{generated}/api/structs/VkMemoryAllocateInfo.adoc]({generated}/api/structs/VkMemoryAllocateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `allocationSize` is the size of the allocation in bytes.

- `memoryTypeIndex` is an index identifying a memory type from the
  `memoryTypes` array of the [VkPhysicalDeviceMemoryProperties](/man/VkPhysicalDeviceMemoryProperties)
  structure.

The internal data of an allocated device memory object :normative{type="must"} include a
reference to implementation-specific resources, referred to as the memory
object’s *payload*.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkMemoryAllocateInfo-allocationSize-07897"}
`allocationSize` :normative{type="must"} be greater than `0`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkMemoryAllocateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO`
::

::validity-field{name="VUID-VkMemoryAllocateInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkDedicatedAllocationMemoryAllocateInfoNV](/man/VkDedicatedAllocationMemoryAllocateInfoNV), [VkExportMemoryAllocateInfo](/man/VkExportMemoryAllocateInfo), [VkExportMemoryAllocateInfoNV](/man/VkExportMemoryAllocateInfoNV), [VkExportMemoryWin32HandleInfoKHR](/man/VkExportMemoryWin32HandleInfoKHR), [VkExportMemoryWin32HandleInfoNV](/man/VkExportMemoryWin32HandleInfoNV), [VkExportMetalObjectCreateInfoEXT](/man/VkExportMetalObjectCreateInfoEXT), [VkImportAndroidHardwareBufferInfoANDROID](/man/VkImportAndroidHardwareBufferInfoANDROID), [VkImportMemoryBufferCollectionFUCHSIA](/man/VkImportMemoryBufferCollectionFUCHSIA), [VkImportMemoryFdInfoKHR](/man/VkImportMemoryFdInfoKHR), [VkImportMemoryHostPointerInfoEXT](/man/VkImportMemoryHostPointerInfoEXT), [VkImportMemoryWin32HandleInfoKHR](/man/VkImportMemoryWin32HandleInfoKHR), [VkImportMemoryWin32HandleInfoNV](/man/VkImportMemoryWin32HandleInfoNV), [VkImportMemoryZirconHandleInfoFUCHSIA](/man/VkImportMemoryZirconHandleInfoFUCHSIA), [VkImportMetalBufferInfoEXT](/man/VkImportMetalBufferInfoEXT), [VkImportScreenBufferInfoQNX](/man/VkImportScreenBufferInfoQNX), [VkMemoryAllocateFlagsInfo](/man/VkMemoryAllocateFlagsInfo), [VkMemoryDedicatedAllocateInfo](/man/VkMemoryDedicatedAllocateInfo), [VkMemoryOpaqueCaptureAddressAllocateInfo](/man/VkMemoryOpaqueCaptureAddressAllocateInfo), or [VkMemoryPriorityAllocateInfoEXT](/man/VkMemoryPriorityAllocateInfoEXT)
::

::validity-field{name="VUID-VkMemoryAllocateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique, with the exception of structures of type [VkExportMetalObjectCreateInfoEXT](/man/VkExportMetalObjectCreateInfoEXT)
::

::






### Freeing Device Memory

To free a memory object, call:

[{generated}/api/protos/vkFreeMemory.adoc]({generated}/api/protos/vkFreeMemory.adoc)

- `device` is the logical device that owns the memory.

- `memory` is the [VkDeviceMemory](/man/VkDeviceMemory) object to be freed.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

Before freeing a memory object, an application :normative{type="must"} ensure the memory
object is no longer in use by the device — for example by command buffers
in the *pending state*.
Memory :normative{type="can"} be freed whilst still bound to resources, but those resources
:normative{type="must"} not be used afterwards.
Freeing a memory object releases the reference it held, if any, to its
payload.
If there are still any bound images or buffers, the memory object’s payload
:normative{type="may"} not be immediately released by the implementation, but :normative{type="must"} be
released by the time all bound images and buffers have been destroyed.
Once all references to a payload are released, it is returned to the heap
from which it was allocated.

How memory objects are bound to Images and Buffers is described in detail in
the Resource Memory Association section.

If a memory object is mapped at the time it is freed, it is implicitly
unmapped.


::note
As described below, host writes are
not implicitly flushed when the memory object is unmapped, but the
implementation :normative{type="must"} guarantee that writes that have not been flushed do not
affect any other memory.
::



::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkFreeMemory-memory-00677"}

All submitted commands that refer to `memory` (via images or
buffers) :normative{type="must"} have completed execution
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkFreeMemory-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkFreeMemory-memory-parameter"}
 If `memory` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `memory` :normative{type="must"} be a valid [VkDeviceMemory](/man/VkDeviceMemory) handle
::

::validity-field{name="VUID-vkFreeMemory-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkFreeMemory-memory-parent"}
 If `memory` is a valid handle, it :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::








### Host Access to Device Memory Objects

Memory objects created with [vkAllocateMemory](/man/vkAllocateMemory) are not directly host
accessible.

Memory objects created with the memory property
`VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` are considered *mappable*.
Memory objects :normative{type="must"} be mappable in order to be successfully mapped on the
host.

To retrieve a host virtual address pointer to a region of a mappable memory
object, call:

[{generated}/api/protos/vkMapMemory.adoc]({generated}/api/protos/vkMapMemory.adoc)

- `device` is the logical device that owns the memory.

- `memory` is the [VkDeviceMemory](/man/VkDeviceMemory) object to be mapped.

- `offset` is a zero-based byte offset from the beginning of the
  memory object.

- `size` is the size of the memory range to map, or
  `VK_WHOLE_SIZE` to map from `offset` to the end of the
  allocation.

- `flags` is reserved for future use.

- `ppData` is a pointer to a `void*` variable in which a
  host-accessible pointer to the beginning of the mapped range is
  returned.
  This pointer minus `offset` :normative{type="must"} be aligned to at least
  [VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits)::`minMemoryMapAlignment`.

After a successful call to `vkMapMemory` the memory object `memory`
is considered to be currently *host mapped*.


::note
It is an application error to call `vkMapMemory` on a memory object that
is already *host mapped*.
::



::note
`vkMapMemory` will fail if the implementation is unable to allocate an
appropriately sized contiguous virtual address range, e.g. due to virtual
address space fragmentation or platform limits.
In such cases, `vkMapMemory` :normative{type="must"} return
`VK_ERROR_MEMORY_MAP_FAILED`.
The application :normative{type="can"} improve the likelihood of success by reducing the size
of the mapped range and/or removing unneeded mappings using
[vkUnmapMemory](/man/vkUnmapMemory).
::


`vkMapMemory` does not check whether the device memory is currently in
use before returning the host-accessible pointer.
The application :normative{type="must"} guarantee that any previously submitted command that
writes to this range has completed before the host reads from or writes to
that range, and that any previously submitted command that reads from that
range has completed before the host writes to that region (see
here for details on fulfilling
such a guarantee).
If the device memory was allocated without the
`VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` set, these guarantees :normative{type="must"} be
made for an extended range: the application :normative{type="must"} round down the start of
the range to the nearest multiple of
[VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits)::`nonCoherentAtomSize`, and round the end
of the range up to the nearest multiple of
[VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits)::`nonCoherentAtomSize`.

While a range of device memory is host mapped, the application is
responsible for synchronizing both device and host access to that memory
range.


::note
It is important for the application developer to become meticulously
familiar with all of the mechanisms described in the chapter on
Synchronization and Cache Control as they are crucial
to maintaining memory access ordering.
::



::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkMapMemory-memory-00678"}
`memory` :normative{type="must"} not be currently host mapped
::

::validity-field{name="VUID-vkMapMemory-offset-00679"}
`offset` :normative{type="must"} be less than the size of `memory`
::

::validity-field{name="VUID-vkMapMemory-size-00680"}

If `size` is not equal to `VK_WHOLE_SIZE`, `size` :normative{type="must"} be
greater than `0`
::

::validity-field{name="VUID-vkMapMemory-size-00681"}

If `size` is not equal to `VK_WHOLE_SIZE`, `size` :normative{type="must"} be
less than or equal to the size of the `memory` minus `offset`
::

::validity-field{name="VUID-vkMapMemory-memory-00682"}
`memory` :normative{type="must"} have been created with a memory type that reports
`VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkMapMemory-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkMapMemory-memory-parameter"}
 `memory` :normative{type="must"} be a valid [VkDeviceMemory](/man/VkDeviceMemory) handle
::

::validity-field{name="VUID-vkMapMemory-flags-zerobitmask"}
 `flags` :normative{type="must"} be `0`
::

::validity-field{name="VUID-vkMapMemory-ppData-parameter"}
 `ppData` :normative{type="must"} be a valid pointer to a pointer value
::

::validity-field{name="VUID-vkMapMemory-memory-parent"}
 `memory` :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::






[{generated}/api/flags/VkMemoryMapFlags.adoc]({generated}/api/flags/VkMemoryMapFlags.adoc)

`VkMemoryMapFlags` is a bitmask type for setting a mask, but is
currently reserved for future use.

Two commands are provided to enable applications to work with non-coherent
memory allocations: `vkFlushMappedMemoryRanges` and
`vkInvalidateMappedMemoryRanges`.


::note
If the memory object was created with the
`VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` set,
`vkFlushMappedMemoryRanges` and `vkInvalidateMappedMemoryRanges` are
unnecessary and :normative{type="may"} have a performance cost.
However, availability
and visibility operations still need to be managed on the device.
See the description of host access
types for more information.
::


After a successful call to `vkMapMemory`
the memory object `memory` is considered to be currently *host mapped*.

To flush ranges of non-coherent memory from the host caches, call:

[{generated}/api/protos/vkFlushMappedMemoryRanges.adoc]({generated}/api/protos/vkFlushMappedMemoryRanges.adoc)

- `device` is the logical device that owns the memory ranges.

- `memoryRangeCount` is the length of the `pMemoryRanges` array.

- `pMemoryRanges` is a pointer to an array of
  [VkMappedMemoryRange](/man/VkMappedMemoryRange) structures describing the memory ranges to
  flush.

`vkFlushMappedMemoryRanges` guarantees that host writes to the memory
ranges described by `pMemoryRanges` are made available to the host
memory domain, such that they :normative{type="can"} be made available to the device memory
domain via memory
domain operations using the `VK_ACCESS_HOST_WRITE_BIT`

access type.

Within each range described by `pMemoryRanges`, each set of
`nonCoherentAtomSize` bytes in that range is flushed if any byte in that
set has been written by the host since it was first host mapped, or the last
time it was flushed.
If `pMemoryRanges` includes sets of `nonCoherentAtomSize` bytes
where no bytes have been written by the host, those bytes :normative{type="must"} not be
flushed.

Unmapping non-coherent memory does not implicitly flush the host mapped
memory, and host writes that have not been flushed :normative{type="may"} not ever be visible
to the device.
However, implementations :normative{type="must"} ensure that writes that have not been flushed
do not become visible to any other memory.


::note
The above guarantee avoids a potential memory corruption in scenarios where
host writes to a mapped memory object have not been flushed before the
memory is unmapped (or freed), and the virtual address range is subsequently
reused for a different mapping (or memory allocation).
::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkFlushMappedMemoryRanges-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkFlushMappedMemoryRanges-pMemoryRanges-parameter"}
 `pMemoryRanges` :normative{type="must"} be a valid pointer to an array of `memoryRangeCount` valid [VkMappedMemoryRange](/man/VkMappedMemoryRange) structures
::

::validity-field{name="VUID-vkFlushMappedMemoryRanges-memoryRangeCount-arraylength"}
 `memoryRangeCount` :normative{type="must"} be greater than `0`
::

::




To invalidate ranges of non-coherent memory from the host caches, call:

[{generated}/api/protos/vkInvalidateMappedMemoryRanges.adoc]({generated}/api/protos/vkInvalidateMappedMemoryRanges.adoc)

- `device` is the logical device that owns the memory ranges.

- `memoryRangeCount` is the length of the `pMemoryRanges` array.

- `pMemoryRanges` is a pointer to an array of
  [VkMappedMemoryRange](/man/VkMappedMemoryRange) structures describing the memory ranges to
  invalidate.

`vkInvalidateMappedMemoryRanges` guarantees that device writes to the
memory ranges described by `pMemoryRanges`, which have been made
available to the host memory domain using the `VK_ACCESS_HOST_WRITE_BIT`
and `VK_ACCESS_HOST_READ_BIT` access
types, are made visible to the host.
If a range of non-coherent memory is written by the host and then
invalidated without first being flushed, its contents are undefined:.

Within each range described by `pMemoryRanges`, each set of
`nonCoherentAtomSize` bytes in that range is invalidated if any byte in
that set has been written by the device since it was first host mapped, or
the last time it was invalidated.


::note
Mapping non-coherent memory does not implicitly invalidate that memory.
::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkInvalidateMappedMemoryRanges-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkInvalidateMappedMemoryRanges-pMemoryRanges-parameter"}
 `pMemoryRanges` :normative{type="must"} be a valid pointer to an array of `memoryRangeCount` valid [VkMappedMemoryRange](/man/VkMappedMemoryRange) structures
::

::validity-field{name="VUID-vkInvalidateMappedMemoryRanges-memoryRangeCount-arraylength"}
 `memoryRangeCount` :normative{type="must"} be greater than `0`
::

::




The `VkMappedMemoryRange` structure is defined as:

[{generated}/api/structs/VkMappedMemoryRange.adoc]({generated}/api/structs/VkMappedMemoryRange.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `memory` is the memory object to which this range belongs.

- `offset` is the zero-based byte offset from the beginning of the
  memory object.

- `size` is either the size of range, or `VK_WHOLE_SIZE` to affect
  the range from `offset` to the end of the current mapping of the
  allocation.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkMappedMemoryRange-memory-00684"}
`memory` :normative{type="must"} be currently host mapped
::

::validity-field{name="VUID-VkMappedMemoryRange-size-00685"}

If `size` is not equal to `VK_WHOLE_SIZE`, `offset` and
`size` :normative{type="must"} specify a range contained within the currently mapped
range of `memory`
::

::validity-field{name="VUID-VkMappedMemoryRange-size-00686"}

If `size` is equal to `VK_WHOLE_SIZE`, `offset` :normative{type="must"} be
within the currently mapped range of `memory`
::

::validity-field{name="VUID-VkMappedMemoryRange-offset-00687"}
`offset` :normative{type="must"} be a multiple of
[VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits)::`nonCoherentAtomSize`
::

::validity-field{name="VUID-VkMappedMemoryRange-size-01389"}

If `size` is equal to `VK_WHOLE_SIZE`, the end of the current
mapping of `memory` :normative{type="must"} either be a multiple of
[VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits)::`nonCoherentAtomSize` bytes from the
beginning of the memory object, or be equal to the end of the memory
object
::

::validity-field{name="VUID-VkMappedMemoryRange-size-01390"}

If `size` is not equal to `VK_WHOLE_SIZE`, `size` :normative{type="must"}
either be a multiple of
[VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits)::`nonCoherentAtomSize`, or `offset`
plus `size` :normative{type="must"} equal the size of `memory`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkMappedMemoryRange-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE`
::

::validity-field{name="VUID-VkMappedMemoryRange-pNext-pNext"}
 `pNext` :normative{type="must"} be `NULL`
::

::validity-field{name="VUID-VkMappedMemoryRange-memory-parameter"}
 `memory` :normative{type="must"} be a valid [VkDeviceMemory](/man/VkDeviceMemory) handle
::

::


To unmap a memory object once host access to it is no longer needed by the
application, call:

[{generated}/api/protos/vkUnmapMemory.adoc]({generated}/api/protos/vkUnmapMemory.adoc)

- `device` is the logical device that owns the memory.

- `memory` is the memory object to be unmapped.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkUnmapMemory-memory-00689"}
`memory` :normative{type="must"} be currently host mapped
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkUnmapMemory-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkUnmapMemory-memory-parameter"}
 `memory` :normative{type="must"} be a valid [VkDeviceMemory](/man/VkDeviceMemory) handle
::

::validity-field{name="VUID-vkUnmapMemory-memory-parent"}
 `memory` :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::








### Lazily Allocated Memory

If the memory object is allocated from a heap with the
`VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT` bit set, that object’s backing
memory :normative{type="may"} be provided by the implementation lazily.
The actual committed size of the memory :normative{type="may"} initially be as small as zero
(or as large as the requested size), and monotonically increases as
additional memory is needed.

A memory type with this flag set is only allowed to be bound to a
`VkImage` whose usage flags include
`VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`.


::note
Using lazily allocated memory objects for framebuffer attachments that are
not needed once a render pass instance has completed :normative{type="may"} allow some
implementations to never allocate memory for such attachments.
::


To determine the amount of lazily-allocated memory that is currently
committed for a memory object, call:

[{generated}/api/protos/vkGetDeviceMemoryCommitment.adoc]({generated}/api/protos/vkGetDeviceMemoryCommitment.adoc)

- `device` is the logical device that owns the memory.

- `memory` is the memory object being queried.

- `pCommittedMemoryInBytes` is a pointer to a [VkDeviceSize](/man/VkDeviceSize)
  value in which the number of bytes currently committed is returned, on
  success.

The implementation :normative{type="may"} update the commitment at any time, and the value
returned by this query :normative{type="may"} be out of date.

The implementation guarantees to allocate any committed memory from the
`heapIndex` indicated by the memory type that the memory object was
created with.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkGetDeviceMemoryCommitment-memory-00690"}
`memory` :normative{type="must"} have been created with a memory type that reports
`VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkGetDeviceMemoryCommitment-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkGetDeviceMemoryCommitment-memory-parameter"}
 `memory` :normative{type="must"} be a valid [VkDeviceMemory](/man/VkDeviceMemory) handle
::

::validity-field{name="VUID-vkGetDeviceMemoryCommitment-pCommittedMemoryInBytes-parameter"}
 `pCommittedMemoryInBytes` :normative{type="must"} be a valid pointer to a [VkDeviceSize](/man/VkDeviceSize) value
::

::validity-field{name="VUID-vkGetDeviceMemoryCommitment-memory-parent"}
 `memory` :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::










# Resource Creation

Vulkan supports two primary resource types: *buffers* and *images*.
Resources are views of memory with associated formatting and dimensionality.
Buffers provide access to raw arrays of bytes, whereas images :normative{type="can"} be
multidimensional and :normative{type="may"} have associated metadata.



## Buffers

Buffers represent linear arrays of data which are used for various purposes
by binding them to a graphics or compute pipeline via descriptor sets or
certain commands, or by directly specifying them as parameters to certain
commands.

Buffers are represented by `VkBuffer` handles:

[{generated}/api/handles/VkBuffer.adoc]({generated}/api/handles/VkBuffer.adoc)

To create buffers, call:

[{generated}/api/protos/vkCreateBuffer.adoc]({generated}/api/protos/vkCreateBuffer.adoc)

- `device` is the logical device that creates the buffer object.

- `pCreateInfo` is a pointer to a [VkBufferCreateInfo](/man/VkBufferCreateInfo) structure
  containing parameters affecting creation of the buffer.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

- `pBuffer` is a pointer to a [VkBuffer](/man/VkBuffer) handle in which the
  resulting buffer object is returned.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCreateBuffer-flags-00911"}

If the `flags` member of `pCreateInfo` includes
`VK_BUFFER_CREATE_SPARSE_BINDING_BIT`,
creating this `VkBuffer` :normative{type="must"} not cause the total required sparse
memory for all currently valid sparse resources on the device to exceed
`VkPhysicalDeviceLimits`::`sparseAddressSpaceSize`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCreateBuffer-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkCreateBuffer-pCreateInfo-parameter"}
 `pCreateInfo` :normative{type="must"} be a valid pointer to a valid [VkBufferCreateInfo](/man/VkBufferCreateInfo) structure
::

::validity-field{name="VUID-vkCreateBuffer-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkCreateBuffer-pBuffer-parameter"}
 `pBuffer` :normative{type="must"} be a valid pointer to a [VkBuffer](/man/VkBuffer) handle
::

::




The `VkBufferCreateInfo` structure is defined as:

[{generated}/api/structs/VkBufferCreateInfo.adoc]({generated}/api/structs/VkBufferCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is a bitmask of [VkBufferCreateFlagBits](/man/VkBufferCreateFlagBits) specifying
  additional parameters of the buffer.

- `size` is the size in bytes of the buffer to be created.

- `usage` is a bitmask of [VkBufferUsageFlagBits](/man/VkBufferUsageFlagBits) specifying
  allowed usages of the buffer.

- `sharingMode` is a [VkSharingMode](/man/VkSharingMode) value specifying the sharing
  mode of the buffer when it will be accessed by multiple queue families.

- `queueFamilyIndexCount` is the number of entries in the
  `pQueueFamilyIndices` array.

- `pQueueFamilyIndices` is a pointer to an array of queue families
  that will access this buffer.
  It is ignored if `sharingMode` is not
  `VK_SHARING_MODE_CONCURRENT`.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkBufferCreateInfo-size-00912"}
`size` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-VkBufferCreateInfo-sharingMode-00913"}

If `sharingMode` is `VK_SHARING_MODE_CONCURRENT`,
`pQueueFamilyIndices` :normative{type="must"} be a valid pointer to an array of
`queueFamilyIndexCount` `uint32_t` values
::

::validity-field{name="VUID-VkBufferCreateInfo-sharingMode-00914"}

If `sharingMode` is `VK_SHARING_MODE_CONCURRENT`,
`queueFamilyIndexCount` :normative{type="must"} be greater than `1`
::

::validity-field{name="VUID-VkBufferCreateInfo-sharingMode-01419"}

If `sharingMode` is `VK_SHARING_MODE_CONCURRENT`, each element
of `pQueueFamilyIndices` :normative{type="must"} be unique and :normative{type="must"} be less than
`pQueueFamilyPropertyCount` returned by
[vkGetPhysicalDeviceQueueFamilyProperties](/man/vkGetPhysicalDeviceQueueFamilyProperties) for the
`physicalDevice` that was used to create `device`
::

::validity-field{name="VUID-VkBufferCreateInfo-flags-00915"}

If the `sparseBinding` feature is not
enabled,
`flags` :normative{type="must"} not contain `VK_BUFFER_CREATE_SPARSE_BINDING_BIT`
::

::validity-field{name="VUID-VkBufferCreateInfo-flags-00916"}

If the `sparseResidencyBuffer`
feature is not enabled,
`flags` :normative{type="must"} not contain
`VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT`
::

::validity-field{name="VUID-VkBufferCreateInfo-flags-00917"}

If the `sparseResidencyAliased`
feature is not enabled,
`flags` :normative{type="must"} not contain `VK_BUFFER_CREATE_SPARSE_ALIASED_BIT`
::

::validity-field{name="VUID-VkBufferCreateInfo-flags-00918"}

If `flags` contains `VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT` or
`VK_BUFFER_CREATE_SPARSE_ALIASED_BIT`, it :normative{type="must"} also contain
`VK_BUFFER_CREATE_SPARSE_BINDING_BIT`
::

::validity-field{name="VUID-VkBufferCreateInfo-None-09205"}


`usage` must be a valid combination of [VkBufferUsageFlagBits](/man/VkBufferUsageFlagBits)
values
::

::validity-field{name="VUID-VkBufferCreateInfo-None-09206"}


`usage` :normative{type="must"} not be `0`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkBufferCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO`
::

::validity-field{name="VUID-VkBufferCreateInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkBufferCollectionBufferCreateInfoFUCHSIA](/man/VkBufferCollectionBufferCreateInfoFUCHSIA), [VkBufferDeviceAddressCreateInfoEXT](/man/VkBufferDeviceAddressCreateInfoEXT), [VkBufferOpaqueCaptureAddressCreateInfo](/man/VkBufferOpaqueCaptureAddressCreateInfo), [VkBufferUsageFlags2CreateInfoKHR](/man/VkBufferUsageFlags2CreateInfoKHR), [VkDedicatedAllocationBufferCreateInfoNV](/man/VkDedicatedAllocationBufferCreateInfoNV), [VkExternalMemoryBufferCreateInfo](/man/VkExternalMemoryBufferCreateInfo), [VkOpaqueCaptureDescriptorDataCreateInfoEXT](/man/VkOpaqueCaptureDescriptorDataCreateInfoEXT), or [VkVideoProfileListInfoKHR](/man/VkVideoProfileListInfoKHR)
::

::validity-field{name="VUID-VkBufferCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkBufferCreateInfo-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkBufferCreateFlagBits](/man/VkBufferCreateFlagBits) values
::

::validity-field{name="VUID-VkBufferCreateInfo-sharingMode-parameter"}
 `sharingMode` :normative{type="must"} be a valid [VkSharingMode](/man/VkSharingMode) value
::

::


Bits which :normative{type="can"} be set in [VkBufferCreateInfo](/man/VkBufferCreateInfo)::`usage`, specifying
usage behavior of a buffer, are:

[{generated}/api/enums/VkBufferUsageFlagBits.adoc]({generated}/api/enums/VkBufferUsageFlagBits.adoc)

- `VK_BUFFER_USAGE_TRANSFER_SRC_BIT` specifies that the buffer :normative{type="can"} be
  used as the source of a *transfer command* (see the definition of
  `VK_PIPELINE_STAGE_TRANSFER_BIT`).

- `VK_BUFFER_USAGE_TRANSFER_DST_BIT` specifies that the buffer :normative{type="can"} be
  used as the destination of a transfer command.

- `VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT` specifies that the buffer
  :normative{type="can"} be used to create a `VkBufferView` suitable for occupying a
  `VkDescriptorSet` slot of type
  `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER`.

- `VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT` specifies that the buffer
  :normative{type="can"} be used to create a `VkBufferView` suitable for occupying a
  `VkDescriptorSet` slot of type
  `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER`.

- `VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT` specifies that the buffer :normative{type="can"}
  be used in a `VkDescriptorBufferInfo` suitable for occupying a
  `VkDescriptorSet` slot either of type
  `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or
  `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`.

- `VK_BUFFER_USAGE_STORAGE_BUFFER_BIT` specifies that the buffer :normative{type="can"}
  be used in a `VkDescriptorBufferInfo` suitable for occupying a
  `VkDescriptorSet` slot either of type
  `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or
  `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`.

- `VK_BUFFER_USAGE_INDEX_BUFFER_BIT` specifies that the buffer is
  suitable for passing as the `buffer` parameter to
  [vkCmdBindIndexBuffer](/man/vkCmdBindIndexBuffer).

- `VK_BUFFER_USAGE_VERTEX_BUFFER_BIT` specifies that the buffer is
  suitable for passing as an element of the `pBuffers` array to
  [vkCmdBindVertexBuffers](/man/vkCmdBindVertexBuffers).

- `VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT` specifies that the buffer is
  suitable for passing as the `buffer` parameter to
  [vkCmdDrawIndirect](/man/vkCmdDrawIndirect), [vkCmdDrawIndexedIndirect](/man/vkCmdDrawIndexedIndirect),
  or [vkCmdDispatchIndirect](/man/vkCmdDispatchIndirect).

[{generated}/api/flags/VkBufferUsageFlags.adoc]({generated}/api/flags/VkBufferUsageFlags.adoc)

`VkBufferUsageFlags` is a bitmask type for setting a mask of zero or
more [VkBufferUsageFlagBits](/man/VkBufferUsageFlagBits).

Bits which :normative{type="can"} be set in [VkBufferCreateInfo](/man/VkBufferCreateInfo)::`flags`, specifying
additional parameters of a buffer, are:

[{generated}/api/enums/VkBufferCreateFlagBits.adoc]({generated}/api/enums/VkBufferCreateFlagBits.adoc)

- `VK_BUFFER_CREATE_SPARSE_BINDING_BIT` specifies that the buffer will
  be backed using sparse memory binding.

- `VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT` specifies that the buffer
  :normative{type="can"} be partially backed using sparse memory binding.
  Buffers created with this flag :normative{type="must"} also be created with the
  `VK_BUFFER_CREATE_SPARSE_BINDING_BIT` flag.

- `VK_BUFFER_CREATE_SPARSE_ALIASED_BIT` specifies that the buffer will
  be backed using sparse memory binding with memory ranges that might also
  simultaneously be backing another buffer (or another portion of the same
  buffer).
  Buffers created with this flag :normative{type="must"} also be created with the
  `VK_BUFFER_CREATE_SPARSE_BINDING_BIT` flag.

See Sparse Resource Features and
Physical Device Features for details of the sparse memory
features supported on a device.

[{generated}/api/flags/VkBufferCreateFlags.adoc]({generated}/api/flags/VkBufferCreateFlags.adoc)

`VkBufferCreateFlags` is a bitmask type for setting a mask of zero or
more [VkBufferCreateFlagBits](/man/VkBufferCreateFlagBits).

To destroy a buffer, call:

[{generated}/api/protos/vkDestroyBuffer.adoc]({generated}/api/protos/vkDestroyBuffer.adoc)

- `device` is the logical device that destroys the buffer.

- `buffer` is the buffer to destroy.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkDestroyBuffer-buffer-00922"}

All submitted commands that refer to `buffer`, either directly or
via a `VkBufferView`, :normative{type="must"} have completed execution
::

::validity-field{name="VUID-vkDestroyBuffer-buffer-00923"}

If `VkAllocationCallbacks` were provided when `buffer` was
created, a compatible set of callbacks :normative{type="must"} be provided here
::

::validity-field{name="VUID-vkDestroyBuffer-buffer-00924"}

If no `VkAllocationCallbacks` were provided when `buffer` was
created, `pAllocator` :normative{type="must"} be `NULL`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkDestroyBuffer-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkDestroyBuffer-buffer-parameter"}
 If `buffer` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `buffer` :normative{type="must"} be a valid [VkBuffer](/man/VkBuffer) handle
::

::validity-field{name="VUID-vkDestroyBuffer-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkDestroyBuffer-buffer-parent"}
 If `buffer` is a valid handle, it :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::








## Buffer Views

A *buffer view* represents a contiguous range of a buffer and a specific
format to be used to interpret the data.
Buffer views are used to enable shaders to access buffer contents using
image operations.
In order to create a valid buffer view, the buffer :normative{type="must"} have been created
with at least one of the following usage flags:

- `VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT`

- `VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT`

Buffer views are represented by `VkBufferView` handles:

[{generated}/api/handles/VkBufferView.adoc]({generated}/api/handles/VkBufferView.adoc)

To create a buffer view, call:

[{generated}/api/protos/vkCreateBufferView.adoc]({generated}/api/protos/vkCreateBufferView.adoc)

- `device` is the logical device that creates the buffer view.

- `pCreateInfo` is a pointer to a [VkBufferViewCreateInfo](/man/VkBufferViewCreateInfo)
  structure containing parameters to be used to create the buffer view.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

- `pView` is a pointer to a [VkBufferView](/man/VkBufferView) handle in which the
  resulting buffer view object is returned.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCreateBufferView-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkCreateBufferView-pCreateInfo-parameter"}
 `pCreateInfo` :normative{type="must"} be a valid pointer to a valid [VkBufferViewCreateInfo](/man/VkBufferViewCreateInfo) structure
::

::validity-field{name="VUID-vkCreateBufferView-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkCreateBufferView-pView-parameter"}
 `pView` :normative{type="must"} be a valid pointer to a [VkBufferView](/man/VkBufferView) handle
::

::




The `VkBufferViewCreateInfo` structure is defined as:

[{generated}/api/structs/VkBufferViewCreateInfo.adoc]({generated}/api/structs/VkBufferViewCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is reserved for future use.

- `buffer` is a [VkBuffer](/man/VkBuffer) on which the view will be created.

- `format` is a [VkFormat](/man/VkFormat) describing the format of the data
  elements in the buffer.

- `offset` is an offset in bytes from the base address of the buffer.
  Accesses to the buffer view from shaders use addressing that is relative
  to this starting offset.

- `range` is a size in bytes of the buffer view.
  If `range` is equal to `VK_WHOLE_SIZE`, the range from
  `offset` to the end of the buffer is used.
  If `VK_WHOLE_SIZE` is used and the remaining size of the buffer is
  not a multiple of the texel block size of
  `format`, the nearest smaller multiple is used.

The buffer view has a *buffer view usage* identifying which descriptor types
can be created from it.
This usage
is equal to the [VkBufferCreateInfo](/man/VkBufferCreateInfo)::`usage` value used to create
`buffer`.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkBufferViewCreateInfo-offset-00925"}
`offset` :normative{type="must"} be less than the size of `buffer`
::

::validity-field{name="VUID-VkBufferViewCreateInfo-range-00928"}

If `range` is not equal to `VK_WHOLE_SIZE`, `range` :normative{type="must"} be
greater than `0`
::

::validity-field{name="VUID-VkBufferViewCreateInfo-range-00929"}

If `range` is not equal to `VK_WHOLE_SIZE`, `range` :normative{type="must"} be
an integer multiple of the texel block size of `format`
::

::validity-field{name="VUID-VkBufferViewCreateInfo-range-00930"}

If `range` is not equal to `VK_WHOLE_SIZE`, the number of texel
buffer elements given by (⌊`range` / (texel block
size)⌋ × (texels per block)) where texel block size and
texels per block are as defined in the Compatible Formats table for `format`, :normative{type="must"} be less than or equal
to `VkPhysicalDeviceLimits`::`maxTexelBufferElements`
::

::validity-field{name="VUID-VkBufferViewCreateInfo-offset-00931"}

If `range` is not equal to `VK_WHOLE_SIZE`, the sum of
`offset` and `range` :normative{type="must"} be less than or equal to the size of
`buffer`
::

::validity-field{name="VUID-VkBufferViewCreateInfo-range-04059"}

If `range` is equal to `VK_WHOLE_SIZE`, the number of texel
buffer elements given by (⌊(size - `offset`) / (texel
block size)⌋ × (texels per block)) where size is the size
of `buffer`, and texel block size and texels per block are as
defined in the Compatible Formats table for
`format`, :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxTexelBufferElements`
::

::validity-field{name="VUID-VkBufferViewCreateInfo-buffer-00932"}
`buffer` :normative{type="must"} have been created with a `usage` value containing
at least one of `VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT` or
`VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT`
::

::validity-field{name="VUID-VkBufferViewCreateInfo-format-08778"}

If the buffer view usage contains
`VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT`, then
format features of
`format` :normative{type="must"} contain
`VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT`
::

::validity-field{name="VUID-VkBufferViewCreateInfo-format-08779"}

If the buffer view usage contains
`VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT`, then
format features of
`format` :normative{type="must"} contain
`VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT`
::

::validity-field{name="VUID-VkBufferViewCreateInfo-buffer-00935"}

If `buffer` is non-sparse then it :normative{type="must"} be bound completely and
contiguously to a single `VkDeviceMemory` object
::

::validity-field{name="VUID-VkBufferViewCreateInfo-offset-02749"}
`offset` :normative{type="must"} be a multiple of
`VkPhysicalDeviceLimits`::`minTexelBufferOffsetAlignment`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkBufferViewCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO`
::

::validity-field{name="VUID-VkBufferViewCreateInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkBufferUsageFlags2CreateInfoKHR](/man/VkBufferUsageFlags2CreateInfoKHR) or [VkExportMetalObjectCreateInfoEXT](/man/VkExportMetalObjectCreateInfoEXT)
::

::validity-field{name="VUID-VkBufferViewCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique, with the exception of structures of type [VkExportMetalObjectCreateInfoEXT](/man/VkExportMetalObjectCreateInfoEXT)
::

::validity-field{name="VUID-VkBufferViewCreateInfo-flags-zerobitmask"}
 `flags` :normative{type="must"} be `0`
::

::validity-field{name="VUID-VkBufferViewCreateInfo-buffer-parameter"}
 `buffer` :normative{type="must"} be a valid [VkBuffer](/man/VkBuffer) handle
::

::validity-field{name="VUID-VkBufferViewCreateInfo-format-parameter"}
 `format` :normative{type="must"} be a valid [VkFormat](/man/VkFormat) value
::

::


[{generated}/api/flags/VkBufferViewCreateFlags.adoc]({generated}/api/flags/VkBufferViewCreateFlags.adoc)

`VkBufferViewCreateFlags` is a bitmask type for setting a mask, but is
currently reserved for future use.

To destroy a buffer view, call:

[{generated}/api/protos/vkDestroyBufferView.adoc]({generated}/api/protos/vkDestroyBufferView.adoc)

- `device` is the logical device that destroys the buffer view.

- `bufferView` is the buffer view to destroy.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkDestroyBufferView-bufferView-00936"}

All submitted commands that refer to `bufferView` :normative{type="must"} have
completed execution
::

::validity-field{name="VUID-vkDestroyBufferView-bufferView-00937"}

If `VkAllocationCallbacks` were provided when `bufferView` was
created, a compatible set of callbacks :normative{type="must"} be provided here
::

::validity-field{name="VUID-vkDestroyBufferView-bufferView-00938"}

If no `VkAllocationCallbacks` were provided when `bufferView`
was created, `pAllocator` :normative{type="must"} be `NULL`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkDestroyBufferView-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkDestroyBufferView-bufferView-parameter"}
 If `bufferView` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `bufferView` :normative{type="must"} be a valid [VkBufferView](/man/VkBufferView) handle
::

::validity-field{name="VUID-vkDestroyBufferView-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkDestroyBufferView-bufferView-parent"}
 If `bufferView` is a valid handle, it :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::






### Buffer View Format Features

Valid uses of a [VkBufferView](/man/VkBufferView) :normative{type="may"} depend on the buffer view’s *format
features*, defined below.
Such constraints are documented in the affected valid usage statement.

- The buffer view’s set of *format features* is the value of
  [VkFormatProperties](/man/VkFormatProperties)::`bufferFeatures` found by calling
  [vkGetPhysicalDeviceFormatProperties](/man/vkGetPhysicalDeviceFormatProperties) on the same `format` as
  [VkBufferViewCreateInfo](/man/VkBufferViewCreateInfo)::`format`.







## Images

Images represent multidimensional - up to 3 - arrays of data which :normative{type="can"} be
used for various purposes (e.g. attachments, textures), by binding them to a
graphics or compute pipeline via descriptor sets, or by directly specifying
them as parameters to certain commands.

Images are represented by `VkImage` handles:

[{generated}/api/handles/VkImage.adoc]({generated}/api/handles/VkImage.adoc)

To create images, call:

[{generated}/api/protos/vkCreateImage.adoc]({generated}/api/protos/vkCreateImage.adoc)

- `device` is the logical device that creates the image.

- `pCreateInfo` is a pointer to a [VkImageCreateInfo](/man/VkImageCreateInfo) structure
  containing parameters to be used to create the image.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

- `pImage` is a pointer to a [VkImage](/man/VkImage) handle in which the
  resulting image object is returned.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCreateImage-flags-00939"}

If the `flags` member of `pCreateInfo` includes
`VK_IMAGE_CREATE_SPARSE_BINDING_BIT`,
creating this `VkImage` :normative{type="must"} not cause the total required sparse
memory for all currently valid sparse resources on the device to exceed
`VkPhysicalDeviceLimits`::`sparseAddressSpaceSize`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCreateImage-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkCreateImage-pCreateInfo-parameter"}
 `pCreateInfo` :normative{type="must"} be a valid pointer to a valid [VkImageCreateInfo](/man/VkImageCreateInfo) structure
::

::validity-field{name="VUID-vkCreateImage-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkCreateImage-pImage-parameter"}
 `pImage` :normative{type="must"} be a valid pointer to a [VkImage](/man/VkImage) handle
::

::




The `VkImageCreateInfo` structure is defined as:

[{generated}/api/structs/VkImageCreateInfo.adoc]({generated}/api/structs/VkImageCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is a bitmask of [VkImageCreateFlagBits](/man/VkImageCreateFlagBits) describing
  additional parameters of the image.

- `imageType` is a [VkImageType](/man/VkImageType) value specifying the basic
  dimensionality of the image.
  Layers in array textures do not count as a dimension for the purposes of
  the image type.

- `format` is a [VkFormat](/man/VkFormat) describing the format and type of the
  texel blocks that will be contained in the image.

- `extent` is a [VkExtent3D](/man/VkExtent3D) describing the number of data
  elements in each dimension of the base level.

- `mipLevels` describes the number of levels of detail available for
  minified sampling of the image.

- `arrayLayers` is the number of layers in the image.

- `samples` is a [VkSampleCountFlagBits](/man/VkSampleCountFlagBits) value specifying the
  number of samples per texel.

- `tiling` is a [VkImageTiling](/man/VkImageTiling) value specifying the tiling
  arrangement of the texel blocks in memory.

- `usage` is a bitmask of [VkImageUsageFlagBits](/man/VkImageUsageFlagBits) describing the
  intended usage of the image.

- `sharingMode` is a [VkSharingMode](/man/VkSharingMode) value specifying the sharing
  mode of the image when it will be accessed by multiple queue families.

- `queueFamilyIndexCount` is the number of entries in the
  `pQueueFamilyIndices` array.

- `pQueueFamilyIndices` is a pointer to an array of queue families
  that will access this image.
  It is ignored if `sharingMode` is not
  `VK_SHARING_MODE_CONCURRENT`.

- `initialLayout` is a [VkImageLayout](/man/VkImageLayout) value specifying the
  initial [VkImageLayout](/man/VkImageLayout) of all image subresources of the image.
  See Image Layouts.

Images created with `tiling` equal to `VK_IMAGE_TILING_LINEAR` have
further restrictions on their limits and capabilities compared to images
created with `tiling` equal to `VK_IMAGE_TILING_OPTIMAL`.
Creation of images with tiling `VK_IMAGE_TILING_LINEAR` :normative{type="may"} not be
supported unless other parameters meet all of the constraints:

- `imageType` is `VK_IMAGE_TYPE_2D`

- `format` is not a depth/stencil format

- `mipLevels` is 1

- `arrayLayers` is 1

- `samples` is `VK_SAMPLE_COUNT_1_BIT`

- `usage` only includes `VK_IMAGE_USAGE_TRANSFER_SRC_BIT` and/or
  `VK_IMAGE_USAGE_TRANSFER_DST_BIT`

Implementations :normative{type="may"} support additional limits and capabilities beyond those
listed above.

To determine the set of valid `usage` bits for a given format, call
[vkGetPhysicalDeviceFormatProperties](/man/vkGetPhysicalDeviceFormatProperties).

If the size of the resultant image would exceed `maxResourceSize`, then
[vkCreateImage](/man/vkCreateImage) :normative{type="must"} fail and return
`VK_ERROR_OUT_OF_DEVICE_MEMORY`.
This failure :normative{type="may"} occur even when all image creation parameters satisfy
their valid usage requirements.




::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkImageCreateInfo-imageCreateMaxMipLevels-02251"}

Each of the following values (as described in
Image Creation Limits) :normative{type="must"} not be
undefined: : `imageCreateMaxMipLevels`,
`imageCreateMaxArrayLayers`, `imageCreateMaxExtent`, and
`imageCreateSampleCounts`
::

::validity-field{name="VUID-VkImageCreateInfo-sharingMode-00941"}

If `sharingMode` is `VK_SHARING_MODE_CONCURRENT`,
`pQueueFamilyIndices` :normative{type="must"} be a valid pointer to an array of
`queueFamilyIndexCount` `uint32_t` values
::

::validity-field{name="VUID-VkImageCreateInfo-sharingMode-00942"}

If `sharingMode` is `VK_SHARING_MODE_CONCURRENT`,
`queueFamilyIndexCount` :normative{type="must"} be greater than `1`
::

::validity-field{name="VUID-VkImageCreateInfo-sharingMode-01392"}

If `sharingMode` is `VK_SHARING_MODE_CONCURRENT`, each element
of `pQueueFamilyIndices` :normative{type="must"} be unique and :normative{type="must"} be less than
`pQueueFamilyPropertyCount` returned by
[vkGetPhysicalDeviceQueueFamilyProperties](/man/vkGetPhysicalDeviceQueueFamilyProperties) for the
`physicalDevice` that was used to create `device`
::

::validity-field{name="VUID-VkImageCreateInfo-format-00943"}
`format` :normative{type="must"} not be `VK_FORMAT_UNDEFINED`
::

::validity-field{name="VUID-VkImageCreateInfo-extent-00944"}
`extent.width` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-VkImageCreateInfo-extent-00945"}
`extent.height` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-VkImageCreateInfo-extent-00946"}
`extent.depth` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-VkImageCreateInfo-mipLevels-00947"}
`mipLevels` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-VkImageCreateInfo-arrayLayers-00948"}
`arrayLayers` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-VkImageCreateInfo-flags-00949"}

If `flags` contains `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT`,
`imageType` :normative{type="must"} be `VK_IMAGE_TYPE_2D`
::

::validity-field{name="VUID-VkImageCreateInfo-flags-08865"}

If `flags` contains `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT`,
`extent.width` and `extent.height` :normative{type="must"} be equal
::

::validity-field{name="VUID-VkImageCreateInfo-flags-08866"}

If `flags` contains `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT`,
`arrayLayers` :normative{type="must"} be greater than or equal to 6
::

::validity-field{name="VUID-VkImageCreateInfo-extent-02252"}
`extent.width` :normative{type="must"} be less than or equal to
`imageCreateMaxExtent.width` (as defined in
Image Creation Limits)
::

::validity-field{name="VUID-VkImageCreateInfo-extent-02253"}
`extent.height` :normative{type="must"} be less than or equal to
`imageCreateMaxExtent.height` (as defined in
Image Creation Limits)
::

::validity-field{name="VUID-VkImageCreateInfo-extent-02254"}
`extent.depth` :normative{type="must"} be less than or equal to
`imageCreateMaxExtent.depth` (as defined in
Image Creation Limits)
::

::validity-field{name="VUID-VkImageCreateInfo-imageType-00956"}

If `imageType` is `VK_IMAGE_TYPE_1D`, both `extent.height`
and `extent.depth` :normative{type="must"} be `1`
::

::validity-field{name="VUID-VkImageCreateInfo-imageType-00957"}

If `imageType` is `VK_IMAGE_TYPE_2D`, `extent.depth` :normative{type="must"}
be `1`
::

::validity-field{name="VUID-VkImageCreateInfo-mipLevels-00958"}
`mipLevels` :normative{type="must"} be less than or equal to the number of levels in
the complete mipmap chain based on `extent.width`,
`extent.height`, and `extent.depth`
::

::validity-field{name="VUID-VkImageCreateInfo-mipLevels-02255"}
`mipLevels` :normative{type="must"} be less than or equal to
`imageCreateMaxMipLevels` (as defined in
Image Creation Limits)
::

::validity-field{name="VUID-VkImageCreateInfo-arrayLayers-02256"}
`arrayLayers` :normative{type="must"} be less than or equal to
`imageCreateMaxArrayLayers` (as defined in
Image Creation Limits)
::

::validity-field{name="VUID-VkImageCreateInfo-imageType-00961"}

If `imageType` is `VK_IMAGE_TYPE_3D`, `arrayLayers` :normative{type="must"} be
`1`
::

::validity-field{name="VUID-VkImageCreateInfo-samples-02257"}

If `samples` is not `VK_SAMPLE_COUNT_1_BIT`, then
`imageType` :normative{type="must"} be `VK_IMAGE_TYPE_2D`, `flags` :normative{type="must"} not
contain `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT`, `mipLevels` :normative{type="must"}
be equal to `1`, and `imageCreateMaybeLinear` (as defined in
Image Creation Limits) :normative{type="must"} be
`VK_FALSE`,
::

::validity-field{name="VUID-VkImageCreateInfo-usage-00963"}

If `usage` includes `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`,
then bits other than `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`,
`VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`, and
`VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT` :normative{type="must"} not be set
::

::validity-field{name="VUID-VkImageCreateInfo-usage-00964"}

If `usage` includes `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`,
`VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`,
`VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`, or
`VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`, `extent.width` :normative{type="must"} be
less than or equal to
`VkPhysicalDeviceLimits`::`maxFramebufferWidth`
::

::validity-field{name="VUID-VkImageCreateInfo-usage-00965"}

If `usage` includes `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`,
`VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`,
`VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`, or
`VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`, `extent.height` :normative{type="must"} be
less than or equal to
`VkPhysicalDeviceLimits`::`maxFramebufferHeight`
::

::validity-field{name="VUID-VkImageCreateInfo-usage-00966"}

If `usage` includes `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`,
`usage` :normative{type="must"} also contain at least one of
`VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`,
`VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`, or
`VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`
::

::validity-field{name="VUID-VkImageCreateInfo-samples-02258"}
`samples` :normative{type="must"} be a bit value that is set in
`imageCreateSampleCounts` (as defined in
Image Creation Limits)
::

::validity-field{name="VUID-VkImageCreateInfo-usage-00968"}

If the `shaderStorageImageMultisample` feature is not enabled, and
`usage` contains `VK_IMAGE_USAGE_STORAGE_BIT`, `samples`
:normative{type="must"} be `VK_SAMPLE_COUNT_1_BIT`
::

::validity-field{name="VUID-VkImageCreateInfo-flags-00969"}

If the `sparseBinding` feature is not
enabled, `flags` :normative{type="must"} not contain
`VK_IMAGE_CREATE_SPARSE_BINDING_BIT`
::

::validity-field{name="VUID-VkImageCreateInfo-flags-01924"}

If the `sparseResidencyAliased`
feature is not enabled, `flags` :normative{type="must"} not contain
`VK_IMAGE_CREATE_SPARSE_ALIASED_BIT`
::

::validity-field{name="VUID-VkImageCreateInfo-tiling-04121"}

If `tiling` is `VK_IMAGE_TILING_LINEAR`, `flags` :normative{type="must"} not
contain `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`
::

::validity-field{name="VUID-VkImageCreateInfo-imageType-00970"}

If `imageType` is `VK_IMAGE_TYPE_1D`, `flags` :normative{type="must"} not
contain `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`
::

::validity-field{name="VUID-VkImageCreateInfo-imageType-00971"}

If the `sparseResidencyImage2D`
feature is not enabled, and `imageType` is `VK_IMAGE_TYPE_2D`,
`flags` :normative{type="must"} not contain `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`
::

::validity-field{name="VUID-VkImageCreateInfo-imageType-00972"}

If the `sparseResidencyImage3D`
feature is not enabled, and `imageType` is `VK_IMAGE_TYPE_3D`,
`flags` :normative{type="must"} not contain `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`
::

::validity-field{name="VUID-VkImageCreateInfo-imageType-00973"}

If the `sparseResidency2Samples` feature is not enabled, `imageType`
is `VK_IMAGE_TYPE_2D`, and `samples` is
`VK_SAMPLE_COUNT_2_BIT`, `flags` :normative{type="must"} not contain
`VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`
::

::validity-field{name="VUID-VkImageCreateInfo-imageType-00974"}

If the `sparseResidency4Samples` feature is not enabled, `imageType`
is `VK_IMAGE_TYPE_2D`, and `samples` is
`VK_SAMPLE_COUNT_4_BIT`, `flags` :normative{type="must"} not contain
`VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`
::

::validity-field{name="VUID-VkImageCreateInfo-imageType-00975"}

If the `sparseResidency8Samples` feature is not enabled, `imageType`
is `VK_IMAGE_TYPE_2D`, and `samples` is
`VK_SAMPLE_COUNT_8_BIT`, `flags` :normative{type="must"} not contain
`VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`
::

::validity-field{name="VUID-VkImageCreateInfo-imageType-00976"}

If the `sparseResidency16Samples` feature is not enabled, `imageType`
is `VK_IMAGE_TYPE_2D`, and `samples` is
`VK_SAMPLE_COUNT_16_BIT`, `flags` :normative{type="must"} not contain
`VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`
::

::validity-field{name="VUID-VkImageCreateInfo-flags-00987"}

If `flags` contains `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` or
`VK_IMAGE_CREATE_SPARSE_ALIASED_BIT`, it :normative{type="must"} also contain
`VK_IMAGE_CREATE_SPARSE_BINDING_BIT`
::

::validity-field{name="VUID-VkImageCreateInfo-None-01925"}

If any of the bits `VK_IMAGE_CREATE_SPARSE_BINDING_BIT`,
`VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`, or
`VK_IMAGE_CREATE_SPARSE_ALIASED_BIT` are set,
`VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT` :normative{type="must"} not also be set
::

::validity-field{name="VUID-VkImageCreateInfo-initialLayout-00993"}
`initialLayout` :normative{type="must"} be `VK_IMAGE_LAYOUT_UNDEFINED` or
`VK_IMAGE_LAYOUT_PREINITIALIZED`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkImageCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO`
::

::validity-field{name="VUID-VkImageCreateInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkBufferCollectionImageCreateInfoFUCHSIA](/man/VkBufferCollectionImageCreateInfoFUCHSIA), [VkDedicatedAllocationImageCreateInfoNV](/man/VkDedicatedAllocationImageCreateInfoNV), [VkExportMetalObjectCreateInfoEXT](/man/VkExportMetalObjectCreateInfoEXT), [VkExternalFormatANDROID](/man/VkExternalFormatANDROID), [VkExternalFormatQNX](/man/VkExternalFormatQNX), [VkExternalMemoryImageCreateInfo](/man/VkExternalMemoryImageCreateInfo), [VkExternalMemoryImageCreateInfoNV](/man/VkExternalMemoryImageCreateInfoNV), [VkImageCompressionControlEXT](/man/VkImageCompressionControlEXT), [VkImageDrmFormatModifierExplicitCreateInfoEXT](/man/VkImageDrmFormatModifierExplicitCreateInfoEXT), [VkImageDrmFormatModifierListCreateInfoEXT](/man/VkImageDrmFormatModifierListCreateInfoEXT), [VkImageFormatListCreateInfo](/man/VkImageFormatListCreateInfo), [VkImageStencilUsageCreateInfo](/man/VkImageStencilUsageCreateInfo), [VkImageSwapchainCreateInfoKHR](/man/VkImageSwapchainCreateInfoKHR), [VkImportMetalIOSurfaceInfoEXT](/man/VkImportMetalIOSurfaceInfoEXT), [VkImportMetalTextureInfoEXT](/man/VkImportMetalTextureInfoEXT), [VkOpaqueCaptureDescriptorDataCreateInfoEXT](/man/VkOpaqueCaptureDescriptorDataCreateInfoEXT), [VkOpticalFlowImageFormatInfoNV](/man/VkOpticalFlowImageFormatInfoNV), or [VkVideoProfileListInfoKHR](/man/VkVideoProfileListInfoKHR)
::

::validity-field{name="VUID-VkImageCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique, with the exception of structures of type [VkExportMetalObjectCreateInfoEXT](/man/VkExportMetalObjectCreateInfoEXT) or [VkImportMetalTextureInfoEXT](/man/VkImportMetalTextureInfoEXT)
::

::validity-field{name="VUID-VkImageCreateInfo-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkImageCreateFlagBits](/man/VkImageCreateFlagBits) values
::

::validity-field{name="VUID-VkImageCreateInfo-imageType-parameter"}
 `imageType` :normative{type="must"} be a valid [VkImageType](/man/VkImageType) value
::

::validity-field{name="VUID-VkImageCreateInfo-format-parameter"}
 `format` :normative{type="must"} be a valid [VkFormat](/man/VkFormat) value
::

::validity-field{name="VUID-VkImageCreateInfo-samples-parameter"}
 `samples` :normative{type="must"} be a valid [VkSampleCountFlagBits](/man/VkSampleCountFlagBits) value
::

::validity-field{name="VUID-VkImageCreateInfo-tiling-parameter"}
 `tiling` :normative{type="must"} be a valid [VkImageTiling](/man/VkImageTiling) value
::

::validity-field{name="VUID-VkImageCreateInfo-usage-parameter"}
 `usage` :normative{type="must"} be a valid combination of [VkImageUsageFlagBits](/man/VkImageUsageFlagBits) values
::

::validity-field{name="VUID-VkImageCreateInfo-usage-requiredbitmask"}
 `usage` :normative{type="must"} not be `0`
::

::validity-field{name="VUID-VkImageCreateInfo-sharingMode-parameter"}
 `sharingMode` :normative{type="must"} be a valid [VkSharingMode](/man/VkSharingMode) value
::

::validity-field{name="VUID-VkImageCreateInfo-initialLayout-parameter"}
 `initialLayout` :normative{type="must"} be a valid [VkImageLayout](/man/VkImageLayout) value
::

::


Bits which :normative{type="can"} be set in

- [VkImageCreateInfo](/man/VkImageCreateInfo)::`usage`

specify intended usage of an image, and are:

[{generated}/api/enums/VkImageUsageFlagBits.adoc]({generated}/api/enums/VkImageUsageFlagBits.adoc)

- `VK_IMAGE_USAGE_TRANSFER_SRC_BIT` specifies that the image :normative{type="can"} be
  used as the source of a transfer command.

- `VK_IMAGE_USAGE_TRANSFER_DST_BIT` specifies that the image :normative{type="can"} be
  used as the destination of a transfer command.

- `VK_IMAGE_USAGE_SAMPLED_BIT` specifies that the image :normative{type="can"} be used
  to create a `VkImageView` suitable for occupying a
  `VkDescriptorSet` slot either of type
  `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE` or
  `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, and be sampled by a
  shader.

- `VK_IMAGE_USAGE_STORAGE_BIT` specifies that the image :normative{type="can"} be used
  to create a `VkImageView` suitable for occupying a
  `VkDescriptorSet` slot of type
  `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`.

- `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT` specifies that the image :normative{type="can"}
  be used to create a `VkImageView` suitable for use as a color or
  resolve attachment in a `VkFramebuffer`.

- `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT` specifies that the
  image :normative{type="can"} be used to create a `VkImageView` suitable for use as a
  depth/stencil
  attachment in a `VkFramebuffer`.

- `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT` specifies that
  implementations :normative{type="may"} support using memory allocations with
  the `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT` to back an image with
  this usage.
  This bit :normative{type="can"} be set for any image that :normative{type="can"} be used to create a
  `VkImageView` suitable for use as a color, resolve, depth/stencil,
  or input attachment.

- `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT` specifies that the image :normative{type="can"}
  be used to create a `VkImageView` suitable for occupying
  `VkDescriptorSet` slot of type
  `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`; be read from a shader as an
  input attachment; and be used as an input attachment in a framebuffer.

[{generated}/api/flags/VkImageUsageFlags.adoc]({generated}/api/flags/VkImageUsageFlags.adoc)

`VkImageUsageFlags` is a bitmask type for setting a mask of zero or more
[VkImageUsageFlagBits](/man/VkImageUsageFlagBits).

When creating a `VkImageView` one of the following
[VkImageUsageFlagBits](/man/VkImageUsageFlagBits) :normative{type="must"} be set:

- `VK_IMAGE_USAGE_SAMPLED_BIT`

- `VK_IMAGE_USAGE_STORAGE_BIT`

- `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`

- `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`

- `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`

- `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`

Bits which :normative{type="can"} be set in [VkImageCreateInfo](/man/VkImageCreateInfo)::`flags`, specifying
additional parameters of an image, are:

[{generated}/api/enums/VkImageCreateFlagBits.adoc]({generated}/api/enums/VkImageCreateFlagBits.adoc)

- `VK_IMAGE_CREATE_SPARSE_BINDING_BIT` specifies that the image will
  be backed using sparse memory binding.

- `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` specifies that the image :normative{type="can"}
  be partially backed using sparse memory binding.
  Images created with this flag :normative{type="must"} also be created with the
  `VK_IMAGE_CREATE_SPARSE_BINDING_BIT` flag.

- `VK_IMAGE_CREATE_SPARSE_ALIASED_BIT` specifies that the image will
  be backed using sparse memory binding with memory ranges that might also
  simultaneously be backing another image (or another portion of the same
  image).
  Images created with this flag :normative{type="must"} also be created with the
  `VK_IMAGE_CREATE_SPARSE_BINDING_BIT` flag.

- `VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT` specifies that the image :normative{type="can"}
  be used to create a `VkImageView` with a different format from the
  image.

- `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT` specifies that the image :normative{type="can"}
  be used to create a `VkImageView` of type
  `VK_IMAGE_VIEW_TYPE_CUBE` or `VK_IMAGE_VIEW_TYPE_CUBE_ARRAY`.

See Sparse Resource Features and
Sparse Physical Device Features for more
details.

[{generated}/api/flags/VkImageCreateFlags.adoc]({generated}/api/flags/VkImageCreateFlags.adoc)

`VkImageCreateFlags` is a bitmask type for setting a mask of zero or
more [VkImageCreateFlagBits](/man/VkImageCreateFlagBits).

Possible values of [VkImageCreateInfo](/man/VkImageCreateInfo)::`imageType`, specifying the
basic dimensionality of an image, are:

[{generated}/api/enums/VkImageType.adoc]({generated}/api/enums/VkImageType.adoc)

- `VK_IMAGE_TYPE_1D` specifies a one-dimensional image.

- `VK_IMAGE_TYPE_2D` specifies a two-dimensional image.

- `VK_IMAGE_TYPE_3D` specifies a three-dimensional image.

Possible values of [VkImageCreateInfo](/man/VkImageCreateInfo)::`tiling`, specifying the
tiling arrangement of texel blocks in an image, are:

[{generated}/api/enums/VkImageTiling.adoc]({generated}/api/enums/VkImageTiling.adoc)

- `VK_IMAGE_TILING_OPTIMAL` specifies optimal tiling (texels are laid
  out in an implementation-dependent arrangement, for more efficient
  memory access).

- `VK_IMAGE_TILING_LINEAR` specifies linear tiling (texels are laid
  out in memory in row-major order, possibly with some padding on each
  row).

To query the memory layout of an image subresource, call:

[{generated}/api/protos/vkGetImageSubresourceLayout.adoc]({generated}/api/protos/vkGetImageSubresourceLayout.adoc)

- `device` is the logical device that owns the image.

- `image` is the image whose layout is being queried.

- `pSubresource` is a pointer to a [VkImageSubresource](/man/VkImageSubresource) structure
  selecting a specific image subresource from the image.

- `pLayout` is a pointer to a [VkSubresourceLayout](/man/VkSubresourceLayout) structure in
  which the layout is returned.

The image :normative{type="must"} be linear.
The
returned layout is valid for host access.

`vkGetImageSubresourceLayout` is invariant for the lifetime of a single
image.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkGetImageSubresourceLayout-image-07789"}
`image` :normative{type="must"} have been created with `tiling` equal to
`VK_IMAGE_TILING_LINEAR`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkGetImageSubresourceLayout-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkGetImageSubresourceLayout-image-parameter"}
 `image` :normative{type="must"} be a valid [VkImage](/man/VkImage) handle
::

::validity-field{name="VUID-vkGetImageSubresourceLayout-pSubresource-parameter"}
 `pSubresource` :normative{type="must"} be a valid pointer to a valid [VkImageSubresource](/man/VkImageSubresource) structure
::

::validity-field{name="VUID-vkGetImageSubresourceLayout-pLayout-parameter"}
 `pLayout` :normative{type="must"} be a valid pointer to a [VkSubresourceLayout](/man/VkSubresourceLayout) structure
::

::validity-field{name="VUID-vkGetImageSubresourceLayout-image-parent"}
 `image` :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::


The `VkImageSubresource` structure is defined as:

[{generated}/api/structs/VkImageSubresource.adoc]({generated}/api/structs/VkImageSubresource.adoc)

- `aspectMask` is a [VkImageAspectFlags](/man/VkImageAspectFlags) value selecting the image
  *aspect*.

- `mipLevel` selects the mipmap level.

- `arrayLayer` selects the array layer.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkImageSubresource-aspectMask-parameter"}
 `aspectMask` :normative{type="must"} be a valid combination of [VkImageAspectFlagBits](/man/VkImageAspectFlagBits) values
::

::validity-field{name="VUID-VkImageSubresource-aspectMask-requiredbitmask"}
 `aspectMask` :normative{type="must"} not be `0`
::

::


Information about the layout of the image subresource is returned in a
`VkSubresourceLayout` structure:

[{generated}/api/structs/VkSubresourceLayout.adoc]({generated}/api/structs/VkSubresourceLayout.adoc)

- `offset` is the byte offset from the start of the image
  where the image subresource begins.

- `size` is the size in bytes of the image subresource.
  `size` includes any extra memory that is required based on
  `rowPitch`.

- `rowPitch` describes the number of bytes between each row of texels
  in an image.

- `arrayPitch` describes the number of bytes between each array layer
  of an image.

- `depthPitch` describes the number of bytes between each slice of 3D
  image.

If the image is linear, then `rowPitch`,
`arrayPitch` and `depthPitch` describe the layout of the image
subresource in linear memory.
For uncompressed formats, `rowPitch` is the number of bytes between
texels with the same x coordinate in adjacent rows (y coordinates differ by
one).
`arrayPitch` is the number of bytes between texels with the same x and y
coordinate in adjacent array layers of the image (array layer values differ
by one).
`depthPitch` is the number of bytes between texels with the same x and y
coordinate in adjacent slices of a 3D image (z coordinates differ by one).
Expressed as an addressing formula, the starting byte of a texel in the
image subresource has address:



For compressed formats, the `rowPitch` is the number of bytes between
compressed texel blocks in adjacent rows.
`arrayPitch` is the number of bytes between compressed texel blocks in
adjacent array layers.
`depthPitch` is the number of bytes between compressed texel blocks in
adjacent slices of a 3D image.



The value of `arrayPitch` is undefined: for images that were not created
as arrays.
`depthPitch` is defined only for 3D images.

If the image has a
color format
, then the `aspectMask` member of `VkImageSubresource` :normative{type="must"} be
`VK_IMAGE_ASPECT_COLOR_BIT`.

If the image has a depth/stencil format
, then `aspectMask` :normative{type="must"} be either `VK_IMAGE_ASPECT_DEPTH_BIT` or
`VK_IMAGE_ASPECT_STENCIL_BIT`.
On implementations that store depth and stencil aspects separately, querying
each of these image subresource layouts will return a different `offset`
and `size` representing the region of memory used for that aspect.
On implementations that store depth and stencil aspects interleaved, the
same `offset` and `size` are returned and represent the interleaved
memory allocation.

To destroy an image, call:

[{generated}/api/protos/vkDestroyImage.adoc]({generated}/api/protos/vkDestroyImage.adoc)

- `device` is the logical device that destroys the image.

- `image` is the image to destroy.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkDestroyImage-image-01000"}

All submitted commands that refer to `image`, either directly or via
a `VkImageView`, :normative{type="must"} have completed execution
::

::validity-field{name="VUID-vkDestroyImage-image-01001"}

If `VkAllocationCallbacks` were provided when `image` was
created, a compatible set of callbacks :normative{type="must"} be provided here
::

::validity-field{name="VUID-vkDestroyImage-image-01002"}

If no `VkAllocationCallbacks` were provided when `image` was
created, `pAllocator` :normative{type="must"} be `NULL`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkDestroyImage-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkDestroyImage-image-parameter"}
 If `image` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `image` :normative{type="must"} be a valid [VkImage](/man/VkImage) handle
::

::validity-field{name="VUID-vkDestroyImage-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkDestroyImage-image-parent"}
 If `image` is a valid handle, it :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::






### Image Format Features

Valid uses of a [VkImage](/man/VkImage) :normative{type="may"} depend on the image’s *format features*,
defined below.
Such constraints are documented in the affected valid usage statement.

- If the image was created with `VK_IMAGE_TILING_LINEAR`, then its set
  of *format features* is the value of
  [VkFormatProperties](/man/VkFormatProperties)::`linearTilingFeatures` found by calling
  [vkGetPhysicalDeviceFormatProperties](/man/vkGetPhysicalDeviceFormatProperties) on the same `format` as
  [VkImageCreateInfo](/man/VkImageCreateInfo)::`format`.

- If the image was created with `VK_IMAGE_TILING_OPTIMAL`,
  then its set of *format features* is the value of
  [VkFormatProperties](/man/VkFormatProperties)::`optimalTilingFeatures` found by calling
  [vkGetPhysicalDeviceFormatProperties](/man/vkGetPhysicalDeviceFormatProperties) on the same `format` as
  [VkImageCreateInfo](/man/VkImageCreateInfo)::`format`.





### Image Mip Level Sizing

A *complete mipmap chain* is the full set of mip levels, from the largest
mip level provided, down to the *minimum mip level size*.



#### Conventional Images

For conventional images, the dimensions of each successive mip level,
n+1, are:



where `width`\<sub>n\</sub>, `height`\<sub>n\</sub>, and `depth`\<sub>n\</sub>
are the dimensions of the next larger mip level, n.

The minimum mip level size is:

- 1 for one-dimensional images,

- 1x1 for two-dimensional images, and

- 1x1x1 for three-dimensional images.

The number of levels in a complete mipmap chain is:



where `width`\<sub>0\</sub>, `height`\<sub>0\</sub>, and `depth`\<sub>0\</sub>
are the dimensions of the largest (most detailed) mip level, `0`.









## Image Layouts

Images are stored in implementation-dependent opaque layouts in memory.
Each layout has limitations on what kinds of operations are supported for
image subresources using the layout.
At any given time, the data representing an image subresource in memory
exists in a particular layout which is determined by the most recent layout
transition that was performed on that image subresource.
Applications have control over which layout each image subresource uses, and
:normative{type="can"} transition an image subresource from one layout to another.
Transitions :normative{type="can"} happen with an image memory barrier, included as part of a
[vkCmdPipelineBarrier](/man/vkCmdPipelineBarrier) or a [vkCmdWaitEvents](/man/vkCmdWaitEvents) command buffer command
(see ), or as part of a subpass
dependency within a render pass (see `VkSubpassDependency`).

Image layout is per-image subresource.
Separate image subresources of the same image :normative{type="can"} be in different layouts
at the same time, with the exception that depth and stencil aspects of a
given image subresource :normative{type="can"} only be in different layouts if the
`separateDepthStencilLayouts`
feature is enabled.


::note
Each layout :normative{type="may"} offer optimal performance for a specific usage of image
memory.
For example, an image with a layout of
`VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL` :normative{type="may"} provide optimal
performance for use as a color attachment, but be unsupported for use in
transfer commands.
Applications :normative{type="can"} transition an image subresource from one layout to another
in order to achieve optimal performance when the image subresource is used
for multiple kinds of operations.
After initialization, applications need not use any layout other than the
general layout, though this :normative{type="may"} produce suboptimal performance on some
implementations.
::


Upon creation, all image subresources of an image are initially in the same
layout, where that layout is selected by the
`VkImageCreateInfo`::`initialLayout` member.
The `initialLayout` :normative{type="must"} be either `VK_IMAGE_LAYOUT_UNDEFINED` or
`VK_IMAGE_LAYOUT_PREINITIALIZED`.
If it is `VK_IMAGE_LAYOUT_PREINITIALIZED`, then the image data :normative{type="can"} be
preinitialized by the host while using this layout, and the transition away
from this layout will preserve that data.
If it is `VK_IMAGE_LAYOUT_UNDEFINED`, then the contents of the data are
considered to be undefined:, and the transition away from this layout is not
guaranteed to preserve that data.
For either of these initial layouts, any image subresources :normative{type="must"} be
transitioned to another layout before they are accessed by the device.

Host access to image memory is only well-defined for
linear images and for image subresources of
those images which are currently in either the
`VK_IMAGE_LAYOUT_PREINITIALIZED` or `VK_IMAGE_LAYOUT_GENERAL`
layout.
Calling [vkGetImageSubresourceLayout](/man/vkGetImageSubresourceLayout) for a linear image returns a
subresource layout mapping that is valid for either of those image layouts.

The set of image layouts consists of:

[{generated}/api/enums/VkImageLayout.adoc]({generated}/api/enums/VkImageLayout.adoc)

The type(s) of device access supported by each layout are:

- `VK_IMAGE_LAYOUT_UNDEFINED` specifies that the layout is unknown.
  Image memory :normative{type="cannot"} be transitioned into this layout.
  This layout :normative{type="can"} be used as the `initialLayout` member of
  [VkImageCreateInfo](/man/VkImageCreateInfo).
  This layout :normative{type="can"} be used in place of the current image layout in a
  layout transition, but doing so will cause the contents of the image’s
  memory to be undefined:.

- `VK_IMAGE_LAYOUT_PREINITIALIZED` specifies that an image’s memory is
  in a defined layout and :normative{type="can"} be populated by data, but that it has not
  yet been initialized by the driver.
  Image memory :normative{type="cannot"} be transitioned into this layout.
  This layout :normative{type="can"} be used as the `initialLayout` member of
  [VkImageCreateInfo](/man/VkImageCreateInfo).
  This layout is intended to be used as the initial layout for an image
  whose contents are written by the host, and hence the data :normative{type="can"} be
  written to memory immediately, without first executing a layout
  transition.
  Currently, `VK_IMAGE_LAYOUT_PREINITIALIZED` is only useful with
  linear images because there is not a
  standard layout defined for `VK_IMAGE_TILING_OPTIMAL` images.

- `VK_IMAGE_LAYOUT_GENERAL` supports all types of device access.

- `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL` :normative{type="must"} only be used as a
  color or resolve attachment in a `VkFramebuffer`.
  This layout is valid only for image subresources of images created with
  the `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT` usage bit enabled.

- `VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL` specifies a
  layout for both the depth and stencil aspects of a depth/stencil format
  image allowing read and write access as a depth/stencil attachment.

- `VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL` specifies a layout
  for both the depth and stencil aspects of a depth/stencil format image
  allowing read only access as a depth/stencil attachment or in shaders as
  a sampled image, combined image/sampler, or input attachment.

- `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL` specifies a layout
  allowing read-only access in a shader as a sampled image, combined
  image/sampler, or input attachment.
  This layout is valid only for image subresources of images created with
  the `VK_IMAGE_USAGE_SAMPLED_BIT` or
  `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT` usage bits enabled.

- `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL` :normative{type="must"} only be used as a
  source image of a transfer command (see the definition of
  `VK_PIPELINE_STAGE_TRANSFER_BIT`).
  This layout is valid only for image subresources of images created with
  the `VK_IMAGE_USAGE_TRANSFER_SRC_BIT` usage bit enabled.

- `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` :normative{type="must"} only be used as a
  destination image of a transfer command.
  This layout is valid only for image subresources of images created with
  the `VK_IMAGE_USAGE_TRANSFER_DST_BIT` usage bit enabled.

The layout of each image subresource is not a state of the image subresource
itself, but is rather a property of how the data in memory is organized, and
thus for each mechanism of accessing an image in the API the application
:normative{type="must"} specify a parameter or structure member that indicates which image
layout the image subresource(s) are considered to be in when the image will
be accessed.
For transfer commands, this is a parameter to the command (see&#x20;
and ).
For use as a framebuffer attachment, this is a member in the substructures
of the [VkRenderPassCreateInfo](/man/VkRenderPassCreateInfo) (see Render Pass).
For use in a descriptor set, this is a member in the
`VkDescriptorImageInfo` structure (see ).



### Image Layout Matching Rules

At the time that any command buffer command accessing an image executes on
any queue, the layouts of the image subresources that are accessed :normative{type="must"} all
match exactly the layout specified via the API controlling those
accesses.

When performing a layout transition on an image subresource, the old layout
value :normative{type="must"} either equal the current layout of the image subresource (at the
time the transition executes), or else be `VK_IMAGE_LAYOUT_UNDEFINED`
(implying that the contents of the image subresource need not be preserved).
The new layout used in a transition :normative{type="must"} not be
`VK_IMAGE_LAYOUT_UNDEFINED` or `VK_IMAGE_LAYOUT_PREINITIALIZED`.







## Image Views

Image objects are not directly accessed by pipeline shaders for reading or
writing image data.
Instead, *image views* representing contiguous ranges of the image
subresources and containing additional metadata are used for that purpose.
Views :normative{type="must"} be created on images of compatible types, and :normative{type="must"} represent a
valid subset of image subresources.

Image views are represented by `VkImageView` handles:

[{generated}/api/handles/VkImageView.adoc]({generated}/api/handles/VkImageView.adoc)

`VK_REMAINING_ARRAY_LAYERS` is a special constant value used for image
views to indicate that all remaining array layers in an image after the base
layer should be included in the view.

[{generated}/api/enums/VK\_REMAINING\_ARRAY\_LAYERS.adoc]({generated}/api/enums/VK_REMAINING_ARRAY_LAYERS.adoc)

`VK_REMAINING_MIP_LEVELS` is a special constant value used for image
views to indicate that all remaining mipmap levels in an image after the
base level should be included in the view.

[{generated}/api/enums/VK\_REMAINING\_MIP\_LEVELS.adoc]({generated}/api/enums/VK_REMAINING_MIP_LEVELS.adoc)

The types of image views that :normative{type="can"} be created are:

[{generated}/api/enums/VkImageViewType.adoc]({generated}/api/enums/VkImageViewType.adoc)

To create an image view, call:

[{generated}/api/protos/vkCreateImageView.adoc]({generated}/api/protos/vkCreateImageView.adoc)

- `device` is the logical device that creates the image view.

- `pCreateInfo` is a pointer to a `VkImageViewCreateInfo`
  structure containing parameters to be used to create the image view.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

- `pView` is a pointer to a [VkImageView](/man/VkImageView) handle in which the
  resulting image view object is returned.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCreateImageView-image-09179"}
[VkImageViewCreateInfo](/man/VkImageViewCreateInfo)::`image` :normative{type="must"} have been created from
`device`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCreateImageView-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkCreateImageView-pCreateInfo-parameter"}
 `pCreateInfo` :normative{type="must"} be a valid pointer to a valid [VkImageViewCreateInfo](/man/VkImageViewCreateInfo) structure
::

::validity-field{name="VUID-vkCreateImageView-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkCreateImageView-pView-parameter"}
 `pView` :normative{type="must"} be a valid pointer to a [VkImageView](/man/VkImageView) handle
::

::




The `VkImageViewCreateInfo` structure is defined as:

[{generated}/api/structs/VkImageViewCreateInfo.adoc]({generated}/api/structs/VkImageViewCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is a bitmask of [VkImageViewCreateFlagBits](/man/VkImageViewCreateFlagBits) specifying
  additional parameters of the image view.

- `image` is a [VkImage](/man/VkImage) on which the view will be created.

- `viewType` is a [VkImageViewType](/man/VkImageViewType) value specifying the type of
  the image view.

- `format` is a [VkFormat](/man/VkFormat) specifying the format and type used to
  interpret texel blocks of the image.

- `components` is a [VkComponentMapping](/man/VkComponentMapping) structure specifying a
  remapping of color components (or of depth or stencil components after
  they have been converted into color components).

- `subresourceRange` is a [VkImageSubresourceRange](/man/VkImageSubresourceRange) structure
  selecting the set of mipmap levels and array layers to be accessible to
  the view.

Some of the `image` creation parameters are inherited by the view.
In particular, image view creation inherits the implicit parameter
`usage` specifying the allowed usages of the image view that, by
default, takes the value of the corresponding `usage` parameter
specified in [VkImageCreateInfo](/man/VkImageCreateInfo) at image creation time.

If `image` was created with the `VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT`
flag,
`format` :normative{type="can"} be different from the image’s format, but if
they are not equal they :normative{type="must"} be *compatible*.
Image format compatibility is defined in the
Format Compatibility Classes section.
Views of compatible formats will have the same mapping between texel
coordinates and memory locations irrespective of the `format`, with only
the interpretation of the bit pattern changing.


::note
Values intended to be used with one view format :normative{type="may"} not be exactly
preserved when written or read through a different format.
For example, an integer value that happens to have the bit pattern of a
floating point denorm or NaN :normative{type="may"} be flushed or canonicalized when written
or read through a view with a floating point format.
Similarly, a value written through a signed normalized format that has a bit
pattern exactly equal to -2\<sup>b\</sup> :normative{type="may"} be changed to -2\<sup>b\</sup> +  1
as described in Conversion from Normalized
Fixed-Point to Floating-Point.
::


The [VkComponentMapping](/man/VkComponentMapping) `components` member describes a remapping
from components of the image to components of the vector returned by shader
image instructions.
This remapping :normative{type="must"} be the identity swizzle for storage image descriptors,
input attachment descriptors,
and framebuffer attachments.




::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkImageViewCreateInfo-image-01003"}

If `image` was not created with
`VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT` then `viewType` :normative{type="must"} not
be `VK_IMAGE_VIEW_TYPE_CUBE` or `VK_IMAGE_VIEW_TYPE_CUBE_ARRAY`
::

::validity-field{name="VUID-VkImageViewCreateInfo-viewType-01004"}

If the `imageCubeArray` feature is not
enabled, `viewType` :normative{type="must"} not be `VK_IMAGE_VIEW_TYPE_CUBE_ARRAY`
::

::validity-field{name="VUID-VkImageViewCreateInfo-image-04441"}
`image` :normative{type="must"} have been created with a `usage` value containing
at least one of the usages defined in the valid image usage list for image views
::

::validity-field{name="VUID-VkImageViewCreateInfo-None-02273"}

The format features of the
resultant image view :normative{type="must"} contain at least one bit
::

::validity-field{name="VUID-VkImageViewCreateInfo-usage-02274"}

If `usage` contains `VK_IMAGE_USAGE_SAMPLED_BIT`, then the
format features of the
resultant image view :normative{type="must"} contain
`VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT`
::

::validity-field{name="VUID-VkImageViewCreateInfo-usage-02275"}

If `usage` contains `VK_IMAGE_USAGE_STORAGE_BIT`, then the image
view’s format features :normative{type="must"}
contain `VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT`
::

::validity-field{name="VUID-VkImageViewCreateInfo-usage-02276"}

If `usage` contains `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`, then
the image view’s format
features :normative{type="must"} contain `VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT`
::

::validity-field{name="VUID-VkImageViewCreateInfo-usage-02277"}

If `usage` contains
`VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`, then the image view’s
format features :normative{type="must"} contain
`VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT`
::

::validity-field{name="VUID-VkImageViewCreateInfo-usage-08932"}

If `usage` contains `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT`,
::

::validity-field{name="VUID-VkImageViewCreateInfo-subresourceRange-01478"}
`subresourceRange.baseMipLevel` :normative{type="must"} be less than the
`mipLevels` specified in [VkImageCreateInfo](/man/VkImageCreateInfo) when `image`
was created
::

::validity-field{name="VUID-VkImageViewCreateInfo-subresourceRange-01718"}

If `subresourceRange.levelCount` is not
`VK_REMAINING_MIP_LEVELS`, `subresourceRange.baseMipLevel`
\+  `subresourceRange.levelCount` :normative{type="must"} be less than or equal to
the `mipLevels` specified in [VkImageCreateInfo](/man/VkImageCreateInfo) when
`image` was created
::

::validity-field{name="VUID-VkImageViewCreateInfo-subresourceRange-01480"}
`subresourceRange.baseArrayLayer` :normative{type="must"} be less than the
`arrayLayers` specified in [VkImageCreateInfo](/man/VkImageCreateInfo) when `image`
was created
::

::validity-field{name="VUID-VkImageViewCreateInfo-subresourceRange-01719"}

If `subresourceRange.layerCount` is not
`VK_REMAINING_ARRAY_LAYERS`,
`subresourceRange.baseArrayLayer` + 
`subresourceRange.layerCount` :normative{type="must"} be less than or equal to the
`arrayLayers` specified in [VkImageCreateInfo](/man/VkImageCreateInfo) when `image`
was created
::

::validity-field{name="VUID-VkImageViewCreateInfo-image-01018"}

If `image` was created with the
`VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT` flag, `format` :normative{type="must"} be
compatible with the `format` used to create `image`, as defined
in Format Compatibility Classes
::

::validity-field{name="VUID-VkImageViewCreateInfo-image-01019"}

If `image` was not created with the
`VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT` flag, `format` :normative{type="must"} be
identical to the `format` used to create `image`
::

::validity-field{name="VUID-VkImageViewCreateInfo-image-01020"}

If `image` is non-sparse then it :normative{type="must"} be bound completely and
contiguously to a single `VkDeviceMemory` object
::

::validity-field{name="VUID-VkImageViewCreateInfo-subResourceRange-01021"}
`viewType` :normative{type="must"} be compatible with the type of `image` as shown
in the view type compatibility
table
::

::validity-field{name="VUID-VkImageViewCreateInfo-imageViewType-04973"}

If `viewType` is `VK_IMAGE_VIEW_TYPE_1D`,
`VK_IMAGE_VIEW_TYPE_2D`, or `VK_IMAGE_VIEW_TYPE_3D`; and
`subresourceRange.layerCount` is not
`VK_REMAINING_ARRAY_LAYERS`, then `subresourceRange.layerCount`
:normative{type="must"} be 1
::

::validity-field{name="VUID-VkImageViewCreateInfo-imageViewType-04974"}

If `viewType` is `VK_IMAGE_VIEW_TYPE_1D`,
`VK_IMAGE_VIEW_TYPE_2D`, or `VK_IMAGE_VIEW_TYPE_3D`; and
`subresourceRange.layerCount` is `VK_REMAINING_ARRAY_LAYERS`,
then the remaining number of layers :normative{type="must"} be 1
::

::validity-field{name="VUID-VkImageViewCreateInfo-viewType-02960"}

If `viewType` is `VK_IMAGE_VIEW_TYPE_CUBE` and
`subresourceRange.layerCount` is not
`VK_REMAINING_ARRAY_LAYERS`, `subresourceRange.layerCount` :normative{type="must"}
be `6`
::

::validity-field{name="VUID-VkImageViewCreateInfo-viewType-02961"}

If `viewType` is `VK_IMAGE_VIEW_TYPE_CUBE_ARRAY` and
`subresourceRange.layerCount` is not
`VK_REMAINING_ARRAY_LAYERS`, `subresourceRange.layerCount` :normative{type="must"}
be a multiple of `6`
::

::validity-field{name="VUID-VkImageViewCreateInfo-viewType-02962"}

If `viewType` is `VK_IMAGE_VIEW_TYPE_CUBE` and
`subresourceRange.layerCount` is `VK_REMAINING_ARRAY_LAYERS`,
the remaining number of layers :normative{type="must"} be `6`
::

::validity-field{name="VUID-VkImageViewCreateInfo-viewType-02963"}

If `viewType` is `VK_IMAGE_VIEW_TYPE_CUBE_ARRAY` and
`subresourceRange.layerCount` is `VK_REMAINING_ARRAY_LAYERS`,
the remaining number of layers :normative{type="must"} be a multiple of `6`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkImageViewCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO`
::

::validity-field{name="VUID-VkImageViewCreateInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkExportMetalObjectCreateInfoEXT](/man/VkExportMetalObjectCreateInfoEXT), [VkImageViewASTCDecodeModeEXT](/man/VkImageViewASTCDecodeModeEXT), [VkImageViewMinLodCreateInfoEXT](/man/VkImageViewMinLodCreateInfoEXT), [VkImageViewSampleWeightCreateInfoQCOM](/man/VkImageViewSampleWeightCreateInfoQCOM), [VkImageViewSlicedCreateInfoEXT](/man/VkImageViewSlicedCreateInfoEXT), [VkImageViewUsageCreateInfo](/man/VkImageViewUsageCreateInfo), [VkOpaqueCaptureDescriptorDataCreateInfoEXT](/man/VkOpaqueCaptureDescriptorDataCreateInfoEXT), or [VkSamplerYcbcrConversionInfo](/man/VkSamplerYcbcrConversionInfo)
::

::validity-field{name="VUID-VkImageViewCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique, with the exception of structures of type [VkExportMetalObjectCreateInfoEXT](/man/VkExportMetalObjectCreateInfoEXT)
::

::validity-field{name="VUID-VkImageViewCreateInfo-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkImageViewCreateFlagBits](/man/VkImageViewCreateFlagBits) values
::

::validity-field{name="VUID-VkImageViewCreateInfo-image-parameter"}
 `image` :normative{type="must"} be a valid [VkImage](/man/VkImage) handle
::

::validity-field{name="VUID-VkImageViewCreateInfo-viewType-parameter"}
 `viewType` :normative{type="must"} be a valid [VkImageViewType](/man/VkImageViewType) value
::

::validity-field{name="VUID-VkImageViewCreateInfo-format-parameter"}
 `format` :normative{type="must"} be a valid [VkFormat](/man/VkFormat) value
::

::validity-field{name="VUID-VkImageViewCreateInfo-components-parameter"}
 `components` :normative{type="must"} be a valid [VkComponentMapping](/man/VkComponentMapping) structure
::

::validity-field{name="VUID-VkImageViewCreateInfo-subresourceRange-parameter"}
 `subresourceRange` :normative{type="must"} be a valid [VkImageSubresourceRange](/man/VkImageSubresourceRange) structure
::

::


Bits which :normative{type="can"} be set in [VkImageViewCreateInfo](/man/VkImageViewCreateInfo)::`flags`,
specifying additional parameters of an image view, are:

[{generated}/api/enums/VkImageViewCreateFlagBits.adoc]({generated}/api/enums/VkImageViewCreateFlagBits.adoc)

[{generated}/api/flags/VkImageViewCreateFlags.adoc]({generated}/api/flags/VkImageViewCreateFlags.adoc)

`VkImageViewCreateFlags` is a bitmask type for setting a mask of zero or
more [VkImageViewCreateFlagBits](/man/VkImageViewCreateFlagBits).

The `VkImageSubresourceRange` structure is defined as:

[{generated}/api/structs/VkImageSubresourceRange.adoc]({generated}/api/structs/VkImageSubresourceRange.adoc)

- `aspectMask` is a bitmask of [VkImageAspectFlagBits](/man/VkImageAspectFlagBits) specifying
  which aspect(s) of the image are included in the view.

- `baseMipLevel` is the first mipmap level accessible to the view.

- `levelCount` is the number of mipmap levels (starting from
  `baseMipLevel`) accessible to the view.

- `baseArrayLayer` is the first array layer accessible to the view.

- `layerCount` is the number of array layers (starting from
  `baseArrayLayer`) accessible to the view.

The number of mipmap levels and array layers :normative{type="must"} be a subset of the image
subresources in the image.
If an application wants to use all mip levels or layers in an image after
the `baseMipLevel` or `baseArrayLayer`, it :normative{type="can"} set `levelCount`
and `layerCount` to the special values `VK_REMAINING_MIP_LEVELS` and
`VK_REMAINING_ARRAY_LAYERS` without knowing the exact number of mip
levels or layers.

For cube and cube array image views, the layers of the image view starting
at `baseArrayLayer` correspond to faces in the order +X, -X, +Y, -Y, +Z,
-Z.
For cube arrays, each set of six sequential layers is a single cube, so the
number of cube maps in a cube map array view is *`layerCount` / 6*, and
image array layer (`baseArrayLayer` +  i) is face index
(i mod 6) of cube *i / 6*.
If the number of layers in the view, whether set explicitly in
`layerCount` or implied by `VK_REMAINING_ARRAY_LAYERS`, is not a
multiple of 6, the last cube map in the array :normative{type="must"} not be accessed.

`aspectMask` :normative{type="must"} be only `VK_IMAGE_ASPECT_COLOR_BIT`,
`VK_IMAGE_ASPECT_DEPTH_BIT` or `VK_IMAGE_ASPECT_STENCIL_BIT` if
`format` is a color, depth-only or stencil-only format,
respectively.
If using a depth/stencil format with both depth and stencil components,
`aspectMask` :normative{type="must"} include at least one of
`VK_IMAGE_ASPECT_DEPTH_BIT` and `VK_IMAGE_ASPECT_STENCIL_BIT`, and
:normative{type="can"} include both.

When using an image view of a depth/stencil image to populate a descriptor
set (e.g. for sampling in the shader, or for use as an input attachment),
the `aspectMask` :normative{type="must"} only include one bit, which selects whether the
image view is used for depth reads (i.e. using a floating-point sampler or
input attachment in the shader) or stencil reads (i.e. using an unsigned
integer sampler or input attachment in the shader).
When an image view of a depth/stencil image is used as a depth/stencil
framebuffer attachment, the `aspectMask` is ignored and both depth and
stencil image subresources are used.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkImageSubresourceRange-levelCount-01720"}

If `levelCount` is not `VK_REMAINING_MIP_LEVELS`, it :normative{type="must"} be
greater than `0`
::

::validity-field{name="VUID-VkImageSubresourceRange-layerCount-01721"}

If `layerCount` is not `VK_REMAINING_ARRAY_LAYERS`, it :normative{type="must"} be
greater than `0`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkImageSubresourceRange-aspectMask-parameter"}
 `aspectMask` :normative{type="must"} be a valid combination of [VkImageAspectFlagBits](/man/VkImageAspectFlagBits) values
::

::validity-field{name="VUID-VkImageSubresourceRange-aspectMask-requiredbitmask"}
 `aspectMask` :normative{type="must"} not be `0`
::

::


Bits which :normative{type="can"} be set in an aspect mask to specify aspects of an image for
purposes such as identifying a subresource, are:

[{generated}/api/enums/VkImageAspectFlagBits.adoc]({generated}/api/enums/VkImageAspectFlagBits.adoc)

- `VK_IMAGE_ASPECT_COLOR_BIT` specifies the color aspect.

- `VK_IMAGE_ASPECT_DEPTH_BIT` specifies the depth aspect.

- `VK_IMAGE_ASPECT_STENCIL_BIT` specifies the stencil aspect.

- `VK_IMAGE_ASPECT_METADATA_BIT` specifies the metadata aspect used
  for sparse resource operations.

[{generated}/api/flags/VkImageAspectFlags.adoc]({generated}/api/flags/VkImageAspectFlags.adoc)

`VkImageAspectFlags` is a bitmask type for setting a mask of zero or
more [VkImageAspectFlagBits](/man/VkImageAspectFlagBits).

The `VkComponentMapping` structure is defined as:

[{generated}/api/structs/VkComponentMapping.adoc]({generated}/api/structs/VkComponentMapping.adoc)

- `r` is a [VkComponentSwizzle](/man/VkComponentSwizzle) specifying the component value
  placed in the R component of the output vector.

- `g` is a [VkComponentSwizzle](/man/VkComponentSwizzle) specifying the component value
  placed in the G component of the output vector.

- `b` is a [VkComponentSwizzle](/man/VkComponentSwizzle) specifying the component value
  placed in the B component of the output vector.

- `a` is a [VkComponentSwizzle](/man/VkComponentSwizzle) specifying the component value
  placed in the A component of the output vector.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkComponentMapping-r-parameter"}
 `r` :normative{type="must"} be a valid [VkComponentSwizzle](/man/VkComponentSwizzle) value
::

::validity-field{name="VUID-VkComponentMapping-g-parameter"}
 `g` :normative{type="must"} be a valid [VkComponentSwizzle](/man/VkComponentSwizzle) value
::

::validity-field{name="VUID-VkComponentMapping-b-parameter"}
 `b` :normative{type="must"} be a valid [VkComponentSwizzle](/man/VkComponentSwizzle) value
::

::validity-field{name="VUID-VkComponentMapping-a-parameter"}
 `a` :normative{type="must"} be a valid [VkComponentSwizzle](/man/VkComponentSwizzle) value
::

::


Possible values of the members of [VkComponentMapping](/man/VkComponentMapping), specifying the
component values placed in each component of the output vector, are:

[{generated}/api/enums/VkComponentSwizzle.adoc]({generated}/api/enums/VkComponentSwizzle.adoc)

- `VK_COMPONENT_SWIZZLE_IDENTITY` specifies that the component is set
  to the identity swizzle.

- `VK_COMPONENT_SWIZZLE_ZERO` specifies that the component is set to
  zero.

- `VK_COMPONENT_SWIZZLE_ONE` specifies that the component is set to
  either 1 or 1.0, depending on whether the type of the image view format
  is integer or floating-point respectively, as determined by the
  Format Definition section for each
  [VkFormat](/man/VkFormat).

- `VK_COMPONENT_SWIZZLE_R` specifies that the component is set to the
  value of the R component of the image.

- `VK_COMPONENT_SWIZZLE_G` specifies that the component is set to the
  value of the G component of the image.

- `VK_COMPONENT_SWIZZLE_B` specifies that the component is set to the
  value of the B component of the image.

- `VK_COMPONENT_SWIZZLE_A` specifies that the component is set to the
  value of the A component of the image.

Setting the identity swizzle on a component is equivalent to setting the
identity mapping on that component.
That is:



To destroy an image view, call:

[{generated}/api/protos/vkDestroyImageView.adoc]({generated}/api/protos/vkDestroyImageView.adoc)

- `device` is the logical device that destroys the image view.

- `imageView` is the image view to destroy.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkDestroyImageView-imageView-01026"}

All submitted commands that refer to `imageView` :normative{type="must"} have
completed execution
::

::validity-field{name="VUID-vkDestroyImageView-imageView-01027"}

If `VkAllocationCallbacks` were provided when `imageView` was
created, a compatible set of callbacks :normative{type="must"} be provided here
::

::validity-field{name="VUID-vkDestroyImageView-imageView-01028"}

If no `VkAllocationCallbacks` were provided when `imageView` was
created, `pAllocator` :normative{type="must"} be `NULL`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkDestroyImageView-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkDestroyImageView-imageView-parameter"}
 If `imageView` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `imageView` :normative{type="must"} be a valid [VkImageView](/man/VkImageView) handle
::

::validity-field{name="VUID-vkDestroyImageView-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkDestroyImageView-imageView-parent"}
 If `imageView` is a valid handle, it :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::






### Image View Format Features

Valid uses of a [VkImageView](/man/VkImageView) :normative{type="may"} depend on the image view’s *format
features*, defined below.
Such constraints are documented in the affected valid usage statement.

- If [VkImageViewCreateInfo](/man/VkImageViewCreateInfo)::`image` was created with
  `VK_IMAGE_TILING_LINEAR`, then the image view’s set of *format
  features* is the value of
  [VkFormatProperties](/man/VkFormatProperties)::`linearTilingFeatures` found by calling
  [vkGetPhysicalDeviceFormatProperties](/man/vkGetPhysicalDeviceFormatProperties) on the same `format` as
  [VkImageViewCreateInfo](/man/VkImageViewCreateInfo)::`format`.

- If [VkImageViewCreateInfo](/man/VkImageViewCreateInfo)::`image` was created with
  `VK_IMAGE_TILING_OPTIMAL`,
  then the image view’s set of *format features* is the value of
  [VkFormatProperties](/man/VkFormatProperties)::`optimalTilingFeatures` found by calling
  [vkGetPhysicalDeviceFormatProperties](/man/vkGetPhysicalDeviceFormatProperties) on the same `format` as
  [VkImageViewCreateInfo](/man/VkImageViewCreateInfo)::`format`.







## Resource Memory Association

Resources are initially created as *virtual allocations* with no backing
memory.
Device memory is allocated separately (see ) and then
associated with the resource.
This association is done differently for sparse and non-sparse resources.

Resources created with any of the sparse creation flags are considered
sparse resources.
Resources created without these flags are non-sparse.
The details on resource memory association for sparse resources is described
in .

Non-sparse resources :normative{type="must"} be bound completely and contiguously to a single
`VkDeviceMemory` object before the resource is passed as a parameter to
any of the following operations:

- creating image or buffer views

- updating descriptor sets

- recording commands in a command buffer

Once bound, the memory binding is immutable for the lifetime of the
resource.

To determine the memory requirements for a buffer resource, call:

[{generated}/api/protos/vkGetBufferMemoryRequirements.adoc]({generated}/api/protos/vkGetBufferMemoryRequirements.adoc)

- `device` is the logical device that owns the buffer.

- `buffer` is the buffer to query.

- `pMemoryRequirements` is a pointer to a [VkMemoryRequirements](/man/VkMemoryRequirements)
  structure in which the memory requirements of the buffer object are
  returned.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkGetBufferMemoryRequirements-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkGetBufferMemoryRequirements-buffer-parameter"}
 `buffer` :normative{type="must"} be a valid [VkBuffer](/man/VkBuffer) handle
::

::validity-field{name="VUID-vkGetBufferMemoryRequirements-pMemoryRequirements-parameter"}
 `pMemoryRequirements` :normative{type="must"} be a valid pointer to a [VkMemoryRequirements](/man/VkMemoryRequirements) structure
::

::validity-field{name="VUID-vkGetBufferMemoryRequirements-buffer-parent"}
 `buffer` :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::


To determine the memory requirements for an image resource, call:

[{generated}/api/protos/vkGetImageMemoryRequirements.adoc]({generated}/api/protos/vkGetImageMemoryRequirements.adoc)

- `device` is the logical device that owns the image.

- `image` is the image to query.

- `pMemoryRequirements` is a pointer to a [VkMemoryRequirements](/man/VkMemoryRequirements)
  structure in which the memory requirements of the image object are
  returned.




::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkGetImageMemoryRequirements-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkGetImageMemoryRequirements-image-parameter"}
 `image` :normative{type="must"} be a valid [VkImage](/man/VkImage) handle
::

::validity-field{name="VUID-vkGetImageMemoryRequirements-pMemoryRequirements-parameter"}
 `pMemoryRequirements` :normative{type="must"} be a valid pointer to a [VkMemoryRequirements](/man/VkMemoryRequirements) structure
::

::validity-field{name="VUID-vkGetImageMemoryRequirements-image-parent"}
 `image` :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::


The `VkMemoryRequirements` structure is defined as:

[{generated}/api/structs/VkMemoryRequirements.adoc]({generated}/api/structs/VkMemoryRequirements.adoc)

- `size` is the size, in bytes, of the memory allocation :normative{type="required"} for
  the resource.

- `alignment` is the alignment, in bytes, of the offset within the
  allocation :normative{type="required"} for the resource.

- `memoryTypeBits` is a bitmask and contains one bit set for every
  supported memory type for the resource.
  Bit `i` is set if and only if the memory type `i` in the
  `VkPhysicalDeviceMemoryProperties` structure for the physical device
  is supported for the resource.

The implementation guarantees certain properties about the memory
requirements returned by
[vkGetBufferMemoryRequirements](/man/vkGetBufferMemoryRequirements) and [vkGetImageMemoryRequirements](/man/vkGetImageMemoryRequirements):

- The `memoryTypeBits` member always contains at least one bit set.

- If `buffer` is a `VkBuffer` not created with the
  `VK_BUFFER_CREATE_SPARSE_BINDING_BIT` bit set, or if `image` is
  linear image, then the `memoryTypeBits`
  member always contains at least one bit set corresponding to a
  `VkMemoryType` with a `propertyFlags` that has both the
  `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` bit and the
  `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` bit set.
  In other words, mappable coherent memory :normative{type="can"} always be attached to
  these objects.

- The
  `memoryTypeBits` member always contains at least one bit set
  corresponding to a `VkMemoryType` with a `propertyFlags` that
  has the `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT` bit set.

- The `memoryTypeBits` member is identical for all `VkBuffer`
  objects created with the same value for the `flags` and `usage`
  members in the [VkBufferCreateInfo](/man/VkBufferCreateInfo) structure
  passed to [vkCreateBuffer](/man/vkCreateBuffer).
  Further, if `usage1` and `usage2` of type [VkBufferUsageFlags](/man/VkBufferUsageFlags)
  are such that the bits set in `usage2` are a subset of the bits set
  in `usage1`, and they have the same
  `flags`,
  then the bits set in `memoryTypeBits` returned for `usage1` :normative{type="must"}
  be a subset of the bits set in `memoryTypeBits` returned for
  `usage2`, for all values of `flags`.

- The `alignment` member is a power of two.

- The `alignment` member is identical for all `VkBuffer` objects
  created with the same combination of values for the `usage` and
  `flags` members in the [VkBufferCreateInfo](/man/VkBufferCreateInfo) structure passed to
  [vkCreateBuffer](/man/vkCreateBuffer).

- The `alignment` member satisfies the buffer descriptor offset
  alignment requirements associated with the `VkBuffer`’s `usage`:





  * If `usage` included `VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT`
    or `VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT`, `alignment`
    :normative{type="must"} be an integer multiple of
    `VkPhysicalDeviceLimits`::`minTexelBufferOffsetAlignment`.

  * If `usage` included `VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT`,
    `alignment` :normative{type="must"} be an integer multiple of
    `VkPhysicalDeviceLimits`::`minUniformBufferOffsetAlignment`.

  * If `usage` included `VK_BUFFER_USAGE_STORAGE_BUFFER_BIT`,
    `alignment` :normative{type="must"} be an integer multiple of
    `VkPhysicalDeviceLimits`::`minStorageBufferOffsetAlignment`.

- For images created with a color format, the `memoryTypeBits` member
  is identical for all `VkImage` objects created with the same
  combination of values for the `tiling` member, the
  `VK_IMAGE_CREATE_SPARSE_BINDING_BIT` bit of the `flags` member,
  and the `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT` of the `usage`
  member in the [VkImageCreateInfo](/man/VkImageCreateInfo) structure passed to
  [vkCreateImage](/man/vkCreateImage).

- For images created with a depth/stencil format, the `memoryTypeBits`
  member is identical for all `VkImage` objects created with the same
  combination of values for the `format` member, the `tiling`
  member, the `VK_IMAGE_CREATE_SPARSE_BINDING_BIT` bit of the
  `flags` member,
  and the `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT` of the `usage`
  member in the [VkImageCreateInfo](/man/VkImageCreateInfo) structure passed to
  [vkCreateImage](/man/vkCreateImage).

- If the memory requirements are for a `VkImage`, the
  `memoryTypeBits` member :normative{type="must"} not refer to a `VkMemoryType` with
  a `propertyFlags` that has the
  `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT` bit set if the `image`
  did not have `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT` bit set in
  the `usage` member of the [VkImageCreateInfo](/man/VkImageCreateInfo) structure passed
  to [vkCreateImage](/man/vkCreateImage).

- If the memory requirements are for a `VkBuffer`, the
  `memoryTypeBits` member :normative{type="must"} not refer to a `VkMemoryType` with
  a `propertyFlags` that has the
  `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT` bit set.






  ::note


  The implication of this requirement is that lazily allocated memory is
  disallowed for buffers in all cases.


  ::


- The `size` member is identical for all `VkBuffer` objects
  created with the same combination of creation parameters specified in
  [VkBufferCreateInfo](/man/VkBufferCreateInfo) and its `pNext` chain.

- The `size` member is identical for all `VkImage` objects created
  with the same combination of creation parameters specified in
  [VkImageCreateInfo](/man/VkImageCreateInfo) and its `pNext` chain.






  ::note


  This, however, does not imply that they interpret the contents of the bound
  memory identically with each other.


  ::


To attach memory to a buffer object, call:

[{generated}/api/protos/vkBindBufferMemory.adoc]({generated}/api/protos/vkBindBufferMemory.adoc)

- `device` is the logical device that owns the buffer and memory.

- `buffer` is the buffer to be attached to memory.

- `memory` is a [VkDeviceMemory](/man/VkDeviceMemory) object describing the device
  memory to attach.

- `memoryOffset` is the start offset of the region of `memory`
  which is to be bound to the buffer.
  The number of bytes returned in the
  `VkMemoryRequirements`::`size` member in `memory`, starting
  from `memoryOffset` bytes, will be bound to the specified buffer.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkBindBufferMemory-buffer-07459"}
`buffer` :normative{type="must"} not have been bound to a memory object
::

::validity-field{name="VUID-vkBindBufferMemory-buffer-01030"}
`buffer` :normative{type="must"} not have been created with any sparse memory binding
flags
::

::validity-field{name="VUID-vkBindBufferMemory-memoryOffset-01031"}
`memoryOffset` :normative{type="must"} be less than the size of `memory`
::

::validity-field{name="VUID-vkBindBufferMemory-memory-01035"}
`memory` :normative{type="must"} have been allocated using one of the memory types
allowed in the `memoryTypeBits` member of the
`VkMemoryRequirements` structure returned from a call to
`vkGetBufferMemoryRequirements` with `buffer`
::

::validity-field{name="VUID-vkBindBufferMemory-memoryOffset-01036"}
`memoryOffset` :normative{type="must"} be an integer multiple of the `alignment`
member of the `VkMemoryRequirements` structure returned from a call
to `vkGetBufferMemoryRequirements` with `buffer`
::

::validity-field{name="VUID-vkBindBufferMemory-size-01037"}

The `size` member of the `VkMemoryRequirements` structure
returned from a call to `vkGetBufferMemoryRequirements` with
`buffer` :normative{type="must"} be less than or equal to the size of `memory`
minus `memoryOffset`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkBindBufferMemory-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkBindBufferMemory-buffer-parameter"}
 `buffer` :normative{type="must"} be a valid [VkBuffer](/man/VkBuffer) handle
::

::validity-field{name="VUID-vkBindBufferMemory-memory-parameter"}
 `memory` :normative{type="must"} be a valid [VkDeviceMemory](/man/VkDeviceMemory) handle
::

::validity-field{name="VUID-vkBindBufferMemory-buffer-parent"}
 `buffer` :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::validity-field{name="VUID-vkBindBufferMemory-memory-parent"}
 `memory` :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::






To attach memory to an image object, call:

[{generated}/api/protos/vkBindImageMemory.adoc]({generated}/api/protos/vkBindImageMemory.adoc)

- `device` is the logical device that owns the image and memory.

- `image` is the image.

- `memory` is the [VkDeviceMemory](/man/VkDeviceMemory) object describing the device
  memory to attach.

- `memoryOffset` is the start offset of the region of `memory`
  which is to be bound to the image.
  The number of bytes returned in the
  `VkMemoryRequirements`::`size` member in `memory`, starting
  from `memoryOffset` bytes, will be bound to the specified image.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkBindImageMemory-image-07460"}
`image` :normative{type="must"} not have been bound to a memory object
::

::validity-field{name="VUID-vkBindImageMemory-image-01045"}
`image` :normative{type="must"} not have been created with any sparse memory binding
flags
::

::validity-field{name="VUID-vkBindImageMemory-memoryOffset-01046"}
`memoryOffset` :normative{type="must"} be less than the size of `memory`
::

::validity-field{name="VUID-vkBindImageMemory-memory-01047"}
`memory` :normative{type="must"} have been allocated using one of the memory types
allowed in the `memoryTypeBits` member of the
`VkMemoryRequirements` structure returned from a call to
[vkGetImageMemoryRequirements](/man/vkGetImageMemoryRequirements) with `image`
::

::validity-field{name="VUID-vkBindImageMemory-memoryOffset-01048"}
`memoryOffset` :normative{type="must"} be an integer multiple of the `alignment`
member of the `VkMemoryRequirements` structure returned from a call
to [vkGetImageMemoryRequirements](/man/vkGetImageMemoryRequirements) with `image`
::

::validity-field{name="VUID-vkBindImageMemory-size-01049"}

The difference of the size of `memory` and `memoryOffset` :normative{type="must"}
be greater than or equal to the `size` member of the
[VkMemoryRequirements](/man/VkMemoryRequirements) structure returned from a call to
[vkGetImageMemoryRequirements](/man/vkGetImageMemoryRequirements) with the same `image`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkBindImageMemory-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkBindImageMemory-image-parameter"}
 `image` :normative{type="must"} be a valid [VkImage](/man/VkImage) handle
::

::validity-field{name="VUID-vkBindImageMemory-memory-parameter"}
 `memory` :normative{type="must"} be a valid [VkDeviceMemory](/man/VkDeviceMemory) handle
::

::validity-field{name="VUID-vkBindImageMemory-image-parent"}
 `image` :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::validity-field{name="VUID-vkBindImageMemory-memory-parent"}
 `memory` :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::









::note
Despite its name, `bufferImageGranularity` is really a granularity
between > linear and > non-linear resources.
::


Given resourceA at the lower memory offset and resourceB at the higher
memory offset in the same `VkDeviceMemory` object, where one resource is
linear and the other is non-linear (as defined in the
Glossary), and the following:



The following property :normative{type="must"} hold:



That is, the end of the first resource (A) and the beginning of the second
resource (B) :normative{type="must"} be on separate > pages of size
`bufferImageGranularity`.
`bufferImageGranularity` :normative{type="may"} be different than the physical page size
of the memory heap.
This restriction is only needed when a linear resource and a non-linear
resource are adjacent in memory and will be used simultaneously.
The memory ranges of adjacent resources :normative{type="can"} be closer than
`bufferImageGranularity`, provided they meet the `alignment`
requirement for the objects in question.

Sparse block size in bytes and sparse image and buffer memory alignments
:normative{type="must"} all be multiples of the `bufferImageGranularity`.
Therefore, memory bound to sparse resources naturally satisfies the
`bufferImageGranularity`.





## Resource Sharing Mode

Buffer and image objects are created with a *sharing mode* controlling how
they :normative{type="can"} be accessed from queues.
The supported sharing modes are:

[{generated}/api/enums/VkSharingMode.adoc]({generated}/api/enums/VkSharingMode.adoc)

- `VK_SHARING_MODE_EXCLUSIVE` specifies that access to any range or
  image subresource of the object will be exclusive to a single queue
  family at a time.

- `VK_SHARING_MODE_CONCURRENT` specifies that concurrent access to any
  range or image subresource of the object from multiple queue families is
  supported.


::note
`VK_SHARING_MODE_CONCURRENT` :normative{type="may"} result in lower performance access to
the buffer or image than `VK_SHARING_MODE_EXCLUSIVE`.
::


Ranges of buffers and image subresources of image objects created using
`VK_SHARING_MODE_EXCLUSIVE` :normative{type="must"} only be accessed by queues in the
queue family that has *ownership* of the resource.
Upon creation, such resources are not owned by any queue family; ownership
is implicitly acquired upon first use within a queue.
Once a resource using `VK_SHARING_MODE_EXCLUSIVE` is owned by some queue
family, the application :normative{type="must"} perform a
queue family ownership transfer to make
the memory contents of a range or image subresource accessible to a
different queue family.


::note
Images still require a layout transition from
`VK_IMAGE_LAYOUT_UNDEFINED` or `VK_IMAGE_LAYOUT_PREINITIALIZED`
before being used on the first queue.
::


A queue family :normative{type="can"} take ownership of an image subresource or buffer range
of a resource created with `VK_SHARING_MODE_EXCLUSIVE`, without an
ownership transfer, in the same way as for a resource that was just created;
however, taking ownership in this way has the effect that the contents of
the image subresource or buffer range are undefined:.

Ranges of buffers and image subresources of image objects created using
`VK_SHARING_MODE_CONCURRENT` :normative{type="must"} only be accessed by queues from the
queue families specified through the `queueFamilyIndexCount` and
`pQueueFamilyIndices` members of the corresponding create info
structures.





## Memory Aliasing

A range of a `VkDeviceMemory` allocation is *aliased* if it is bound to
multiple resources simultaneously, as described below, via
[vkBindImageMemory](/man/vkBindImageMemory), [vkBindBufferMemory](/man/vkBindBufferMemory),
or via sparse memory bindings.

Consider two resources, resource\<sub>A\</sub> and resource\<sub>B\</sub>, bound respectively to
memory range\<sub>A\</sub> and range\<sub>B\</sub>.
Let paddedRange\<sub>A\</sub> and paddedRange\<sub>B\</sub> be, respectively, range\<sub>A\</sub> and
range\<sub>B\</sub> aligned to `bufferImageGranularity`.
If the resources are both linear or both non-linear (as defined in the
Glossary), then the resources *alias* the
memory in the intersection of range\<sub>A\</sub> and range\<sub>B\</sub>.
If one resource is linear and the other is non-linear, then the resources
*alias* the memory in the intersection of paddedRange\<sub>A\</sub> and paddedRange\<sub>B\</sub>.

Applications :normative{type="can"} alias memory, but use of multiple aliases is subject to
several constraints.


::note
Memory aliasing :normative{type="can"} be useful to reduce the total device memory footprint
of an application, if some large resources are used for disjoint periods of
time.
::


When a non-linear,
non-`VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` image is bound to an aliased
range, all image subresources of the image *overlap* the range.
When a linear image is bound to an aliased range, the image subresources
that (according to the image’s advertised layout) include bytes from the
aliased range overlap the range.
When a `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` image has sparse image
blocks bound to an aliased range, only image subresources including those
sparse image blocks overlap the range, and when the memory bound to the
image’s mip tail overlaps an aliased range all image subresources in the mip
tail overlap the range.

Buffers, and linear image subresources in either the
`VK_IMAGE_LAYOUT_PREINITIALIZED` or `VK_IMAGE_LAYOUT_GENERAL`
layouts, are *host-accessible subresources*.
That is, the host has a well-defined addressing scheme to interpret the
contents, and thus the layout of the data in memory :normative{type="can"} be consistently
interpreted across aliases if each of those aliases is a host-accessible
subresource.
Non-linear images, and linear image subresources in other layouts, are not
host-accessible.

If two aliases are both host-accessible, then they interpret the contents of
the memory in consistent ways, and data written to one alias :normative{type="can"} be read by
the other alias.

Otherwise, the aliases interpret the contents of the memory differently, and
writes via one alias make the contents of memory partially or completely
undefined: to the other alias.
If the first alias is a host-accessible subresource, then the bytes affected
are those written by the memory operations according to its addressing
scheme.
If the first alias is not host-accessible, then the bytes affected are those
overlapped by the image subresources that were written.
If the second alias is a host-accessible subresource, the affected bytes
become undefined:.
If the second alias is not host-accessible, all sparse image blocks (for
sparse partially-resident images) or all image subresources (for non-sparse
image and fully resident sparse images) that overlap the affected bytes
become undefined:.

If any image subresources are made undefined: due to writes to an alias,
then each of those image subresources :normative{type="must"} have its layout transitioned
from `VK_IMAGE_LAYOUT_UNDEFINED` to a valid layout before it is used, or
from `VK_IMAGE_LAYOUT_PREINITIALIZED` if the memory has been written by
the host.
If any sparse blocks of a sparse image have been made undefined:, then only
the image subresources containing them :normative{type="must"} be transitioned.

Use of an overlapping range by two aliases :normative{type="must"} be separated by a memory
dependency using the appropriate access
types if at least one of those uses performs writes, whether the aliases
interpret memory consistently or not.
If buffer or image memory barriers are used, the scope of the barrier :normative{type="must"}
contain the entire range and/or set of image subresources that overlap.

If two aliasing image views are used in the same framebuffer, then the
render pass :normative{type="must"} declare the attachments using the
`VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT`, and
follow the other rules listed in that section.


::note
Memory recycled via an application suballocator (i.e. without freeing and
reallocating the memory objects) is not substantially different from memory
aliasing.
However, a suballocator usually waits on a fence before recycling a region
of memory, and signaling a fence involves sufficient implicit dependencies
to satisfy all the above requirements.
::




### Resource Memory Overlap

Applications :normative{type="can"} safely access a resource concurrently as long as the
memory locations do not overlap as defined in
Memory Location.
This includes aliased resources if such aliasing is well-defined.
It also includes access from different queues and/or queue families if such
concurrent access is supported by the resource.
Transfer commands only access memory locations specified by the range of the
transfer command.


::note
The intent is that buffers (or linear images) can be accessed concurrently,
even when they share cache lines, but otherwise do not access the same
memory range.
The concept of a device cache line size is not exposed in the memory model.
::










# Samplers

`VkSampler` objects represent the state of an image sampler which is
used by the implementation to read image data and apply filtering and other
transformations for the shader.

Samplers are represented by `VkSampler` handles:

[{generated}/api/handles/VkSampler.adoc]({generated}/api/handles/VkSampler.adoc)

To create a sampler object, call:

[{generated}/api/protos/vkCreateSampler.adoc]({generated}/api/protos/vkCreateSampler.adoc)

- `device` is the logical device that creates the sampler.

- `pCreateInfo` is a pointer to a [VkSamplerCreateInfo](/man/VkSamplerCreateInfo) structure
  specifying the state of the sampler object.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

- `pSampler` is a pointer to a [VkSampler](/man/VkSampler) handle in which the
  resulting sampler object is returned.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCreateSampler-maxSamplerAllocationCount-04110"}

There :normative{type="must"} be less than
[VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits)::`maxSamplerAllocationCount`

[VkSampler](/man/VkSampler) objects currently created on the device
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCreateSampler-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkCreateSampler-pCreateInfo-parameter"}
 `pCreateInfo` :normative{type="must"} be a valid pointer to a valid [VkSamplerCreateInfo](/man/VkSamplerCreateInfo) structure
::

::validity-field{name="VUID-vkCreateSampler-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkCreateSampler-pSampler-parameter"}
 `pSampler` :normative{type="must"} be a valid pointer to a [VkSampler](/man/VkSampler) handle
::

::




The `VkSamplerCreateInfo` structure is defined as:

[{generated}/api/structs/VkSamplerCreateInfo.adoc]({generated}/api/structs/VkSamplerCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is a bitmask of [VkSamplerCreateFlagBits](/man/VkSamplerCreateFlagBits) describing
  additional parameters of the sampler.

- `magFilter` is a [VkFilter](/man/VkFilter) value specifying the magnification
  filter to apply to lookups.

- `minFilter` is a [VkFilter](/man/VkFilter) value specifying the minification
  filter to apply to lookups.

- `mipmapMode` is a [VkSamplerMipmapMode](/man/VkSamplerMipmapMode) value specifying the
  mipmap filter to apply to lookups.

- `addressModeU` is a [VkSamplerAddressMode](/man/VkSamplerAddressMode) value specifying the
  addressing mode for U coordinates outside \[0,1).

- `addressModeV` is a [VkSamplerAddressMode](/man/VkSamplerAddressMode) value specifying the
  addressing mode for V coordinates outside \[0,1).

- `addressModeW` is a [VkSamplerAddressMode](/man/VkSamplerAddressMode) value specifying the
  addressing mode for W coordinates outside \[0,1).

- [samplers-mipLodBias](#samplers-mipLodBias) `mipLodBias` is the bias to be added to
  mipmap LOD calculation and bias provided by image sampling functions in
  SPIR-V, as described in the LOD
  Operation section.

- [samplers-maxAnisotropy](#samplers-maxAnisotropy) `anisotropyEnable` is `VK_TRUE` to
  enable anisotropic filtering, as described in the
  Texel Anisotropic Filtering
  section, or `VK_FALSE` otherwise.

- `maxAnisotropy` is the anisotropy value clamp used by the sampler
  when `anisotropyEnable` is `VK_TRUE`.
  If `anisotropyEnable` is `VK_FALSE`, `maxAnisotropy` is
  ignored.

- `compareEnable` is `VK_TRUE` to enable comparison against a
  reference value during lookups, or `VK_FALSE` otherwise.





  * Note: Some implementations will default to shader state if this member
    does not match.

- `compareOp` is a [VkCompareOp](/man/VkCompareOp) value specifying the comparison
  operator to apply to fetched data before filtering as described in the
  Depth Compare Operation section.

- `minLod` is used to clamp the minimum of the computed LOD value.

- `maxLod` is used to clamp the maximum of the computed LOD value.
  To avoid clamping the maximum value, set `maxLod` to the constant
  `VK_LOD_CLAMP_NONE`.

- `borderColor` is a [VkBorderColor](/man/VkBorderColor) value specifying the
  predefined border color to use.

- [samplers-unnormalizedCoordinates](#samplers-unnormalizedCoordinates) `unnormalizedCoordinates`
  controls whether to use unnormalized or normalized texel coordinates to
  address texels of the image.
  When set to `VK_TRUE`, the range of the image coordinates used to
  lookup the texel is in the range of zero to the image size in each
  dimension.
  When set to `VK_FALSE` the range of image coordinates is zero to
  one.





  When `unnormalizedCoordinates` is `VK_TRUE`, images the sampler is
  used with in the shader have the following requirements:





  * The `viewType` :normative{type="must"} be either `VK_IMAGE_VIEW_TYPE_1D` or
    `VK_IMAGE_VIEW_TYPE_2D`.

  * The image view :normative{type="must"} have a single layer and a single mip level.





  When `unnormalizedCoordinates` is `VK_TRUE`, image built-in
  functions in the shader that use the sampler have the following
  requirements:





  * The functions :normative{type="must"} not use projection.

  * The functions :normative{type="must"} not use offsets.


::note
# Mapping of OpenGL to Vulkan filter modes

`magFilter` values of `VK_FILTER_NEAREST` and `VK_FILTER_LINEAR`
directly correspond to `GL_NEAREST` and `GL_LINEAR` magnification
filters.
`minFilter` and `mipmapMode` combine to correspond to the similarly
named OpenGL minification filter of `GL_minFilter_MIPMAP_mipmapMode`
(e.g. `minFilter` of `VK_FILTER_LINEAR` and `mipmapMode` of
`VK_SAMPLER_MIPMAP_MODE_NEAREST` correspond to
`GL_LINEAR_MIPMAP_NEAREST`).

There are no Vulkan filter modes that directly correspond to OpenGL
minification filters of `GL_LINEAR` or `GL_NEAREST`, but they :normative{type="can"} be
emulated using `VK_SAMPLER_MIPMAP_MODE_NEAREST`, `minLod` = 0, and
`maxLod` = 0.25, and using `minFilter` = `VK_FILTER_LINEAR` or
`minFilter` = `VK_FILTER_NEAREST`, respectively.

Note that using a `maxLod` of zero would cause
magnification to always be performed, and the
`magFilter` to always be used.
This is valid, just not an exact match for OpenGL behavior.
Clamping the maximum LOD to 0.25 allows the λ value to be
non-zero and minification to be performed, while still always rounding down
to the base level.
If the `minFilter` and `magFilter` are equal, then using a
`maxLod` of zero also works.
::


The maximum number of sampler objects which :normative{type="can"} be simultaneously created
on a device is implementation-dependent and specified by the
`maxSamplerAllocationCount` member
of the [VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits) structure.


::note
For historical reasons, if `maxSamplerAllocationCount` is exceeded, some
implementations may return `VK_ERROR_TOO_MANY_OBJECTS`.
Exceeding this limit will result in undefined: behavior, and an application
should not rely on the use of the returned error code in order to identify
when the limit is reached.
::


Since [VkSampler](/man/VkSampler) is a non-dispatchable handle type, implementations
:normative{type="may"} return the same handle for sampler state vectors that are identical.
In such cases, all such objects would only count once against the
`maxSamplerAllocationCount` limit.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkSamplerCreateInfo-mipLodBias-01069"}

The absolute value of `mipLodBias` :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxSamplerLodBias`
::

::validity-field{name="VUID-VkSamplerCreateInfo-maxLod-01973"}
`maxLod` :normative{type="must"} be greater than or equal to `minLod`
::

::validity-field{name="VUID-VkSamplerCreateInfo-anisotropyEnable-01070"}

If the `samplerAnisotropy` feature
is not enabled, `anisotropyEnable` :normative{type="must"} be `VK_FALSE`
::

::validity-field{name="VUID-VkSamplerCreateInfo-anisotropyEnable-01071"}

If `anisotropyEnable` is `VK_TRUE`, `maxAnisotropy` :normative{type="must"} be
between `1.0` and
`VkPhysicalDeviceLimits`::`maxSamplerAnisotropy`, inclusive
::

::validity-field{name="VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01072"}

If `unnormalizedCoordinates` is `VK_TRUE`, `minFilter` and
`magFilter` :normative{type="must"} be equal
::

::validity-field{name="VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01073"}

If `unnormalizedCoordinates` is `VK_TRUE`, `mipmapMode`
:normative{type="must"} be `VK_SAMPLER_MIPMAP_MODE_NEAREST`
::

::validity-field{name="VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01074"}

If `unnormalizedCoordinates` is `VK_TRUE`, `minLod` and
`maxLod` :normative{type="must"} be zero
::

::validity-field{name="VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01075"}

If `unnormalizedCoordinates` is `VK_TRUE`, `addressModeU`
and `addressModeV` :normative{type="must"} each be either
`VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE` or
`VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER`
::

::validity-field{name="VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01076"}

If `unnormalizedCoordinates` is `VK_TRUE`,
`anisotropyEnable` :normative{type="must"} be `VK_FALSE`
::

::validity-field{name="VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01077"}

If `unnormalizedCoordinates` is `VK_TRUE`, `compareEnable`
:normative{type="must"} be `VK_FALSE`
::

::validity-field{name="VUID-VkSamplerCreateInfo-addressModeU-01078"}

If any of `addressModeU`, `addressModeV` or `addressModeW`
are `VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER`, `borderColor`
:normative{type="must"} be a valid [VkBorderColor](/man/VkBorderColor) value
::

::validity-field{name="VUID-VkSamplerCreateInfo-addressModeU-01079"}

If `samplerMirrorClampToEdge`
is not enabled, and if the 
extension is not enabled, `addressModeU`, `addressModeV` and
`addressModeW` :normative{type="must"} not be
`VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE`
::

::validity-field{name="VUID-VkSamplerCreateInfo-compareEnable-01080"}

If `compareEnable` is `VK_TRUE`, `compareOp` :normative{type="must"} be a
valid [VkCompareOp](/man/VkCompareOp) value
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkSamplerCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO`
::

::validity-field{name="VUID-VkSamplerCreateInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkOpaqueCaptureDescriptorDataCreateInfoEXT](/man/VkOpaqueCaptureDescriptorDataCreateInfoEXT), [VkSamplerBlockMatchWindowCreateInfoQCOM](/man/VkSamplerBlockMatchWindowCreateInfoQCOM), [VkSamplerBorderColorComponentMappingCreateInfoEXT](/man/VkSamplerBorderColorComponentMappingCreateInfoEXT), [VkSamplerCubicWeightsCreateInfoQCOM](/man/VkSamplerCubicWeightsCreateInfoQCOM), [VkSamplerCustomBorderColorCreateInfoEXT](/man/VkSamplerCustomBorderColorCreateInfoEXT), [VkSamplerReductionModeCreateInfo](/man/VkSamplerReductionModeCreateInfo), or [VkSamplerYcbcrConversionInfo](/man/VkSamplerYcbcrConversionInfo)
::

::validity-field{name="VUID-VkSamplerCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkSamplerCreateInfo-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkSamplerCreateFlagBits](/man/VkSamplerCreateFlagBits) values
::

::validity-field{name="VUID-VkSamplerCreateInfo-magFilter-parameter"}
 `magFilter` :normative{type="must"} be a valid [VkFilter](/man/VkFilter) value
::

::validity-field{name="VUID-VkSamplerCreateInfo-minFilter-parameter"}
 `minFilter` :normative{type="must"} be a valid [VkFilter](/man/VkFilter) value
::

::validity-field{name="VUID-VkSamplerCreateInfo-mipmapMode-parameter"}
 `mipmapMode` :normative{type="must"} be a valid [VkSamplerMipmapMode](/man/VkSamplerMipmapMode) value
::

::validity-field{name="VUID-VkSamplerCreateInfo-addressModeU-parameter"}
 `addressModeU` :normative{type="must"} be a valid [VkSamplerAddressMode](/man/VkSamplerAddressMode) value
::

::validity-field{name="VUID-VkSamplerCreateInfo-addressModeV-parameter"}
 `addressModeV` :normative{type="must"} be a valid [VkSamplerAddressMode](/man/VkSamplerAddressMode) value
::

::validity-field{name="VUID-VkSamplerCreateInfo-addressModeW-parameter"}
 `addressModeW` :normative{type="must"} be a valid [VkSamplerAddressMode](/man/VkSamplerAddressMode) value
::

::


`VK_LOD_CLAMP_NONE` is a special constant value used for
[VkSamplerCreateInfo](/man/VkSamplerCreateInfo)::`maxLod` to indicate that maximum LOD
clamping should not be performed.

[{generated}/api/enums/VK\_LOD\_CLAMP\_NONE.adoc]({generated}/api/enums/VK_LOD_CLAMP_NONE.adoc)

Bits which :normative{type="can"} be set in [VkSamplerCreateInfo](/man/VkSamplerCreateInfo)::`flags`, specifying
additional parameters of a sampler, are:

[{generated}/api/enums/VkSamplerCreateFlagBits.adoc]({generated}/api/enums/VkSamplerCreateFlagBits.adoc)

[{generated}/api/flags/VkSamplerCreateFlags.adoc]({generated}/api/flags/VkSamplerCreateFlags.adoc)

`VkSamplerCreateFlags` is a bitmask type for setting a mask of zero or
more [VkSamplerCreateFlagBits](/man/VkSamplerCreateFlagBits).

Possible values of the [VkSamplerCreateInfo](/man/VkSamplerCreateInfo)::`magFilter` and
`minFilter` parameters, specifying filters used for texture lookups,
are:

[{generated}/api/enums/VkFilter.adoc]({generated}/api/enums/VkFilter.adoc)

- `VK_FILTER_NEAREST` specifies nearest filtering.

- `VK_FILTER_LINEAR` specifies linear filtering.

These filters are described in detail in Texel
Filtering.

Possible values of the [VkSamplerCreateInfo](/man/VkSamplerCreateInfo)::`mipmapMode`,
specifying the mipmap mode used for texture lookups, are:

[{generated}/api/enums/VkSamplerMipmapMode.adoc]({generated}/api/enums/VkSamplerMipmapMode.adoc)

- `VK_SAMPLER_MIPMAP_MODE_NEAREST` specifies nearest filtering.

- `VK_SAMPLER_MIPMAP_MODE_LINEAR` specifies linear filtering.

These modes are described in detail in Texel
Filtering.

Possible values of the [VkSamplerCreateInfo](/man/VkSamplerCreateInfo)::`addressMode*`
parameters, specifying the behavior of sampling with coordinates outside the
range \[0,1] for the respective u, v, or w coordinate
as defined in the Wrapping Operation
section, are:

[{generated}/api/enums/VkSamplerAddressMode.adoc]({generated}/api/enums/VkSamplerAddressMode.adoc)

- `VK_SAMPLER_ADDRESS_MODE_REPEAT` specifies that the repeat wrap mode
  will be used.

- `VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT` specifies that the
  mirrored repeat wrap mode will be used.

- `VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE` specifies that the clamp to
  edge wrap mode will be used.

- `VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER` specifies that the clamp
  to border wrap mode will be used.

*Comparison operators* compare a *reference* and a *test* value, and return
a true (> passed) or false (> failed) value depending on the comparison
operator chosen.
The supported operators are:

[{generated}/api/enums/VkCompareOp.adoc]({generated}/api/enums/VkCompareOp.adoc)

- `VK_COMPARE_OP_NEVER` specifies that the comparison always evaluates
  false.

- `VK_COMPARE_OP_LESS` specifies that the comparison evaluates
  *reference* < *test*.

- `VK_COMPARE_OP_EQUAL` specifies that the comparison evaluates
  *reference* = *test*.

- `VK_COMPARE_OP_LESS_OR_EQUAL` specifies that the comparison
  evaluates *reference* ≤ *test*.

- `VK_COMPARE_OP_GREATER` specifies that the comparison evaluates
  *reference* > *test*.

- `VK_COMPARE_OP_NOT_EQUAL` specifies that the comparison evaluates
  *reference* ≠ *test*.

- `VK_COMPARE_OP_GREATER_OR_EQUAL` specifies that the comparison
  evaluates *reference* ≥ *test*.

- `VK_COMPARE_OP_ALWAYS` specifies that the comparison always
  evaluates true.

Comparison operators are used for:

- The Depth Compare Operation
  operator for a sampler, specified by
  [VkSamplerCreateInfo](/man/VkSamplerCreateInfo)::`compareOp`.

- The stencil comparison operator for the stencil
  test, specified by
  [VkStencilOpState](/man/VkStencilOpState)::`compareOp`.

- The Depth Comparison operator for the
  depth test, specified by
  [VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo)::`depthCompareOp`.

Each such use describes how the *reference* and *test* values for that
comparison are determined.

Possible values of [VkSamplerCreateInfo](/man/VkSamplerCreateInfo)::`borderColor`, specifying
the border color used for texture lookups, are:

[{generated}/api/enums/VkBorderColor.adoc]({generated}/api/enums/VkBorderColor.adoc)

- `VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK` specifies a transparent,
  floating-point format, black color.

- `VK_BORDER_COLOR_INT_TRANSPARENT_BLACK` specifies a transparent,
  integer format, black color.

- `VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK` specifies an opaque,
  floating-point format, black color.

- `VK_BORDER_COLOR_INT_OPAQUE_BLACK` specifies an opaque, integer
  format, black color.

- `VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE` specifies an opaque,
  floating-point format, white color.

- `VK_BORDER_COLOR_INT_OPAQUE_WHITE` specifies an opaque, integer
  format, white color.

These colors are described in detail in Texel
Replacement.

To destroy a sampler, call:

[{generated}/api/protos/vkDestroySampler.adoc]({generated}/api/protos/vkDestroySampler.adoc)

- `device` is the logical device that destroys the sampler.

- `sampler` is the sampler to destroy.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkDestroySampler-sampler-01082"}

All submitted commands that refer to `sampler` :normative{type="must"} have completed
execution
::

::validity-field{name="VUID-vkDestroySampler-sampler-01083"}

If `VkAllocationCallbacks` were provided when `sampler` was
created, a compatible set of callbacks :normative{type="must"} be provided here
::

::validity-field{name="VUID-vkDestroySampler-sampler-01084"}

If no `VkAllocationCallbacks` were provided when `sampler` was
created, `pAllocator` :normative{type="must"} be `NULL`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkDestroySampler-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkDestroySampler-sampler-parameter"}
 If `sampler` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `sampler` :normative{type="must"} be a valid [VkSampler](/man/VkSampler) handle
::

::validity-field{name="VUID-vkDestroySampler-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkDestroySampler-sampler-parent"}
 If `sampler` is a valid handle, it :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::








# Resource Descriptors

A *descriptor* is an opaque data structure representing a shader resource
such as a buffer, buffer view, image view, sampler, or combined image
sampler.
Descriptors are organized into *descriptor sets*, which are bound during
command recording for use in subsequent drawing commands.
The arrangement of content in each descriptor set is determined by a
*descriptor set layout*, which determines what descriptors can be stored
within it.
The sequence of descriptor set layouts that :normative{type="can"} be used by a pipeline is
specified in a *pipeline layout*.
Each pipeline object :normative{type="can"} use up to `maxBoundDescriptorSets` (see
Limits) descriptor sets.

Shaders access resources via variables decorated with a descriptor set and
binding number that link them to a descriptor in a descriptor set.
The shader interface mapping to bound descriptor sets is described in the
Shader Resource Interface section.



## Descriptor Types

There are a number of different types of descriptor supported by Vulkan,
corresponding to different resources or usage.
The following sections describe the API definitions of each descriptor type.
The mapping of each type to SPIR-V is listed in the
Shader Resource and Descriptor Type
Correspondence and Shader Resource and Storage Class Correspondence tables in the
Shader Interfaces chapter.



### Storage Image

A *storage image* (`VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`) is a descriptor
type associated with an image resource via an
image view that load, store, and atomic
operations :normative{type="can"} be performed on.

Storage image loads are supported in all shader stages for image views whose
format features contain
`VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT`.

Stores to storage images are supported in
compute shaders for image views whose
format features contain
`VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT`.

Atomic operations on storage images are supported in
compute shaders for image views whose
format features contain
`VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT`.

When the `fragmentStoresAndAtomics` feature is enabled, stores and atomic
operations are also supported for storage images in fragment shaders with
the same set of image formats as supported in compute shaders.
When the `vertexPipelineStoresAndAtomics` feature is enabled, stores and atomic
operations are also supported in vertex, tessellation, and geometry shaders
with the same set of image formats as supported in compute shaders.

The image subresources for a storage image :normative{type="must"} be in the
`VK_IMAGE_LAYOUT_GENERAL` layout in order to access its data in a
shader.





### Sampler

A *sampler descriptor* (`VK_DESCRIPTOR_TYPE_SAMPLER`) is a descriptor
type associated with a sampler object, used to control the
behavior of sampling operations performed on a
sampled image.





### Sampled Image

A *sampled image* (`VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`) is a descriptor
type associated with an image resource via an
image view that sampling operations
:normative{type="can"} be performed on.

Shaders combine a sampled image variable and a sampler variable to perform
sampling operations.

Sampled images are supported in all shader stages for image views whose
format features contain
`VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT`.

An image subresources for a sampled image :normative{type="must"} be in one of the following
layouts:

- `VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL`

- `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`

- `VK_IMAGE_LAYOUT_GENERAL`





### Combined Image Sampler

A *combined image sampler* (`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`)
is a single descriptor type associated with both a sampler and
an image resource, combining both a
sampler and sampled image descriptor into a single descriptor.

The
sampler and image in this type of descriptor :normative{type="can"} be used freely with any
other samplers and images.

An image subresources for a combined image sampler :normative{type="must"} be in one of the
following layouts:

- `VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL`

- `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`

- `VK_IMAGE_LAYOUT_GENERAL`


::note
On some implementations, it :normative{type="may"} be more efficient to sample from an image
using a combination of sampler and sampled image that are stored together in
the descriptor set in a combined descriptor.
::






### Uniform Texel Buffer

A *uniform texel buffer* (`VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER`) is
a descriptor type associated with a buffer resource
via a buffer view that image sampling
operations :normative{type="can"} be performed on.

Uniform texel buffers define a tightly-packed 1-dimensional linear array of
texels, with texels going through format conversion when read in a shader in
the same way as they are for an image.

Load operations from uniform texel buffers are supported in all shader
stages for buffer view formats which report
format features support for
`VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT`





### Storage Texel Buffer

A *storage texel buffer* (`VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER`) is
a descriptor type associated with a buffer resource
via a buffer view that image load,
store, and atomic operations :normative{type="can"} be performed on.

Storage texel buffers define a tightly-packed 1-dimensional linear array of
texels, with texels going through format conversion when read in a shader in
the same way as they are for an image.
Unlike uniform texel buffers, these
buffers can also be written to in the same way as for
storage images.

Storage texel buffer loads are supported in all shader stages for texel
buffer view formats which report
format features support for
`VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT`

Stores to storage texel buffers are supported in
compute shaders for texel buffer formats which report
format features support for
`VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT`

Atomic operations on storage texel buffers are supported in
compute shaders for texel buffer formats which report
format features support for
`VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT`

When the `fragmentStoresAndAtomics` feature is enabled, stores and atomic
operations are also supported for storage texel buffers in fragment shaders
with the same set of texel buffer formats as supported in compute shaders.
When the `vertexPipelineStoresAndAtomics` feature is enabled, stores and atomic
operations are also supported in vertex, tessellation, and geometry shaders
with the same set of texel buffer formats as supported in compute shaders.





### Storage Buffer

A *storage buffer* (`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER`) is a descriptor
type associated with a buffer resource directly,
described in a shader as a structure with various members that load, store,
and atomic operations :normative{type="can"} be performed on.


::note
Atomic operations :normative{type="can"} only be performed on members of certain types as
defined in the SPIR-V environment appendix.
::






### Uniform Buffer

A *uniform buffer* (`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER`) is a descriptor
type associated with a buffer resource directly,
described in a shader as a structure with various members that load
operations :normative{type="can"} be performed on.





### Dynamic Uniform Buffer

A *dynamic uniform buffer* (`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`)
is almost identical to a uniform buffer,
and differs only in how the offset into the buffer is specified.
The base offset calculated by the [VkDescriptorBufferInfo](/man/VkDescriptorBufferInfo) when
initially updating the descriptor set is added
to a dynamic offset when binding
the descriptor set.





### Dynamic Storage Buffer

A *dynamic storage buffer* (`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`)
is almost identical to a storage buffer,
and differs only in how the offset into the buffer is specified.
The base offset calculated by the [VkDescriptorBufferInfo](/man/VkDescriptorBufferInfo) when
initially updating the descriptor set is added
to a dynamic offset when binding
the descriptor set.





### Input Attachment

An *input attachment* (`VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`) is a
descriptor type associated with an image resource via
an image view that :normative{type="can"} be used for
framebuffer local load operations in
fragment shaders.

All image formats that are supported for color attachments
(`VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT`
) or depth/stencil attachments
(`VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT`) for a given image
tiling mode are also supported for input attachments.

An image view used as an input attachment :normative{type="must"} be in one of the following
layouts:

- `VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL`

- `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`

- `VK_IMAGE_LAYOUT_GENERAL`







## Descriptor Sets

Descriptors are grouped together into descriptor set objects.
A descriptor set object is an opaque object containing storage for a set of
descriptors, where the types and number of descriptors is defined by a
descriptor set layout.
The layout object :normative{type="may"} be used to define the association of each descriptor
binding with memory or other implementation resources.
The layout is used both for determining the resources that need to be
associated with the descriptor set, and determining the interface between
shader stages and shader resources.



### Descriptor Set Layout

A descriptor set layout object is defined by an array of zero or more
descriptor bindings.
Each individual descriptor binding is specified by a descriptor type, a
count (array size) of the number of descriptors in the binding, a set of
shader stages that :normative{type="can"} access the binding, and (if using immutable
samplers) an array of sampler descriptors.

Descriptor set layout objects are represented by `VkDescriptorSetLayout`
handles:

[{generated}/api/handles/VkDescriptorSetLayout.adoc]({generated}/api/handles/VkDescriptorSetLayout.adoc)

To create descriptor set layout objects, call:

[{generated}/api/protos/vkCreateDescriptorSetLayout.adoc]({generated}/api/protos/vkCreateDescriptorSetLayout.adoc)

- `device` is the logical device that creates the descriptor set
  layout.

- `pCreateInfo` is a pointer to a
  [VkDescriptorSetLayoutCreateInfo](/man/VkDescriptorSetLayoutCreateInfo) structure specifying the state of
  the descriptor set layout object.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

- `pSetLayout` is a pointer to a [VkDescriptorSetLayout](/man/VkDescriptorSetLayout) handle in
  which the resulting descriptor set layout object is returned.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCreateDescriptorSetLayout-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkCreateDescriptorSetLayout-pCreateInfo-parameter"}
 `pCreateInfo` :normative{type="must"} be a valid pointer to a valid [VkDescriptorSetLayoutCreateInfo](/man/VkDescriptorSetLayoutCreateInfo) structure
::

::validity-field{name="VUID-vkCreateDescriptorSetLayout-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkCreateDescriptorSetLayout-pSetLayout-parameter"}
 `pSetLayout` :normative{type="must"} be a valid pointer to a [VkDescriptorSetLayout](/man/VkDescriptorSetLayout) handle
::

::




Information about the descriptor set layout is passed in a
`VkDescriptorSetLayoutCreateInfo` structure:

[{generated}/api/structs/VkDescriptorSetLayoutCreateInfo.adoc]({generated}/api/structs/VkDescriptorSetLayoutCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is a bitmask
  specifying options for descriptor set layout creation.

- `bindingCount` is the number of elements in `pBindings`.

- `pBindings` is a pointer to an array of
  [VkDescriptorSetLayoutBinding](/man/VkDescriptorSetLayoutBinding) structures.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkDescriptorSetLayoutCreateInfo-binding-00279"}

The [VkDescriptorSetLayoutBinding](/man/VkDescriptorSetLayoutBinding)::`binding` members of the
elements of the `pBindings` array :normative{type="must"} each have different values
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkDescriptorSetLayoutCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO`
::

::validity-field{name="VUID-VkDescriptorSetLayoutCreateInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkDescriptorSetLayoutBindingFlagsCreateInfo](/man/VkDescriptorSetLayoutBindingFlagsCreateInfo) or [VkMutableDescriptorTypeCreateInfoEXT](/man/VkMutableDescriptorTypeCreateInfoEXT)
::

::validity-field{name="VUID-VkDescriptorSetLayoutCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkDescriptorSetLayoutCreateInfo-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkDescriptorSetLayoutCreateFlagBits](/man/VkDescriptorSetLayoutCreateFlagBits) values
::

::validity-field{name="VUID-VkDescriptorSetLayoutCreateInfo-pBindings-parameter"}
 If `bindingCount` is not `0`, `pBindings` :normative{type="must"} be a valid pointer to an array of `bindingCount` valid [VkDescriptorSetLayoutBinding](/man/VkDescriptorSetLayoutBinding) structures
::

::


Bits which :normative{type="can"} be set in
[VkDescriptorSetLayoutCreateInfo](/man/VkDescriptorSetLayoutCreateInfo)::`flags`, specifying options for
descriptor set layout, are:

[{generated}/api/enums/VkDescriptorSetLayoutCreateFlagBits.adoc]({generated}/api/enums/VkDescriptorSetLayoutCreateFlagBits.adoc)


::note
All bits for this type are defined by extensions, and none of those
extensions are enabled in this build of the specification.
::


[{generated}/api/flags/VkDescriptorSetLayoutCreateFlags.adoc]({generated}/api/flags/VkDescriptorSetLayoutCreateFlags.adoc)

`VkDescriptorSetLayoutCreateFlags` is a bitmask type for setting a mask
of zero or more [VkDescriptorSetLayoutCreateFlagBits](/man/VkDescriptorSetLayoutCreateFlagBits).

The `VkDescriptorSetLayoutBinding` structure is defined as:

[{generated}/api/structs/VkDescriptorSetLayoutBinding.adoc]({generated}/api/structs/VkDescriptorSetLayoutBinding.adoc)

- `binding` is the binding number of this entry and corresponds to a
  resource of the same binding number in the shader stages.

- `descriptorType` is a [VkDescriptorType](/man/VkDescriptorType) specifying which type
  of resource descriptors are used for this binding.

- `descriptorCount` is the number of descriptors contained in the
  &#x20;   binding, accessed in a shader as an
  array.
  &#x20;   If `descriptorCount` is zero this binding entry is reserved and the
  &#x20;   resource :normative{type="must"} not be accessed from any stage via this binding within
  &#x20;   any pipeline using the set layout.

- `stageFlags` member is a bitmask of [VkShaderStageFlagBits](/man/VkShaderStageFlagBits)
  specifying which pipeline shader stages :normative{type="can"} access a resource for this
  binding.
  `VK_SHADER_STAGE_ALL` is a shorthand specifying that all defined
  shader stages, including any additional stages defined by extensions,
  :normative{type="can"} access the resource.





  If a shader stage is not included in `stageFlags`, then a resource :normative{type="must"}
  not be accessed from that stage via this binding within any pipeline using
  the set layout.
  Other than input attachments which are limited to the fragment shader, there
  are no limitations on what combinations of stages :normative{type="can"} use a descriptor
  binding, and in particular a binding :normative{type="can"} be used by both graphics stages
  and the compute stage.

- `pImmutableSamplers` affects initialization of samplers.
  If `descriptorType` specifies a `VK_DESCRIPTOR_TYPE_SAMPLER` or
  `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` type descriptor, then
  `pImmutableSamplers` :normative{type="can"} be used to initialize a set of *immutable
  samplers*.
  Immutable samplers are permanently bound into the set layout and :normative{type="must"}
  not be changed; updating a `VK_DESCRIPTOR_TYPE_SAMPLER` descriptor
  with immutable samplers is not allowed and updates to a
  `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` descriptor with
  immutable samplers does not modify the samplers (the image views are
  updated, but the sampler updates are ignored).
  If `pImmutableSamplers` is not `NULL`, then it is a pointer to an
  array of sampler handles that will be copied into the set layout and
  used for the corresponding binding.
  Only the sampler handles are copied; the sampler objects :normative{type="must"} not be
  destroyed before the final use of the set layout and any descriptor
  pools and sets created using it.
  If `pImmutableSamplers` is `NULL`, then the sampler slots are
  dynamic and sampler handles :normative{type="must"} be bound into descriptor sets using
  this layout.
  If `descriptorType` is not one of these descriptor types, then
  `pImmutableSamplers` is ignored.

The above layout definition allows the descriptor bindings to be specified
sparsely such that not all binding numbers between 0 and the maximum binding
number need to be specified in the `pBindings` array.
Bindings that are not specified have a `descriptorCount` and
`stageFlags` of zero, and the value of `descriptorType` is
undefined:.
However, all binding numbers between 0 and the maximum binding number in the
[VkDescriptorSetLayoutCreateInfo](/man/VkDescriptorSetLayoutCreateInfo)::`pBindings` array :normative{type="may"} consume
memory in the descriptor set layout even if not all descriptor bindings are
used, though it :normative{type="should"} not consume additional memory from the descriptor
pool.


::note
The maximum binding number specified :normative{type="should"} be as compact as possible to
avoid wasted memory.
::



::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkDescriptorSetLayoutBinding-descriptorType-00282"}

If `descriptorType` is `VK_DESCRIPTOR_TYPE_SAMPLER` or
`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, and
`descriptorCount` is not `0` and `pImmutableSamplers` is not
`NULL`, `pImmutableSamplers` :normative{type="must"} be a valid pointer to an array of
`descriptorCount` valid `VkSampler` handles
::

::validity-field{name="VUID-VkDescriptorSetLayoutBinding-descriptorCount-00283"}

If `descriptorCount` is not `0`, `stageFlags` :normative{type="must"} be a valid
combination of [VkShaderStageFlagBits](/man/VkShaderStageFlagBits) values
::

::validity-field{name="VUID-VkDescriptorSetLayoutBinding-descriptorType-01510"}

If `descriptorType` is `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT` and
`descriptorCount` is not `0`, then `stageFlags` :normative{type="must"} be `0` or
`VK_SHADER_STAGE_FRAGMENT_BIT`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkDescriptorSetLayoutBinding-descriptorType-parameter"}
 `descriptorType` :normative{type="must"} be a valid [VkDescriptorType](/man/VkDescriptorType) value
::

::


The following examples show a shader snippet using two descriptor sets, and
application code that creates corresponding descriptor set layouts.







To destroy a descriptor set layout, call:

[{generated}/api/protos/vkDestroyDescriptorSetLayout.adoc]({generated}/api/protos/vkDestroyDescriptorSetLayout.adoc)

- `device` is the logical device that destroys the descriptor set
  layout.

- `descriptorSetLayout` is the descriptor set layout to destroy.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-00284"}

If `VkAllocationCallbacks` were provided when
`descriptorSetLayout` was created, a compatible set of callbacks
:normative{type="must"} be provided here
::

::validity-field{name="VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-00285"}

If no `VkAllocationCallbacks` were provided when
`descriptorSetLayout` was created, `pAllocator` :normative{type="must"} be `NULL`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkDestroyDescriptorSetLayout-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-parameter"}
 If `descriptorSetLayout` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `descriptorSetLayout` :normative{type="must"} be a valid [VkDescriptorSetLayout](/man/VkDescriptorSetLayout) handle
::

::validity-field{name="VUID-vkDestroyDescriptorSetLayout-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkDestroyDescriptorSetLayout-descriptorSetLayout-parent"}
 If `descriptorSetLayout` is a valid handle, it :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::








### Pipeline Layouts

Access to descriptor sets from a pipeline is accomplished through a
*pipeline layout*.
Zero or more descriptor set layouts and zero or more push constant ranges
are combined to form a pipeline layout object describing the complete set of
resources that :normative{type="can"} be accessed by a pipeline.
The pipeline layout represents a sequence of descriptor sets with each
having a specific layout.
This sequence of layouts is used to determine the interface between shader
stages and shader resources.
Each pipeline is created using a pipeline layout.

Pipeline layout objects are represented by `VkPipelineLayout` handles:

[{generated}/api/handles/VkPipelineLayout.adoc]({generated}/api/handles/VkPipelineLayout.adoc)

To create a pipeline layout, call:

[{generated}/api/protos/vkCreatePipelineLayout.adoc]({generated}/api/protos/vkCreatePipelineLayout.adoc)

- `device` is the logical device that creates the pipeline layout.

- `pCreateInfo` is a pointer to a [VkPipelineLayoutCreateInfo](/man/VkPipelineLayoutCreateInfo)
  structure specifying the state of the pipeline layout object.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

- `pPipelineLayout` is a pointer to a [VkPipelineLayout](/man/VkPipelineLayout) handle in
  which the resulting pipeline layout object is returned.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCreatePipelineLayout-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkCreatePipelineLayout-pCreateInfo-parameter"}
 `pCreateInfo` :normative{type="must"} be a valid pointer to a valid [VkPipelineLayoutCreateInfo](/man/VkPipelineLayoutCreateInfo) structure
::

::validity-field{name="VUID-vkCreatePipelineLayout-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkCreatePipelineLayout-pPipelineLayout-parameter"}
 `pPipelineLayout` :normative{type="must"} be a valid pointer to a [VkPipelineLayout](/man/VkPipelineLayout) handle
::

::




The [VkPipelineLayoutCreateInfo](/man/VkPipelineLayoutCreateInfo) structure is defined as:

[{generated}/api/structs/VkPipelineLayoutCreateInfo.adoc]({generated}/api/structs/VkPipelineLayoutCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is a bitmask of [VkPipelineLayoutCreateFlagBits](/man/VkPipelineLayoutCreateFlagBits)
  specifying options for pipeline layout creation.

- `setLayoutCount` is the number of descriptor sets included in the
  pipeline layout.

- `pSetLayouts` is a pointer to an array of
  `VkDescriptorSetLayout` objects.

- `pushConstantRangeCount` is the number of push constant ranges
  included in the pipeline layout.

- `pPushConstantRanges` is a pointer to an array of
  `VkPushConstantRange` structures defining a set of push constant
  ranges for use in a single pipeline layout.
  In addition to descriptor set layouts, a pipeline layout also describes
  how many push constants :normative{type="can"} be accessed by each stage of the pipeline.






  ::note


  Push constants represent a high speed path to modify constant data in
  pipelines that is expected to outperform memory-backed resource updates.


  ::



::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkPipelineLayoutCreateInfo-setLayoutCount-00286"}
`setLayoutCount` :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxBoundDescriptorSets`
::

::validity-field{name="VUID-VkPipelineLayoutCreateInfo-descriptorType-03016"}

The total number of descriptors in descriptor set layouts
with a `descriptorType` of `VK_DESCRIPTOR_TYPE_SAMPLER` and
`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` accessible to any given
shader stage across all elements of `pSetLayouts` :normative{type="must"} be less than
or equal to
`VkPhysicalDeviceLimits`::`maxPerStageDescriptorSamplers`
::

::validity-field{name="VUID-VkPipelineLayoutCreateInfo-descriptorType-03017"}

The total number of descriptors in descriptor set layouts
with a `descriptorType` of `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER`
and `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` accessible to any
given shader stage across all elements of `pSetLayouts` :normative{type="must"} be
less than or equal to
`VkPhysicalDeviceLimits`::`maxPerStageDescriptorUniformBuffers`
::

::validity-field{name="VUID-VkPipelineLayoutCreateInfo-descriptorType-03018"}

The total number of descriptors in descriptor set layouts
with a `descriptorType` of `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER`
and `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC` accessible to any
given shader stage across all elements of `pSetLayouts` :normative{type="must"} be
less than or equal to
`VkPhysicalDeviceLimits`::`maxPerStageDescriptorStorageBuffers`
::

::validity-field{name="VUID-VkPipelineLayoutCreateInfo-descriptorType-06939"}

The total number of descriptors in descriptor set layouts
with a `descriptorType` of
`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`,
`VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`,
and `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER`, accessible to any
given shader stage across all elements of `pSetLayouts` :normative{type="must"} be
less than or equal to
`VkPhysicalDeviceLimits`::`maxPerStageDescriptorSampledImages`
::

::validity-field{name="VUID-VkPipelineLayoutCreateInfo-descriptorType-03020"}

The total number of descriptors in descriptor set layouts
with a `descriptorType` of `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`,
and `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` accessible to any
given shader stage across all elements of `pSetLayouts` :normative{type="must"} be
less than or equal to
`VkPhysicalDeviceLimits`::`maxPerStageDescriptorStorageImages`
::

::validity-field{name="VUID-VkPipelineLayoutCreateInfo-descriptorType-03021"}

The total number of descriptors in descriptor set layouts
with a `descriptorType` of `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`
accessible to any given shader stage across all elements of
`pSetLayouts` :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxPerStageDescriptorInputAttachments`
::

::validity-field{name="VUID-VkPipelineLayoutCreateInfo-descriptorType-03028"}

The total number of descriptors in descriptor set layouts
with a `descriptorType` of `VK_DESCRIPTOR_TYPE_SAMPLER` and
`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` accessible across all
shader stages and across all elements of `pSetLayouts` :normative{type="must"} be less
than or equal to
`VkPhysicalDeviceLimits`::`maxDescriptorSetSamplers`
::

::validity-field{name="VUID-VkPipelineLayoutCreateInfo-descriptorType-03029"}

The total number of descriptors in descriptor set layouts
with a `descriptorType` of `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER`
accessible across all shader stages and across all elements of
`pSetLayouts` :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxDescriptorSetUniformBuffers`
::

::validity-field{name="VUID-VkPipelineLayoutCreateInfo-descriptorType-03030"}

The total number of descriptors in descriptor set layouts
with a `descriptorType` of
`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` accessible across all
shader stages and across all elements of `pSetLayouts` :normative{type="must"} be less
than or equal to
`VkPhysicalDeviceLimits`::`maxDescriptorSetUniformBuffersDynamic`
::

::validity-field{name="VUID-VkPipelineLayoutCreateInfo-descriptorType-03031"}

The total number of descriptors in descriptor set layouts
with a `descriptorType` of `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER`
accessible across all shader stages and across all elements of
`pSetLayouts` :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxDescriptorSetStorageBuffers`
::

::validity-field{name="VUID-VkPipelineLayoutCreateInfo-descriptorType-03032"}

The total number of descriptors in descriptor set layouts
with a `descriptorType` of
`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC` accessible across all
shader stages and across all elements of `pSetLayouts` :normative{type="must"} be less
than or equal to
`VkPhysicalDeviceLimits`::`maxDescriptorSetStorageBuffersDynamic`
::

::validity-field{name="VUID-VkPipelineLayoutCreateInfo-descriptorType-03033"}

The total number of descriptors in descriptor set layouts
with a `descriptorType` of
`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`,
`VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`, and
`VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER` accessible across all
shader stages and across all elements of `pSetLayouts` :normative{type="must"} be less
than or equal to
`VkPhysicalDeviceLimits`::`maxDescriptorSetSampledImages`
::

::validity-field{name="VUID-VkPipelineLayoutCreateInfo-descriptorType-03034"}

The total number of descriptors in descriptor set layouts
with a `descriptorType` of `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`,
and `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` accessible across all
shader stages and across all elements of `pSetLayouts` :normative{type="must"} be less
than or equal to
`VkPhysicalDeviceLimits`::`maxDescriptorSetStorageImages`
::

::validity-field{name="VUID-VkPipelineLayoutCreateInfo-descriptorType-03035"}

The total number of descriptors in descriptor set layouts
with a `descriptorType` of `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`
accessible across all shader stages and across all elements of
`pSetLayouts` :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxDescriptorSetInputAttachments`
::

::validity-field{name="VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-00292"}

Any two elements of `pPushConstantRanges` :normative{type="must"} not include the same
stage in `stageFlags`
::

::validity-field{name="VUID-VkPipelineLayoutCreateInfo-graphicsPipelineLibrary-06753"}

Elements
    of `pSetLayouts` :normative{type="must"} be valid [VkDescriptorSetLayout](/man/VkDescriptorSetLayout) objects
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkPipelineLayoutCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO`
::

::validity-field{name="VUID-VkPipelineLayoutCreateInfo-pNext-pNext"}
 `pNext` :normative{type="must"} be `NULL`
::

::validity-field{name="VUID-VkPipelineLayoutCreateInfo-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkPipelineLayoutCreateFlagBits](/man/VkPipelineLayoutCreateFlagBits) values
::

::validity-field{name="VUID-VkPipelineLayoutCreateInfo-pSetLayouts-parameter"}
 If `setLayoutCount` is not `0`, `pSetLayouts` :normative{type="must"} be a valid pointer to an array of `setLayoutCount` valid or [VK_NULL_HANDLE](/man/VK_NULL_HANDLE) [VkDescriptorSetLayout](/man/VkDescriptorSetLayout) handles
::

::validity-field{name="VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-parameter"}
 If `pushConstantRangeCount` is not `0`, `pPushConstantRanges` :normative{type="must"} be a valid pointer to an array of `pushConstantRangeCount` valid [VkPushConstantRange](/man/VkPushConstantRange) structures
::

::


[{generated}/api/enums/VkPipelineLayoutCreateFlagBits.adoc]({generated}/api/enums/VkPipelineLayoutCreateFlagBits.adoc)

All values for this enum are defined by extensions.

[{generated}/api/flags/VkPipelineLayoutCreateFlags.adoc]({generated}/api/flags/VkPipelineLayoutCreateFlags.adoc)

`VkPipelineLayoutCreateFlags` is a bitmask type for setting a mask of
[VkPipelineLayoutCreateFlagBits](/man/VkPipelineLayoutCreateFlagBits).

The `VkPushConstantRange` structure is defined as:

[{generated}/api/structs/VkPushConstantRange.adoc]({generated}/api/structs/VkPushConstantRange.adoc)

- `stageFlags` is a set of stage flags describing the shader stages
  that will access a range of push constants.
  If a particular stage is not included in the range, then accessing
  members of that range of push constants from the corresponding shader
  stage will return undefined: values.

- `offset` and `size` are the start offset and size, respectively,
  consumed by the range.
  Both `offset` and `size` are in units of bytes and :normative{type="must"} be a
  multiple of 4.
  The layout of the push constant variables is specified in the shader.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkPushConstantRange-offset-00294"}
`offset` :normative{type="must"} be less than
`VkPhysicalDeviceLimits`::`maxPushConstantsSize`
::

::validity-field{name="VUID-VkPushConstantRange-offset-00295"}
`offset` :normative{type="must"} be a multiple of `4`
::

::validity-field{name="VUID-VkPushConstantRange-size-00296"}
`size` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-VkPushConstantRange-size-00297"}
`size` :normative{type="must"} be a multiple of `4`
::

::validity-field{name="VUID-VkPushConstantRange-size-00298"}
`size` :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxPushConstantsSize` minus
`offset`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkPushConstantRange-stageFlags-parameter"}
 `stageFlags` :normative{type="must"} be a valid combination of [VkShaderStageFlagBits](/man/VkShaderStageFlagBits) values
::

::validity-field{name="VUID-VkPushConstantRange-stageFlags-requiredbitmask"}
 `stageFlags` :normative{type="must"} not be `0`
::

::


Once created, pipeline layouts are used as part of pipeline creation (see
Pipelines), as part of binding descriptor sets (see
Descriptor Set Binding), and as part of setting
push constants (see Push Constant
Updates).
Pipeline creation accepts a pipeline layout as input, and the layout :normative{type="may"} be
used to map (set, binding, arrayElement) tuples to implementation resources
or memory locations within a descriptor set.
The assignment of implementation resources depends only on the bindings
defined in the descriptor sets that comprise the pipeline layout, and not on
any shader source.

All resource variables statically used in all shaders
in a pipeline :normative{type="must"} be declared with a (set, binding, arrayElement) that
exists in the corresponding descriptor set layout and is of an appropriate
descriptor type and includes the set of shader stages it is used by in
`stageFlags`.
The pipeline layout :normative{type="can"} include entries that are not used by a particular
pipeline.
The pipeline layout allows the application to provide a consistent set of
bindings across multiple pipeline compiles, which enables those pipelines to
be compiled in a way that the implementation :normative{type="may"} cheaply switch pipelines
without reprogramming the bindings.

Similarly, the push constant block declared in each shader (if present)
:normative{type="must"} only place variables at offsets that are each included in a push
constant range with `stageFlags` including the bit corresponding to the
shader stage that uses it.
The pipeline layout :normative{type="can"} include ranges or portions of ranges that are not
used by a particular pipeline.

There is a limit on the total number of resources of each type that :normative{type="can"} be
included in bindings in all descriptor set layouts in a pipeline layout as
shown in Pipeline Layout Resource
Limits.
The > Total Resources Available column gives the limit on the number of
each type of resource that :normative{type="can"} be included in bindings in all descriptor
sets in the pipeline layout.
Some resource types count against multiple limits.
Additionally, there are limits on the total number of each type of resource
that :normative{type="can"} be used in any pipeline stage as described in
Shader Resource Limits.



To destroy a pipeline layout, call:

[{generated}/api/protos/vkDestroyPipelineLayout.adoc]({generated}/api/protos/vkDestroyPipelineLayout.adoc)

- `device` is the logical device that destroys the pipeline layout.

- `pipelineLayout` is the pipeline layout to destroy.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkDestroyPipelineLayout-pipelineLayout-00299"}

If `VkAllocationCallbacks` were provided when `pipelineLayout`
was created, a compatible set of callbacks :normative{type="must"} be provided here
::

::validity-field{name="VUID-vkDestroyPipelineLayout-pipelineLayout-00300"}

If no `VkAllocationCallbacks` were provided when
`pipelineLayout` was created, `pAllocator` :normative{type="must"} be `NULL`
::

::validity-field{name="VUID-vkDestroyPipelineLayout-pipelineLayout-02004"}
`pipelineLayout` :normative{type="must"} not have been passed to any `vkCmd*`
command for any command buffers that are still in the
recording state when
`vkDestroyPipelineLayout` is called
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkDestroyPipelineLayout-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkDestroyPipelineLayout-pipelineLayout-parameter"}
 If `pipelineLayout` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `pipelineLayout` :normative{type="must"} be a valid [VkPipelineLayout](/man/VkPipelineLayout) handle
::

::validity-field{name="VUID-vkDestroyPipelineLayout-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkDestroyPipelineLayout-pipelineLayout-parent"}
 If `pipelineLayout` is a valid handle, it :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::






#### Pipeline Layout Compatibility

Two pipeline layouts are defined to be > compatible for
>
>
> push constants if they were created
with identical push constant ranges.
Two pipeline layouts are defined to be > compatible for set N if they were
created with *identically defined* descriptor set layouts for sets zero
through N,
and if they were created with identical push constant ranges.

When binding a descriptor set (see Descriptor Set
Binding) to set number N, a previously bound descriptor set bound with
lower index M than N is disturbed if the pipeline layouts for set M and N
are not compatible for set M. Otherwise, the bound descriptor set in M is
not disturbed.

If, additionally, the previously bound descriptor set for set N was bound
using a pipeline layout not compatible for set N, then all bindings in sets
numbered greater than N are disturbed.

When binding a pipeline, the pipeline :normative{type="can"} correctly access any previously
bound descriptor set N if it was bound with compatible pipeline layout for
set N, and it was not disturbed.

Layout compatibility means that descriptor sets :normative{type="can"} be bound to a command
buffer for use by any pipeline created with a compatible pipeline layout,
and without having bound a particular pipeline first.
It also means that descriptor sets :normative{type="can"} remain valid across a pipeline
change, and the same resources will be accessible to the newly bound
pipeline.

When a descriptor set is disturbed by binding descriptor sets, the disturbed
set is considered to contain undefined: descriptors bound with the same
pipeline layout as the disturbing descriptor set.


::note
Place the least frequently changing descriptor sets near the start of the
pipeline layout, and place the descriptor sets representing the most
frequently changing resources near the end.
When pipelines are switched, only the descriptor set bindings that have been
invalidated will need to be updated and the remainder of the descriptor set
bindings will remain in place.
::


The maximum number of descriptor sets that :normative{type="can"} be bound to a pipeline
layout is queried from physical device properties (see
`maxBoundDescriptorSets` in Limits).









### Allocation of Descriptor Sets

A *descriptor pool* maintains a pool of descriptors, from which descriptor
sets are allocated.
Descriptor pools are externally synchronized, meaning that the application
:normative{type="must"} not allocate and/or free descriptor sets from the same pool in
multiple threads simultaneously.

Descriptor pools are represented by `VkDescriptorPool` handles:

[{generated}/api/handles/VkDescriptorPool.adoc]({generated}/api/handles/VkDescriptorPool.adoc)

To create a descriptor pool object, call:

[{generated}/api/protos/vkCreateDescriptorPool.adoc]({generated}/api/protos/vkCreateDescriptorPool.adoc)

- `device` is the logical device that creates the descriptor pool.

- `pCreateInfo` is a pointer to a [VkDescriptorPoolCreateInfo](/man/VkDescriptorPoolCreateInfo)
  structure specifying the state of the descriptor pool object.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

- `pDescriptorPool` is a pointer to a [VkDescriptorPool](/man/VkDescriptorPool) handle in
  which the resulting descriptor pool object is returned.

The created descriptor pool is returned in `pDescriptorPool`.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCreateDescriptorPool-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkCreateDescriptorPool-pCreateInfo-parameter"}
 `pCreateInfo` :normative{type="must"} be a valid pointer to a valid [VkDescriptorPoolCreateInfo](/man/VkDescriptorPoolCreateInfo) structure
::

::validity-field{name="VUID-vkCreateDescriptorPool-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkCreateDescriptorPool-pDescriptorPool-parameter"}
 `pDescriptorPool` :normative{type="must"} be a valid pointer to a [VkDescriptorPool](/man/VkDescriptorPool) handle
::

::




Additional information about the pool is passed in a
`VkDescriptorPoolCreateInfo` structure:

[{generated}/api/structs/VkDescriptorPoolCreateInfo.adoc]({generated}/api/structs/VkDescriptorPoolCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is a bitmask of [VkDescriptorPoolCreateFlagBits](/man/VkDescriptorPoolCreateFlagBits)
  specifying certain supported operations on the pool.

- `maxSets` is the maximum number of descriptor sets that :normative{type="can"} be
  allocated from the pool.

- `poolSizeCount` is the number of elements in `pPoolSizes`.

- `pPoolSizes` is a pointer to an array of [VkDescriptorPoolSize](/man/VkDescriptorPoolSize)
  structures, each containing a descriptor type and number of descriptors
  of that type to be allocated in the pool.

If multiple `VkDescriptorPoolSize` structures containing the same
descriptor type appear in the `pPoolSizes` array then the pool will be
created with enough storage for the total number of descriptors of each
type.

Fragmentation of a descriptor pool is possible and :normative{type="may"} lead to descriptor
set allocation failures.
A failure due to fragmentation is defined as failing a descriptor set
allocation despite the sum of all outstanding descriptor set allocations
from the pool plus the requested allocation requiring no more than the total
number of descriptors requested at pool creation.
Implementations provide certain guarantees of when fragmentation :normative{type="must"} not
cause allocation failure, as described below.

If a descriptor pool has not had any descriptor sets freed since it was
created or most recently reset then fragmentation :normative{type="must"} not cause an
allocation failure (note that this is always the case for a pool created
without the `VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT` bit
set).
Additionally, if all sets allocated from the pool since it was created or
most recently reset use the same number of descriptors (of each type) and
the requested allocation also uses that same number of descriptors (of each
type), then fragmentation :normative{type="must"} not cause an allocation failure.

If an allocation failure occurs due to fragmentation, an application :normative{type="can"}
create an additional descriptor pool to perform further descriptor set
allocations.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkDescriptorPoolCreateInfo-descriptorPoolOverallocation-09227"}
`maxSets` :normative{type="must"} be greater than `0`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkDescriptorPoolCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO`
::

::validity-field{name="VUID-VkDescriptorPoolCreateInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkDescriptorPoolInlineUniformBlockCreateInfo](/man/VkDescriptorPoolInlineUniformBlockCreateInfo) or [VkMutableDescriptorTypeCreateInfoEXT](/man/VkMutableDescriptorTypeCreateInfoEXT)
::

::validity-field{name="VUID-VkDescriptorPoolCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkDescriptorPoolCreateInfo-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkDescriptorPoolCreateFlagBits](/man/VkDescriptorPoolCreateFlagBits) values
::

::validity-field{name="VUID-VkDescriptorPoolCreateInfo-pPoolSizes-parameter"}
 If `poolSizeCount` is not `0`, `pPoolSizes` :normative{type="must"} be a valid pointer to an array of `poolSizeCount` valid [VkDescriptorPoolSize](/man/VkDescriptorPoolSize) structures
::

::


Bits which :normative{type="can"} be set in [VkDescriptorPoolCreateInfo](/man/VkDescriptorPoolCreateInfo)::`flags`,
enabling operations on a descriptor pool, are:

[{generated}/api/enums/VkDescriptorPoolCreateFlagBits.adoc]({generated}/api/enums/VkDescriptorPoolCreateFlagBits.adoc)

- `VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT` specifies that
  descriptor sets :normative{type="can"} return their individual allocations to the pool,
  i.e. all of [vkAllocateDescriptorSets](/man/vkAllocateDescriptorSets), [vkFreeDescriptorSets](/man/vkFreeDescriptorSets),
  and [vkResetDescriptorPool](/man/vkResetDescriptorPool) are allowed.
  Otherwise, descriptor sets allocated from the pool :normative{type="must"} not be
  individually freed back to the pool, i.e. only
  [vkAllocateDescriptorSets](/man/vkAllocateDescriptorSets) and [vkResetDescriptorPool](/man/vkResetDescriptorPool) are
  allowed.

[{generated}/api/flags/VkDescriptorPoolCreateFlags.adoc]({generated}/api/flags/VkDescriptorPoolCreateFlags.adoc)

`VkDescriptorPoolCreateFlags` is a bitmask type for setting a mask of
zero or more [VkDescriptorPoolCreateFlagBits](/man/VkDescriptorPoolCreateFlagBits).

The `VkDescriptorPoolSize` structure is defined as:

[{generated}/api/structs/VkDescriptorPoolSize.adoc]({generated}/api/structs/VkDescriptorPoolSize.adoc)

- `type` is the type of descriptor.

- `descriptorCount` is the number of descriptors of that type to
  allocate.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkDescriptorPoolSize-descriptorCount-00302"}
`descriptorCount` :normative{type="must"} be greater than `0`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkDescriptorPoolSize-type-parameter"}
 `type` :normative{type="must"} be a valid [VkDescriptorType](/man/VkDescriptorType) value
::

::


To destroy a descriptor pool, call:

[{generated}/api/protos/vkDestroyDescriptorPool.adoc]({generated}/api/protos/vkDestroyDescriptorPool.adoc)

- `device` is the logical device that destroys the descriptor pool.

- `descriptorPool` is the descriptor pool to destroy.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

When a pool is destroyed, all descriptor sets allocated from the pool are
implicitly freed and become invalid.
Descriptor sets allocated from a given pool do not need to be freed before
destroying that descriptor pool.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkDestroyDescriptorPool-descriptorPool-00303"}

All submitted commands that refer to `descriptorPool` (via any
allocated descriptor sets) :normative{type="must"} have completed execution
::

::validity-field{name="VUID-vkDestroyDescriptorPool-descriptorPool-00304"}

If `VkAllocationCallbacks` were provided when `descriptorPool`
was created, a compatible set of callbacks :normative{type="must"} be provided here
::

::validity-field{name="VUID-vkDestroyDescriptorPool-descriptorPool-00305"}

If no `VkAllocationCallbacks` were provided when
`descriptorPool` was created, `pAllocator` :normative{type="must"} be `NULL`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkDestroyDescriptorPool-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkDestroyDescriptorPool-descriptorPool-parameter"}
 If `descriptorPool` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `descriptorPool` :normative{type="must"} be a valid [VkDescriptorPool](/man/VkDescriptorPool) handle
::

::validity-field{name="VUID-vkDestroyDescriptorPool-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkDestroyDescriptorPool-descriptorPool-parent"}
 If `descriptorPool` is a valid handle, it :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::




Descriptor sets are allocated from descriptor pool objects, and are
represented by `VkDescriptorSet` handles:

[{generated}/api/handles/VkDescriptorSet.adoc]({generated}/api/handles/VkDescriptorSet.adoc)

To allocate descriptor sets from a descriptor pool, call:

[{generated}/api/protos/vkAllocateDescriptorSets.adoc]({generated}/api/protos/vkAllocateDescriptorSets.adoc)

- `device` is the logical device that owns the descriptor pool.

- `pAllocateInfo` is a pointer to a [VkDescriptorSetAllocateInfo](/man/VkDescriptorSetAllocateInfo)
  structure describing parameters of the allocation.

- `pDescriptorSets` is a pointer to an array of [VkDescriptorSet](/man/VkDescriptorSet)
  handles in which the resulting descriptor set objects are returned.

The allocated descriptor sets are returned in `pDescriptorSets`.

When a descriptor set is allocated, the initial state is largely
uninitialized and all descriptors are undefined:, with the exception that
samplers with a non-null `pImmutableSamplers` are initialized on
allocation.
Descriptors also become undefined: if the underlying resource or view object
is destroyed.
Descriptor sets containing undefined: descriptors :normative{type="can"} still be bound and
used, subject to the following conditions:

- Descriptors that are statically used :normative{type="must"} have
  been populated before the descriptor set is
  consumed.

- Entries that are not used by a pipeline :normative{type="can"} have undefined:
  descriptors.

If an allocation fails due to fragmentation, an indeterminate error is
returned with an unspecified error code.
Any returned error other than
`VK_ERROR_FRAGMENTED_POOL` does not imply its usual meaning:
applications :normative{type="should"} assume that the allocation failed due to fragmentation,
and create a new descriptor pool.


::note
Applications :normative{type="should"} check for a negative return value when allocating new
descriptor sets, assume that any error
effectively means `VK_ERROR_FRAGMENTED_POOL`, and try to create a new
descriptor pool.
If `VK_ERROR_FRAGMENTED_POOL` is the actual return value, it adds
certainty to that decision.

The reason for this is that `VK_ERROR_FRAGMENTED_POOL` was only added in
a later version of the 1.0 specification, and so drivers :normative{type="may"} return other
errors if they were written against earlier versions.
To ensure full compatibility with earlier patch versions, these other errors
are allowed.
::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkAllocateDescriptorSets-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkAllocateDescriptorSets-pAllocateInfo-parameter"}
 `pAllocateInfo` :normative{type="must"} be a valid pointer to a valid [VkDescriptorSetAllocateInfo](/man/VkDescriptorSetAllocateInfo) structure
::

::validity-field{name="VUID-vkAllocateDescriptorSets-pDescriptorSets-parameter"}
 `pDescriptorSets` :normative{type="must"} be a valid pointer to an array of `pAllocateInfo→descriptorSetCount` [VkDescriptorSet](/man/VkDescriptorSet) handles
::

::validity-field{name="VUID-vkAllocateDescriptorSets-pAllocateInfo::descriptorSetCount-arraylength"}
 `pAllocateInfo→descriptorSetCount` :normative{type="must"} be greater than `0`
::

::






The `VkDescriptorSetAllocateInfo` structure is defined as:

[{generated}/api/structs/VkDescriptorSetAllocateInfo.adoc]({generated}/api/structs/VkDescriptorSetAllocateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `descriptorPool` is the pool which the sets will be allocated from.

- `descriptorSetCount` determines the number of descriptor sets to be
  allocated from the pool.

- `pSetLayouts` is a pointer to an array of descriptor set layouts,
  with each member specifying how the corresponding descriptor set is
  allocated.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkDescriptorSetAllocateInfo-apiVersion-07895"}
`descriptorSetCount` :normative{type="must"} not be greater than the number of sets
that are currently available for allocation in `descriptorPool`
::

::validity-field{name="VUID-VkDescriptorSetAllocateInfo-apiVersion-07896"}
`descriptorPool` :normative{type="must"} have enough free descriptor capacity
remaining to allocate the descriptor sets of the specified layouts
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkDescriptorSetAllocateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO`
::

::validity-field{name="VUID-VkDescriptorSetAllocateInfo-pNext-pNext"}
 `pNext` :normative{type="must"} be `NULL` or a pointer to a valid instance of [VkDescriptorSetVariableDescriptorCountAllocateInfo](/man/VkDescriptorSetVariableDescriptorCountAllocateInfo)
::

::validity-field{name="VUID-VkDescriptorSetAllocateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkDescriptorSetAllocateInfo-descriptorPool-parameter"}
 `descriptorPool` :normative{type="must"} be a valid [VkDescriptorPool](/man/VkDescriptorPool) handle
::

::validity-field{name="VUID-VkDescriptorSetAllocateInfo-pSetLayouts-parameter"}
 `pSetLayouts` :normative{type="must"} be a valid pointer to an array of `descriptorSetCount` valid [VkDescriptorSetLayout](/man/VkDescriptorSetLayout) handles
::

::validity-field{name="VUID-VkDescriptorSetAllocateInfo-descriptorSetCount-arraylength"}
 `descriptorSetCount` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-VkDescriptorSetAllocateInfo-commonparent"}
 Both of `descriptorPool`, and the elements of `pSetLayouts` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::


To free allocated descriptor sets, call:

[{generated}/api/protos/vkFreeDescriptorSets.adoc]({generated}/api/protos/vkFreeDescriptorSets.adoc)

- `device` is the logical device that owns the descriptor pool.

- `descriptorPool` is the descriptor pool from which the descriptor
  sets were allocated.

- `descriptorSetCount` is the number of elements in the
  `pDescriptorSets` array.

- `pDescriptorSets` is a pointer to an array of handles to
  [VkDescriptorSet](/man/VkDescriptorSet) objects.

After calling `vkFreeDescriptorSets`, all descriptor sets in
`pDescriptorSets` are invalid.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkFreeDescriptorSets-pDescriptorSets-00309"}

All submitted commands that refer to any element of
`pDescriptorSets` :normative{type="must"} have completed execution
::

::validity-field{name="VUID-vkFreeDescriptorSets-pDescriptorSets-00310"}
`pDescriptorSets` :normative{type="must"} be a valid pointer to an array of
`descriptorSetCount` `VkDescriptorSet` handles, each element of
which :normative{type="must"} either be a valid handle or [VK_NULL_HANDLE](/man/VK_NULL_HANDLE)
::

::validity-field{name="VUID-vkFreeDescriptorSets-descriptorPool-00312"}
`descriptorPool` :normative{type="must"} have been created with the
`VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT` flag
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkFreeDescriptorSets-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkFreeDescriptorSets-descriptorPool-parameter"}
 `descriptorPool` :normative{type="must"} be a valid [VkDescriptorPool](/man/VkDescriptorPool) handle
::

::validity-field{name="VUID-vkFreeDescriptorSets-descriptorSetCount-arraylength"}
 `descriptorSetCount` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-vkFreeDescriptorSets-descriptorPool-parent"}
 `descriptorPool` :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::validity-field{name="VUID-vkFreeDescriptorSets-pDescriptorSets-parent"}
 Each element of `pDescriptorSets` that is a valid handle :normative{type="must"} have been created, allocated, or retrieved from `descriptorPool`
::

::






To return all descriptor sets allocated from a given pool to the pool,
rather than freeing individual descriptor sets, call:

[{generated}/api/protos/vkResetDescriptorPool.adoc]({generated}/api/protos/vkResetDescriptorPool.adoc)

- `device` is the logical device that owns the descriptor pool.

- `descriptorPool` is the descriptor pool to be reset.

- `flags` is reserved for future use.

Resetting a descriptor pool recycles all of the resources from all of the
descriptor sets allocated from the descriptor pool back to the descriptor
pool, and the descriptor sets are implicitly freed.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkResetDescriptorPool-descriptorPool-00313"}

All uses of `descriptorPool` (via any allocated descriptor sets)
:normative{type="must"} have completed execution
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkResetDescriptorPool-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkResetDescriptorPool-descriptorPool-parameter"}
 `descriptorPool` :normative{type="must"} be a valid [VkDescriptorPool](/man/VkDescriptorPool) handle
::

::validity-field{name="VUID-vkResetDescriptorPool-flags-zerobitmask"}
 `flags` :normative{type="must"} be `0`
::

::validity-field{name="VUID-vkResetDescriptorPool-descriptorPool-parent"}
 `descriptorPool` :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::






[{generated}/api/flags/VkDescriptorPoolResetFlags.adoc]({generated}/api/flags/VkDescriptorPoolResetFlags.adoc)

`VkDescriptorPoolResetFlags` is a bitmask type for setting a mask, but
is currently reserved for future use.





### Descriptor Set Updates

Once allocated, descriptor sets :normative{type="can"} be updated with a combination of write
and copy operations.
To update descriptor sets, call:

[{generated}/api/protos/vkUpdateDescriptorSets.adoc]({generated}/api/protos/vkUpdateDescriptorSets.adoc)

- `device` is the logical device that updates the descriptor sets.

- `descriptorWriteCount` is the number of elements in the
  `pDescriptorWrites` array.

- `pDescriptorWrites` is a pointer to an array of
  [VkWriteDescriptorSet](/man/VkWriteDescriptorSet) structures describing the descriptor sets to
  write to.

- `descriptorCopyCount` is the number of elements in the
  `pDescriptorCopies` array.

- `pDescriptorCopies` is a pointer to an array of
  [VkCopyDescriptorSet](/man/VkCopyDescriptorSet) structures describing the descriptor sets to
  copy between.

The operations described by `pDescriptorWrites` are performed first,
followed by the operations described by `pDescriptorCopies`.
Within each array, the operations are performed in the order they appear in
the array.

Each element in the `pDescriptorWrites` array describes an operation
updating the descriptor set using descriptors for resources specified in the
structure.

Each element in the `pDescriptorCopies` array is a
[VkCopyDescriptorSet](/man/VkCopyDescriptorSet) structure describing an operation copying
descriptors between sets.

If the `dstSet` member of any element of `pDescriptorWrites` or
`pDescriptorCopies` is bound, accessed, or modified by any command that
was recorded to a command buffer which is currently in the
recording or executable state,
that command buffer becomes invalid.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkUpdateDescriptorSets-pDescriptorWrites-06236"}

For each element i where
`pDescriptorWrites`[i].`descriptorType` is
`VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER` or
`VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER`, elements of the
`pTexelBufferView` member of `pDescriptorWrites`[i] :normative{type="must"} have
been created on `device`
::

::validity-field{name="VUID-vkUpdateDescriptorSets-pDescriptorWrites-06237"}

For each element i where
`pDescriptorWrites`[i].`descriptorType` is
`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER`,
`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER`,
`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`, or
`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`, the `buffer` member
of any element of the `pBufferInfo` member of
`pDescriptorWrites`[i] :normative{type="must"} have been created on `device`
::

::validity-field{name="VUID-vkUpdateDescriptorSets-pDescriptorWrites-06238"}

For each element i where
`pDescriptorWrites`[i].`descriptorType` is
`VK_DESCRIPTOR_TYPE_SAMPLER` or
`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, and `dstSet` was
not allocated with a layout that included immutable samplers for
`dstBinding` with `descriptorType`, the `sampler` member of
any element of the `pImageInfo` member of `pDescriptorWrites`[i]
:normative{type="must"} have been created on `device`
::

::validity-field{name="VUID-vkUpdateDescriptorSets-pDescriptorWrites-06239"}

For each element i where
`pDescriptorWrites`[i].`descriptorType` is
`VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`,
`VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`,
`VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`, or
`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` the `imageView`
member of any element of `pDescriptorWrites`[i] :normative{type="must"} have been
created on `device`
::

::validity-field{name="VUID-vkUpdateDescriptorSets-pDescriptorWrites-06493"}

For each element i where
`pDescriptorWrites`[i].`descriptorType` is
`VK_DESCRIPTOR_TYPE_SAMPLER`,
`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`,
`VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`,
`VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`, or
`VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`,
`pDescriptorWrites`[i].`pImageInfo` :normative{type="must"} be a valid pointer to
an array of `pDescriptorWrites`[i].`descriptorCount` valid
`VkDescriptorImageInfo` structures
::

::validity-field{name="VUID-vkUpdateDescriptorSets-None-03047"}

The `dstSet` member of each element of `pDescriptorWrites` or
`pDescriptorCopies`
:normative{type="must"} not be used by any command that was recorded to a command buffer
which is in the pending state
::

::validity-field{name="VUID-vkUpdateDescriptorSets-pDescriptorWrites-06993"}

Host access to `pDescriptorWrites`[i].`dstSet` and
`pDescriptorCopies`[i].`dstSet` :normative{type="must"} be
externally synchronized
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkUpdateDescriptorSets-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkUpdateDescriptorSets-pDescriptorWrites-parameter"}
 If `descriptorWriteCount` is not `0`, `pDescriptorWrites` :normative{type="must"} be a valid pointer to an array of `descriptorWriteCount` valid [VkWriteDescriptorSet](/man/VkWriteDescriptorSet) structures
::

::validity-field{name="VUID-vkUpdateDescriptorSets-pDescriptorCopies-parameter"}
 If `descriptorCopyCount` is not `0`, `pDescriptorCopies` :normative{type="must"} be a valid pointer to an array of `descriptorCopyCount` valid [VkCopyDescriptorSet](/man/VkCopyDescriptorSet) structures
::

::


The `VkWriteDescriptorSet` structure is defined as:

[{generated}/api/structs/VkWriteDescriptorSet.adoc]({generated}/api/structs/VkWriteDescriptorSet.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `dstSet` is the destination descriptor set to update.

- `dstBinding` is the descriptor binding within that set.

- `dstArrayElement` is the starting element in that array.

- `descriptorCount` is the number of descriptors to update.
  `descriptorCount` is one of





  * the number of elements in `pImageInfo`

  * the number of elements in `pBufferInfo`

  * the number of elements in `pTexelBufferView`

- `descriptorType` is a [VkDescriptorType](/man/VkDescriptorType) specifying the type of
  each descriptor in `pImageInfo`, `pBufferInfo`, or
  `pTexelBufferView`, as described below.
  It :normative{type="must"}
  be the same type as the `descriptorType` specified in
  `VkDescriptorSetLayoutBinding` for `dstSet` at `dstBinding`.
  The type of the descriptor also controls which array the descriptors are
  taken from.

- `pImageInfo` is a pointer to an array of [VkDescriptorImageInfo](/man/VkDescriptorImageInfo)
  structures or is ignored, as described below.

- `pBufferInfo` is a pointer to an array of
  [VkDescriptorBufferInfo](/man/VkDescriptorBufferInfo) structures or is ignored, as described
  below.

- `pTexelBufferView` is a pointer to an array of [VkBufferView](/man/VkBufferView)
  handles as described in the Buffer Views
  section or is ignored, as described below.

Only one of `pImageInfo`, `pBufferInfo`, or `pTexelBufferView`
members is used according to the descriptor type specified in the
`descriptorType` member of the containing `VkWriteDescriptorSet`
structure,
as specified below.

If the `dstBinding` has fewer than `descriptorCount` array elements
remaining starting from `dstArrayElement`, then the remainder will be
used to update the subsequent binding - `dstBinding`+1 starting at
array element zero.
If a binding has a `descriptorCount` of zero, it is skipped.
This behavior applies recursively, with the update affecting consecutive
bindings as needed to update all `descriptorCount` descriptors.
Consecutive bindings :normative{type="must"} have identical [VkDescriptorType](/man/VkDescriptorType),
[VkShaderStageFlags](/man/VkShaderStageFlags),
and immutable samplers references.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkWriteDescriptorSet-dstBinding-00315"}
`dstBinding` :normative{type="must"} be less than or equal to the maximum value of
`binding` of all [VkDescriptorSetLayoutBinding](/man/VkDescriptorSetLayoutBinding) structures
specified when `dstSet`’s descriptor set layout was created
::

::validity-field{name="VUID-VkWriteDescriptorSet-dstBinding-00316"}
`dstBinding` :normative{type="must"} be a binding with a non-zero
`descriptorCount`
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorCount-00317"}

All consecutive bindings updated via a single `VkWriteDescriptorSet`
structure, except those with a `descriptorCount` of zero, :normative{type="must"} have
identical `descriptorType` and `stageFlags`
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorCount-00318"}

All consecutive bindings updated via a single `VkWriteDescriptorSet`
structure, except those with a `descriptorCount` of zero, :normative{type="must"} all
either use immutable samplers or :normative{type="must"} all not use immutable samplers
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-00319"}
`descriptorType` :normative{type="must"} match the type of `dstBinding` within
`dstSet`
::

::validity-field{name="VUID-VkWriteDescriptorSet-dstSet-00320"}
`dstSet` :normative{type="must"} be a valid [VkDescriptorSet](/man/VkDescriptorSet) handle
::

::validity-field{name="VUID-VkWriteDescriptorSet-dstArrayElement-00321"}

The sum of `dstArrayElement` and `descriptorCount` :normative{type="must"} be less
than or equal to the number of array elements in the descriptor set
binding specified by `dstBinding`, and all applicable consecutive
bindings, as described by 
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-02994"}

If `descriptorType` is `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER`
or `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER`, each element of
`pTexelBufferView` :normative{type="must"} be either a valid `VkBufferView` handle
or [VK_NULL_HANDLE](/man/VK_NULL_HANDLE)
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-02995"}

If `descriptorType` is `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER`
or `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` and the
`nullDescriptor` feature is not
enabled, each element of `pTexelBufferView` :normative{type="must"} not be
[VK_NULL_HANDLE](/man/VK_NULL_HANDLE)
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-00324"}

If `descriptorType` is `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER`,
`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER`,
`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`, or
`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`, `pBufferInfo` :normative{type="must"}
be a valid pointer to an array of `descriptorCount` valid
`VkDescriptorBufferInfo` structures
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-00325"}

If `descriptorType` is `VK_DESCRIPTOR_TYPE_SAMPLER` or
`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, and `dstSet` was
not allocated with a layout that included immutable samplers for
`dstBinding` with `descriptorType`, the `sampler` member of
each element of `pImageInfo` :normative{type="must"} be a valid `VkSampler` object
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-02996"}

If `descriptorType` is
`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`,
`VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`, or
`VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`, the `imageView` member of
each element of `pImageInfo` :normative{type="must"} be either a valid
`VkImageView` handle or [VK_NULL_HANDLE](/man/VK_NULL_HANDLE)
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-02997"}

If `descriptorType` is
`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`,
`VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`, or
`VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`, and the
`nullDescriptor` feature is not
enabled, the `imageView` member of each element of `pImageInfo`
:normative{type="must"} not be [VK_NULL_HANDLE](/man/VK_NULL_HANDLE)
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-07683"}

If `descriptorType` is `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`,
the `imageView` member of each element of `pImageInfo` :normative{type="must"} not
be [VK_NULL_HANDLE](/man/VK_NULL_HANDLE)
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-00327"}

If `descriptorType` is `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or
`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`, the `offset` member
of each element of `pBufferInfo` :normative{type="must"} be a multiple of
`VkPhysicalDeviceLimits`::`minUniformBufferOffsetAlignment`
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-00328"}

If `descriptorType` is `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or
`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`, the `offset` member
of each element of `pBufferInfo` :normative{type="must"} be a multiple of
`VkPhysicalDeviceLimits`::`minStorageBufferOffsetAlignment`
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-00329"}

If `descriptorType` is `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER`,
`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`,
`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER`, or
`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`, and the `buffer`
member of any element of `pBufferInfo` is the handle of a non-sparse
buffer, then that buffer :normative{type="must"} be bound completely and contiguously to a
single `VkDeviceMemory` object
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-00330"}

If `descriptorType` is `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or
`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`, the `buffer` member
of each element of `pBufferInfo` :normative{type="must"} have been created with
`VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT` set
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-00331"}

If `descriptorType` is `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or
`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`, the `buffer` member
of each element of `pBufferInfo` :normative{type="must"} have been created with
`VK_BUFFER_USAGE_STORAGE_BUFFER_BIT` set
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-00332"}

If `descriptorType` is `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or
`VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`, the `range` member
of each element of `pBufferInfo`, or the
effective range if `range` is
`VK_WHOLE_SIZE`, :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxUniformBufferRange`
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-00333"}

If `descriptorType` is `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or
`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`, the `range` member
of each element of `pBufferInfo`, or the
effective range if `range` is
`VK_WHOLE_SIZE`, :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxStorageBufferRange`
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-08765"}

If `descriptorType` is
`VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER`, the
`pTexelBufferView` buffer view
usage :normative{type="must"} include `VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT`
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-08766"}

If `descriptorType` is
`VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER`, the
`pTexelBufferView` buffer view
usage :normative{type="must"} include `VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT`
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-00336"}

If `descriptorType` is `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE` or
`VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`, the `imageView` member of
each element of `pImageInfo` :normative{type="must"} have been created with the
identity swizzle
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-00337"}

If `descriptorType` is `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE` or
`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, the `imageView`
member of each element of `pImageInfo` :normative{type="must"} have been created with
`VK_IMAGE_USAGE_SAMPLED_BIT` set
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-04149"}

If `descriptorType` is `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE` the
`imageLayout` member of each element of `pImageInfo` :normative{type="must"} be a
member of the list given in Sampled
Image
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-04150"}

If `descriptorType` is
`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` the `imageLayout`
member of each element of `pImageInfo` :normative{type="must"} be a member of the list
given in Combined Image Sampler
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-04151"}

If `descriptorType` is `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT` the
`imageLayout` member of each element of `pImageInfo` :normative{type="must"} be a
member of the list given in Input
Attachment
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-04152"}

If `descriptorType` is `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE` the
`imageLayout` member of each element of `pImageInfo` :normative{type="must"} be a
member of the list given in Storage
Image
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-00338"}

If `descriptorType` is `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`,
the `imageView` member of each element of `pImageInfo` :normative{type="must"}
have been created with `VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT` set
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-00339"}

If `descriptorType` is `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`, the
`imageView` member of each element of `pImageInfo` :normative{type="must"} have
been created with `VK_IMAGE_USAGE_STORAGE_BIT` set
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-02752"}

If `descriptorType` is `VK_DESCRIPTOR_TYPE_SAMPLER`, then
`dstSet` :normative{type="must"} not have been allocated with a layout that included
immutable samplers for `dstBinding`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkWriteDescriptorSet-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET`
::

::validity-field{name="VUID-VkWriteDescriptorSet-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkWriteDescriptorSetAccelerationStructureKHR](/man/VkWriteDescriptorSetAccelerationStructureKHR), [VkWriteDescriptorSetAccelerationStructureNV](/man/VkWriteDescriptorSetAccelerationStructureNV), or [VkWriteDescriptorSetInlineUniformBlock](/man/VkWriteDescriptorSetInlineUniformBlock)
::

::validity-field{name="VUID-VkWriteDescriptorSet-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorType-parameter"}
 `descriptorType` :normative{type="must"} be a valid [VkDescriptorType](/man/VkDescriptorType) value
::

::validity-field{name="VUID-VkWriteDescriptorSet-descriptorCount-arraylength"}
 `descriptorCount` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-VkWriteDescriptorSet-commonparent"}
 Both of `dstSet`, and the elements of `pTexelBufferView` that are valid handles of non-ignored parameters :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::


The type of descriptors in a descriptor set is specified by
[VkWriteDescriptorSet](/man/VkWriteDescriptorSet)::`descriptorType`, which :normative{type="must"} be one of the
values:

[{generated}/api/enums/VkDescriptorType.adoc]({generated}/api/enums/VkDescriptorType.adoc)

- `VK_DESCRIPTOR_TYPE_SAMPLER` specifies a sampler descriptor.

- `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` specifies a
  combined image sampler
  descriptor.

- `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE` specifies a
  sampled image descriptor.

- `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE` specifies a
  storage image descriptor.

- `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER` specifies a
  uniform texel buffer descriptor.

- `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` specifies a
  storage texel buffer descriptor.

- `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` specifies a
  uniform buffer descriptor.

- `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` specifies a
  storage buffer descriptor.

- `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` specifies a
  dynamic uniform buffer
  descriptor.

- `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC` specifies a
  dynamic storage buffer
  descriptor.

- `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT` specifies an
  input attachment descriptor.

When a descriptor set is updated via elements of [VkWriteDescriptorSet](/man/VkWriteDescriptorSet),
members of `pImageInfo`, `pBufferInfo` and `pTexelBufferView`
are only accessed by the implementation when they correspond to descriptor
type being defined - otherwise they are ignored.
The members accessed are as follows for each descriptor type:

- For `VK_DESCRIPTOR_TYPE_SAMPLER`, only the `sampler` member of
  each element of [VkWriteDescriptorSet](/man/VkWriteDescriptorSet)::`pImageInfo` is
  accessed.

- For `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`,
  `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`, or
  `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`, only the `imageView` and
  `imageLayout` members of each element of
  [VkWriteDescriptorSet](/man/VkWriteDescriptorSet)::`pImageInfo` are accessed.

- For `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, all members of each
  element of [VkWriteDescriptorSet](/man/VkWriteDescriptorSet)::`pImageInfo` are accessed.

- For `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER`,
  `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER`,
  `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`, or
  `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`, all members of each
  element of [VkWriteDescriptorSet](/man/VkWriteDescriptorSet)::`pBufferInfo` are accessed.

- For `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER` or
  `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER`, each element of
  [VkWriteDescriptorSet](/man/VkWriteDescriptorSet)::`pTexelBufferView` is accessed.

The `VkDescriptorBufferInfo` structure is defined as:

[{generated}/api/structs/VkDescriptorBufferInfo.adoc]({generated}/api/structs/VkDescriptorBufferInfo.adoc)

- `buffer` is
  the buffer resource.

- `offset` is the offset in bytes from the start of `buffer`.
  Access to buffer memory via this descriptor uses addressing that is
  relative to this starting offset.

- `range` is the size in bytes that is used for this descriptor
  update, or `VK_WHOLE_SIZE` to use the range from `offset` to the
  end of the buffer.






  ::note


  When setting `range` to `VK_WHOLE_SIZE`, the
  effective range :normative{type="must"} not be larger than
  the maximum range for the descriptor type (`maxUniformBufferRange` or `maxStorageBufferRange`).
  This means that `VK_WHOLE_SIZE` is not typically useful in the common
  case where uniform buffer descriptors are suballocated from a buffer that is
  much larger than `maxUniformBufferRange`.


  ::


For `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` and
`VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC` descriptor types,
`offset` is the base offset from which the dynamic offset is applied and
`range` is the static size used for all dynamic offsets.

When `range` is `VK_WHOLE_SIZE` the effective range is calculated at
[vkUpdateDescriptorSets](/man/vkUpdateDescriptorSets) is by taking the size of `buffer` minus the
`offset`.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkDescriptorBufferInfo-offset-00340"}
`offset` :normative{type="must"} be less than the size of `buffer`
::

::validity-field{name="VUID-VkDescriptorBufferInfo-range-00341"}

If `range` is not equal to `VK_WHOLE_SIZE`, `range` :normative{type="must"} be
greater than `0`
::

::validity-field{name="VUID-VkDescriptorBufferInfo-range-00342"}

If `range` is not equal to `VK_WHOLE_SIZE`, `range` :normative{type="must"} be
less than or equal to the size of `buffer` minus `offset`
::

::validity-field{name="VUID-VkDescriptorBufferInfo-buffer-02998"}

If the `nullDescriptor` feature is not
enabled, `buffer` :normative{type="must"} not be [VK_NULL_HANDLE](/man/VK_NULL_HANDLE)
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkDescriptorBufferInfo-buffer-parameter"}
 If `buffer` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `buffer` :normative{type="must"} be a valid [VkBuffer](/man/VkBuffer) handle
::

::


The `VkDescriptorImageInfo` structure is defined as:

[{generated}/api/structs/VkDescriptorImageInfo.adoc]({generated}/api/structs/VkDescriptorImageInfo.adoc)

- `sampler` is a sampler handle, and is used in descriptor updates for
  types `VK_DESCRIPTOR_TYPE_SAMPLER` and
  `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` if the binding being
  updated does not use immutable samplers.

- `imageView` is
  an image view handle, and is used in descriptor updates for types
  `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`,
  `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`,
  `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, and
  `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`.

- `imageLayout` is the layout that the image subresources accessible
  from `imageView` will be in at the time this descriptor is accessed.
  `imageLayout` is used in descriptor updates for types
  `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`,
  `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`,
  `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, and
  `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`.

Members of `VkDescriptorImageInfo` that are not used in an update (as
described above) are ignored.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkDescriptorImageInfo-imageView-01976"}

If `imageView` is created from a depth/stencil image, the
`aspectMask` used to create the `imageView` :normative{type="must"} include either
`VK_IMAGE_ASPECT_DEPTH_BIT` or `VK_IMAGE_ASPECT_STENCIL_BIT` but
not both
::

::validity-field{name="VUID-VkDescriptorImageInfo-imageLayout-09425"}

If `imageLayout` is `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL`,
then the `aspectMask` used to create `imageView` :normative{type="must"} not
include either `VK_IMAGE_ASPECT_DEPTH_BIT` or
`VK_IMAGE_ASPECT_STENCIL_BIT`
::

::validity-field{name="VUID-VkDescriptorImageInfo-imageLayout-09426"}

If `imageLayout` is
`VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL` or
`VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL`, then the
`aspectMask` used to create `imageView` :normative{type="must"} not include
`VK_IMAGE_ASPECT_COLOR_BIT`
::

::validity-field{name="VUID-VkDescriptorImageInfo-imageLayout-00344"}
`imageLayout` :normative{type="must"} match the actual [VkImageLayout](/man/VkImageLayout) of each
subresource accessible from `imageView` at the time this descriptor
is accessed as defined by the image layout matching rules
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkDescriptorImageInfo-commonparent"}
 Both of `imageView`, and `sampler` that are valid handles of non-ignored parameters :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::


The `VkCopyDescriptorSet` structure is defined as:

[{generated}/api/structs/VkCopyDescriptorSet.adoc]({generated}/api/structs/VkCopyDescriptorSet.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `srcSet`, `srcBinding`, and `srcArrayElement` are the source
  set, binding, and array element, respectively.

- `dstSet`, `dstBinding`, and `dstArrayElement` are the
  destination set, binding, and array element, respectively.

- `descriptorCount` is the number of descriptors to copy from the
  source to destination.
  If `descriptorCount` is greater than the number of remaining array
  elements in the source or destination binding, those affect consecutive
  bindings in a manner similar to [VkWriteDescriptorSet](/man/VkWriteDescriptorSet) above.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkCopyDescriptorSet-srcBinding-00345"}
`srcBinding` :normative{type="must"} be a valid binding within `srcSet`
::

::validity-field{name="VUID-VkCopyDescriptorSet-srcArrayElement-00346"}

The sum of `srcArrayElement` and `descriptorCount` :normative{type="must"} be less
than or equal to the number of array elements in the descriptor set
binding specified by `srcBinding`, and all applicable consecutive
bindings, as described by 
::

::validity-field{name="VUID-VkCopyDescriptorSet-dstBinding-00347"}
`dstBinding` :normative{type="must"} be a valid binding within `dstSet`
::

::validity-field{name="VUID-VkCopyDescriptorSet-dstArrayElement-00348"}

The sum of `dstArrayElement` and `descriptorCount` :normative{type="must"} be less
than or equal to the number of array elements in the descriptor set
binding specified by `dstBinding`, and all applicable consecutive
bindings, as described by 
::

::validity-field{name="VUID-VkCopyDescriptorSet-dstBinding-02632"}

The type of `dstBinding` within `dstSet` :normative{type="must"} be equal to the
type of `srcBinding` within `srcSet`
::

::validity-field{name="VUID-VkCopyDescriptorSet-srcSet-00349"}

If `srcSet` is equal to `dstSet`, then the source and
destination ranges of descriptors :normative{type="must"} not overlap, where the ranges
:normative{type="may"} include array elements from consecutive bindings as described by

::

::validity-field{name="VUID-VkCopyDescriptorSet-dstBinding-02753"}

If the descriptor type of the descriptor set binding specified by
`dstBinding` is `VK_DESCRIPTOR_TYPE_SAMPLER`, then `dstSet`
:normative{type="must"} not have been allocated with a layout that included immutable
samplers for `dstBinding`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkCopyDescriptorSet-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET`
::

::validity-field{name="VUID-VkCopyDescriptorSet-pNext-pNext"}
 `pNext` :normative{type="must"} be `NULL`
::

::validity-field{name="VUID-VkCopyDescriptorSet-srcSet-parameter"}
 `srcSet` :normative{type="must"} be a valid [VkDescriptorSet](/man/VkDescriptorSet) handle
::

::validity-field{name="VUID-VkCopyDescriptorSet-dstSet-parameter"}
 `dstSet` :normative{type="must"} be a valid [VkDescriptorSet](/man/VkDescriptorSet) handle
::

::validity-field{name="VUID-VkCopyDescriptorSet-commonparent"}
 Both of `dstSet`, and `srcSet` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::






### Descriptor Set Binding

To bind one or more descriptor sets to a command buffer, call:

[{generated}/api/protos/vkCmdBindDescriptorSets.adoc]({generated}/api/protos/vkCmdBindDescriptorSets.adoc)

- `commandBuffer` is the command buffer that the descriptor sets will
  be bound to.

- `pipelineBindPoint` is a [VkPipelineBindPoint](/man/VkPipelineBindPoint) indicating the
  type of the pipeline that will use the descriptors.
  There is a separate set of bind points for each pipeline type, so
  binding one does not disturb the others.

- `layout` is a [VkPipelineLayout](/man/VkPipelineLayout) object used to program the
  bindings.

- `firstSet` is the set number of the first descriptor set to be
  bound.

- `descriptorSetCount` is the number of elements in the
  `pDescriptorSets` array.

- `pDescriptorSets` is a pointer to an array of handles to
  [VkDescriptorSet](/man/VkDescriptorSet) objects describing the descriptor sets to bind to.

- `dynamicOffsetCount` is the number of dynamic offsets in the
  `pDynamicOffsets` array.

- `pDynamicOffsets` is a pointer to an array of `uint32_t` values
  specifying dynamic offsets.

`vkCmdBindDescriptorSets` binds descriptor sets
`pDescriptorSets`\[0..`descriptorSetCount`-1] to set numbers
\[`firstSet`..`firstSet`+`descriptorSetCount`-1] for subsequent
bound pipeline commands set by
`pipelineBindPoint`.
Any bindings that were previously applied via these sets
are no longer valid.

Once bound, a descriptor set affects rendering of subsequent commands that
interact with the given pipeline type in the command buffer until either a
different set is bound to the same set number, or the set is disturbed as
described in Pipeline Layout
Compatibility.

A compatible descriptor set :normative{type="must"} be bound for all set numbers that any
shaders in a pipeline access, at the time that a drawing or dispatching
command is recorded to execute using that pipeline.
However, if none of the shaders in a pipeline statically use any bindings
with a particular set number, then no descriptor set need be bound for that
set number, even if the pipeline layout includes a non-trivial descriptor
set layout for that set number.

When consuming a descriptor, a descriptor is considered valid if the
descriptor is not undefined: as described by
descriptor set allocation.
A descriptor that was disturbed by Pipeline
Layout Compatibility, or was never bound by `vkCmdBindDescriptorSets`
is not considered valid.
If a pipeline accesses a descriptor either statically or dynamically
depending on the [VkDescriptorBindingFlagBits](/man/VkDescriptorBindingFlagBits), the consuming descriptor
type in the pipeline :normative{type="must"} match the [VkDescriptorType](/man/VkDescriptorType) in
[VkDescriptorSetLayoutCreateInfo](/man/VkDescriptorSetLayoutCreateInfo) for the descriptor to be considered
valid.


::note
Further validation may be carried out beyond validation for descriptor
types, e.g. Texel Input Validation.
::


If any of the sets being bound include dynamic uniform or storage buffers,
then `pDynamicOffsets` includes one element for each array element in
each dynamic descriptor type binding in each set.
Values are taken from `pDynamicOffsets` in an order such that all
entries for set N come before set N+1; within a set, entries are ordered by
the binding numbers in the descriptor set layouts; and within a binding
array, elements are in order.
`dynamicOffsetCount` :normative{type="must"} equal the total number of dynamic descriptors
in the sets being bound.

The effective offset used for dynamic uniform and storage buffer bindings is
the sum of the relative offset taken from `pDynamicOffsets`, and the
base address of the buffer plus base offset in the descriptor set.
The range of the dynamic uniform and storage buffer bindings is the buffer
range as specified in the descriptor set.

Each of the `pDescriptorSets` :normative{type="must"} be compatible with the pipeline
layout specified by `layout`.
The layout used to program the bindings :normative{type="must"} also be compatible with the
pipeline used in subsequent bound pipeline
commands with that pipeline type, as defined in the
Pipeline Layout Compatibility section.

The descriptor set contents bound by a call to `vkCmdBindDescriptorSets`
:normative{type="may"} be consumed at the following times:

- during host execution of the command, or during shader execution of the
  resulting draws and dispatches, or any time in between.

Thus, the contents of a descriptor set binding :normative{type="must"} not be altered
(overwritten by an update command, or freed) between the first point in time
that it :normative{type="may"} be consumed, and when the command completes executing on the
queue.

The contents of `pDynamicOffsets` are consumed immediately during
execution of `vkCmdBindDescriptorSets`.
Once all pending uses have completed, it is legal to update and reuse a
descriptor set.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdBindDescriptorSets-pDescriptorSets-00358"}

Each element of `pDescriptorSets` :normative{type="must"} have been allocated with a
`VkDescriptorSetLayout` that matches (is the same as, or identically
defined as) the `VkDescriptorSetLayout` at set *n* in `layout`,
where *n* is the sum of `firstSet` and the index into
`pDescriptorSets`
::

::validity-field{name="VUID-vkCmdBindDescriptorSets-dynamicOffsetCount-00359"}
`dynamicOffsetCount` :normative{type="must"} be equal to the total number of dynamic
descriptors in `pDescriptorSets`
::

::validity-field{name="VUID-vkCmdBindDescriptorSets-firstSet-00360"}

The sum of `firstSet` and `descriptorSetCount` :normative{type="must"} be less
than or equal to [VkPipelineLayoutCreateInfo](/man/VkPipelineLayoutCreateInfo)::`setLayoutCount`
provided when `layout` was created
::

::validity-field{name="VUID-vkCmdBindDescriptorSets-pipelineBindPoint-00361"}
`pipelineBindPoint` :normative{type="must"} be supported by the `commandBuffer`’s
parent `VkCommandPool`’s queue family
::

::validity-field{name="VUID-vkCmdBindDescriptorSets-pDynamicOffsets-01971"}

Each element of `pDynamicOffsets` which corresponds to a descriptor
binding with type `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` :normative{type="must"}
be a multiple of
`VkPhysicalDeviceLimits`::`minUniformBufferOffsetAlignment`
::

::validity-field{name="VUID-vkCmdBindDescriptorSets-pDynamicOffsets-01972"}

Each element of `pDynamicOffsets` which corresponds to a descriptor
binding with type `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC` :normative{type="must"}
be a multiple of
`VkPhysicalDeviceLimits`::`minStorageBufferOffsetAlignment`
::

::validity-field{name="VUID-vkCmdBindDescriptorSets-pDescriptorSets-01979"}

For each dynamic uniform or storage buffer binding in
`pDescriptorSets`, the sum of the effective offset and the range of the binding :normative{type="must"} be less than or
equal to the size of the buffer
::

::validity-field{name="VUID-vkCmdBindDescriptorSets-pDescriptorSets-06715"}

For each dynamic uniform or storage buffer binding in
`pDescriptorSets`, if the range was set with `VK_WHOLE_SIZE`
then `pDynamicOffsets` which corresponds to the descriptor binding
:normative{type="must"} be 0
::

::validity-field{name="VUID-vkCmdBindDescriptorSets-graphicsPipelineLibrary-06754"}

Each
    element of `pDescriptorSets` :normative{type="must"} be a valid [VkDescriptorSet](/man/VkDescriptorSet)
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdBindDescriptorSets-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdBindDescriptorSets-pipelineBindPoint-parameter"}
 `pipelineBindPoint` :normative{type="must"} be a valid [VkPipelineBindPoint](/man/VkPipelineBindPoint) value
::

::validity-field{name="VUID-vkCmdBindDescriptorSets-layout-parameter"}
 `layout` :normative{type="must"} be a valid [VkPipelineLayout](/man/VkPipelineLayout) handle
::

::validity-field{name="VUID-vkCmdBindDescriptorSets-pDescriptorSets-parameter"}
 `pDescriptorSets` :normative{type="must"} be a valid pointer to an array of `descriptorSetCount` valid or [VK_NULL_HANDLE](/man/VK_NULL_HANDLE) [VkDescriptorSet](/man/VkDescriptorSet) handles
::

::validity-field{name="VUID-vkCmdBindDescriptorSets-pDynamicOffsets-parameter"}
 If `dynamicOffsetCount` is not `0`, `pDynamicOffsets` :normative{type="must"} be a valid pointer to an array of `dynamicOffsetCount` `uint32_t` values
::

::validity-field{name="VUID-vkCmdBindDescriptorSets-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdBindDescriptorSets-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics, or compute operations
::

::validity-field{name="VUID-vkCmdBindDescriptorSets-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdBindDescriptorSets-descriptorSetCount-arraylength"}
 `descriptorSetCount` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-vkCmdBindDescriptorSets-commonparent"}
 Each of `commandBuffer`, `layout`, and the elements of `pDescriptorSets` that are valid handles of non-ignored parameters :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::










### Push Constant Updates

As described above in section Pipeline
Layouts, the pipeline layout defines shader push constants which are
updated via Vulkan commands rather than via writes to memory or copy
commands.


::note
Push constants represent a high speed path to modify constant data in
pipelines that is expected to outperform memory-backed resource updates.
::


To update push constants, call:

[{generated}/api/protos/vkCmdPushConstants.adoc]({generated}/api/protos/vkCmdPushConstants.adoc)

- `commandBuffer` is the command buffer in which the push constant
  update will be recorded.

- `layout` is the pipeline layout used to program the push constant
  updates.

- `stageFlags` is a bitmask of [VkShaderStageFlagBits](/man/VkShaderStageFlagBits) specifying
  the shader stages that will use the push constants in the updated range.

- `offset` is the start offset of the push constant range to update,
  in units of bytes.

- `size` is the size of the push constant range to update, in units of
  bytes.

- `pValues` is a pointer to an array of `size` bytes containing
  the new push constant values.

When a command buffer begins recording, all push constant values are
undefined:.

Push constant values :normative{type="can"} be updated incrementally, causing shader stages in
`stageFlags` to read the new data from `pValues` for push constants
modified by this command, while still reading the previous data for push
constants not modified by this command.
When a bound pipeline command is issued,
the bound pipeline’s layout :normative{type="must"} be compatible with the layouts used to set
the values of all push constants in the pipeline layout’s push constant
ranges, as described in Pipeline Layout
Compatibility.
Binding a pipeline with a layout that is not compatible with the push
constant layout does not disturb the push constant values.


::note
As `stageFlags` needs to include all flags the relevant push constant
ranges were created with, any flags that are not supported by the queue
family that the [VkCommandPool](/man/VkCommandPool) used to allocate `commandBuffer` was
created on are ignored.
::



::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdPushConstants-offset-01795"}

For each byte in the range specified by `offset` and `size` and
for each shader stage in `stageFlags`, there :normative{type="must"} be a push
constant range in `layout` that includes that byte and that stage
::

::validity-field{name="VUID-vkCmdPushConstants-offset-01796"}

For each byte in the range specified by `offset` and `size` and
for each push constant range that overlaps that byte, `stageFlags`
:normative{type="must"} include all stages in that push constant range’s
[VkPushConstantRange](/man/VkPushConstantRange)::`stageFlags`
::

::validity-field{name="VUID-vkCmdPushConstants-offset-00368"}
`offset` :normative{type="must"} be a multiple of `4`
::

::validity-field{name="VUID-vkCmdPushConstants-size-00369"}
`size` :normative{type="must"} be a multiple of `4`
::

::validity-field{name="VUID-vkCmdPushConstants-offset-00370"}
`offset` :normative{type="must"} be less than
`VkPhysicalDeviceLimits`::`maxPushConstantsSize`
::

::validity-field{name="VUID-vkCmdPushConstants-size-00371"}
`size` :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxPushConstantsSize` minus
`offset`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdPushConstants-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdPushConstants-layout-parameter"}
 `layout` :normative{type="must"} be a valid [VkPipelineLayout](/man/VkPipelineLayout) handle
::

::validity-field{name="VUID-vkCmdPushConstants-stageFlags-parameter"}
 `stageFlags` :normative{type="must"} be a valid combination of [VkShaderStageFlagBits](/man/VkShaderStageFlagBits) values
::

::validity-field{name="VUID-vkCmdPushConstants-stageFlags-requiredbitmask"}
 `stageFlags` :normative{type="must"} not be `0`
::

::validity-field{name="VUID-vkCmdPushConstants-pValues-parameter"}
 `pValues` :normative{type="must"} be a valid pointer to an array of `size` bytes
::

::validity-field{name="VUID-vkCmdPushConstants-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdPushConstants-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics, or compute operations
::

::validity-field{name="VUID-vkCmdPushConstants-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdPushConstants-size-arraylength"}
 `size` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-vkCmdPushConstants-commonparent"}
 Both of `commandBuffer`, and `layout` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::














# Shader Interfaces

When a pipeline is created, the set of shaders specified in the
corresponding `VkPipelineCreateInfo` structure are implicitly linked at
a number of different interfaces.

- Shader Input and Output Interface

- Vertex Input Interface

- Fragment Output Interface

- Fragment Input Attachment Interface

- Shader Resource Interface

This chapter describes valid uses for a set of SPIR-V decorations.
Any other use of one of these decorations is invalid, with the exception
that, when using SPIR-V versions 1.4 and earlier: `Block`,
`BufferBlock`, `Offset`, `ArrayStride`, and `MatrixStride` can
also decorate types and type members used by variables in the `Private`
and `Function` storage classes.


::note
In this chapter, there are references to SPIR-V terms such as the
`MeshNV` execution model.
These terms will appear even in a build of the specification which does not
support any extensions.
This is as intended, since these terms appear in the unified SPIR-V
specification without such qualifiers.
::




## Shader Input and Output Interfaces

When multiple stages are present in a pipeline, the outputs of one stage
form an interface with the inputs of the next stage.
When such an interface involves a shader, shader outputs are matched against
the inputs of the next stage, and shader inputs are matched against the
outputs of the previous stage.

All the variables forming the shader input and output *interfaces* are
listed as operands to the `OpEntryPoint` instruction and are declared
with the `Input` or `Output` storage classes, respectively, in the
SPIR-V module.
These generally form the interfaces between consecutive shader stages,
regardless of any non-shader stages between the consecutive shader stages.

There are two classes of variables that :normative{type="can"} be matched between shader
stages, built-in variables and user-defined variables.
Each class has a different set of matching criteria.

`Output` variables of a shader stage have undefined: values until the
shader writes to them or uses the `Initializer` operand when declaring
the variable.



### Built-in Interface Block

Shader built-in variables meeting the
following requirements define the *built-in interface block*.
They :normative{type="must"}

- be explicitly declared (there are no implicit built-ins),

- be identified with a `BuiltIn` decoration,

- form object types as described in the
  Built-in Variables section, and

- be declared in a block whose top-level members are the built-ins.

There :normative{type="must"} be no more than one built-in interface block per shader per
interface
.

Built-ins :normative{type="must"} not have any `Location` or `Component` decorations.





### User-defined Variable Interface

The non-built-in variables listed by `OpEntryPoint` with the `Input`
or `Output` storage class form the *user-defined variable interface*.
These :normative{type="must"} have numeric type or, recursively,
composite types of such types.
These variables :normative{type="must"} be identified with a `Location` decoration and :normative{type="can"}
also be identified with a `Component` decoration.





### Interface Matching

An output variable, block, or structure member in a given shader stage has
an interface match with an input variable, block, or structure member in a
subsequent shader stage if they both adhere to the following conditions:

- They have equivalent decorations, other than:





  * one is not decorated with `Component` and the other is declared with
    a `Component` of `0`

  * Interpolation decorations

  * `RelaxedPrecision` if one is an input variable and the other an
    output variable

- Their types match as follows:





  * if the input is declared in a tessellation control or geometry shader
    as an `OpTypeArray` with an `Element` `Type` equivalent to the
    `OpType*` declaration of the output, and neither is a structure
    member; or

  * if in any other case they are declared with an equivalent `OpType*`
    declaration.

- If both are structures and every member has an interface match.


::note
The word > structure above refers to both variables that have an
`OpTypeStruct` type and interface blocks (which are also declared as
`OpTypeStruct`).
::


All input variables and blocks :normative{type="must"} have an interface match in the
preceding shader stage, except for built-in variables in fragment shaders.
Shaders :normative{type="can"} declare and write to output variables that are not declared or
read by the subsequent stage.

The value of an input variable is undefined: if the preceding stage does not
write to a matching output variable, as described above.





### Location Assignment

This section describes `Location` assignments for user-defined variables
and how many `Location` slots are consumed by a given user-variable type.
As mentioned above, some inputs and
outputs have an additional level of arrayness relative to other shader
inputs and outputs.
This outer array level is removed from the type before considering how many
`Location` slots the type consumes.

The `Location` value specifies an interface slot comprised of a 32-bit
four-component vector conveyed between stages.
The `Component` specifies word
components within these vector `Location` slots.
Only types with widths of
32 or 64 are supported in shader interfaces.

Inputs and outputs of the following types consume a single interface
`Location`:

- 32-bit scalar and vector types, and

- 64-bit scalar and 2-component vector types.

64-bit three- and four-component vectors consume two consecutive
`Location` slots.

If a declared input or output is an array of size *n* and each element takes
*m* `Location` slots, it will be assigned *m* × *n* consecutive
`Location` slots starting with the specified `Location`.

If the declared input or output is an *n* × *m*
32- or 64-bit matrix, it will be assigned multiple `Location` slots
starting with the specified `Location`.
The number of `Location` slots assigned for each matrix will be the same
as for an *n*-element array of *m*-component vectors.

An `OpVariable` with a structure type that is not a block :normative{type="must"} be
decorated with a `Location`.

When an `OpVariable` with a structure type (either block or non-block) is
decorated with a `Location`, the members in the structure type :normative{type="must"} not
be decorated with a `Location`.
The `OpVariable`’s members are assigned consecutive `Location` slots
in declaration order, starting from the first member, which is assigned the
`Location` decoration from the `OpVariable`.

When a block-type `OpVariable` is declared without a `Location`
decoration, each member in its structure type :normative{type="must"} be decorated with a
`Location`.
Types nested deeper than the top-level members :normative{type="must"} not have `Location`
decorations.

The `Location` slots consumed by block and structure members are
determined by applying the rules above in a depth-first traversal of the
instantiated members as though the structure or block member were declared
as an input or output variable of the same type.

Any two inputs listed as operands on the same `OpEntryPoint` :normative{type="must"} not be
assigned the same `Location` slot and `Component` word, either
explicitly or implicitly.
Any two outputs listed as operands on the same `OpEntryPoint` :normative{type="must"} not
be assigned the same `Location` slot and `Component` word, either
explicitly or implicitly.

The number of input and output `Location` slots available for a shader
input or output interface is limited, and dependent on the shader stage as
described in .
All variables in both the built-in interface
block and the user-defined variable
interface count against these limits.
Each effective `Location` :normative{type="must"} have a value less than the number of
`Location` slots available for the given interface, as specified in the
> Locations Available column in .







### Component Assignment

The `Component` decoration allows the `Location` to be more finely
specified for scalars and vectors, down to the individual `Component`
word within a `Location` slot that are consumed.
The `Component` word within a `Location` are 0, 1, 2, and 3.
A variable or block member starting at `Component` N will consume
`Component` words N, N+1, N+2, …​
up through its size.
For single precision types,
it is invalid if this sequence of `Component` words gets larger than 3.
A scalar 64-bit type will consume two of these `Component` words in
sequence, and a two-component 64-bit vector type will consume all four
`Component` words available within a `Location`.
A three- or four-component 64-bit vector type :normative{type="must"} not specify a non-zero
`Component` decoration.
A three-component 64-bit vector type will consume all four `Component`
words of the first `Location` and `Component` 0 and 1 of the second
`Location`.
This leaves `Component` 2 and 3 available for other component-qualified
declarations.

A scalar or two-component 64-bit data type :normative{type="must"} not specify a
`Component` decoration of 1 or 3.
A `Component` decoration :normative{type="must"} not be specified for any type that is not
a scalar or vector.

A four-component 64-bit data type will consume all four `Component` words
of the first `Location` and all four `Component` words of the second
`Location`.







## Vertex Input Interface

When the vertex stage is present in a pipeline, the vertex shader input
variables form an interface with the vertex input attributes.
The vertex shader input variables are matched by the `Location` and
`Component` decorations to the vertex input attributes specified in the
`pVertexInputState` member of the [VkGraphicsPipelineCreateInfo](/man/VkGraphicsPipelineCreateInfo)
structure.

The vertex shader input variables listed by `OpEntryPoint` with the
`Input` storage class form the *vertex input interface*.
These variables :normative{type="must"} be identified with a `Location` decoration and :normative{type="can"}
also be identified with a `Component` decoration.

For the purposes of interface matching: variables declared without a
`Component` decoration are considered to have a `Component` decoration
of zero.
The number of available vertex input `Location` slots is given by the
`maxVertexInputAttributes` member of the `VkPhysicalDeviceLimits`
structure.

See  for details.

All vertex shader inputs declared as above :normative{type="must"} have a corresponding
attribute and binding in the pipeline.





## Fragment Output Interface

When the fragment stage is present in a pipeline, the fragment shader
outputs form an interface with the output attachments defined by a
render pass instance.
The fragment shader output variables are matched by the `Location` and
`Component` decorations to specified color attachments.

The fragment shader output variables listed by `OpEntryPoint` with the
`Output` storage class form the *fragment output interface*.
These variables :normative{type="must"} be identified with a `Location` decoration.
They :normative{type="can"} also be identified with a `Component` decoration and/or an
`Index` decoration.
For the purposes of interface matching: variables declared without a
`Component` decoration are considered to have a `Component` decoration
of zero, and variables declared without an `Index` decoration are
considered to have an `Index` decoration of zero.

A fragment shader output variable identified with a `Location` decoration
of *i* is associated with
the color attachment indicated by
[VkSubpassDescription](/man/VkSubpassDescription)::`pColorAttachments`\[*i*].
Values are written to those attachments after passing through the blending
unit as described in , if enabled.
Locations are consumed as described in
Location Assignment.
The number of available fragment output `Location` slots is given by the
`maxFragmentOutputAttachments` member of the
`VkPhysicalDeviceLimits` structure.

When an active fragment shader invocation finishes, the values of all
fragment shader outputs are copied out and used as blend inputs or color
attachments writes.
If the invocation does not set a value for them, the input values to those
blending or color attachment writes are undefined:.

Components of the output variables are assigned as described in
Component Assignment.
Output `Component` words identified as 0, 1, 2, and 3 will be directed to
the R, G, B, and A inputs to the blending unit, respectively, or to the
output attachment if blending is disabled.
If two variables are placed within the same `Location`, they :normative{type="must"} have
the same underlying type (floating-point or integer).
`Component` words which do not correspond to any fragment shader output
will also result in undefined: values for blending or color attachment
writes.

Fragment outputs identified with an `Index` of zero are directed to the
first input of the blending unit associated with the corresponding
`Location`.
Outputs identified with an `Index` of one are directed to the second
input of the corresponding blending unit.

There :normative{type="must"} be no output variable which has the same `Location`,
`Component`, and `Index` as any other, either explicitly declared or
implied.

Output values written by a fragment shader :normative{type="must"} be declared with either
`OpTypeFloat` or `OpTypeInt`, and a `Width` of 32.
Composites of these types are also permitted.
If the color attachment has a signed or unsigned normalized fixed-point
format, color values are assumed to be floating-point and are converted to
fixed-point as described in ; If the color
attachment has an integer format, color values are assumed to be integers
and converted to the bit-depth of the target.
Any value that cannot be represented in the attachment’s format is
undefined:.
For any other attachment format no conversion is performed.
If the type of the values written by the fragment shader do not match the
format of the corresponding color attachment, the resulting values are
undefined: for those components.





## Fragment Input Attachment Interface

When a fragment stage is present in a pipeline, the fragment shader subpass
inputs form an interface with the input attachments of the current subpass.
The fragment shader subpass input variables are matched by
`InputAttachmentIndex` decorations to the input attachments specified in
the `pInputAttachments` array of the [VkSubpassDescription](/man/VkSubpassDescription)
structure describing the subpass that the fragment shader is executed in.

The fragment shader subpass input variables with the `UniformConstant`
storage class and a decoration of `InputAttachmentIndex` that are
statically used by `OpEntryPoint` form the *fragment input attachment
interface*.
These variables :normative{type="must"} be declared with a type of `OpTypeImage`, a
`Dim` operand of `SubpassData`, an `Arrayed` operand of 0, and a
`Sampled` operand of 2.
The `MS` operand of the `OpTypeImage` :normative{type="must"} be 0 if the `samples`
field of the corresponding [VkAttachmentDescription](/man/VkAttachmentDescription) is
`VK_SAMPLE_COUNT_1_BIT` and
1 otherwise.

A subpass input variable identified with an `InputAttachmentIndex`
decoration of *i* reads from the input attachment indicated by
`pInputAttachments`\[*i*] member of `VkSubpassDescription`.
If the subpass input variable is declared as an array of size N, it consumes
N consecutive input attachments, starting with the index specified.
There :normative{type="must"} not be more than one input variable with the same
`InputAttachmentIndex` whether explicitly declared or implied by an array
declaration per image aspect.
A multi-aspect image (e.g. a depth/stencil format) :normative{type="can"} use the same input
variable.
The number of available input attachment indices is given by the
`maxPerStageDescriptorInputAttachments` member of the
`VkPhysicalDeviceLimits` structure.

Variables identified with the `InputAttachmentIndex` :normative{type="must"} only be used
by a fragment stage.
The numeric format of the subpass input :normative{type="must"}
match the format of the corresponding input attachment, or the values of
subpass loads from these variables are undefined:.
If the framebuffer attachment contains both depth and stencil aspects, the
numeric format of the subpass input determines if depth or stencil aspect is
accessed by the shader.

See  for more details.



### Fragment Input Attachment Compatibility

An input attachment that is statically accessed by a fragment shader :normative{type="must"}
be backed by a descriptor that is equivalent to the [VkImageView](/man/VkImageView) in the
[VkFramebuffer](/man/VkFramebuffer), except for `subresourceRange.aspectMask`.
The `aspectMask` :normative{type="must"} be equal to the aspect accessed by the shader.







## Shader Resource Interface

When a shader stage accesses buffer or image resources, as described in the
Resource Descriptors section, the shader resource
variables :normative{type="must"} be matched with the pipeline
layout that is provided at pipeline creation time.

The set of shader variables that form the *shader resource interface* for a
stage are the variables statically used by that stage’s `OpEntryPoint`
with a storage class of `Uniform`, `UniformConstant`,
or `PushConstant`.
For the fragment shader, this includes the fragment input attachment interface.

The shader resource interface consists of two sub-interfaces: the push
constant interface and the descriptor set interface.



### Push Constant Interface

The shader variables defined with a storage class of `PushConstant` that
are statically used by the shader entry points for the pipeline define the
*push constant interface*.
They :normative{type="must"} be:

- typed as `OpTypeStruct`,

- identified with a `Block` decoration, and

- laid out explicitly using the `Offset`, `ArrayStride`, and
  `MatrixStride` decorations as specified in
  Offset and Stride Assignment.

There :normative{type="must"} be no more than one push constant block statically used per
shader entry point.

Each statically used member of a push constant block :normative{type="must"} be placed at an
`Offset` such that the entire member is entirely contained within the
[VkPushConstantRange](/man/VkPushConstantRange) for each `OpEntryPoint` that uses it, and the
`stageFlags` for that range :normative{type="must"} specify the appropriate
[VkShaderStageFlagBits](/man/VkShaderStageFlagBits) for that stage.
The `Offset` decoration for any member of a push constant block :normative{type="must"} not
cause the space required for that member to extend outside the range
\[0, `maxPushConstantsSize`).

Any member of a push constant block that is declared as an array :normative{type="must"} only
be accessed with *dynamically uniform* indices.





### Descriptor Set Interface

The *descriptor set interface* is comprised of the shader variables with the
storage class of
`Uniform` or `UniformConstant` (including the variables in the
fragment input attachment interface) that are
statically used by the shader entry points for the pipeline.

These variables :normative{type="must"} have `DescriptorSet` and `Binding` decorations
specified, which are assigned and matched with the
`VkDescriptorSetLayout` objects in the pipeline layout as described in
DescriptorSet and Binding Assignment.

The `Image` `Format` of an `OpTypeImage` declaration :normative{type="must"} not be
*Unknown*, for variables which are used for `OpImageRead`,
`OpImageSparseRead`, or `OpImageWrite` operations, except under the
following conditions:

- For `OpImageWrite`, if the image format is listed in the
  storage without format list
  and if the `shaderStorageImageWriteWithoutFormat` feature is enabled
  and the shader module declares the `StorageImageWriteWithoutFormat`
  capability.

- For `OpImageRead` or `OpImageSparseRead`, if the image format is
  listed in the storage without
  format list and if the `shaderStorageImageReadWithoutFormat`
  feature is enabled and the shader module declares the
  `StorageImageReadWithoutFormat` capability.

- For `OpImageRead`, if `Dim` is `SubpassData` (indicating a read
  from an input attachment).

The `Image` `Format` of an `OpTypeImage` declaration :normative{type="must"} not be
*Unknown*, for variables which are used for `OpAtomic*` operations.

Variables identified with the `Uniform` storage class are used to access
transparent buffer backed resources.
Such variables :normative{type="must"} be:

- typed as `OpTypeStruct`, or an array of this type,

- identified with a `Block` or `BufferBlock` decoration, and

- laid out explicitly using the `Offset`, `ArrayStride`, and
  `MatrixStride` decorations as specified in
  Offset and Stride Assignment.

The `Offset` decoration for any variable in a `Block` :normative{type="must"} not cause
the space required for that variable to extend outside the range \[0,
`maxUniformBufferRange`).
The `Offset` decoration for any variable in a `BufferBlock` :normative{type="must"} not
cause the space required for that variable to extend outside the range
\[0, `maxStorageBufferRange`).

Variables identified with a storage class of `UniformConstant` and a
decoration of `InputAttachmentIndex` :normative{type="must"} be declared as described in
Fragment Input Attachment Interface.

SPIR-V variables decorated with a descriptor set and binding that identify a
combined image sampler descriptor
:normative{type="can"} have a type of `OpTypeImage`, `OpTypeSampler` (`Sampled`=1),
or `OpTypeSampledImage`.

Arrays of any of these types :normative{type="can"} be indexed with *constant integral
expressions*.
The following features :normative{type="must"} be enabled and capabilities :normative{type="must"} be declared
in order to index such arrays with dynamically uniform or non-uniform
indices:

- Storage images (except storage texel buffers and input attachments):





  * Dynamically uniform: `shaderStorageImageArrayDynamicIndexing` and
    `StorageImageArrayDynamicIndexing`

- Sampled images (except uniform texel buffers), samplers and combined
  image samplers:





  * Dynamically uniform: `shaderSampledImageArrayDynamicIndexing` and
    `SampledImageArrayDynamicIndexing`

- Uniform buffers:





  * Dynamically uniform: `shaderUniformBufferArrayDynamicIndexing` and
    `UniformBufferArrayDynamicIndexing`

- Storage buffers:





  * Dynamically uniform: `shaderStorageBufferArrayDynamicIndexing` and
    `StorageBufferArrayDynamicIndexing`

If an instruction loads from or stores to a resource (including atomics and
image instructions) and the resource descriptor being accessed is loaded
from an array element with a non-constant index, then the corresponding
dynamic
indexing feature :normative{type="must"} be enabled and the capability :normative{type="must"} be declared.











### DescriptorSet and Binding Assignment

A variable decorated with a `DescriptorSet` decoration of s and a
`Binding` decoration of b indicates that this variable is
associated with the [VkDescriptorSetLayoutBinding](/man/VkDescriptorSetLayoutBinding) that has a
`binding` equal to b in `pSetLayouts`\[*s*] that was specified
in [VkPipelineLayoutCreateInfo](/man/VkPipelineLayoutCreateInfo).

`DescriptorSet` decoration values :normative{type="must"} be between zero and
`maxBoundDescriptorSets` minus one, inclusive.
`Binding` decoration values :normative{type="can"} be any 32-bit unsigned integer value, as
described in .
Each descriptor set has its own binding name space.

If the `Binding` decoration is used with an array, the entire array is
assigned that binding value.
The array :normative{type="must"} be a single-dimensional array and size of the array :normative{type="must"} be
no larger than the number of descriptors in the binding.
The array :normative{type="must"} not be runtime-sized.
The index of each element of the array is referred to as the *arrayElement*.
For the purposes of interface matching and descriptor set
operations, if a resource variable is not an
array, it is treated as if it has an arrayElement of zero.

There is a limit on the number of resources of each type that :normative{type="can"} be
accessed by a pipeline stage as shown in
Shader Resource Limits.
The > Resources Per Stage column gives the limit on the number each type
of resource that :normative{type="can"} be statically used for an entry point in any given
stage in a pipeline.
The > Resource Types column lists which resource types are counted against
the limit.
Some resource types count against multiple limits.

The pipeline layout :normative{type="may"} include descriptor sets and bindings which are not
referenced by any variables statically used by the entry points for the
shader stages in the binding’s `stageFlags`.

However, if a variable assigned to a given `DescriptorSet` and
`Binding` is statically used by the entry point for a shader stage, the
pipeline layout :normative{type="must"} contain a descriptor set layout binding in that
descriptor set layout and for that binding number, and that binding’s
`stageFlags` :normative{type="must"} include the appropriate [VkShaderStageFlagBits](/man/VkShaderStageFlagBits)
for that stage.
The variable :normative{type="must"} be of a valid resource type determined by its SPIR-V type
and storage class, as defined in
Shader Resource and
Storage Class Correspondence.
The descriptor set layout binding :normative{type="must"} be of a corresponding descriptor
type, as defined in Shader Resource
and Descriptor Type Correspondence.


::note
There are no limits on the number of shader variables that can have
overlapping set and binding values in a shader; but which resources are
statically used has an impact.
If any shader variable identifying a resource is
statically used in a shader, then the underlying
descriptor bound at the declared set and binding must
support the declared type in the
shader when the shader executes.

If multiple shader variables are declared with the same set and binding
values, and with the same underlying descriptor type, they can all be
statically used within the same shader.
However, accesses are not automatically synchronized, and `Aliased`
decorations should be used to avoid data hazards (see
[section
2.18.2 Aliasing in the SPIR-V specification](https://registry.khronos.org/spir-v/specs/unified1/SPIRV.html#_a_id_aliasingsection_a_aliasing)).

If multiple shader variables with the same set and binding values are
declared in a single shader, but with different declared types, where any of
those are not supported by the relevant bound descriptor, that shader can
only be executed if the variables with the unsupported type are not
statically used.

A noteworthy example of using multiple statically-used shader variables
sharing the same descriptor set and binding values is a descriptor of type
`VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` that has multiple
corresponding shader variables in the `UniformConstant` storage class,
where some could be `OpTypeImage` (`Sampled`=1), some could be
`OpTypeSampler`, and some could be `OpTypeSampledImage`.
::










### Offset and Stride Assignment

Certain objects :normative{type="must"} be explicitly laid out using the `Offset`,
`ArrayStride`, and `MatrixStride`, as described in
[SPIR-V
explicit layout validation rules](https://registry.khronos.org/spir-v/specs/unified1/SPIRV.html#ShaderValidation).
All such layouts also :normative{type="must"} conform to the following requirements.


::note
The numeric order of `Offset` decorations does not need to follow member
declaration order.
::


*Alignment Requirements*

There are different alignment requirements depending on the specific
resources and on the features enabled on the device.

Matrix types are defined in terms of arrays as follows:

- A column-major matrix with C columns and R rows is
  equivalent to a C element array of vectors with R
  components.

- A row-major matrix with C columns and R rows is equivalent
  to an R element array of vectors with C components.

The *scalar alignment* of the type of an `OpTypeStruct` member is defined
recursively as follows:

- A scalar of size N has a scalar alignment of N.

- A vector type has a scalar alignment equal to that of its component
  type.

- An array type has a scalar alignment equal to that of its element type.

- A structure has a scalar alignment equal to the largest scalar alignment
  of any of its members.

- A matrix type inherits *scalar alignment* from the equivalent array
  declaration.

The *base alignment* of the type of an `OpTypeStruct` member is defined
recursively as follows:

- A scalar has a base alignment equal to its scalar alignment.

- A two-component vector has a base alignment equal to twice its scalar
  alignment.

- A three- or four-component vector has a base alignment equal to four
  times its scalar alignment.

- An array has a base alignment equal to the base alignment of its element
  type.

- A structure has a base alignment equal to the largest base alignment of
  any of its members.
  An empty structure has a base alignment equal to the size of the
  smallest scalar type permitted by the capabilities declared in the
  SPIR-V module.
  (e.g., for a 1 byte aligned empty struct in the `StorageBuffer`
  storage class, `StorageBuffer8BitAccess` or
  `UniformAndStorageBuffer8BitAccess` :normative{type="must"} be declared in the SPIR-V
  module.)

- A matrix type inherits *base alignment* from the equivalent array
  declaration.

The *extended alignment* of the type of an `OpTypeStruct` member is
similarly defined as follows:

- A scalar or vector type has an extended alignment equal to its base
  alignment.

- An array or structure type has an extended alignment equal to the
  largest extended alignment of any of its members, rounded up to a
  multiple of 16.

- A matrix type inherits extended alignment from the equivalent array
  declaration.

*Standard Buffer Layout*

Every member of an `OpTypeStruct` that is required to be explicitly laid
out :normative{type="must"} be aligned according to the first matching rule as follows.
If the struct is contained in pointer types of multiple storage classes, it
:normative{type="must"} satisfy the requirements for every storage class used to reference it.

1) Any
   member of an `OpTypeStruct` with a storage class of `Uniform` and
   a decoration of `Block` :normative{type="must"} be aligned according to its extended
   alignment.

2) Every other member :normative{type="must"} be aligned according to its base alignment.

The memory layout :normative{type="must"} obey the following rules:

- The `Offset` decoration of any member :normative{type="must"} be a multiple of its
  alignment.

- Any `ArrayStride` or `MatrixStride` decoration :normative{type="must"} be a multiple
  of the alignment of the array or matrix as defined above.

- The `Offset` decoration of a member :normative{type="must"} not place it between the
  end of a structure, an array or a matrix and the next multiple of the
  alignment of that structure, array or matrix.


::note
The *std430 layout* in GLSL satisfies these rules for types using the base
alignment.
The *std140 layout* satisfies the rules for types using the extended
alignment.
::








## Built-In Variables

Built-in variables are accessed in shaders by declaring a variable decorated
with a `BuiltIn` SPIR-V decoration.
The meaning of each `BuiltIn` decoration is as follows.
In the remainder of this section, the name of a built-in is used
interchangeably with a term equivalent to a variable decorated with that
particular built-in.
Built-ins that represent integer values :normative{type="can"} be declared as either signed or
unsigned 32-bit integers.

As mentioned above, some inputs and
outputs have an additional level of arrayness relative to other shader
inputs and outputs.
This level of arrayness is not included in the type descriptions below, but
must be included when declaring the built-in.































































# Image Operations



## Image Operations Overview

Vulkan Image Operations are operations performed by those SPIR-V Image
Instructions which take an `OpTypeImage` (representing a
`VkImageView`) or `OpTypeSampledImage` (representing a
(`VkImageView`, `VkSampler`) pair).
Read, write, and atomic operations also take texel coordinates as operands,
and return a value based on a neighborhood of texture elements (*texels*)
within the image.
Query operations return properties of the bound image or of the lookup
itself.
The > Depth operand of `OpTypeImage` is ignored.


::note
Texel is a term which is a combination of the words texture and element.
Early interactive computer graphics supported texture operations on
textures, a small subset of the image operations on images described here.
The discrete samples remain essentially equivalent, however, so we retain
the historical term texel to refer to them.
::


Image Operations include the functionality of the following SPIR-V Image
Instructions:

- `OpImageSample*` and `OpImageSparseSample*` read one or more
  neighboring texels of the image, and filter
  the texel values based on the state of the sampler.





  * Instructions with `ImplicitLod` in the name
    determine the LOD used in the
    sampling operation based on the coordinates used in neighboring
    fragments.

  * Instructions with `ExplicitLod` in the name
    determine the LOD used in the
    sampling operation based on additional coordinates.

  * Instructions with `Proj` in the name apply homogeneous
    projection to the coordinates.

- `OpImageFetch` and `OpImageSparseFetch` return a single texel of
  the image.
  No sampler is used.

- `OpImage*Gather` and `OpImageSparse*Gather` read neighboring
  texels and return a single component of each.

- `OpImageRead` (and `OpImageSparseRead`) and `OpImageWrite` read
  and write, respectively, a texel in the image.
  No sampler is used.

- `OpImage*Dref*` instructions apply
  depth comparison on the texel
  values.

- `OpImageSparse*` instructions additionally return a
  sparse residency code.

- `OpImageQuerySize`, `OpImageQuerySizeLod`,
  `OpImageQueryLevels`, and `OpImageQuerySamples` return properties
  of the image descriptor that would be accessed.
  The image itself is not accessed.

- `OpImageQueryLod` returns the LOD parameters that would be used in a
  sample operation.
  The actual operation is not performed.



### Texel Coordinate Systems

Images are addressed by *texel coordinates*.
There are three *texel coordinate systems*:

- normalized texel coordinates \[0.0, 1.0]

- unnormalized texel coordinates \[0.0, width / height / depth)

- integer texel coordinates \[0, width / height / depth)

SPIR-V `OpImageFetch`, `OpImageSparseFetch`, `OpImageRead`,
`OpImageSparseRead`,
and `OpImageWrite` instructions use integer texel coordinates.

Other image instructions :normative{type="can"} use either normalized or unnormalized texel
coordinates (selected by the `unnormalizedCoordinates` state of the
sampler used in the instruction), but there are
limitations on what operations, image
state, and sampler state is supported.
Normalized coordinates are logically
converted to unnormalized as part of
image operations, and certain steps are
only performed on normalized coordinates.
The array layer coordinate is always treated as unnormalized even when other
coordinates are normalized.

Normalized texel coordinates are referred to as (s,t,r,q,a), with the
coordinates having the following meanings:

- s: Coordinate in the first dimension of an image.

- t: Coordinate in the second dimension of an image.

- r: Coordinate in the third dimension of an image.





  * (s,t,r) are interpreted as a direction vector for Cube images.

- q: Fourth coordinate, for homogeneous (projective) coordinates.

- a: Coordinate for array layer.

The coordinates are extracted from the SPIR-V operand based on the
dimensionality of the image variable and type of instruction.
For `Proj` instructions, the components are in order (s, \[t,] \[r,]
q), with t and r being conditionally present based on the
`Dim` of the image.
For non-`Proj` instructions, the coordinates are (s \[,t] \[,r]
\[,a]), with t and r being conditionally present based on the
`Dim` of the image and a being conditionally present based on the
`Arrayed` property of the image.
Projective image instructions are not supported on `Arrayed` images.

Unnormalized texel coordinates are referred to as (u,v,w,a), with the
coordinates having the following meanings:

- u: Coordinate in the first dimension of an image.

- v: Coordinate in the second dimension of an image.

- w: Coordinate in the third dimension of an image.

- a: Coordinate for array layer.

Only the u and v coordinates are directly extracted from the
SPIR-V operand, because only 1D and 2D (non-`Arrayed`) dimensionalities
support unnormalized coordinates.
The components are in order (u \[,v]), with v being conditionally
present when the dimensionality is 2D.
When normalized coordinates are converted to unnormalized coordinates, all
four coordinates are used.

Integer texel coordinates are referred to as (i,j,k,l,n), with the
coordinates having the following meanings:

- i: Coordinate in the first dimension of an image.

- j: Coordinate in the second dimension of an image.

- k: Coordinate in the third dimension of an image.

- l: Coordinate for array layer.

- n: Index of the sample within the texel.

They are extracted from the SPIR-V operand in order (i \[,j] \[,k] \[,l]
\[,n]), with j and k conditionally present based on the `Dim`
of the image, and l conditionally present based on the `Arrayed`
property of the image.
n is conditionally present and is taken from the `Sample` image
operand.

For all coordinate types, unused coordinates are assigned a value of zero.



The Texel Coordinate Systems - For the example shown of an 8×4 texel
two dimensional image.

- Normalized texel coordinates:





  * The s coordinate goes from 0.0 to 1.0.

  * The t coordinate goes from 0.0 to 1.0.

- Unnormalized texel coordinates:





  * The u coordinate within the range 0.0 to 8.0 is within the image,
    otherwise it is outside the image.

  * The v coordinate within the range 0.0 to 4.0 is within the image,
    otherwise it is outside the image.

- Integer texel coordinates:





  * The i coordinate within the range 0 to 7 addresses texels within
    the image, otherwise it is outside the image.

  * The j coordinate within the range 0 to 3 addresses texels within
    the image, otherwise it is outside the image.

- Also shown for linear filtering:





  * Given the unnormalized coordinates (u,v), the four texels
    selected are i\<sub>0\</sub>j\<sub>0\</sub>, i\<sub>1\</sub>j\<sub>0\</sub>, i\<sub>0\</sub>j\<sub>1\</sub>, and
    i\<sub>1\</sub>j\<sub>1\</sub>.

  * The fractions α and β.

  * Given the offset Δ\<sub>i\</sub> and Δ\<sub>j\</sub>, the
    four texels selected by the offset are i\<sub>0\</sub>j'\<sub>0\</sub>,
    i\<sub>1\</sub>j'\<sub>0\</sub>, i\<sub>0\</sub>j'\<sub>1\</sub>, and i\<sub>1\</sub>j'\<sub>1\</sub>.



The Texel Coordinate Systems - For the example shown of an 8×4 texel
two dimensional image.

- Texel coordinates as above.
  Also shown for nearest filtering:





  * Given the unnormalized coordinates (u,v), the texel selected is
    ij.

  * Given the offset Δ\<sub>i\</sub> and Δ\<sub>j\</sub>, the
    texel selected by the offset is ij'.







## Conversion Formulas



### RGB to Shared Exponent Conversion

An RGB color (red, green, blue) is transformed to a shared exponent
color (red\<sub>shared\</sub>, green\<sub>shared\</sub>, blue\<sub>shared\</sub>, exp\<sub>shared\</sub>) as
follows:

First, the components (red, green, blue) are clamped to
(red\<sub>clamped\</sub>, green\<sub>clamped\</sub>, blue\<sub>clamped\</sub>) as:



where:




::note
NaN, if supported, is handled as in\


IEEE 754-2008 `minNum()` and `maxNum()`.
This results in any NaN being mapped to zero.
::


The largest clamped component, max\<sub>clamped\</sub> is determined:



A preliminary shared exponent exp' is computed:



The shared exponent exp\<sub>shared\</sub> is computed:





Finally, three integer values in the range 0 to 2\<sup>N\</sup> are
computed:







### Shared Exponent to RGB

A shared exponent color (red\<sub>shared\</sub>, green\<sub>shared\</sub>, blue\<sub>shared\</sub>,
exp\<sub>shared\</sub>) is transformed to an RGB color (red, green, blue) as
follows:



where:









## Texel Input Operations

*Texel input instructions* are SPIR-V image instructions that read from an
image.
*Texel input operations* are a set of steps that are performed on state,
coordinates, and texel values while processing a texel input instruction,
and which are common to some or all texel input instructions.
They include the following steps, which are performed in the listed order:

- Validation operations





  * Instruction/Sampler/Image validation

  * Coordinate validation

  * Sparse validation

- Format conversion

- Texel replacement

- Depth comparison

- Conversion to RGBA

- Component swizzle

For texel input instructions involving multiple texels (for sampling or
gathering), these steps are applied for each texel that is used in the
instruction.
Depending on the type of image instruction, other steps are conditionally
performed between these steps or involving multiple coordinate or texel
values.



### Texel Input Validation Operations

*Texel input validation operations* inspect instruction/image/sampler state
or coordinates, and in certain circumstances cause the texel value to be
replaced or become undefined:.
There are a series of validations that the texel undergoes.



#### Instruction/Sampler/Image View Validation

There are a number of cases where a SPIR-V instruction :normative{type="can"} mismatch with
the sampler, the image view, or both, and a number of further cases where
the sampler :normative{type="can"} mismatch with the image view.
In such cases the value of the texel returned is undefined:.

These cases include:

- The sampler `borderColor` is an integer type and the image view
  `format` is not one of the [VkFormat](/man/VkFormat) integer types or a stencil
  component of a depth/stencil format.

- The sampler `borderColor` is a float type and the image view
  `format` is not one of the [VkFormat](/man/VkFormat) float types or a depth
  component of a depth/stencil format.

- The sampler `borderColor` is one of the opaque black colors
  (`VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK` or
  `VK_BORDER_COLOR_INT_OPAQUE_BLACK`) and the image view
  [VkComponentSwizzle](/man/VkComponentSwizzle) for any of the [VkComponentMapping](/man/VkComponentMapping)
  components is not the identity
  swizzle.

- The [VkImageLayout](/man/VkImageLayout) of any subresource in the image view does not
  match the [VkDescriptorImageInfo](/man/VkDescriptorImageInfo)::`imageLayout` used to write
  the image descriptor.

- The SPIR-V Image Format is not compatible
  with the image view’s `format`.

- The sampler `unnormalizedCoordinates` is `VK_TRUE` and any of
  the limitations of unnormalized
  coordinates are violated.

- The SPIR-V instruction is one of the `OpImage*Dref*` instructions and
  the sampler `compareEnable` is `VK_FALSE`

- The SPIR-V instruction is not one of the `OpImage*Dref*` instructions
  and the sampler `compareEnable` is `VK_TRUE`

- The SPIR-V instruction is one of the `OpImage*Dref*` instructions and
  the image view `format` is not one of the depth/stencil formats with
  a depth component, or the image view aspect is not
  `VK_IMAGE_ASPECT_DEPTH_BIT`.

- The SPIR-V instruction’s image variable’s properties are not compatible
  with the image view:





  * Rules for `viewType`:





    * `VK_IMAGE_VIEW_TYPE_1D` :normative{type="must"} have `Dim` = 1D, `Arrayed` =
      0, `MS` = 0.

    * `VK_IMAGE_VIEW_TYPE_2D` :normative{type="must"} have `Dim` = 2D, `Arrayed` = 0.

    * `VK_IMAGE_VIEW_TYPE_3D` :normative{type="must"} have `Dim` = 3D, `Arrayed` =
      0, `MS` = 0.

    * `VK_IMAGE_VIEW_TYPE_CUBE` :normative{type="must"} have `Dim` = Cube, `Arrayed`
      \= 0, `MS` = 0.

    * `VK_IMAGE_VIEW_TYPE_1D_ARRAY` :normative{type="must"} have `Dim` = 1D,
      `Arrayed` = 1, `MS` = 0.

    * `VK_IMAGE_VIEW_TYPE_2D_ARRAY` :normative{type="must"} have `Dim` = 2D,
      `Arrayed` = 1.

    * `VK_IMAGE_VIEW_TYPE_CUBE_ARRAY` :normative{type="must"} have `Dim` = Cube,
      `Arrayed` = 1, `MS` = 0.

  * If the image was created with [VkImageCreateInfo](/man/VkImageCreateInfo)::`samples`
    equal to `VK_SAMPLE_COUNT_1_BIT`, the instruction :normative{type="must"} have
    `MS` = 0.

  * If the image was created with [VkImageCreateInfo](/man/VkImageCreateInfo)::`samples`
    not equal to `VK_SAMPLE_COUNT_1_BIT`, the instruction :normative{type="must"} have
    `MS` = 1.

  * If the `Sampled` `Type` of the `OpTypeImage` does not match
    the SPIR-V Type.

  * If the signedness of any read or sample
    operation does not match the signedness of the image’s format.





#### Integer Texel Coordinate Validation

Integer texel coordinates are validated against the size of the image level,
and the number of layers and number of samples in the image.
For SPIR-V instructions that use integer texel coordinates, this is
performed directly on the integer coordinates.
For instructions that use normalized or unnormalized texel coordinates, this
is performed on the coordinates that result after
conversion to integer texel
coordinates.

If the integer texel coordinates do not satisfy all of the conditions



where:



then the texel fails integer texel coordinate validation.

There are four cases to consider:

1) Valid Texel Coordinates





   * If the texel coordinates pass validation (that is, the coordinates lie
     within the image),





   then the texel value comes from the value in image memory.

2) Border Texel





   * If the texel coordinates fail validation, and

   * If the read is the result of an image sample instruction or image gather
     instruction, and

   * If the image is not a cube image,





   then the texel is a border texel and texel
   replacement is performed.

3) Invalid Texel





   * If the texel coordinates fail validation, and

   * If the read is the result of an image fetch instruction, image read
     instruction, or atomic instruction,





   then the texel is an invalid texel and texel
   replacement is performed.

4) Cube Map Edge or Corner





   Otherwise the texel coordinates lie beyond the edges or corners of the
   selected cube map face, and Cube map edge handling
   is performed.





#### Cube Map Edge Handling

If the texel coordinates lie beyond the edges or corners of the selected
cube map face (as described in the prior section), the following steps are
performed.
Note that this does not occur when using `VK_FILTER_NEAREST` filtering
within a mip level, since `VK_FILTER_NEAREST` is treated as using
`VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE`.

- Cube Map Edge Texel





  * If the texel lies beyond the selected cube map face in either only
    i or only j, then the coordinates (i,j) and the array
    layer l are transformed to select the adjacent texel from the
    appropriate neighboring face.

- Cube Map Corner Texel





  * If the texel lies beyond the selected cube map face in both i and
    &#x20;    j, then there is no unique neighboring face from which to read
    &#x20;    that texel.
    &#x20;    The texel :normative{type="should"} be replaced by the average of the three values of the
    &#x20;    adjacent texels in each incident face.
    &#x20;    However, implementations :normative{type="may"} replace the cube map corner texel by
    &#x20;    other methods.
    The methods are subject to the constraint that if the three available texels
    have the same value, the resulting filtered texel :normative{type="must"} have that value.





#### Sparse Validation

If the texel reads from an unbound region of a sparse image, the texel is a
*sparse unbound texel*, and processing continues with
texel replacement.







### Format Conversion

Texels undergo a format conversion from the [VkFormat](/man/VkFormat) of the image view
to a vector of either floating point or signed or unsigned integer
components, with the number of components based on the number of components
present in the format.

- Color formats have one, two, three, or four components, according to the
  format.

- Depth/stencil formats are one component.
  The depth or stencil component is selected by the `aspectMask` of
  the image view.

Each component is converted based on its type and size (as defined in the
Format Definition section for each [VkFormat](/man/VkFormat)),
using the appropriate equations in 16-Bit Floating-Point
Numbers, Unsigned 11-Bit Floating-Point Numbers,
Unsigned 10-Bit Floating-Point Numbers,
Fixed-Point Data Conversion, and
Shared Exponent to RGB.
Signed integer components smaller than 32 bits are sign-extended.

If the image view format is sRGB, the color components are first converted
as if they are UNORM, and then sRGB to linear conversion is applied to the
R, G, and B components as described in the > sRGB EOTF section of the
Khronos Data Format Specification.
The A component, if present, is unchanged.

If the image view format is block-compressed, then the texel value is first
decoded, then converted based on the type and number of components defined
by the compressed format.





### Texel Replacement

A texel is replaced if it is one (and only one) of:

- a border texel,

- an invalid texel, or

- a sparse unbound texel.

Border texels are replaced with a value based on the image format and the
`borderColor` of the sampler.
The border color is:




::note
The names `VK_BORDER_COLOR_*_TRANSPARENT_BLACK`,
`VK_BORDER_COLOR_*_OPAQUE_BLACK`, and
`VK_BORDER_COLOR_*_OPAQUE_WHITE` are meant to describe which components
are zeros and ones in the vocabulary of compositing, and are not meant to
imply that the numerical value of `VK_BORDER_COLOR_INT_OPAQUE_WHITE` is
a saturating value for integers.
::


This is substituted for the texel value by replacing the number of
components in the image format



The value returned by a read of an invalid texel is undefined:, unless that
read operation is from a buffer resource and the `robustBufferAccess`
feature is enabled.
In that case, an invalid texel is replaced as described by the
`robustBufferAccess` feature.

If the
[VkPhysicalDeviceSparseProperties](/man/VkPhysicalDeviceSparseProperties)::`residencyNonResidentStrict`
property is `VK_TRUE`, a sparse unbound texel is replaced with 0 or 0.0
values for integer and floating-point components of the image format,
respectively.

If `residencyNonResidentStrict` is `VK_FALSE`, the value of the
sparse unbound texel is undefined:.





### Depth Compare Operation

If the image view has a depth/stencil format, the depth component is
selected by the `aspectMask`, and the operation is an `OpImage*Dref*`
instruction, a depth comparison is performed.
The result is 1.0 if the comparison evaluates to true, and
0.0 otherwise.
This value replaces the depth component D.

The compare operation is selected by the [VkCompareOp](/man/VkCompareOp) value set by
[VkSamplerCreateInfo](/man/VkSamplerCreateInfo)::`compareOp`.
The reference value from the SPIR-V operand D\<sub>ref\</sub> and the texel depth
value D\<sub>tex\</sub> are used as the *reference* and *test* values,
respectively, in that operation.

If the image being sampled has an unsigned normalized fixed-point format,
then D\<sub>ref\</sub> is clamped to \[0,1] before the compare operation.





### Conversion to RGBA

The texel is expanded from one, two, or three components to four components
based on the image base color:



where one = 1.0f for floating-point formats and depth aspects, and
one = 1 for integer formats and stencil aspects.





### Component Swizzle

All texel input instructions apply a *swizzle* based on the
[VkComponentSwizzle](/man/VkComponentSwizzle) enums in the `components` member of the
[VkImageViewCreateInfo](/man/VkImageViewCreateInfo) structure for the image being read.

The swizzle :normative{type="can"} rearrange the components of the texel, or substitute zero
or one for any components.
It is defined as follows for each color component:



where:



If the border color is one of the `VK_BORDER_COLOR_*_OPAQUE_BLACK` enums
and the [VkComponentSwizzle](/man/VkComponentSwizzle) is not the
identity swizzle for all
components, the value of the texel after swizzle is undefined:.

If the image view has a depth/stencil format and the
[VkComponentSwizzle](/man/VkComponentSwizzle) is `VK_COMPONENT_SWIZZLE_ONE`, the value of the
texel after swizzle is undefined:.





### Sparse Residency

`OpImageSparse*` instructions return a structure which includes a
*residency code* indicating whether any texels accessed by the instruction
are sparse unbound texels.
This code :normative{type="can"} be interpreted by the `OpImageSparseTexelsResident`
instruction which converts the residency code to a boolean value.







## Texel Output Operations

*Texel output instructions* are SPIR-V image instructions that write to an
image.
*Texel output operations* are a set of steps that are performed on state,
coordinates, and texel values while processing a texel output instruction,
and which are common to some or all texel output instructions.
They include the following steps, which are performed in the listed order:

- Validation operations





  * Format validation

  * Type validation

  * Coordinate validation

  * Sparse validation

- Texel output format conversion



### Texel Output Validation Operations

*Texel output validation operations* inspect instruction/image state or
coordinates, and in certain circumstances cause the write to have no effect.
There are a series of validations that the texel undergoes.



#### Texel Format Validation

If the image format of the `OpTypeImage` is not
compatible with the `VkImageView`’s
`format`, the write causes the contents of the image’s memory to become
undefined:.





#### Texel Type Validation

If the `Sampled` `Type` of the `OpTypeImage` does not match the
SPIR-V Type, the write causes the value of the texel to
become undefined:.
For integer types, if the signedness of the
access does not match the signedness of the accessed resource, the write
causes the value of the texel to become undefined:.







### Integer Texel Coordinate Validation

The integer texel coordinates are validated according to the same rules as
for texel input coordinate
validation.

If the texel fails integer texel coordinate validation, then the write has
no effect.





### Sparse Texel Operation

If the texel attempts to write to an unbound region of a sparse image, the
texel is a sparse unbound texel.
In such a case, if the
[VkPhysicalDeviceSparseProperties](/man/VkPhysicalDeviceSparseProperties)::`residencyNonResidentStrict`
property is `VK_TRUE`, the sparse unbound texel write has no effect.
If `residencyNonResidentStrict` is `VK_FALSE`, the write :normative{type="may"} have a
side effect that becomes visible to other accesses to unbound texels in any
resource, but will not be visible to any device memory allocated by the
application.





### Texel Output Format Conversion

If the image format is sRGB, a linear to sRGB conversion is applied to the
R, G, and B components as described in the > sRGB EOTF section of the
Khronos Data Format Specification.
The A component, if present, is unchanged.

Texels then undergo a format conversion from the floating point, signed, or
unsigned integer type of the texel data to the [VkFormat](/man/VkFormat) of the image
view.
If the number of components in the texel data is larger than the number of
components in the format, additional components are discarded.

Each component is converted based on its type and size (as defined in the
Format Definition section for each [VkFormat](/man/VkFormat)).
Floating-point outputs are converted as described in
Floating-Point Format Conversions and
Fixed-Point Data Conversion.
Integer outputs are converted such that their value is preserved.
The converted value of any integer that cannot be represented in the target
format is undefined:.







## Normalized Texel Coordinate Operations

If the image sampler instruction provides normalized texel coordinates, some
of the following operations are performed.



### Projection Operation

For `Proj` image operations, the normalized texel coordinates
(s,t,r,q,a) and (if present) the D\<sub>ref\</sub> coordinate are
transformed as follows:







### Derivative Image Operations

Derivatives are used for LOD selection.
These derivatives are either implicit (in an `ImplicitLod` image
instruction in a fragment shader) or explicit (provided explicitly by shader
to the image instruction in any shader).

For implicit derivatives image instructions, the derivatives of texel
coordinates are calculated in the same manner as
derivative operations.
That is:



Partial derivatives not defined above for certain image dimensionalities are
set to zero.

For explicit LOD image instructions, if the :normative{type="optional"} SPIR-V operand
`Grad` is provided, then the operand values are used for the derivatives.
The number of components present in each derivative for a given image
dimensionality matches the number of partial derivatives computed above.

If the :normative{type="optional"} SPIR-V operand `Lod` is provided, then derivatives are
set to zero, the cube map derivative transformation is skipped, and the
scale factor operation is skipped.
Instead, the floating point scalar coordinate is directly assigned to
λ\<sub>base\</sub> as described in LOD Operation.





### Cube Map Face Selection and Transformations

For cube map image instructions, the (s,t,r) coordinates are treated
as a direction vector (r\<sub>x\</sub>,r\<sub>y\</sub>,r\<sub>z\</sub>).
The direction vector is used to select a cube map face.
The direction vector is transformed to a per-face texel coordinate system
(s\<sub>face\</sub>,t\<sub>face\</sub>), The direction vector is also used to transform the
derivatives to per-face derivatives.





### Cube Map Face Selection

The direction vector selects one of the cube map’s faces based on the
largest magnitude coordinate direction (the major axis direction).
Since two or more coordinates :normative{type="can"} have identical magnitude, the
implementation :normative{type="must"} have rules to disambiguate this situation.

The rules :normative{type="should"} have as the first rule that r\<sub>z\</sub> wins over
r\<sub>y\</sub> and r\<sub>x\</sub>, and the second rule that r\<sub>y\</sub> wins over
r\<sub>x\</sub>.
An implementation :normative{type="may"} choose other rules, but the rules :normative{type="must"} be
deterministic and depend only on (r\<sub>x\</sub>,r\<sub>y\</sub>,r\<sub>z\</sub>).

The layer number (corresponding to a cube map face), the coordinate
selections for s\<sub>c\</sub>, t\<sub>c\</sub>, r\<sub>c\</sub>, and the selection of
derivatives, are determined by the major axis direction as specified in the
following two tables.









### Cube Map Coordinate Transformation







### Cube Map Derivative Transformation









### Scale Factor Operation, LOD Operation and Image Level(s) Selection

LOD selection :normative{type="can"} be either explicit (provided explicitly by the image
instruction) or implicit (determined from a scale factor calculated from the
derivatives).
The LOD :normative{type="must"} be computed with `mipmapPrecisionBits` of accuracy.



#### Scale Factor Operation

The magnitude of the derivatives are calculated by:



where:



and:



(for the `baseMipLevel`, from the image descriptor).

A point sampled in screen space has an elliptical footprint in texture
space.
The minimum and maximum scale factors (ρ\<sub>min\</sub>, ρ\<sub>max\</sub>) :normative{type="should"}
be the minor and major axes of this ellipse.

The *scale factors* ρ\<sub>x\</sub> and ρ\<sub>y\</sub>, calculated from the
magnitude of the derivatives in x and y, are used to compute the minimum and
maximum scale factors.

ρ\<sub>x\</sub> and ρ\<sub>y\</sub> :normative{type="may"} be approximated with functions
f\<sub>x\</sub> and f\<sub>y\</sub>, subject to the following constraints:





The minimum and maximum scale factors (ρ\<sub>min\</sub>,ρ\<sub>max\</sub>) are
determined by:



The ratio of anisotropy is determined by:



where:



If ρ\<sub>max\</sub> = ρ\<sub>min\</sub> = 0, then all the partial derivatives are
zero, the fragment’s footprint in texel space is a point, and η
:normative{type="should"} be treated as 1.
If ρ\<sub>max\</sub> ≠ 0 and ρ\<sub>min\</sub> = 0 then all partial
derivatives along one axis are zero, the fragment’s footprint in texel space
is a line segment, and η :normative{type="should"} be treated as max\<sub>Aniso\</sub>.
However, anytime the footprint is small in texel space the implementation
:normative{type="may"} use a smaller value of η, even when ρ\<sub>min\</sub> is zero
or close to zero.
If either [VkPhysicalDeviceFeatures](/man/VkPhysicalDeviceFeatures)::`samplerAnisotropy` or
[VkSamplerCreateInfo](/man/VkSamplerCreateInfo)::`anisotropyEnable` are `VK_FALSE`,
max\<sub>Aniso\</sub> is set to 1.

If η = 1, sampling is isotropic.
If η > 1, sampling is anisotropic.

The sampling rate (N) is derived as:



An implementation :normative{type="may"} round N up to the nearest supported sampling
rate.
An implementation :normative{type="may"} use the value of N as an approximation of
η.





#### LOD Operation

The LOD parameter λ is computed as follows:



where:



and maxSamplerLodBias is the value of the [VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits)
feature `maxSamplerLodBias`.





#### Image Level(s) Selection

The image level(s) d, d\<sub>hi\</sub>, and d\<sub>lo\</sub> which texels are
read from are determined by an image-level parameter d\<sub>l\</sub>, which is
computed based on the LOD parameter, as follows:



where:





and:



`baseMipLevel` and `levelCount` are taken from the
`subresourceRange` of the image view.

If the sampler’s `mipmapMode` is `VK_SAMPLER_MIPMAP_MODE_NEAREST`,
then the level selected is d = d\<sub>l\</sub>.

If the sampler’s `mipmapMode` is `VK_SAMPLER_MIPMAP_MODE_LINEAR`,
two neighboring levels are selected:



δ is the fractional value, quantized to the number of
mipmap precision bits, used for
linear filtering between levels.







### (s,t,r,q,a) to (u,v,w,a) Transformation

The normalized texel coordinates are scaled by the image level dimensions
and the array layer is selected.

This transformation is performed once for each level used in
filtering (either d, or d\<sub>hi\</sub> and
d\<sub>lo\</sub>).



where:



and where (Δ\<sub>i\</sub>, Δ\<sub>j\</sub>, Δ\<sub>k\</sub>) are
taken from the image instruction if it includes a `ConstOffset` or
`Offset` operand, otherwise they are taken to be zero.

Operations then proceed to Unnormalized Texel Coordinate Operations.







## Unnormalized Texel Coordinate Operations



### (u,v,w,a) to (i,j,k,l,n) Transformation and Array Layer Selection

The unnormalized texel coordinates are transformed to integer texel
coordinates relative to the selected mipmap level.

The layer index l is computed as:



where `layerCount` is the number of layers in the image subresource
range of the image view, `baseArrayLayer` is the first layer from the
subresource range, and where:



The sample index n is assigned the value 0.

Nearest filtering (`VK_FILTER_NEAREST`) computes the integer texel
coordinates that the unnormalized coordinates lie within:



where:



Linear filtering (`VK_FILTER_LINEAR`) computes a set of neighboring
coordinates which bound the unnormalized coordinates.
The integer texel coordinates are combinations of i\<sub>0\</sub> or i\<sub>1\</sub>,
j\<sub>0\</sub> or j\<sub>1\</sub>, k\<sub>0\</sub> or k\<sub>1\</sub>, as well as weights
α, β, and γ.





where:



and where:



where the number of fraction bits retained is specified by
`VkPhysicalDeviceLimits`::`subTexelPrecisionBits`.







## Integer Texel Coordinate Operations

The `OpImageFetch` and `OpImageFetchSparse` SPIR-V instructions :normative{type="may"}
supply a LOD from which texels are to be fetched using the optional SPIR-V
operand `Lod`.
Other integer-coordinate operations :normative{type="must"} not.
If the `Lod` is provided then it :normative{type="must"} be an integer.

The image level selected is:



If d does not lie in the range \[`baseMipLevel`,
`baseMipLevel` +  `levelCount`)
then any values fetched are
undefined:, and any writes (if supported) are discarded.





## Image Sample Operations



### Wrapping Operation

`Cube` images ignore the wrap modes specified in the sampler.
Instead, if `VK_FILTER_NEAREST` is used within a mip level then
`VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE` is used, and if
`VK_FILTER_LINEAR` is used within a mip level then sampling at the edges
is performed as described earlier in the Cube map
edge handling section.

The first integer texel coordinate i is transformed based on the
`addressModeU` parameter of the sampler.



where:



j (for 2D and Cube image) and k (for 3D image) are similarly
transformed based on the `addressModeV` and `addressModeW`
parameters of the sampler, respectively.





### Texel Gathering

SPIR-V instructions with `Gather` in the name return a vector derived
from 4 texels in the base level of the image view.
The rules for the `VK_FILTER_LINEAR` minification filter are applied to
identify the four selected texels.
Each texel is then converted to an RGBA value according to
conversion to RGBA and then
swizzled.
A four-component vector is then assembled by taking the component indicated
by the `Component` value in the instruction from the swizzled color value
of the four texels.
If the operation does not use the `ConstOffsets` image operand then the
four texels form the 2 × 2 rectangle used for texture filtering:



If the operation does use the `ConstOffsets` image operand then the
offsets allow a custom filter to be defined:



where:







### Texel Filtering

Texel filtering is first performed for each level (either d or
d\<sub>hi\</sub> and d\<sub>lo\</sub>).

If λ is less than or equal to zero, the texture is said to be
*magnified*, and the filter mode within a mip level is selected by the
`magFilter` in the sampler.
If λ is greater than zero, the texture is said to be
*minified*, and the filter mode within a mip level is selected by the
`minFilter` in the sampler.



#### Texel Nearest Filtering

Within a mip level, `VK_FILTER_NEAREST` filtering selects a single value
using the (i, j, k) texel coordinates, with all texels taken from
layer l.







#### Texel Linear Filtering

Within a mip level, `VK_FILTER_LINEAR` filtering combines 8 (for 3D), 4
(for 2D or Cube), or 2 (for 1D) texel values, together with their linear
weights.
The linear weights are derived from the fractions computed earlier:



The values of multiple texels, together with their weights, are combined
using a weighted average to produce a filtered value:







#### Texel Mipmap Filtering

`VK_SAMPLER_MIPMAP_MODE_NEAREST` filtering returns the value of a single
mipmap level,

τ = τ\[d].

`VK_SAMPLER_MIPMAP_MODE_LINEAR` filtering combines the values of
multiple mipmap levels (τ\[hi] and τ\[lo]), together with their linear
weights.

The linear weights are derived from the fraction computed earlier:



The values of multiple mipmap levels together with their linear weights, are
combined using a weighted average to produce a final filtered value:







#### Texel Anisotropic Filtering

Anisotropic filtering is enabled by the `anisotropyEnable` in the
sampler.
When enabled, the image filtering scheme accounts for a degree of
anisotropy.

The particular scheme for anisotropic texture filtering is
implementation-dependent.
Implementations :normative{type="should"} consider the `magFilter`, `minFilter` and
`mipmapMode` of the sampler to control the specifics of the anisotropic
filtering scheme used.
In addition, implementations :normative{type="should"} consider `minLod` and `maxLod`
of the sampler.


::note
For historical reasons, vendor implementations of anisotropic filtering
interpret these sampler parameters in different ways, particularly in corner
cases such as `magFilter`, `minFilter` of `NEAREST` or
`maxAnisotropy` equal to 1.0.
Applications should not expect consistent behavior in such cases, and should
use anisotropic filtering only with parameters which are expected to give a
quality improvement relative to `LINEAR` filtering.

The following describes one particular approach to implementing anisotropic
filtering for the 2D Image case; implementations :normative{type="may"} choose other methods:

Given a `magFilter`, `minFilter` of `VK_FILTER_LINEAR` and a
`mipmapMode` of `VK_SAMPLER_MIPMAP_MODE_NEAREST`:

Instead of a single isotropic sample, N isotropic samples are sampled within
the image footprint of the image level d to approximate an anisotropic
filter.
The sum τ\<sub>2Daniso\</sub> is defined using the single isotropic
τ\<sub>2D\</sub>(u,v) at level d.


::










## Image Operation Steps

Each step described in this chapter is performed by a subset of the image
instructions:

- Texel Input Validation Operations, Format Conversion, Texel Replacement,
  Conversion to RGBA, and Component Swizzle: Performed by all instructions
  except `OpImageWrite`.

- Depth Comparison: Performed by `OpImage*Dref` instructions.

- All Texel output operations: Performed by `OpImageWrite`.

- Projection: Performed by all `OpImage*Proj` instructions.

- Derivative Image Operations, Cube Map Operations, Scale Factor
  Operation, LOD Operation and Image Level(s) Selection, and Texel
  Anisotropic Filtering: Performed by all `OpImageSample*` and
  `OpImageSparseSample*` instructions.

- (s,t,r,q,a) to (u,v,w,a) Transformation, Wrapping, and (u,v,w,a) to
  (i,j,k,l,n) Transformation And Array Layer Selection: Performed by all
  `OpImageSample`, `OpImageSparseSample`, and `OpImage*Gather`
  instructions.

- Texel Gathering: Performed by `OpImage*Gather` instructions.

- Texel Filtering: Performed by all `OpImageSample*` and
  `OpImageSparseSample*` instructions.

- Sparse Residency: Performed by all `OpImageSparse*` instructions.





## Image Query Instructions



### Image Property Queries

`OpImageQuerySize`, `OpImageQuerySizeLod`, `OpImageQueryLevels`,
and `OpImageQuerySamples` query properties of the image descriptor that
would be accessed by a shader image operation.

`OpImageQuerySizeLod` returns the size of the image level identified by
the `Level` `of` `Detail` operand.
If that level does not exist in the image,
then the value returned is undefined:.





### Lod Query

`OpImageQueryLod` returns the Lod parameters that would be used in an
image operation with the given image and coordinates.
The
steps described in this chapter are performed as if for
`OpImageSampleImplicitLod`, up to .
The return value is the vector (λ', d\<sub>l\</sub>).
These values :normative{type="may"} be subject to implementation-specific maxima and minima
for very large, out-of-range values.









# Queries

*Queries* provide a mechanism to return information about the processing of
a sequence of Vulkan commands.
Query operations are asynchronous, and as such, their results are not
returned immediately.
Instead, their results, and their availability status are stored in a
Query Pool.
The state of these queries :normative{type="can"} be read back on the host, or copied to a
buffer object on the device.

The supported query types are Occlusion Queries,
Pipeline Statistics Queries,
and Timestamp Queries.



## Query Pools

Queries are managed using *query pool* objects.
Each query pool is a collection of a specific number of queries of a
particular type.

Query pools are represented by `VkQueryPool` handles:

[{generated}/api/handles/VkQueryPool.adoc]({generated}/api/handles/VkQueryPool.adoc)

To create a query pool, call:

[{generated}/api/protos/vkCreateQueryPool.adoc]({generated}/api/protos/vkCreateQueryPool.adoc)

- `device` is the logical device that creates the query pool.

- `pCreateInfo` is a pointer to a [VkQueryPoolCreateInfo](/man/VkQueryPoolCreateInfo)
  structure containing the number and type of queries to be managed by the
  pool.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.

- `pQueryPool` is a pointer to a [VkQueryPool](/man/VkQueryPool) handle in which the
  resulting query pool object is returned.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCreateQueryPool-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkCreateQueryPool-pCreateInfo-parameter"}
 `pCreateInfo` :normative{type="must"} be a valid pointer to a valid [VkQueryPoolCreateInfo](/man/VkQueryPoolCreateInfo) structure
::

::validity-field{name="VUID-vkCreateQueryPool-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkCreateQueryPool-pQueryPool-parameter"}
 `pQueryPool` :normative{type="must"} be a valid pointer to a [VkQueryPool](/man/VkQueryPool) handle
::

::




The `VkQueryPoolCreateInfo` structure is defined as:

[{generated}/api/structs/VkQueryPoolCreateInfo.adoc]({generated}/api/structs/VkQueryPoolCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is reserved for future use.

- `queryType` is a [VkQueryType](/man/VkQueryType) value specifying the type of
  queries managed by the pool.

- `queryCount` is the number of queries managed by the pool.

- `pipelineStatistics` is a bitmask of
  [VkQueryPipelineStatisticFlagBits](/man/VkQueryPipelineStatisticFlagBits) specifying which counters will be
  returned in queries on the new pool, as described below in
  .

`pipelineStatistics` is ignored if `queryType` is not
`VK_QUERY_TYPE_PIPELINE_STATISTICS`.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkQueryPoolCreateInfo-queryType-00791"}

If the `pipelineStatisticsQuery` feature is not enabled, `queryType`
:normative{type="must"} not be `VK_QUERY_TYPE_PIPELINE_STATISTICS`
::

::validity-field{name="VUID-VkQueryPoolCreateInfo-queryType-00792"}

If `queryType` is `VK_QUERY_TYPE_PIPELINE_STATISTICS`,
`pipelineStatistics` :normative{type="must"} be a valid combination of
[VkQueryPipelineStatisticFlagBits](/man/VkQueryPipelineStatisticFlagBits) values
::

::validity-field{name="VUID-VkQueryPoolCreateInfo-queryCount-02763"}
`queryCount` :normative{type="must"} be greater than 0
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkQueryPoolCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO`
::

::validity-field{name="VUID-VkQueryPoolCreateInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkQueryPoolPerformanceCreateInfoKHR](/man/VkQueryPoolPerformanceCreateInfoKHR), [VkQueryPoolPerformanceQueryCreateInfoINTEL](/man/VkQueryPoolPerformanceQueryCreateInfoINTEL), [VkQueryPoolVideoEncodeFeedbackCreateInfoKHR](/man/VkQueryPoolVideoEncodeFeedbackCreateInfoKHR), [VkVideoDecodeH264ProfileInfoKHR](/man/VkVideoDecodeH264ProfileInfoKHR), [VkVideoDecodeH265ProfileInfoKHR](/man/VkVideoDecodeH265ProfileInfoKHR), [VkVideoDecodeUsageInfoKHR](/man/VkVideoDecodeUsageInfoKHR), [VkVideoEncodeH264ProfileInfoEXT](/man/VkVideoEncodeH264ProfileInfoEXT), [VkVideoEncodeH265ProfileInfoEXT](/man/VkVideoEncodeH265ProfileInfoEXT), [VkVideoEncodeUsageInfoKHR](/man/VkVideoEncodeUsageInfoKHR), or [VkVideoProfileInfoKHR](/man/VkVideoProfileInfoKHR)
::

::validity-field{name="VUID-VkQueryPoolCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkQueryPoolCreateInfo-flags-zerobitmask"}
 `flags` :normative{type="must"} be `0`
::

::validity-field{name="VUID-VkQueryPoolCreateInfo-queryType-parameter"}
 `queryType` :normative{type="must"} be a valid [VkQueryType](/man/VkQueryType) value
::

::


[{generated}/api/flags/VkQueryPoolCreateFlags.adoc]({generated}/api/flags/VkQueryPoolCreateFlags.adoc)

`VkQueryPoolCreateFlags` is a bitmask type for setting a mask, but is
currently reserved for future use.

To destroy a query pool, call:

[{generated}/api/protos/vkDestroyQueryPool.adoc]({generated}/api/protos/vkDestroyQueryPool.adoc)

- `device` is the logical device that destroys the query pool.

- `queryPool` is the query pool to destroy.

- `pAllocator` controls host memory allocation as described in the
  Memory Allocation chapter.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkDestroyQueryPool-queryPool-00793"}

All submitted commands that refer to `queryPool` :normative{type="must"} have
completed execution
::

::validity-field{name="VUID-vkDestroyQueryPool-queryPool-00794"}

If `VkAllocationCallbacks` were provided when `queryPool` was
created, a compatible set of callbacks :normative{type="must"} be provided here
::

::validity-field{name="VUID-vkDestroyQueryPool-queryPool-00795"}

If no `VkAllocationCallbacks` were provided when `queryPool` was
created, `pAllocator` :normative{type="must"} be `NULL`
::

::



::note
Applications :normative{type="can"} verify that `queryPool` :normative{type="can"} be destroyed by checking
that `vkGetQueryPoolResults`() without the
`VK_QUERY_RESULT_PARTIAL_BIT` flag returns `VK_SUCCESS` for all
queries that are used in command buffers submitted for execution.
::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkDestroyQueryPool-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkDestroyQueryPool-queryPool-parameter"}
 If `queryPool` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `queryPool` :normative{type="must"} be a valid [VkQueryPool](/man/VkQueryPool) handle
::

::validity-field{name="VUID-vkDestroyQueryPool-pAllocator-parameter"}
 If `pAllocator` is not `NULL`, `pAllocator` :normative{type="must"} be a valid pointer to a valid [VkAllocationCallbacks](/man/VkAllocationCallbacks) structure
::

::validity-field{name="VUID-vkDestroyQueryPool-queryPool-parent"}
 If `queryPool` is a valid handle, it :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::




Possible values of [VkQueryPoolCreateInfo](/man/VkQueryPoolCreateInfo)::`queryType`, specifying
the type of queries managed by the pool, are:

[{generated}/api/enums/VkQueryType.adoc]({generated}/api/enums/VkQueryType.adoc)

- `VK_QUERY_TYPE_OCCLUSION` specifies an occlusion query.

- `VK_QUERY_TYPE_PIPELINE_STATISTICS` specifies a pipeline statistics query.

- `VK_QUERY_TYPE_TIMESTAMP` specifies a timestamp query.





## Query Operation

The operation of queries is controlled by the commands
[vkCmdBeginQuery](/man/vkCmdBeginQuery), [vkCmdEndQuery](/man/vkCmdEndQuery),
[vkCmdResetQueryPool](/man/vkCmdResetQueryPool), [vkCmdCopyQueryPoolResults](/man/vkCmdCopyQueryPoolResults),
and [vkCmdWriteTimestamp](/man/vkCmdWriteTimestamp).

In order for a `VkCommandBuffer` to record query management commands,
the queue family for which its `VkCommandPool` was created :normative{type="must"} support
the appropriate type of operations (graphics, compute) suitable for the
query type of a given query pool.

Each query in a query pool has a status that is either *unavailable* or
*available*, and also has state to store the numerical results of a query
operation of the type requested when the query pool was created.
Resetting a query via [vkCmdResetQueryPool](/man/vkCmdResetQueryPool)
sets the status to unavailable and makes the numerical results undefined:.
A query is made available by the operation of [vkCmdEndQuery](/man/vkCmdEndQuery),
or [vkCmdWriteTimestamp](/man/vkCmdWriteTimestamp).
Both the availability status and numerical results :normative{type="can"} be retrieved by
calling either [vkGetQueryPoolResults](/man/vkGetQueryPoolResults) or
[vkCmdCopyQueryPoolResults](/man/vkCmdCopyQueryPoolResults).

After query pool creation, each query is in an uninitialized state and :normative{type="must"}
be reset before it is used.
Queries :normative{type="must"} also be reset between uses.

To reset a range of queries in a query pool on a queue, call:

[{generated}/api/protos/vkCmdResetQueryPool.adoc]({generated}/api/protos/vkCmdResetQueryPool.adoc)

- `commandBuffer` is the command buffer into which this command will
  be recorded.

- `queryPool` is the handle of the query pool managing the queries
  being reset.

- `firstQuery` is the initial query index to reset.

- `queryCount` is the number of queries to reset.

When executed on a queue, this command sets the status of query indices
\[`firstQuery`, `firstQuery` +  `queryCount` - 1] to
unavailable.

This command defines an execution dependency between other query commands
that reference the same query.

The first synchronization scope
includes all commands which reference the queries in `queryPool`
indicated by `firstQuery` and `queryCount` that occur earlier in
submission order.

The second synchronization scope
includes all commands which reference the queries in `queryPool`
indicated by `firstQuery` and `queryCount` that occur later in
submission order.

The operation of this command happens after the first scope and happens
before the second scope.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdResetQueryPool-firstQuery-00796"}
`firstQuery` :normative{type="must"} be less than the number of queries in
`queryPool`
::

::validity-field{name="VUID-vkCmdResetQueryPool-firstQuery-00797"}

The sum of `firstQuery` and `queryCount` :normative{type="must"} be less than or
equal to the number of queries in `queryPool`
::

::validity-field{name="VUID-vkCmdResetQueryPool-None-02841"}

All queries used by the command :normative{type="must"} not be active
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdResetQueryPool-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdResetQueryPool-queryPool-parameter"}
 `queryPool` :normative{type="must"} be a valid [VkQueryPool](/man/VkQueryPool) handle
::

::validity-field{name="VUID-vkCmdResetQueryPool-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdResetQueryPool-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics, compute, decode, encode, or optical flow operations
::

::validity-field{name="VUID-vkCmdResetQueryPool-renderpass"}
 This command :normative{type="must"} only be called outside of a render pass instance
::

::validity-field{name="VUID-vkCmdResetQueryPool-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdResetQueryPool-commonparent"}
 Both of `commandBuffer`, and `queryPool` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::






Once queries are reset and ready for use, query commands :normative{type="can"} be issued to a
command buffer.
Occlusion queries and pipeline statistics queries count events - drawn
samples and pipeline stage invocations, respectively - resulting from
commands that are recorded between a [vkCmdBeginQuery](/man/vkCmdBeginQuery) command and a
[vkCmdEndQuery](/man/vkCmdEndQuery) command within a specified command buffer, effectively
scoping a set of drawing and/or dispatching commands.
Timestamp queries write timestamps to a query pool.

A query :normative{type="must"} begin and end in the same command buffer, although if it is a
primary command buffer, and the `inheritedQueries` feature is enabled, it :normative{type="can"} execute secondary
command buffers during the query operation.
For a secondary command buffer to be executed while a query is active, it
:normative{type="must"} set the `occlusionQueryEnable`, `queryFlags`, and/or
`pipelineStatistics` members of [VkCommandBufferInheritanceInfo](/man/VkCommandBufferInheritanceInfo) to
conservative values, as described in the Command
Buffer Recording section.
A query :normative{type="must"} either begin and end inside the same subpass of a render pass
instance, or :normative{type="must"} both begin and end outside of a render pass instance
(i.e. contain entire render pass instances).

To begin a query, call:

[{generated}/api/protos/vkCmdBeginQuery.adoc]({generated}/api/protos/vkCmdBeginQuery.adoc)

- `commandBuffer` is the command buffer into which this command will
  be recorded.

- `queryPool` is the query pool that will manage the results of the
  query.

- `query` is the query index within the query pool that will contain
  the results.

- `flags` is a bitmask of [VkQueryControlFlagBits](/man/VkQueryControlFlagBits) specifying
  constraints on the types of queries that :normative{type="can"} be performed.

If the `queryType` of the pool is `VK_QUERY_TYPE_OCCLUSION` and
`flags` contains `VK_QUERY_CONTROL_PRECISE_BIT`, an implementation
:normative{type="must"} return a result that matches the actual number of samples passed.
This is described in more detail in Occlusion Queries.

After beginning a query, that query is considered *active* within the
command buffer it was called in until that same query is ended.
Queries active in a primary command buffer when secondary command buffers
are executed are considered active for those secondary command buffers.

This command defines an execution dependency between other query commands
that reference the same query.

The first synchronization scope
includes all commands which reference the queries in `queryPool`
indicated by `query` that occur earlier in
submission order.

The second synchronization scope
includes all commands which reference the queries in `queryPool`
indicated by `query` that occur later in
submission order.

The operation of this command happens after the first scope and happens
before the second scope.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdBeginQuery-None-00807"}

All queries used by the command :normative{type="must"} be *unavailable*
::

::validity-field{name="VUID-vkCmdBeginQuery-queryType-02804"}

The `queryType` used to create `queryPool` :normative{type="must"} not be
`VK_QUERY_TYPE_TIMESTAMP`
::

::validity-field{name="VUID-vkCmdBeginQuery-queryType-00800"}

If the `occlusionQueryPrecise`
feature is not enabled, or the `queryType` used to create
`queryPool` was not `VK_QUERY_TYPE_OCCLUSION`, `flags` :normative{type="must"}
not contain `VK_QUERY_CONTROL_PRECISE_BIT`
::

::validity-field{name="VUID-vkCmdBeginQuery-query-00802"}
`query` :normative{type="must"} be less than the number of queries in `queryPool`
::

::validity-field{name="VUID-vkCmdBeginQuery-queryType-00803"}

If the `queryType` used to create `queryPool` was
`VK_QUERY_TYPE_OCCLUSION`, the `VkCommandPool` that
`commandBuffer` was allocated from :normative{type="must"} support graphics operations
::

::validity-field{name="VUID-vkCmdBeginQuery-queryType-00804"}

If the `queryType` used to create `queryPool` was
`VK_QUERY_TYPE_PIPELINE_STATISTICS` and any of the
`pipelineStatistics` indicate graphics operations, the
`VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"}
support graphics operations
::

::validity-field{name="VUID-vkCmdBeginQuery-queryType-00805"}

If the `queryType` used to create `queryPool` was
`VK_QUERY_TYPE_PIPELINE_STATISTICS` and any of the
`pipelineStatistics` indicate compute operations, the
`VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"}
support compute operations
::

::validity-field{name="VUID-vkCmdBeginQuery-queryPool-01922"}
`queryPool` :normative{type="must"} have been created with a `queryType` that
differs from that of any queries that are
active within `commandBuffer`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdBeginQuery-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdBeginQuery-queryPool-parameter"}
 `queryPool` :normative{type="must"} be a valid [VkQueryPool](/man/VkQueryPool) handle
::

::validity-field{name="VUID-vkCmdBeginQuery-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkQueryControlFlagBits](/man/VkQueryControlFlagBits) values
::

::validity-field{name="VUID-vkCmdBeginQuery-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdBeginQuery-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics, compute, decode, or encode operations
::

::validity-field{name="VUID-vkCmdBeginQuery-commonparent"}
 Both of `commandBuffer`, and `queryPool` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::






Bits which :normative{type="can"} be set in [vkCmdBeginQuery](/man/vkCmdBeginQuery)::`flags`, specifying
constraints on the types of queries that :normative{type="can"} be performed, are:

[{generated}/api/enums/VkQueryControlFlagBits.adoc]({generated}/api/enums/VkQueryControlFlagBits.adoc)

- `VK_QUERY_CONTROL_PRECISE_BIT` specifies the precision of
  occlusion queries.

[{generated}/api/flags/VkQueryControlFlags.adoc]({generated}/api/flags/VkQueryControlFlags.adoc)

`VkQueryControlFlags` is a bitmask type for setting a mask of zero or
more [VkQueryControlFlagBits](/man/VkQueryControlFlagBits).

To end a query after the set of desired drawing or dispatching commands is
executed, call:

[{generated}/api/protos/vkCmdEndQuery.adoc]({generated}/api/protos/vkCmdEndQuery.adoc)

- `commandBuffer` is the command buffer into which this command will
  be recorded.

- `queryPool` is the query pool that is managing the results of the
  query.

- `query` is the query index within the query pool where the result is
  stored.

The command completes the query in `queryPool` identified by
`query`, and marks it as available.

This command defines an execution dependency between other query commands
that reference the same query.

The first synchronization scope
includes all commands which reference the queries in `queryPool`
indicated by `query` that occur earlier in
submission order.

The second synchronization scope
includes only the operation of this command.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdEndQuery-None-01923"}

All queries used by the command :normative{type="must"} be
active
::

::validity-field{name="VUID-vkCmdEndQuery-query-00810"}
`query` :normative{type="must"} be less than the number of queries in `queryPool`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdEndQuery-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdEndQuery-queryPool-parameter"}
 `queryPool` :normative{type="must"} be a valid [VkQueryPool](/man/VkQueryPool) handle
::

::validity-field{name="VUID-vkCmdEndQuery-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdEndQuery-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics, compute, decode, or encode operations
::

::validity-field{name="VUID-vkCmdEndQuery-commonparent"}
 Both of `commandBuffer`, and `queryPool` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::






An application :normative{type="can"} retrieve results either by requesting they be written
into application-provided memory, or by requesting they be copied into a
`VkBuffer`.
In either case, the layout in memory is defined as follows:

- The first query’s result is written starting at the first byte requested
  by the command, and each subsequent query’s result begins `stride`
  bytes later.

- Occlusion queries, pipeline statistics queries,
  and timestamp queries store results in a tightly packed array of
  unsigned integers, either 32- or 64-bits as requested by the command,
  storing the numerical results and, if requested, the availability
  status.

- If `VK_QUERY_RESULT_WITH_AVAILABILITY_BIT` is used, the final
  element of each query’s result is an integer indicating whether the
  query’s result is available, with any non-zero value indicating that it
  is available.

- Occlusion queries write one integer value - the number of samples
  passed.
  Pipeline statistics queries write one integer value for each bit that is
  enabled in the `pipelineStatistics` when the pool is created, and
  the statistics values are written in bit order starting from the least
  significant bit.
  Timestamp queries write one integer value.

- If more than one query is retrieved and `stride` is not at least as
  large as the size of the array of values corresponding to a single
  query, the values written to memory are undefined:.

To retrieve status and results for a set of queries, call:

[{generated}/api/protos/vkGetQueryPoolResults.adoc]({generated}/api/protos/vkGetQueryPoolResults.adoc)

- `device` is the logical device that owns the query pool.

- `queryPool` is the query pool managing the queries containing the
  desired results.

- `firstQuery` is the initial query index.

- `queryCount` is the number of queries to read.

- `dataSize` is the size in bytes of the buffer pointed to by
  `pData`.

- `pData` is a pointer to a user-allocated buffer where the results
  will be written

- `stride` is the stride in bytes between results for individual
  queries within `pData`.

- `flags` is a bitmask of [VkQueryResultFlagBits](/man/VkQueryResultFlagBits) specifying how
  and when results are returned.

Any results written for a query are written according to
a layout dependent on the query type.

If no bits are set in `flags`, and all requested queries are in the
available state, results are written as an array of 32-bit unsigned integer
values.
Behavior when not all queries are available is described
below.

If `VK_QUERY_RESULT_WITH_AVAILABILITY_BIT` is set, results for all
queries in `queryPool` identified by `firstQuery` and
`queryCount` are copied to `pData`, along with an extra availability
value written directly after the results of each query and interpreted as an
unsigned integer.
A value of zero indicates that the results are not yet available, otherwise
the query is complete and results are available.
The size of the availability
values is 64 bits if `VK_QUERY_RESULT_64_BIT` is set in `flags`.
Otherwise, it is 32 bits.


::note
If `VK_QUERY_RESULT_WITH_AVAILABILITY_BIT`
is set, the layout of data in the buffer is a *(result,availability)*
pair for each query returned, and `stride` is the stride between each
pair.
::


Results for any available query written by this command are final and
represent the final result of the query.
If `VK_QUERY_RESULT_PARTIAL_BIT` is set, then for any query that is
unavailable, an intermediate result between zero and the final result value
is written for that query.
Otherwise, any result written by this command is undefined:.

If `VK_QUERY_RESULT_64_BIT` is set, results and, if returned,
availability
values for all queries are written as an array of 64-bit values.
Otherwise, results and availability
values are written as an array of 32-bit values.
If an unsigned integer query’s value overflows the result type, the value
:normative{type="may"} either wrap or saturate.

If `VK_QUERY_RESULT_WAIT_BIT` is set, this command defines an execution
dependency with any earlier commands that writes one of the identified
queries.
The first synchronization scope
includes all instances of [vkCmdEndQuery](/man/vkCmdEndQuery),
and [vkCmdWriteTimestamp](/man/vkCmdWriteTimestamp) that reference any query in `queryPool`
indicated by `firstQuery` and `queryCount`.
The second synchronization scope
includes the host operations of this command.

If `VK_QUERY_RESULT_WAIT_BIT` is not set, `vkGetQueryPoolResults`
:normative{type="may"} return `VK_NOT_READY` if there are queries in the unavailable
state.


::note
Applications :normative{type="must"} take care to ensure that use of the
`VK_QUERY_RESULT_WAIT_BIT` bit has the desired effect.

For example, if a query has been used previously and a command buffer
records the commands `vkCmdResetQueryPool`, `vkCmdBeginQuery`, and
`vkCmdEndQuery` for that query, then the query will remain in the
available state until
the `vkCmdResetQueryPool` command executes on a queue.
Applications :normative{type="can"} use fences or events to ensure that a query has already
been reset before checking for its results or availability status.
Otherwise, a stale value could be returned from a previous use of the query.

The above also applies when `VK_QUERY_RESULT_WAIT_BIT` is used in
combination with `VK_QUERY_RESULT_WITH_AVAILABILITY_BIT`.
In this case, the returned availability status :normative{type="may"} reflect the result of a
previous use of the query unless
the `vkCmdResetQueryPool` command has been executed since the last use
of the query.
::



::note
Applications :normative{type="can"} double-buffer query pool usage, with a pool per frame, and
reset queries at the end of the frame in which they are read.
::



::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkGetQueryPoolResults-None-09401"}

All queries used by the command :normative{type="must"} not be uninitialized
::

::validity-field{name="VUID-vkGetQueryPoolResults-firstQuery-00813"}
`firstQuery` :normative{type="must"} be less than the number of queries in
`queryPool`
::

::validity-field{name="VUID-vkGetQueryPoolResults-flags-02828"}

If `VK_QUERY_RESULT_64_BIT` is not set in `flags`
then `pData` and `stride` :normative{type="must"} be multiples of `4`
::

::validity-field{name="VUID-vkGetQueryPoolResults-flags-00815"}

If `VK_QUERY_RESULT_64_BIT` is set in `flags` then `pData`
and `stride` :normative{type="must"} be multiples of `8`
::

::validity-field{name="VUID-vkGetQueryPoolResults-stride-08993"}

If `VK_QUERY_RESULT_WITH_AVAILABILITY_BIT` is set, `stride`
:normative{type="must"} be large enough to contain the unsigned integer representing
availability
in addition to the query result.
::

::validity-field{name="VUID-vkGetQueryPoolResults-firstQuery-00816"}

The sum of `firstQuery` and `queryCount` :normative{type="must"} be less than or
equal to the number of queries in `queryPool`
::

::validity-field{name="VUID-vkGetQueryPoolResults-dataSize-00817"}
`dataSize` :normative{type="must"} be large enough to contain the result of each
query, as described here
::

::validity-field{name="VUID-vkGetQueryPoolResults-queryType-00818"}

If the `queryType` used to create `queryPool` was
`VK_QUERY_TYPE_TIMESTAMP`, `flags` :normative{type="must"} not contain
`VK_QUERY_RESULT_PARTIAL_BIT`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkGetQueryPoolResults-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkGetQueryPoolResults-queryPool-parameter"}
 `queryPool` :normative{type="must"} be a valid [VkQueryPool](/man/VkQueryPool) handle
::

::validity-field{name="VUID-vkGetQueryPoolResults-pData-parameter"}
 `pData` :normative{type="must"} be a valid pointer to an array of `dataSize` bytes
::

::validity-field{name="VUID-vkGetQueryPoolResults-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkQueryResultFlagBits](/man/VkQueryResultFlagBits) values
::

::validity-field{name="VUID-vkGetQueryPoolResults-dataSize-arraylength"}
 `dataSize` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-vkGetQueryPoolResults-queryPool-parent"}
 `queryPool` :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::




Bits which :normative{type="can"} be set in [vkGetQueryPoolResults](/man/vkGetQueryPoolResults)::`flags` and
[vkCmdCopyQueryPoolResults](/man/vkCmdCopyQueryPoolResults)::`flags`, specifying how and when
results are returned, are:

[{generated}/api/enums/VkQueryResultFlagBits.adoc]({generated}/api/enums/VkQueryResultFlagBits.adoc)

- `VK_QUERY_RESULT_64_BIT` specifies the results will be written as an
  array of 64-bit unsigned integer values.
  If this bit is not set, the results will be written as an array of
  32-bit unsigned integer values.

- `VK_QUERY_RESULT_WAIT_BIT` specifies that Vulkan will wait for each
  query’s status to become available before retrieving its results.

- `VK_QUERY_RESULT_WITH_AVAILABILITY_BIT` specifies that the
  availability status accompanies the results.

- `VK_QUERY_RESULT_PARTIAL_BIT` specifies that returning partial
  results is acceptable.

[{generated}/api/flags/VkQueryResultFlags.adoc]({generated}/api/flags/VkQueryResultFlags.adoc)

`VkQueryResultFlags` is a bitmask type for setting a mask of zero or
more [VkQueryResultFlagBits](/man/VkQueryResultFlagBits).

To copy query statuses and numerical results directly to buffer memory,
call:

[{generated}/api/protos/vkCmdCopyQueryPoolResults.adoc]({generated}/api/protos/vkCmdCopyQueryPoolResults.adoc)

- `commandBuffer` is the command buffer into which this command will
  be recorded.

- `queryPool` is the query pool managing the queries containing the
  desired results.

- `firstQuery` is the initial query index.

- `queryCount` is the number of queries.
  `firstQuery` and `queryCount` together define a range of
  queries.

- `dstBuffer` is a [VkBuffer](/man/VkBuffer) object that will receive the results
  of the copy command.

- `dstOffset` is an offset into `dstBuffer`.

- `stride` is the stride in bytes between results for individual
  queries within `dstBuffer`.
  The required size of the backing memory for `dstBuffer` is
  determined as described above for [vkGetQueryPoolResults](/man/vkGetQueryPoolResults).

- `flags` is a bitmask of [VkQueryResultFlagBits](/man/VkQueryResultFlagBits) specifying how
  and when results are returned.

Any results written for a query are written according to
a layout dependent on the query type.

Results for any query in `queryPool` identified by `firstQuery` and
`queryCount` that is available are copied to `dstBuffer`.

If `VK_QUERY_RESULT_WITH_AVAILABILITY_BIT` is set, results for all
queries in `queryPool` identified by `firstQuery` and
`queryCount` are copied to `dstBuffer`, along with an extra
availability value written directly after the results of each query and
interpreted as an unsigned integer.
A value of zero indicates that the results are not yet available, otherwise
the query is complete and results are available.

Results for any available query written by this command are final and
represent the final result of the query.
If `VK_QUERY_RESULT_PARTIAL_BIT` is set, then for any query that is
unavailable, an intermediate result between zero and the final result value
is written for that query.
Otherwise, any result written by this command is undefined:.

If `VK_QUERY_RESULT_64_BIT` is set, results and availability
values for all queries are written as an array of 64-bit values.
Otherwise, results and availability
values are written as an array of 32-bit values.
If an unsigned integer query’s value overflows the result type, the value
:normative{type="may"} either wrap or saturate.

This command defines an execution dependency between other query commands
that reference the same query.

The first synchronization scope
includes all commands which reference the queries in `queryPool`
indicated by `query` that occur earlier in
submission order.
If `flags` does not include `VK_QUERY_RESULT_WAIT_BIT`,
[vkCmdEndQuery](/man/vkCmdEndQuery), and [vkCmdWriteTimestamp](/man/vkCmdWriteTimestamp) are excluded from this
scope.

The second synchronization scope
includes all commands which reference the queries in `queryPool`
indicated by `query` that occur later in
submission order.

The operation of this command happens after the first scope and happens
before the second scope.

`vkCmdCopyQueryPoolResults` is considered to be a transfer operation,
and its writes to buffer memory :normative{type="must"} be synchronized using
`VK_PIPELINE_STAGE_TRANSFER_BIT` and `VK_ACCESS_TRANSFER_WRITE_BIT`
before using the results.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdCopyQueryPoolResults-None-09402"}

All queries used by the command :normative{type="must"} not be uninitialized when the
command is executed
::

::validity-field{name="VUID-vkCmdCopyQueryPoolResults-dstOffset-00819"}
`dstOffset` :normative{type="must"} be less than the size of `dstBuffer`
::

::validity-field{name="VUID-vkCmdCopyQueryPoolResults-firstQuery-00820"}
`firstQuery` :normative{type="must"} be less than the number of queries in
`queryPool`
::

::validity-field{name="VUID-vkCmdCopyQueryPoolResults-firstQuery-00821"}

The sum of `firstQuery` and `queryCount` :normative{type="must"} be less than or
equal to the number of queries in `queryPool`
::

::validity-field{name="VUID-vkCmdCopyQueryPoolResults-flags-00822"}

If `VK_QUERY_RESULT_64_BIT` is not set in `flags` then
`dstOffset` and `stride` :normative{type="must"} be multiples of `4`
::

::validity-field{name="VUID-vkCmdCopyQueryPoolResults-flags-00823"}

If `VK_QUERY_RESULT_64_BIT` is set in `flags` then
`dstOffset` and `stride` :normative{type="must"} be multiples of `8`
::

::validity-field{name="VUID-vkCmdCopyQueryPoolResults-dstBuffer-00824"}
`dstBuffer` :normative{type="must"} have enough storage, from `dstOffset`, to
contain the result of each query, as described
here
::

::validity-field{name="VUID-vkCmdCopyQueryPoolResults-dstBuffer-00825"}
`dstBuffer` :normative{type="must"} have been created with
`VK_BUFFER_USAGE_TRANSFER_DST_BIT` usage flag
::

::validity-field{name="VUID-vkCmdCopyQueryPoolResults-dstBuffer-00826"}

If `dstBuffer` is non-sparse then it :normative{type="must"} be bound completely and
contiguously to a single `VkDeviceMemory` object
::

::validity-field{name="VUID-vkCmdCopyQueryPoolResults-queryType-00827"}

If the `queryType` used to create `queryPool` was
`VK_QUERY_TYPE_TIMESTAMP`, `flags` :normative{type="must"} not contain
`VK_QUERY_RESULT_PARTIAL_BIT`
::

::validity-field{name="VUID-vkCmdCopyQueryPoolResults-None-07429"}

All queries used by the command :normative{type="must"} not be active
::

::validity-field{name="VUID-vkCmdCopyQueryPoolResults-None-08752"}

All queries used by the command :normative{type="must"} have been made *available* by
prior executed commands
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdCopyQueryPoolResults-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdCopyQueryPoolResults-queryPool-parameter"}
 `queryPool` :normative{type="must"} be a valid [VkQueryPool](/man/VkQueryPool) handle
::

::validity-field{name="VUID-vkCmdCopyQueryPoolResults-dstBuffer-parameter"}
 `dstBuffer` :normative{type="must"} be a valid [VkBuffer](/man/VkBuffer) handle
::

::validity-field{name="VUID-vkCmdCopyQueryPoolResults-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkQueryResultFlagBits](/man/VkQueryResultFlagBits) values
::

::validity-field{name="VUID-vkCmdCopyQueryPoolResults-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdCopyQueryPoolResults-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics, or compute operations
::

::validity-field{name="VUID-vkCmdCopyQueryPoolResults-renderpass"}
 This command :normative{type="must"} only be called outside of a render pass instance
::

::validity-field{name="VUID-vkCmdCopyQueryPoolResults-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdCopyQueryPoolResults-commonparent"}
 Each of `commandBuffer`, `dstBuffer`, and `queryPool` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::






Rendering operations such as clears, MSAA resolves, attachment load/store
operations, and blits :normative{type="may"} count towards the results of queries.
This behavior is implementation-dependent and :normative{type="may"} vary depending on the
path used within an implementation.
For example, some implementations have several types of clears, some of
which :normative{type="may"} include vertices and some not.





## Occlusion Queries

Occlusion queries track the number of samples that pass the per-fragment
tests for a set of drawing commands.
As such, occlusion queries are only available on queue families supporting
graphics operations.
The application :normative{type="can"} then use these results to inform future rendering
decisions.
An occlusion query is begun and ended by calling `vkCmdBeginQuery` and
`vkCmdEndQuery`, respectively.
When an occlusion query begins, the count of passing samples always starts
at zero.
For each drawing command, the count is incremented as described in
Sample Counting.
If `flags` does not contain `VK_QUERY_CONTROL_PRECISE_BIT` an
implementation :normative{type="may"} generate any non-zero result value for the query if the
count of passing samples is non-zero.


::note
Not setting `VK_QUERY_CONTROL_PRECISE_BIT` mode :normative{type="may"} be more efficient
on some implementations, and :normative{type="should"} be used where it is sufficient to know
a boolean result on whether any samples passed the per-fragment tests.
In this case, some implementations :normative{type="may"} only return zero or one, indifferent
to the actual number of samples passing the per-fragment tests.

Setting `VK_QUERY_CONTROL_PRECISE_BIT` does not guarantee that different
implementations return the same number of samples in an occlusion query.
Some implementations may kill fragments in the
pre-rasterization shader
stage, and these killed fragments do not contribute to the final result of
the query.
It is possible that some implementations generate a zero result value for
the query, while others generate a non-zero value.
::


When an occlusion query finishes, the result for that query is marked as
available.
The application :normative{type="can"} then either copy the result to a buffer (via
`vkCmdCopyQueryPoolResults`) or request it be put into host memory (via
`vkGetQueryPoolResults`).


::note
If occluding geometry is not drawn first, samples :normative{type="can"} pass the depth test,
but still not be visible in a final image.
::






## Pipeline Statistics Queries

Pipeline statistics queries allow the application to sample a specified set
of `VkPipeline` counters.
These counters are accumulated by Vulkan for a set of either drawing or
dispatching commands while a pipeline statistics query is active.
As such, pipeline statistics queries are available on queue families
supporting either graphics or compute operations.
The availability of pipeline statistics queries is indicated by the
`pipelineStatisticsQuery` member of the `VkPhysicalDeviceFeatures`
object (see `vkGetPhysicalDeviceFeatures` and `vkCreateDevice` for
detecting and requesting this query type on a `VkDevice`).

A pipeline statistics query is begun and ended by calling
`vkCmdBeginQuery` and `vkCmdEndQuery`, respectively.
When a pipeline statistics query begins, all statistics counters are set to
zero.
While the query is active, the pipeline type determines which set of
statistics are available, but these :normative{type="must"} be configured on the query pool
when it is created.
If a statistic counter is issued on a command buffer that does not support
the corresponding operation, the value of that counter is undefined: after
the query has been made available.
At least one statistic counter relevant to the operations supported on the
recording command buffer :normative{type="must"} be enabled.

Bits which :normative{type="can"} be set in
[VkQueryPoolCreateInfo](/man/VkQueryPoolCreateInfo)::`pipelineStatistics` for query pools and in
[VkCommandBufferInheritanceInfo](/man/VkCommandBufferInheritanceInfo)::`pipelineStatistics` for secondary
command buffers, individually enabling pipeline statistics counters, are:

[{generated}/api/enums/VkQueryPipelineStatisticFlagBits.adoc]({generated}/api/enums/VkQueryPipelineStatisticFlagBits.adoc)

- `VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT` specifies
  that queries managed by the pool will count the number of vertices
  processed by the input assembly stage.
  Vertices corresponding to incomplete primitives :normative{type="may"} contribute to the
  count.

- `VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT`
  specifies that queries managed by the pool will count the number of
  primitives processed by the input assembly stage.
  If primitive restart is enabled, restarting the primitive topology has
  no effect on the count.
  Incomplete primitives :normative{type="may"} be counted.

- `VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT`
  specifies that queries managed by the pool will count the number of
  vertex shader invocations.
  This counter’s value is incremented each time a vertex shader is
  invoked.

- `VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT`
  specifies that queries managed by the pool will count the number of
  geometry shader invocations.
  This counter’s value is incremented each time a geometry shader is
  invoked.
  In the case of instanced geometry shaders, the
  geometry shader invocations count is incremented for each separate
  instanced invocation.

- `VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT`
  specifies that queries managed by the pool will count the number of
  primitives generated by geometry shader invocations.
  The counter’s value is incremented each time the geometry shader emits a
  primitive.
  Restarting primitive topology using the SPIR-V instructions
  `OpEndPrimitive` or `OpEndStreamPrimitive` has no effect on the
  geometry shader output primitives count.

- `VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT` specifies
  that queries managed by the pool will count the number of primitives
  processed by the Primitive Clipping stage of
  the pipeline.
  The counter’s value is incremented each time a primitive reaches the
  primitive clipping stage.

- `VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT` specifies that
  queries managed by the pool will count the number of primitives output
  by the Primitive Clipping stage of the
  pipeline.
  The counter’s value is incremented each time a primitive passes the
  primitive clipping stage.
  The actual number of primitives output by the primitive clipping stage
  for a particular input primitive is implementation-dependent but :normative{type="must"}
  satisfy the following conditions:





  * If at least one vertex of the input primitive lies inside the clipping
    volume, the counter is incremented by one or more.

  * Otherwise, the counter is incremented by zero or more.

- `VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT`
  specifies that queries managed by the pool will count the number of
  fragment shader invocations.
  The counter’s value is incremented each time the fragment shader is
  invoked.

- `VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT`
  specifies that queries managed by the pool will count the number of
  patches processed by the tessellation control shader.
  The counter’s value is incremented once for each patch for which a
  tessellation control shader is
  invoked.

- `VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT`
  specifies that queries managed by the pool will count the number of
  invocations of the tessellation evaluation shader.
  The counter’s value is incremented each time the tessellation evaluation
  shader is invoked.

- `VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT`
  specifies that queries managed by the pool will count the number of
  compute shader invocations.
  The counter’s value is incremented every time the compute shader is
  invoked.
  Implementations :normative{type="may"} skip the execution of certain compute shader
  invocations or execute additional compute shader invocations for
  implementation-dependent reasons as long as the results of rendering
  otherwise remain unchanged.

These values are intended to measure relative statistics on one
implementation.
Various device architectures will count these values differently.
Any or all counters :normative{type="may"} be affected by the issues described in
Query Operation.


::note
For example, tile-based rendering devices :normative{type="may"} need to replay the scene
multiple times, affecting some of the counts.
::


If a pipeline has `rasterizerDiscardEnable` enabled, implementations
:normative{type="may"} discard primitives after the final
pre-rasterization shader
stage.
As a result, if `rasterizerDiscardEnable` is enabled, the clipping input
and output primitives counters :normative{type="may"} not be incremented.

When a pipeline statistics query finishes, the result for that query is
marked as available.
The application :normative{type="can"} copy the result to a buffer (via
`vkCmdCopyQueryPoolResults`), or request it be put into host memory (via
`vkGetQueryPoolResults`).

[{generated}/api/flags/VkQueryPipelineStatisticFlags.adoc]({generated}/api/flags/VkQueryPipelineStatisticFlags.adoc)

`VkQueryPipelineStatisticFlags` is a bitmask type for setting a mask of
zero or more [VkQueryPipelineStatisticFlagBits](/man/VkQueryPipelineStatisticFlagBits).





## Timestamp Queries

*Timestamps* provide applications with a mechanism for timing the execution
of commands.
A timestamp is an integer value generated by the `VkPhysicalDevice`.
Unlike other queries, timestamps do not operate over a range, and so do not
use [vkCmdBeginQuery](/man/vkCmdBeginQuery) or [vkCmdEndQuery](/man/vkCmdEndQuery).
The mechanism is built around a set of commands that allow the application
to tell the `VkPhysicalDevice` to write timestamp values to a
query pool and then either read timestamp values on the
host (using [vkGetQueryPoolResults](/man/vkGetQueryPoolResults)) or copy timestamp values to a
`VkBuffer` (using [vkCmdCopyQueryPoolResults](/man/vkCmdCopyQueryPoolResults)).
The application :normative{type="can"} then compute differences between timestamps to
determine execution time.

The number of valid bits in a timestamp value is determined by the
`VkQueueFamilyProperties`::`timestampValidBits` property of the
queue on which the timestamp is written.
Timestamps are supported on any queue which reports a non-zero value for
`timestampValidBits` via [vkGetPhysicalDeviceQueueFamilyProperties](/man/vkGetPhysicalDeviceQueueFamilyProperties).
If the `timestampComputeAndGraphics` limit is `VK_TRUE`, timestamps are
supported by every queue family that supports either graphics or compute
operations (see [VkQueueFamilyProperties](/man/VkQueueFamilyProperties)).

The number of nanoseconds it takes for a timestamp value to be incremented
by 1 :normative{type="can"} be obtained from
`VkPhysicalDeviceLimits`::`timestampPeriod` after a call to
`vkGetPhysicalDeviceProperties`.

To request a timestamp and write the value to memory, call:

[{generated}/api/protos/vkCmdWriteTimestamp.adoc]({generated}/api/protos/vkCmdWriteTimestamp.adoc)

- `commandBuffer` is the command buffer into which the command will be
  recorded.

- `pipelineStage` is a [VkPipelineStageFlagBits](/man/VkPipelineStageFlagBits) value, specifying
  a stage of the pipeline.

- `queryPool` is the query pool that will manage the timestamp.

- `query` is the query within the query pool that will contain the
  timestamp.

When `vkCmdWriteTimestamp` is submitted to a queue, it defines an
execution dependency on commands that were submitted before it, and writes a
timestamp to a query pool.

The first synchronization scope
includes all commands that occur earlier in
submission order.
The synchronization scope is limited to operations on the pipeline stage
specified by `pipelineStage`.

The second synchronization scope
includes only the timestamp write operation.


::note
Implementations may write the timestamp at any stage that is
logically later than `stage`.
::


Any timestamp write that happens-after another timestamp write in the same submission :normative{type="must"} not
have a lower value unless its value overflows the maximum supported integer
bit width of the query.
If an overflow occurs, the timestamp value :normative{type="must"} wrap back to zero.


::note
Comparisons between timestamps should be done between timestamps where they
are guaranteed to not decrease.
For example, subtracting an older timestamp from a newer one to determine
the execution time of a sequence of commands is only a reliable measurement
if the two timestamp writes were performed in the same
submission.
::



::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdWriteTimestamp-pipelineStage-04074"}
`pipelineStage` :normative{type="must"} be a
valid stage for the queue
family that was used to create the command pool that `commandBuffer`
was allocated from
::

::validity-field{name="VUID-vkCmdWriteTimestamp-pipelineStage-04075"}

If the `geometryShader` feature is not
enabled, `pipelineStage` :normative{type="must"} not be
`VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT`
::

::validity-field{name="VUID-vkCmdWriteTimestamp-pipelineStage-04076"}

If the `tessellationShader` feature
is not enabled, `pipelineStage` :normative{type="must"} not be
`VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT` or
`VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT`
::

::validity-field{name="VUID-vkCmdWriteTimestamp-pipelineStage-06490"}
`pipelineStage` :normative{type="must"} not be `VK_PIPELINE_STAGE_NONE`
::

::validity-field{name="VUID-vkCmdWriteTimestamp-queryPool-01416"}
`queryPool` :normative{type="must"} have been created with a `queryType` of
`VK_QUERY_TYPE_TIMESTAMP`
::

::validity-field{name="VUID-vkCmdWriteTimestamp-timestampValidBits-00829"}

The command pool’s queue family :normative{type="must"} support a non-zero
`timestampValidBits`
::

::validity-field{name="VUID-vkCmdWriteTimestamp-query-04904"}
`query` :normative{type="must"} be less than the number of queries in `queryPool`
::

::validity-field{name="VUID-vkCmdWriteTimestamp-None-00830"}

All queries used by the command :normative{type="must"} be *unavailable*
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdWriteTimestamp-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdWriteTimestamp-pipelineStage-parameter"}
 `pipelineStage` :normative{type="must"} be a valid [VkPipelineStageFlagBits](/man/VkPipelineStageFlagBits) value
::

::validity-field{name="VUID-vkCmdWriteTimestamp-queryPool-parameter"}
 `queryPool` :normative{type="must"} be a valid [VkQueryPool](/man/VkQueryPool) handle
::

::validity-field{name="VUID-vkCmdWriteTimestamp-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdWriteTimestamp-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support transfer, graphics, compute, decode, encode, or optical flow operations
::

::validity-field{name="VUID-vkCmdWriteTimestamp-commonparent"}
 Both of `commandBuffer`, and `queryPool` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::












# Clear Commands



## Clearing Images Outside a Render Pass Instance

Color and depth/stencil images :normative{type="can"} be cleared outside a render pass
instance using [vkCmdClearColorImage](/man/vkCmdClearColorImage) or
[vkCmdClearDepthStencilImage](/man/vkCmdClearDepthStencilImage), respectively.
These commands are only allowed outside of a render pass instance.

To clear one or more subranges of a color image, call:

[{generated}/api/protos/vkCmdClearColorImage.adoc]({generated}/api/protos/vkCmdClearColorImage.adoc)

- `commandBuffer` is the command buffer into which the command will be
  recorded.

- `image` is the image to be cleared.

- `imageLayout` specifies the current layout of the image subresource
  ranges to be cleared, and :normative{type="must"} be
  `VK_IMAGE_LAYOUT_GENERAL` or
  `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`.

- `pColor` is a pointer to a [VkClearColorValue](/man/VkClearColorValue) structure
  containing the values that the image subresource ranges will be cleared
  to (see  below).

- `rangeCount` is the number of image subresource range structures in
  `pRanges`.

- `pRanges` is a pointer to an array of [VkImageSubresourceRange](/man/VkImageSubresourceRange)
  structures describing a range of mipmap levels, array layers, and
  aspects to be cleared, as described in Image
  Views.

Each specified range in `pRanges` is cleared to the value specified by
`pColor`.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdClearColorImage-image-00002"}
`image` :normative{type="must"} have been created with
`VK_IMAGE_USAGE_TRANSFER_DST_BIT` usage flag
::

::validity-field{name="VUID-vkCmdClearColorImage-image-00003"}

If `image` is non-sparse then it :normative{type="must"} be bound completely and
contiguously to a single `VkDeviceMemory` object
::

::validity-field{name="VUID-vkCmdClearColorImage-imageLayout-00004"}
`imageLayout` :normative{type="must"} specify the layout of the image subresource
ranges of `image` specified in `pRanges` at the time this
command is executed on a `VkDevice`
::

::validity-field{name="VUID-vkCmdClearColorImage-imageLayout-01394"}
`imageLayout` :normative{type="must"} be
`VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` or
`VK_IMAGE_LAYOUT_GENERAL`
::

::validity-field{name="VUID-vkCmdClearColorImage-aspectMask-02498"}

The [VkImageSubresourceRange](/man/VkImageSubresourceRange)::`aspectMask` members of the
elements of the `pRanges` array :normative{type="must"} each only include
`VK_IMAGE_ASPECT_COLOR_BIT`
::

::validity-field{name="VUID-vkCmdClearColorImage-baseMipLevel-01470"}

The [VkImageSubresourceRange](/man/VkImageSubresourceRange)::`baseMipLevel` members of the
elements of the `pRanges` array :normative{type="must"} each be less than the
`mipLevels` specified in [VkImageCreateInfo](/man/VkImageCreateInfo) when `image`
was created
::

::validity-field{name="VUID-vkCmdClearColorImage-pRanges-01692"}

For each [VkImageSubresourceRange](/man/VkImageSubresourceRange) element of `pRanges`, if the
`levelCount` member is not `VK_REMAINING_MIP_LEVELS`, then
`baseMipLevel` +  `levelCount` :normative{type="must"} be less than or
equal to the `mipLevels` specified in [VkImageCreateInfo](/man/VkImageCreateInfo) when
`image` was created
::

::validity-field{name="VUID-vkCmdClearColorImage-baseArrayLayer-01472"}

The [VkImageSubresourceRange](/man/VkImageSubresourceRange)::`baseArrayLayer` members of the
elements of the `pRanges` array :normative{type="must"} each be less than the
`arrayLayers` specified in [VkImageCreateInfo](/man/VkImageCreateInfo) when `image`
was created
::

::validity-field{name="VUID-vkCmdClearColorImage-pRanges-01693"}

For each [VkImageSubresourceRange](/man/VkImageSubresourceRange) element of `pRanges`, if the
`layerCount` member is not `VK_REMAINING_ARRAY_LAYERS`, then
`baseArrayLayer` +  `layerCount` :normative{type="must"} be less than or
equal to the `arrayLayers` specified in [VkImageCreateInfo](/man/VkImageCreateInfo) when
`image` was created
::

::validity-field{name="VUID-vkCmdClearColorImage-image-00007"}
`image` :normative{type="must"} not have a compressed or depth/stencil format
::

::validity-field{name="VUID-vkCmdClearColorImage-pColor-04961"}
`pColor` :normative{type="must"} be a valid pointer to a [VkClearColorValue](/man/VkClearColorValue) union
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdClearColorImage-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdClearColorImage-image-parameter"}
 `image` :normative{type="must"} be a valid [VkImage](/man/VkImage) handle
::

::validity-field{name="VUID-vkCmdClearColorImage-imageLayout-parameter"}
 `imageLayout` :normative{type="must"} be a valid [VkImageLayout](/man/VkImageLayout) value
::

::validity-field{name="VUID-vkCmdClearColorImage-pRanges-parameter"}
 `pRanges` :normative{type="must"} be a valid pointer to an array of `rangeCount` valid [VkImageSubresourceRange](/man/VkImageSubresourceRange) structures
::

::validity-field{name="VUID-vkCmdClearColorImage-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdClearColorImage-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics, or compute operations
::

::validity-field{name="VUID-vkCmdClearColorImage-renderpass"}
 This command :normative{type="must"} only be called outside of a render pass instance
::

::validity-field{name="VUID-vkCmdClearColorImage-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdClearColorImage-rangeCount-arraylength"}
 `rangeCount` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-vkCmdClearColorImage-commonparent"}
 Both of `commandBuffer`, and `image` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::






To clear one or more subranges of a depth/stencil image, call:

[{generated}/api/protos/vkCmdClearDepthStencilImage.adoc]({generated}/api/protos/vkCmdClearDepthStencilImage.adoc)

- `commandBuffer` is the command buffer into which the command will be
  recorded.

- `image` is the image to be cleared.

- `imageLayout` specifies the current layout of the image subresource
  ranges to be cleared, and :normative{type="must"} be `VK_IMAGE_LAYOUT_GENERAL` or
  `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`.

- `pDepthStencil` is a pointer to a [VkClearDepthStencilValue](/man/VkClearDepthStencilValue)
  structure containing the values that the depth and stencil image
  subresource ranges will be cleared to (see  below).

- `rangeCount` is the number of image subresource range structures in
  `pRanges`.

- `pRanges` is a pointer to an array of [VkImageSubresourceRange](/man/VkImageSubresourceRange)
  structures describing a range of mipmap levels, array layers, and
  aspects to be cleared, as described in Image
  Views.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdClearDepthStencilImage-pRanges-02659"}

If the `aspect` member of any element of `pRanges` includes
`VK_IMAGE_ASPECT_STENCIL_BIT`,
`VK_IMAGE_USAGE_TRANSFER_DST_BIT` :normative{type="must"} have been included in the
[VkImageCreateInfo](/man/VkImageCreateInfo)::`usage` used to create `image`
::

::validity-field{name="VUID-vkCmdClearDepthStencilImage-pRanges-02660"}

If the `aspect` member of any element of `pRanges` includes
`VK_IMAGE_ASPECT_DEPTH_BIT`, `VK_IMAGE_USAGE_TRANSFER_DST_BIT`
:normative{type="must"} have been included in the [VkImageCreateInfo](/man/VkImageCreateInfo)::`usage`
used to create `image`
::

::validity-field{name="VUID-vkCmdClearDepthStencilImage-image-00010"}

If `image` is non-sparse then it :normative{type="must"} be bound completely and
contiguously to a single `VkDeviceMemory` object
::

::validity-field{name="VUID-vkCmdClearDepthStencilImage-imageLayout-00011"}
`imageLayout` :normative{type="must"} specify the layout of the image subresource
ranges of `image` specified in `pRanges` at the time this
command is executed on a `VkDevice`
::

::validity-field{name="VUID-vkCmdClearDepthStencilImage-imageLayout-00012"}
`imageLayout` :normative{type="must"} be either of
`VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` or
`VK_IMAGE_LAYOUT_GENERAL`
::

::validity-field{name="VUID-vkCmdClearDepthStencilImage-aspectMask-02824"}

The [VkImageSubresourceRange](/man/VkImageSubresourceRange)::`aspectMask` member of each
element of the `pRanges` array :normative{type="must"} not include bits other than
`VK_IMAGE_ASPECT_DEPTH_BIT` or `VK_IMAGE_ASPECT_STENCIL_BIT`
::

::validity-field{name="VUID-vkCmdClearDepthStencilImage-image-02825"}

If the `image`’s format does not have a stencil component, then the
[VkImageSubresourceRange](/man/VkImageSubresourceRange)::`aspectMask` member of each element
of the `pRanges` array :normative{type="must"} not include the
`VK_IMAGE_ASPECT_STENCIL_BIT` bit
::

::validity-field{name="VUID-vkCmdClearDepthStencilImage-image-02826"}

If the `image`’s format does not have a depth component, then the
[VkImageSubresourceRange](/man/VkImageSubresourceRange)::`aspectMask` member of each element
of the `pRanges` array :normative{type="must"} not include the
`VK_IMAGE_ASPECT_DEPTH_BIT` bit
::

::validity-field{name="VUID-vkCmdClearDepthStencilImage-baseMipLevel-01474"}

The [VkImageSubresourceRange](/man/VkImageSubresourceRange)::`baseMipLevel` members of the
elements of the `pRanges` array :normative{type="must"} each be less than the
`mipLevels` specified in [VkImageCreateInfo](/man/VkImageCreateInfo) when `image`
was created
::

::validity-field{name="VUID-vkCmdClearDepthStencilImage-pRanges-01694"}

For each [VkImageSubresourceRange](/man/VkImageSubresourceRange) element of `pRanges`, if the
`levelCount` member is not `VK_REMAINING_MIP_LEVELS`, then
`baseMipLevel` +  `levelCount` :normative{type="must"} be less than or
equal to the `mipLevels` specified in [VkImageCreateInfo](/man/VkImageCreateInfo) when
`image` was created
::

::validity-field{name="VUID-vkCmdClearDepthStencilImage-baseArrayLayer-01476"}

The [VkImageSubresourceRange](/man/VkImageSubresourceRange)::`baseArrayLayer` members of the
elements of the `pRanges` array :normative{type="must"} each be less than the
`arrayLayers` specified in [VkImageCreateInfo](/man/VkImageCreateInfo) when `image`
was created
::

::validity-field{name="VUID-vkCmdClearDepthStencilImage-pRanges-01695"}

For each [VkImageSubresourceRange](/man/VkImageSubresourceRange) element of `pRanges`, if the
`layerCount` member is not `VK_REMAINING_ARRAY_LAYERS`, then
`baseArrayLayer` +  `layerCount` :normative{type="must"} be less than or
equal to the `arrayLayers` specified in [VkImageCreateInfo](/man/VkImageCreateInfo) when
`image` was created
::

::validity-field{name="VUID-vkCmdClearDepthStencilImage-image-00014"}
`image` :normative{type="must"} have a depth/stencil format
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdClearDepthStencilImage-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdClearDepthStencilImage-image-parameter"}
 `image` :normative{type="must"} be a valid [VkImage](/man/VkImage) handle
::

::validity-field{name="VUID-vkCmdClearDepthStencilImage-imageLayout-parameter"}
 `imageLayout` :normative{type="must"} be a valid [VkImageLayout](/man/VkImageLayout) value
::

::validity-field{name="VUID-vkCmdClearDepthStencilImage-pDepthStencil-parameter"}
 `pDepthStencil` :normative{type="must"} be a valid pointer to a valid [VkClearDepthStencilValue](/man/VkClearDepthStencilValue) structure
::

::validity-field{name="VUID-vkCmdClearDepthStencilImage-pRanges-parameter"}
 `pRanges` :normative{type="must"} be a valid pointer to an array of `rangeCount` valid [VkImageSubresourceRange](/man/VkImageSubresourceRange) structures
::

::validity-field{name="VUID-vkCmdClearDepthStencilImage-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdClearDepthStencilImage-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics operations
::

::validity-field{name="VUID-vkCmdClearDepthStencilImage-renderpass"}
 This command :normative{type="must"} only be called outside of a render pass instance
::

::validity-field{name="VUID-vkCmdClearDepthStencilImage-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdClearDepthStencilImage-rangeCount-arraylength"}
 `rangeCount` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-vkCmdClearDepthStencilImage-commonparent"}
 Both of `commandBuffer`, and `image` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::






Clears outside render pass instances are treated as transfer operations for
the purposes of memory barriers.





## Clearing Images Inside a Render Pass Instance

To clear one or more regions of color and depth/stencil attachments inside a
render pass instance, call:

[{generated}/api/protos/vkCmdClearAttachments.adoc]({generated}/api/protos/vkCmdClearAttachments.adoc)

- `commandBuffer` is the command buffer into which the command will be
  recorded.

- `attachmentCount` is the number of entries in the `pAttachments`
  array.

- `pAttachments` is a pointer to an array of [VkClearAttachment](/man/VkClearAttachment)
  structures defining the attachments to clear and the clear values to
  use.

- `rectCount` is the number of entries in the `pRects` array.

- `pRects` is a pointer to an array of [VkClearRect](/man/VkClearRect) structures
  defining regions within each selected attachment to clear.

Unlike other clear commands, [vkCmdClearAttachments](/man/vkCmdClearAttachments) is not a
transfer command.
It performs its operations in rasterization order.
For color attachments, the operations are executed as color attachment
writes, by the `VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT` stage.
For depth/stencil attachments, the operations are executed as
depth writes and stencil writes by
the `VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT` and
`VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT` stages.

`vkCmdClearAttachments` is not affected by the bound pipeline state.


::note
It is generally preferable to clear attachments by using the
`VK_ATTACHMENT_LOAD_OP_CLEAR` load operation at the start of rendering,
as it is more efficient on some implementations.
::


If any attachment’s `aspectMask` to be cleared is not backed by an image
view, the clear has no effect on that aspect.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdClearAttachments-aspectMask-07884"}

If
the `aspectMask` member of any element of `pAttachments`
contains `VK_IMAGE_ASPECT_DEPTH_BIT`, the current subpass instance’s
depth-stencil attachment :normative{type="must"} be either `VK_ATTACHMENT_UNUSED` or
the attachment `format` :normative{type="must"} contain a depth component
::

::validity-field{name="VUID-vkCmdClearAttachments-aspectMask-07885"}

If
the `aspectMask` member of any element of `pAttachments`
contains `VK_IMAGE_ASPECT_STENCIL_BIT`, the current subpass
instance’s depth-stencil attachment :normative{type="must"} be either
`VK_ATTACHMENT_UNUSED` or the attachment `format` :normative{type="must"} contain
a stencil component
::

::validity-field{name="VUID-vkCmdClearAttachments-aspectMask-07271"}

If the `aspectMask` member of any element of `pAttachments`
contains `VK_IMAGE_ASPECT_COLOR_BIT`, the `colorAttachment`
:normative{type="must"} be a valid color attachment index in the current render pass
instance
::

::validity-field{name="VUID-vkCmdClearAttachments-rect-02682"}

The `rect` member of each element of `pRects` :normative{type="must"} have an
`extent.width` greater than `0`
::

::validity-field{name="VUID-vkCmdClearAttachments-rect-02683"}

The `rect` member of each element of `pRects` :normative{type="must"} have an
`extent.height` greater than `0`
::

::validity-field{name="VUID-vkCmdClearAttachments-pRects-00016"}

The rectangular region specified by each element of `pRects` :normative{type="must"}
be contained within the render area of the current render pass instance
::

::validity-field{name="VUID-vkCmdClearAttachments-pRects-06937"}

The layers specified by each element of `pRects` :normative{type="must"} be contained
within every attachment that `pAttachments` refers to, i.e. for each
element of `pRects`, [VkClearRect](/man/VkClearRect)::`baseArrayLayer` + 
[VkClearRect](/man/VkClearRect)::`layerCount` :normative{type="must"} be less than or equal to the
number of layers rendered to in the current render pass instance
::

::validity-field{name="VUID-vkCmdClearAttachments-layerCount-01934"}

The `layerCount` member of each element of `pRects` :normative{type="must"} not be
`0`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdClearAttachments-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdClearAttachments-pAttachments-parameter"}
 `pAttachments` :normative{type="must"} be a valid pointer to an array of `attachmentCount` valid [VkClearAttachment](/man/VkClearAttachment) structures
::

::validity-field{name="VUID-vkCmdClearAttachments-pRects-parameter"}
 `pRects` :normative{type="must"} be a valid pointer to an array of `rectCount` [VkClearRect](/man/VkClearRect) structures
::

::validity-field{name="VUID-vkCmdClearAttachments-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdClearAttachments-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics operations
::

::validity-field{name="VUID-vkCmdClearAttachments-renderpass"}
 This command :normative{type="must"} only be called inside of a render pass instance
::

::validity-field{name="VUID-vkCmdClearAttachments-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdClearAttachments-attachmentCount-arraylength"}
 `attachmentCount` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-vkCmdClearAttachments-rectCount-arraylength"}
 `rectCount` :normative{type="must"} be greater than `0`
::

::






The `VkClearRect` structure is defined as:

[{generated}/api/structs/VkClearRect.adoc]({generated}/api/structs/VkClearRect.adoc)

- `rect` is the two-dimensional region to be cleared.

- `baseArrayLayer` is the first layer to be cleared.

- `layerCount` is the number of layers to clear.

The layers \[`baseArrayLayer`, `baseArrayLayer` +&#x20;
`layerCount`) counting from the base layer of the attachment image view
are cleared.

The `VkClearAttachment` structure is defined as:

[{generated}/api/structs/VkClearAttachment.adoc]({generated}/api/structs/VkClearAttachment.adoc)

- `aspectMask` is a mask selecting the color, depth and/or stencil
  aspects of the attachment to be cleared.

- `colorAttachment` is only meaningful if
  `VK_IMAGE_ASPECT_COLOR_BIT` is set in `aspectMask`, in which
  case it is an index into the currently bound color attachments.

- `clearValue` is the color or depth/stencil value to clear the
  attachment to, as described in Clear Values below.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkClearAttachment-aspectMask-00019"}

If `aspectMask` includes `VK_IMAGE_ASPECT_COLOR_BIT`, it :normative{type="must"}
not include `VK_IMAGE_ASPECT_DEPTH_BIT` or
`VK_IMAGE_ASPECT_STENCIL_BIT`
::

::validity-field{name="VUID-VkClearAttachment-aspectMask-00020"}
`aspectMask` :normative{type="must"} not include `VK_IMAGE_ASPECT_METADATA_BIT`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkClearAttachment-aspectMask-parameter"}
 `aspectMask` :normative{type="must"} be a valid combination of [VkImageAspectFlagBits](/man/VkImageAspectFlagBits) values
::

::validity-field{name="VUID-VkClearAttachment-aspectMask-requiredbitmask"}
 `aspectMask` :normative{type="must"} not be `0`
::

::






## Clear Values

The `VkClearColorValue` structure is defined as:

[{generated}/api/structs/VkClearColorValue.adoc]({generated}/api/structs/VkClearColorValue.adoc)

- `float32` are the color clear values when the format of the image or
  attachment is one of the numeric formats with
  a numeric type that is floating-point.
  Floating point values are automatically converted to the format of the
  image, with the clear value being treated as linear if the image is
  sRGB.

- `int32` are the color clear values when the format of the image or
  attachment has a numeric type that is signed integer (`SINT`).
  Signed integer values are converted to the format of the image by
  casting to the smaller type (with negative 32-bit values mapping to
  negative values in the smaller type).
  If the integer clear value is not representable in the target type (e.g.
  would overflow in conversion to that type), the clear value is
  undefined:.

- `uint32` are the color clear values when the format of the image or
  attachment has a numeric type that is unsigned integer (`UINT`).
  Unsigned integer values are converted to the format of the image by
  casting to the integer type with fewer bits.

The four array elements of the clear color map to R, G, B, and A components
of image formats, in order.

If the image has more than one sample, the same value is written to all
samples for any pixels being cleared.

The `VkClearDepthStencilValue` structure is defined as:

[{generated}/api/structs/VkClearDepthStencilValue.adoc]({generated}/api/structs/VkClearDepthStencilValue.adoc)

- `depth` is the clear value for the depth aspect of the depth/stencil
  attachment.
  It is a floating-point value which is automatically converted to the
  attachment’s format.

- `stencil` is the clear value for the stencil aspect of the
  depth/stencil attachment.
  It is a 32-bit integer value which is converted to the attachment’s
  format by taking the appropriate number of LSBs.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkClearDepthStencilValue-depth-00022"}
`depth` :normative{type="must"} be between `0.0` and `1.0`, inclusive
::

::


The `VkClearValue` union is defined as:

[{generated}/api/structs/VkClearValue.adoc]({generated}/api/structs/VkClearValue.adoc)

- `color` specifies the color image clear values to use when clearing
  a color image or attachment.

- `depthStencil` specifies the depth and stencil clear values to use
  when clearing a depth/stencil image or attachment.

This union is used where part of the API requires either color or
depth/stencil clear values, depending on the attachment, and defines the
initial clear values in the [VkRenderPassBeginInfo](/man/VkRenderPassBeginInfo) structure.





## Filling Buffers

To clear buffer data, call:

[{generated}/api/protos/vkCmdFillBuffer.adoc]({generated}/api/protos/vkCmdFillBuffer.adoc)

- `commandBuffer` is the command buffer into which the command will be
  recorded.

- `dstBuffer` is the buffer to be filled.

- `dstOffset` is the byte offset into the buffer at which to start
  filling, and :normative{type="must"} be a multiple of 4.

- `size` is the number of bytes to fill, and :normative{type="must"} be either a
  multiple of 4, or `VK_WHOLE_SIZE` to fill the range from
  `offset` to the end of the buffer.
  If `VK_WHOLE_SIZE` is used and the remaining size of the buffer is
  not a multiple of 4, then the nearest smaller multiple is used.

- `data` is the 4-byte word written repeatedly to the buffer to fill
  `size` bytes of data.
  The data word is written to memory according to the host endianness.

`vkCmdFillBuffer` is treated as a > transfer operation for the
purposes of synchronization barriers.
The `VK_BUFFER_USAGE_TRANSFER_DST_BIT` :normative{type="must"} be specified in `usage`
of [VkBufferCreateInfo](/man/VkBufferCreateInfo) in order for the buffer to be compatible with
`vkCmdFillBuffer`.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdFillBuffer-dstOffset-00024"}
`dstOffset` :normative{type="must"} be less than the size of `dstBuffer`
::

::validity-field{name="VUID-vkCmdFillBuffer-dstOffset-00025"}
`dstOffset` :normative{type="must"} be a multiple of `4`
::

::validity-field{name="VUID-vkCmdFillBuffer-size-00026"}

If `size` is not equal to `VK_WHOLE_SIZE`, `size` :normative{type="must"} be
greater than `0`
::

::validity-field{name="VUID-vkCmdFillBuffer-size-00027"}

If `size` is not equal to `VK_WHOLE_SIZE`, `size` :normative{type="must"} be
less than or equal to the size of `dstBuffer` minus `dstOffset`
::

::validity-field{name="VUID-vkCmdFillBuffer-size-00028"}

If `size` is not equal to `VK_WHOLE_SIZE`, `size` :normative{type="must"} be a
multiple of `4`
::

::validity-field{name="VUID-vkCmdFillBuffer-dstBuffer-00029"}
`dstBuffer` :normative{type="must"} have been created with
`VK_BUFFER_USAGE_TRANSFER_DST_BIT` usage flag
::

::validity-field{name="VUID-vkCmdFillBuffer-apiVersion-07894"}

The
    [VkCommandPool](/man/VkCommandPool) that `commandBuffer` was allocated from :normative{type="must"}
    support graphics or compute operations
::

::validity-field{name="VUID-vkCmdFillBuffer-dstBuffer-00031"}

If `dstBuffer` is non-sparse then it :normative{type="must"} be bound completely and
contiguously to a single [VkDeviceMemory](/man/VkDeviceMemory) object
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdFillBuffer-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdFillBuffer-dstBuffer-parameter"}
 `dstBuffer` :normative{type="must"} be a valid [VkBuffer](/man/VkBuffer) handle
::

::validity-field{name="VUID-vkCmdFillBuffer-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdFillBuffer-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support transfer, graphics or compute operations
::

::validity-field{name="VUID-vkCmdFillBuffer-renderpass"}
 This command :normative{type="must"} only be called outside of a render pass instance
::

::validity-field{name="VUID-vkCmdFillBuffer-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdFillBuffer-commonparent"}
 Both of `commandBuffer`, and `dstBuffer` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::










## Updating Buffers

To update buffer data inline in a command buffer, call:

[{generated}/api/protos/vkCmdUpdateBuffer.adoc]({generated}/api/protos/vkCmdUpdateBuffer.adoc)

- `commandBuffer` is the command buffer into which the command will be
  recorded.

- `dstBuffer` is a handle to the buffer to be updated.

- `dstOffset` is the byte offset into the buffer to start updating,
  and :normative{type="must"} be a multiple of 4.

- `dataSize` is the number of bytes to update, and :normative{type="must"} be a multiple
  of 4.

- `pData` is a pointer to the source data for the buffer update, and
  :normative{type="must"} be at least `dataSize` bytes in size.

`dataSize` :normative{type="must"} be less than or equal to 65536 bytes.
For larger updates, applications :normative{type="can"} use buffer to buffer
copies.


::note
Buffer updates performed with `vkCmdUpdateBuffer` first copy the data
into command buffer memory when the command is recorded (which requires
additional storage and may incur an additional allocation), and then copy
the data from the command buffer into `dstBuffer` when the command is
executed on a device.

The additional cost of this functionality compared to buffer to buffer copies means it is only recommended for very small
amounts of data, and is why it is limited to only 65536 bytes.

Applications :normative{type="can"} work around this by issuing multiple
`vkCmdUpdateBuffer` commands to different ranges of the same buffer, but
it is strongly recommended that they :normative{type="should"} not.
::


The source data is copied from the user pointer to the command buffer when
the command is called.

`vkCmdUpdateBuffer` is only allowed outside of a render pass.
This command is treated as a > transfer operation for the purposes of
synchronization barriers.
The `VK_BUFFER_USAGE_TRANSFER_DST_BIT` :normative{type="must"} be specified in `usage`
of [VkBufferCreateInfo](/man/VkBufferCreateInfo) in order for the buffer to be compatible with
`vkCmdUpdateBuffer`.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdUpdateBuffer-dstOffset-00032"}
`dstOffset` :normative{type="must"} be less than the size of `dstBuffer`
::

::validity-field{name="VUID-vkCmdUpdateBuffer-dataSize-00033"}
`dataSize` :normative{type="must"} be less than or equal to the size of
`dstBuffer` minus `dstOffset`
::

::validity-field{name="VUID-vkCmdUpdateBuffer-dstBuffer-00034"}
`dstBuffer` :normative{type="must"} have been created with
`VK_BUFFER_USAGE_TRANSFER_DST_BIT` usage flag
::

::validity-field{name="VUID-vkCmdUpdateBuffer-dstBuffer-00035"}

If `dstBuffer` is non-sparse then it :normative{type="must"} be bound completely and
contiguously to a single `VkDeviceMemory` object
::

::validity-field{name="VUID-vkCmdUpdateBuffer-dstOffset-00036"}
`dstOffset` :normative{type="must"} be a multiple of `4`
::

::validity-field{name="VUID-vkCmdUpdateBuffer-dataSize-00037"}
`dataSize` :normative{type="must"} be less than or equal to `65536`
::

::validity-field{name="VUID-vkCmdUpdateBuffer-dataSize-00038"}
`dataSize` :normative{type="must"} be a multiple of `4`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdUpdateBuffer-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdUpdateBuffer-dstBuffer-parameter"}
 `dstBuffer` :normative{type="must"} be a valid [VkBuffer](/man/VkBuffer) handle
::

::validity-field{name="VUID-vkCmdUpdateBuffer-pData-parameter"}
 `pData` :normative{type="must"} be a valid pointer to an array of `dataSize` bytes
::

::validity-field{name="VUID-vkCmdUpdateBuffer-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdUpdateBuffer-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support transfer, graphics, or compute operations
::

::validity-field{name="VUID-vkCmdUpdateBuffer-renderpass"}
 This command :normative{type="must"} only be called outside of a render pass instance
::

::validity-field{name="VUID-vkCmdUpdateBuffer-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdUpdateBuffer-dataSize-arraylength"}
 `dataSize` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-vkCmdUpdateBuffer-commonparent"}
 Both of `commandBuffer`, and `dstBuffer` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::







::note
The `pData` parameter was of type `uint32_t*` instead of `void*`
prior to version 1.0.19 of the Specification and [VK\_HEADER\_VERSION](/man/VK_HEADER_VERSION) 19
of the Vulkan Header Files.
This was a historical anomaly, as the source data may be of other types.
::








# Copy Commands

An application :normative{type="can"} copy buffer and image data using several methods
described in this chapter, depending on the type of data transfer.

All copy commands are treated as > transfer operations for the purposes of
synchronization barriers.

All copy commands that have a source format with an X component in its
format description read undefined: values from those bits.

All copy commands that have a destination format with an X component in its
format description write undefined: values to those bits.



## Copying Data Between Buffers

To copy data between buffer objects, call:

[{generated}/api/protos/vkCmdCopyBuffer.adoc]({generated}/api/protos/vkCmdCopyBuffer.adoc)

- `commandBuffer` is the command buffer into which the command will be
  recorded.

- `srcBuffer` is the source buffer.

- `dstBuffer` is the destination buffer.

- `regionCount` is the number of regions to copy.

- `pRegions` is a pointer to an array of [VkBufferCopy](/man/VkBufferCopy) structures
  specifying the regions to copy.

Each source region specified by `pRegions` is copied from the source
buffer to the destination region of the destination buffer.
If any of the specified regions in `srcBuffer` overlaps in memory with
any of the specified regions in `dstBuffer`, values read from those
overlapping regions are undefined:.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdCopyBuffer-srcOffset-00113"}

The `srcOffset` member of each element of `pRegions` :normative{type="must"} be
less than the size of `srcBuffer`
::

::validity-field{name="VUID-vkCmdCopyBuffer-dstOffset-00114"}

The `dstOffset` member of each element of `pRegions` :normative{type="must"} be
less than the size of `dstBuffer`
::

::validity-field{name="VUID-vkCmdCopyBuffer-size-00115"}

The `size` member of each element of `pRegions` :normative{type="must"} be less
than or equal to the size of `srcBuffer` minus `srcOffset`
::

::validity-field{name="VUID-vkCmdCopyBuffer-size-00116"}

The `size` member of each element of `pRegions` :normative{type="must"} be less
than or equal to the size of `dstBuffer` minus `dstOffset`
::

::validity-field{name="VUID-vkCmdCopyBuffer-pRegions-00117"}

The union of the source regions, and the union of the destination
regions, specified by the elements of `pRegions`, :normative{type="must"} not overlap
in memory
::

::validity-field{name="VUID-vkCmdCopyBuffer-srcBuffer-00118"}
`srcBuffer` :normative{type="must"} have been created with
`VK_BUFFER_USAGE_TRANSFER_SRC_BIT` usage flag
::

::validity-field{name="VUID-vkCmdCopyBuffer-srcBuffer-00119"}

If `srcBuffer` is non-sparse then it :normative{type="must"} be bound completely and
contiguously to a single `VkDeviceMemory` object
::

::validity-field{name="VUID-vkCmdCopyBuffer-dstBuffer-00120"}
`dstBuffer` :normative{type="must"} have been created with
`VK_BUFFER_USAGE_TRANSFER_DST_BIT` usage flag
::

::validity-field{name="VUID-vkCmdCopyBuffer-dstBuffer-00121"}

If `dstBuffer` is non-sparse then it :normative{type="must"} be bound completely and
contiguously to a single `VkDeviceMemory` object
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdCopyBuffer-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdCopyBuffer-srcBuffer-parameter"}
 `srcBuffer` :normative{type="must"} be a valid [VkBuffer](/man/VkBuffer) handle
::

::validity-field{name="VUID-vkCmdCopyBuffer-dstBuffer-parameter"}
 `dstBuffer` :normative{type="must"} be a valid [VkBuffer](/man/VkBuffer) handle
::

::validity-field{name="VUID-vkCmdCopyBuffer-pRegions-parameter"}
 `pRegions` :normative{type="must"} be a valid pointer to an array of `regionCount` valid [VkBufferCopy](/man/VkBufferCopy) structures
::

::validity-field{name="VUID-vkCmdCopyBuffer-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdCopyBuffer-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support transfer, graphics, or compute operations
::

::validity-field{name="VUID-vkCmdCopyBuffer-renderpass"}
 This command :normative{type="must"} only be called outside of a render pass instance
::

::validity-field{name="VUID-vkCmdCopyBuffer-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdCopyBuffer-regionCount-arraylength"}
 `regionCount` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-vkCmdCopyBuffer-commonparent"}
 Each of `commandBuffer`, `dstBuffer`, and `srcBuffer` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::






The `VkBufferCopy` structure is defined as:

[{generated}/api/structs/VkBufferCopy.adoc]({generated}/api/structs/VkBufferCopy.adoc)

- `srcOffset` is the starting offset in bytes from the start of
  `srcBuffer`.

- `dstOffset` is the starting offset in bytes from the start of
  `dstBuffer`.

- `size` is the number of bytes to copy.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkBufferCopy-size-01988"}

The `size` :normative{type="must"} be greater than `0`
::

::






## Copying Data Between Images

To copy data between image objects, call:

[{generated}/api/protos/vkCmdCopyImage.adoc]({generated}/api/protos/vkCmdCopyImage.adoc)

- `commandBuffer` is the command buffer into which the command will be
  recorded.

- `srcImage` is the source image.

- `srcImageLayout` is the current layout of the source image
  subresource.

- `dstImage` is the destination image.

- `dstImageLayout` is the current layout of the destination image
  subresource.

- `regionCount` is the number of regions to copy.

- `pRegions` is a pointer to an array of [VkImageCopy](/man/VkImageCopy) structures
  specifying the regions to copy.

Each source region specified by `pRegions` is copied from the source
image to the destination region of the destination image.
If any of the specified regions in `srcImage` overlaps in memory with
any of the specified regions in `dstImage`, values read from those
overlapping regions are undefined:.

If the format of the destination image has a different
block extent than the source image (e.g.
one is a compressed format), the offset and extent for each of the regions
specified is scaled according to the block
extents of each format to match in size.
Copy regions for each image :normative{type="must"} be aligned to a multiple of the texel
block extent in each dimension, except at the edges of the image, where
region extents :normative{type="must"} match the edge of the image.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdCopyImage-pRegions-00124"}

The union of all source regions, and the union of all destination
regions, specified by the elements of `pRegions`, :normative{type="must"} not overlap
in memory
::

::validity-field{name="VUID-vkCmdCopyImage-srcImageLayout-00128"}
`srcImageLayout` :normative{type="must"} specify the layout of the image subresources
of `srcImage` specified in `pRegions` at the time this command
is executed on a `VkDevice`
::

::validity-field{name="VUID-vkCmdCopyImage-srcImageLayout-01917"}
`srcImageLayout` :normative{type="must"} be
`VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL`, or
`VK_IMAGE_LAYOUT_GENERAL`
::

::validity-field{name="VUID-vkCmdCopyImage-dstImageLayout-00133"}
`dstImageLayout` :normative{type="must"} specify the layout of the image subresources
of `dstImage` specified in `pRegions` at the time this command
is executed on a `VkDevice`
::

::validity-field{name="VUID-vkCmdCopyImage-dstImageLayout-01395"}
`dstImageLayout` :normative{type="must"} be
`VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`, or
`VK_IMAGE_LAYOUT_GENERAL`
::

::validity-field{name="VUID-vkCmdCopyImage-srcImage-01548"}

The
    [VkFormat](/man/VkFormat) of each of `srcImage` and `dstImage` :normative{type="must"} be
    size-compatible
::

::validity-field{name="VUID-vkCmdCopyImage-srcImage-09247"}

If the [VkFormat](/man/VkFormat) of each of `srcImage` and `dstImage` is a
compressed image format, the formats :normative{type="must"}
have the same texel block extent
::

::validity-field{name="VUID-vkCmdCopyImage-srcImage-00136"}

The sample count of `srcImage` and `dstImage` :normative{type="must"} match
::

::validity-field{name="VUID-vkCmdCopyImage-srcOffset-01783"}

The `srcOffset` and `extent` members of each element of
`pRegions` :normative{type="must"} respect the image transfer granularity requirements
of `commandBuffer`’s command pool’s queue family, as described in
[VkQueueFamilyProperties](/man/VkQueueFamilyProperties)
::

::validity-field{name="VUID-vkCmdCopyImage-dstOffset-01784"}

The `dstOffset` and `extent` members of each element of
`pRegions` :normative{type="must"} respect the image transfer granularity requirements
of `commandBuffer`’s command pool’s queue family, as described in
[VkQueueFamilyProperties](/man/VkQueueFamilyProperties)
::

::validity-field{name="VUID-vkCmdCopyImage-apiVersion-07932"}

If
either `srcImage` or `dstImage` is of type
`VK_IMAGE_TYPE_3D`, then for each element of `pRegions`,
`srcSubresource.baseArrayLayer` and
`dstSubresource.baseArrayLayer` :normative{type="must"} both be `0`, and
`srcSubresource.layerCount` and `dstSubresource.layerCount`
:normative{type="must"} both be `1`
::

::validity-field{name="VUID-vkCmdCopyImage-srcImage-04443"}

If `srcImage` is of type `VK_IMAGE_TYPE_3D`, then for each
element of `pRegions`, `srcSubresource.baseArrayLayer` :normative{type="must"} be
`0` and `srcSubresource.layerCount` :normative{type="must"} be `1`
::

::validity-field{name="VUID-vkCmdCopyImage-dstImage-04444"}

If `dstImage` is of type `VK_IMAGE_TYPE_3D`, then for each
element of `pRegions`, `dstSubresource.baseArrayLayer` :normative{type="must"} be
`0` and `dstSubresource.layerCount` :normative{type="must"} be `1`
::

::validity-field{name="VUID-vkCmdCopyImage-aspectMask-00142"}

For each element of `pRegions`, `srcSubresource.aspectMask`
:normative{type="must"} specify aspects present in `srcImage`
::

::validity-field{name="VUID-vkCmdCopyImage-aspectMask-00143"}

For each element of `pRegions`, `dstSubresource.aspectMask`
:normative{type="must"} specify aspects present in `dstImage`
::

::validity-field{name="VUID-vkCmdCopyImage-srcOffset-00144"}

For each element of `pRegions`, `srcOffset.x` and
(`extent.width` +  `srcOffset.x`) :normative{type="must"} both be
greater than or equal to `0` and less than or equal to the width of the
specified `srcSubresource` of `srcImage`
::

::validity-field{name="VUID-vkCmdCopyImage-srcOffset-00145"}

For each element of `pRegions`, `srcOffset.y` and
(`extent.height` +  `srcOffset.y`) :normative{type="must"} both be
greater than or equal to `0` and less than or equal to the height of the
specified `srcSubresource` of `srcImage`
::

::validity-field{name="VUID-vkCmdCopyImage-srcImage-00146"}

If `srcImage` is of type `VK_IMAGE_TYPE_1D`, then for each
element of `pRegions`, `srcOffset.y` :normative{type="must"} be `0` and
`extent.height` :normative{type="must"} be `1`
::

::validity-field{name="VUID-vkCmdCopyImage-srcOffset-00147"}

If `srcImage` is of type `VK_IMAGE_TYPE_3D`, then for each
element of `pRegions`, `srcOffset.z` and
(`extent.depth` +  `srcOffset.z`) :normative{type="must"} both be
greater than or equal to `0` and less than or equal to the depth of the
specified `srcSubresource` of `srcImage`
::

::validity-field{name="VUID-vkCmdCopyImage-srcImage-01785"}

If `srcImage` is of type `VK_IMAGE_TYPE_1D`, then for each
element of `pRegions`, `srcOffset.z` :normative{type="must"} be `0` and
`extent.depth` :normative{type="must"} be `1`
::

::validity-field{name="VUID-vkCmdCopyImage-dstImage-01786"}

If `dstImage` is of type `VK_IMAGE_TYPE_1D`, then for each
element of `pRegions`, `dstOffset.z` :normative{type="must"} be `0` and
`extent.depth` :normative{type="must"} be `1`
::

::validity-field{name="VUID-vkCmdCopyImage-srcImage-01787"}

If `srcImage` is of type `VK_IMAGE_TYPE_2D`, then for each
element of `pRegions`, `srcOffset.z` :normative{type="must"} be `0`
::

::validity-field{name="VUID-vkCmdCopyImage-dstImage-01788"}

If `dstImage` is of type `VK_IMAGE_TYPE_2D`, then for each
element of `pRegions`, `dstOffset.z` :normative{type="must"} be `0`
::

::validity-field{name="VUID-vkCmdCopyImage-apiVersion-07933"}

If
`srcImage` and `dstImage` :normative{type="must"} have the same [VkImageType](/man/VkImageType)
::

::validity-field{name="VUID-vkCmdCopyImage-apiVersion-08969"}

If
`srcImage` or `dstImage` is of type `VK_IMAGE_TYPE_2D`, then
for each element of `pRegions`, `extent.depth` :normative{type="must"} be `1`
::

::validity-field{name="VUID-vkCmdCopyImage-dstOffset-00150"}

For each element of `pRegions`, `dstOffset.x` and
(`extent.width` +  `dstOffset.x`) :normative{type="must"} both be
greater than or equal to `0` and less than or equal to the width of the
specified `dstSubresource` of `dstImage`
::

::validity-field{name="VUID-vkCmdCopyImage-dstOffset-00151"}

For each element of `pRegions`, `dstOffset.y` and
(`extent.height` +  `dstOffset.y`) :normative{type="must"} both be
greater than or equal to `0` and less than or equal to the height of the
specified `dstSubresource` of `dstImage`
::

::validity-field{name="VUID-vkCmdCopyImage-dstImage-00152"}

If `dstImage` is of type `VK_IMAGE_TYPE_1D`, then for each
element of `pRegions`, `dstOffset.y` :normative{type="must"} be `0` and
`extent.height` :normative{type="must"} be `1`
::

::validity-field{name="VUID-vkCmdCopyImage-dstOffset-00153"}

If `dstImage` is of type `VK_IMAGE_TYPE_3D`, then for each
element of `pRegions`, `dstOffset.z` and
(`extent.depth` +  `dstOffset.z`) :normative{type="must"} both be
greater than or equal to `0` and less than or equal to the depth of the
specified `dstSubresource` of `dstImage`
::

::validity-field{name="VUID-vkCmdCopyImage-pRegions-07278"}

For each element of `pRegions`, `srcOffset.x` :normative{type="must"} be a
multiple of the texel block extent
width of the [VkFormat](/man/VkFormat) of `srcImage`
::

::validity-field{name="VUID-vkCmdCopyImage-pRegions-07279"}

For each element of `pRegions`, `srcOffset.y` :normative{type="must"} be a
multiple of the texel block extent
height of the [VkFormat](/man/VkFormat) of `srcImage`
::

::validity-field{name="VUID-vkCmdCopyImage-pRegions-07280"}

For each element of `pRegions`, `srcOffset.z` :normative{type="must"} be a
multiple of the texel block extent
depth of the [VkFormat](/man/VkFormat) of `srcImage`
::

::validity-field{name="VUID-vkCmdCopyImage-pRegions-07281"}

For each element of `pRegions`, `dstOffset.x` :normative{type="must"} be a
multiple of the texel block extent
width of the [VkFormat](/man/VkFormat) of `dstImage`
::

::validity-field{name="VUID-vkCmdCopyImage-pRegions-07282"}

For each element of `pRegions`, `dstOffset.y` :normative{type="must"} be a
multiple of the texel block extent
height of the [VkFormat](/man/VkFormat) of `dstImage`
::

::validity-field{name="VUID-vkCmdCopyImage-pRegions-07283"}

For each element of `pRegions`, `dstOffset.z` :normative{type="must"} be a
multiple of the texel block extent
depth of the [VkFormat](/man/VkFormat) of `dstImage`
::

::validity-field{name="VUID-vkCmdCopyImage-srcImage-01728"}

For each element of `pRegions`, if the sum of `srcOffset.x` and
`extent.width` does not equal the width of the subresource specified
by `srcSubresource`, `extent.width` :normative{type="must"} be a multiple of the
texel block extent width of the
[VkFormat](/man/VkFormat) of `srcImage`
::

::validity-field{name="VUID-vkCmdCopyImage-srcImage-01729"}

For each element of `pRegions`, if the sum of `srcOffset.y` and
`extent.height` does not equal the height of the subresource
specified by `srcSubresource`, `extent.height` :normative{type="must"} be a
multiple of the texel block extent
height of the [VkFormat](/man/VkFormat) of `srcImage`
::

::validity-field{name="VUID-vkCmdCopyImage-srcImage-01730"}

For each element of `pRegions`, if the sum of `srcOffset.z` and
`extent.depth` does not equal the depth of the subresource specified
by `srcSubresource`, `extent.depth` :normative{type="must"} be a multiple of the
texel block extent depth of the
[VkFormat](/man/VkFormat) of `srcImage`
::

::validity-field{name="VUID-vkCmdCopyImage-dstImage-01732"}

For each element of `pRegions`, if the sum of `dstOffset.x` and
`extent.width` does not equal the width of the subresource specified
by `dstSubresource`, `extent.width` :normative{type="must"} be a multiple of the
texel block extent width of the
[VkFormat](/man/VkFormat) of `dstImage`
::

::validity-field{name="VUID-vkCmdCopyImage-dstImage-01733"}

For each element of `pRegions`, if the sum of `dstOffset.y` and
`extent.height` does not equal the height of the subresource
specified by `dstSubresource`, `extent.height` :normative{type="must"} be a
multiple of the texel block extent
height of the [VkFormat](/man/VkFormat) of `dstImage`
::

::validity-field{name="VUID-vkCmdCopyImage-dstImage-01734"}

For each element of `pRegions`, if the sum of `dstOffset.z` and
`extent.depth` does not equal the depth of the subresource specified
by `dstSubresource`, `extent.depth` :normative{type="must"} be a multiple of the
texel block extent depth of the
[VkFormat](/man/VkFormat) of `dstImage`
::

::validity-field{name="VUID-vkCmdCopyImage-aspect-06662"}
`VK_IMAGE_USAGE_TRANSFER_SRC_BIT` :normative{type="must"} have been included in the
[VkImageCreateInfo](/man/VkImageCreateInfo)::`usage` used to create `srcImage`
::

::validity-field{name="VUID-vkCmdCopyImage-aspect-06663"}
`VK_IMAGE_USAGE_TRANSFER_DST_BIT` :normative{type="must"} have been included in the
[VkImageCreateInfo](/man/VkImageCreateInfo)::`usage` used to create `dstImage`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdCopyImage-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdCopyImage-srcImage-parameter"}
 `srcImage` :normative{type="must"} be a valid [VkImage](/man/VkImage) handle
::

::validity-field{name="VUID-vkCmdCopyImage-srcImageLayout-parameter"}
 `srcImageLayout` :normative{type="must"} be a valid [VkImageLayout](/man/VkImageLayout) value
::

::validity-field{name="VUID-vkCmdCopyImage-dstImage-parameter"}
 `dstImage` :normative{type="must"} be a valid [VkImage](/man/VkImage) handle
::

::validity-field{name="VUID-vkCmdCopyImage-dstImageLayout-parameter"}
 `dstImageLayout` :normative{type="must"} be a valid [VkImageLayout](/man/VkImageLayout) value
::

::validity-field{name="VUID-vkCmdCopyImage-pRegions-parameter"}
 `pRegions` :normative{type="must"} be a valid pointer to an array of `regionCount` valid [VkImageCopy](/man/VkImageCopy) structures
::

::validity-field{name="VUID-vkCmdCopyImage-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdCopyImage-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support transfer, graphics, or compute operations
::

::validity-field{name="VUID-vkCmdCopyImage-renderpass"}
 This command :normative{type="must"} only be called outside of a render pass instance
::

::validity-field{name="VUID-vkCmdCopyImage-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdCopyImage-regionCount-arraylength"}
 `regionCount` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-vkCmdCopyImage-commonparent"}
 Each of `commandBuffer`, `dstImage`, and `srcImage` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::






The `VkImageCopy` structure is defined as:

[{generated}/api/structs/VkImageCopy.adoc]({generated}/api/structs/VkImageCopy.adoc)

- `srcSubresource` and `dstSubresource` are
  [VkImageSubresourceLayers](/man/VkImageSubresourceLayers) structures specifying the image
  subresources of the images used for the source and destination image
  data, respectively.

- `srcOffset` and `dstOffset` select the initial `x`, `y`,
  and `z` offsets in texels of the sub-regions of the source and
  destination image data.

- `extent` is the size in texels of the image to copy in `width`,
  `height` and `depth`.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkImageCopy-apiVersion-07940"}

The
    `aspectMask` member of `srcSubresource` and `dstSubresource`
    :normative{type="must"} match
::

::validity-field{name="VUID-VkImageCopy-apiVersion-07941"}

The
    `layerCount` member of `srcSubresource` and `dstSubresource`
    :normative{type="must"} match
::

::validity-field{name="VUID-VkImageCopy-extent-06668"}
`extent.width` :normative{type="must"} not be 0
::

::validity-field{name="VUID-VkImageCopy-extent-06669"}
`extent.height` :normative{type="must"} not be 0
::

::validity-field{name="VUID-VkImageCopy-extent-06670"}
`extent.depth` :normative{type="must"} not be 0
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkImageCopy-srcSubresource-parameter"}
 `srcSubresource` :normative{type="must"} be a valid [VkImageSubresourceLayers](/man/VkImageSubresourceLayers) structure
::

::validity-field{name="VUID-VkImageCopy-dstSubresource-parameter"}
 `dstSubresource` :normative{type="must"} be a valid [VkImageSubresourceLayers](/man/VkImageSubresourceLayers) structure
::

::


The `VkImageSubresourceLayers` structure is defined as:

[{generated}/api/structs/VkImageSubresourceLayers.adoc]({generated}/api/structs/VkImageSubresourceLayers.adoc)

- `aspectMask` is a combination of [VkImageAspectFlagBits](/man/VkImageAspectFlagBits),
  selecting the color, depth and/or stencil aspects to be copied.

- `mipLevel` is the mipmap level to copy

- `baseArrayLayer` and `layerCount` are the starting layer and
  number of layers to copy.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkImageSubresourceLayers-aspectMask-00167"}

If `aspectMask` contains `VK_IMAGE_ASPECT_COLOR_BIT`, it :normative{type="must"}
not contain either of `VK_IMAGE_ASPECT_DEPTH_BIT` or
`VK_IMAGE_ASPECT_STENCIL_BIT`
::

::validity-field{name="VUID-VkImageSubresourceLayers-aspectMask-00168"}
`aspectMask` :normative{type="must"} not contain `VK_IMAGE_ASPECT_METADATA_BIT`
::

::validity-field{name="VUID-VkImageSubresourceLayers-layerCount-09243"}


`layerCount` :normative{type="must"} not be `VK_REMAINING_ARRAY_LAYERS`
::

::validity-field{name="VUID-VkImageSubresourceLayers-layerCount-01700"}

If `layerCount` is not `VK_REMAINING_ARRAY_LAYERS`, it :normative{type="must"} be
greater than 0
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkImageSubresourceLayers-aspectMask-parameter"}
 `aspectMask` :normative{type="must"} be a valid combination of [VkImageAspectFlagBits](/man/VkImageAspectFlagBits) values
::

::validity-field{name="VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask"}
 `aspectMask` :normative{type="must"} not be `0`
::

::






## Copying Data Between Buffers and Images

Data :normative{type="can"} be copied between buffers and images, enabling applications to
load and store data between images and user defined offsets in buffer
memory.

When copying between a buffer and an image, whole texel blocks are always
copied; each texel block in the specified extent in the image to be copied
will be written to a region in the buffer, specified according to the
position of the texel block, and the texel
block extent and size of the format being copied.

For a set of coordinates (x,y,z,layer), where:



and where blockWidth, blockHeight, and blockDepth are the
dimensions of the texel block extent of
the image’s format.

For each (x,y,z,layer) coordinate, texels in the image layer selected
by layer are accessed in the following ranges:



where imageWidth, imageHeight, and imageDepth are the
dimensions of the image subresource.

For each (x,y,z,layer) coordinate, bytes in the buffer are accessed at
offsets in the range \[texelOffset, texelOffset +  blockSize),
where:



When copying between a buffer and the depth or stencil aspect of an image,
data in the buffer is assumed to be laid out as separate planes rather than
interleaved.
Addressing calculations are thus performed for a different format than the
base image, according to the aspect, as described in the following table:



Each texel block is copied from one resource to the other according to the
above addressing equations.

To copy data from a buffer object to an image object, call:

[{generated}/api/protos/vkCmdCopyBufferToImage.adoc]({generated}/api/protos/vkCmdCopyBufferToImage.adoc)

- `commandBuffer` is the command buffer into which the command will be
  recorded.

- `srcBuffer` is the source buffer.

- `dstImage` is the destination image.

- `dstImageLayout` is the layout of the destination image subresources
  for the copy.

- `regionCount` is the number of regions to copy.

- `pRegions` is a pointer to an array of [VkBufferImageCopy](/man/VkBufferImageCopy)
  structures specifying the regions to copy.

Each source region specified by `pRegions` is copied from the source
buffer to the destination region of the destination image according to the
addressing calculations for each
resource.
If any of the specified regions in `srcBuffer` overlaps in memory with
any of the specified regions in `dstImage`, values read from those
overlapping regions are undefined:.
If any region accesses a depth aspect in `dstImage`
values copied from `srcBuffer` outside of the range \[0,1] will be
be written as undefined: values to the destination image.

Copy regions for the image :normative{type="must"} be aligned to a multiple of the texel block
extent in each dimension, except at the edges of the image, where region
extents :normative{type="must"} match the edge of the image.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdCopyBufferToImage-dstImage-07966"}

If `dstImage` is non-sparse then the image
:normative{type="must"} be bound completely and contiguously to a single
`VkDeviceMemory` object
::

::validity-field{name="VUID-vkCmdCopyBufferToImage-imageSubresource-07967"}

The `imageSubresource.mipLevel` member of each element of
`pRegions` :normative{type="must"} be less than the `mipLevels` specified in
[VkImageCreateInfo](/man/VkImageCreateInfo) when `dstImage` was created
::

::validity-field{name="VUID-vkCmdCopyBufferToImage-imageSubresource-07968"}
`imageSubresource.baseArrayLayer` + 
`imageSubresource.layerCount` of each element of `pRegions`
:normative{type="must"} be less than or equal to the `arrayLayers` specified in
[VkImageCreateInfo](/man/VkImageCreateInfo) when `dstImage` was created
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdCopyBufferToImage-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdCopyBufferToImage-srcBuffer-parameter"}
 `srcBuffer` :normative{type="must"} be a valid [VkBuffer](/man/VkBuffer) handle
::

::validity-field{name="VUID-vkCmdCopyBufferToImage-dstImage-parameter"}
 `dstImage` :normative{type="must"} be a valid [VkImage](/man/VkImage) handle
::

::validity-field{name="VUID-vkCmdCopyBufferToImage-dstImageLayout-parameter"}
 `dstImageLayout` :normative{type="must"} be a valid [VkImageLayout](/man/VkImageLayout) value
::

::validity-field{name="VUID-vkCmdCopyBufferToImage-pRegions-parameter"}
 `pRegions` :normative{type="must"} be a valid pointer to an array of `regionCount` valid [VkBufferImageCopy](/man/VkBufferImageCopy) structures
::

::validity-field{name="VUID-vkCmdCopyBufferToImage-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdCopyBufferToImage-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support transfer, graphics, or compute operations
::

::validity-field{name="VUID-vkCmdCopyBufferToImage-renderpass"}
 This command :normative{type="must"} only be called outside of a render pass instance
::

::validity-field{name="VUID-vkCmdCopyBufferToImage-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdCopyBufferToImage-regionCount-arraylength"}
 `regionCount` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-vkCmdCopyBufferToImage-commonparent"}
 Each of `commandBuffer`, `dstImage`, and `srcBuffer` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::






To copy data from an image object to a buffer object, call:

[{generated}/api/protos/vkCmdCopyImageToBuffer.adoc]({generated}/api/protos/vkCmdCopyImageToBuffer.adoc)

- `commandBuffer` is the command buffer into which the command will be
  recorded.

- `srcImage` is the source image.

- `srcImageLayout` is the layout of the source image subresources for
  the copy.

- `dstBuffer` is the destination buffer.

- `regionCount` is the number of regions to copy.

- `pRegions` is a pointer to an array of [VkBufferImageCopy](/man/VkBufferImageCopy)
  structures specifying the regions to copy.

Each source region specified by `pRegions` is copied from the source
image to the destination region of the destination buffer according to the
addressing calculations for each
resource.
If any of the specified regions in `srcImage` overlaps in memory with
any of the specified regions in `dstBuffer`, values read from those
overlapping regions are undefined:.

Copy regions for the image :normative{type="must"} be aligned to a multiple of the texel block
extent in each dimension, except at the edges of the image, where region
extents :normative{type="must"} match the edge of the image.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdCopyImageToBuffer-srcImage-07966"}

If `srcImage` is non-sparse then the image
:normative{type="must"} be bound completely and contiguously to a single
`VkDeviceMemory` object
::

::validity-field{name="VUID-vkCmdCopyImageToBuffer-imageSubresource-07967"}

The `imageSubresource.mipLevel` member of each element of
`pRegions` :normative{type="must"} be less than the `mipLevels` specified in
[VkImageCreateInfo](/man/VkImageCreateInfo) when `srcImage` was created
::

::validity-field{name="VUID-vkCmdCopyImageToBuffer-imageSubresource-07968"}
`imageSubresource.baseArrayLayer` + 
`imageSubresource.layerCount` of each element of `pRegions`
:normative{type="must"} be less than or equal to the `arrayLayers` specified in
[VkImageCreateInfo](/man/VkImageCreateInfo) when `srcImage` was created
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdCopyImageToBuffer-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdCopyImageToBuffer-srcImage-parameter"}
 `srcImage` :normative{type="must"} be a valid [VkImage](/man/VkImage) handle
::

::validity-field{name="VUID-vkCmdCopyImageToBuffer-srcImageLayout-parameter"}
 `srcImageLayout` :normative{type="must"} be a valid [VkImageLayout](/man/VkImageLayout) value
::

::validity-field{name="VUID-vkCmdCopyImageToBuffer-dstBuffer-parameter"}
 `dstBuffer` :normative{type="must"} be a valid [VkBuffer](/man/VkBuffer) handle
::

::validity-field{name="VUID-vkCmdCopyImageToBuffer-pRegions-parameter"}
 `pRegions` :normative{type="must"} be a valid pointer to an array of `regionCount` valid [VkBufferImageCopy](/man/VkBufferImageCopy) structures
::

::validity-field{name="VUID-vkCmdCopyImageToBuffer-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdCopyImageToBuffer-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support transfer, graphics, or compute operations
::

::validity-field{name="VUID-vkCmdCopyImageToBuffer-renderpass"}
 This command :normative{type="must"} only be called outside of a render pass instance
::

::validity-field{name="VUID-vkCmdCopyImageToBuffer-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdCopyImageToBuffer-regionCount-arraylength"}
 `regionCount` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-vkCmdCopyImageToBuffer-commonparent"}
 Each of `commandBuffer`, `dstBuffer`, and `srcImage` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::






For both [vkCmdCopyBufferToImage](/man/vkCmdCopyBufferToImage) and [vkCmdCopyImageToBuffer](/man/vkCmdCopyImageToBuffer), each
element of `pRegions` is a structure defined as:

[{generated}/api/structs/VkBufferImageCopy.adoc]({generated}/api/structs/VkBufferImageCopy.adoc)

- `bufferOffset` is the offset in bytes from the start of the buffer
  object where the image data is copied from or to.

- `bufferRowLength` and `bufferImageHeight` specify in texels a
  subregion of a larger two- or three-dimensional image in buffer memory,
  and control the addressing calculations.
  If either of these values is zero, that aspect of the buffer memory is
  considered to be tightly packed according to the `imageExtent`.

- `imageSubresource` is a [VkImageSubresourceLayers](/man/VkImageSubresourceLayers) used to
  specify the specific image subresources of the image used for the source
  or destination image data.

- `imageOffset` selects the initial `x`, `y`, `z` offsets
  in texels of the sub-region of the source or destination image data.

- `imageExtent` is the size in texels of the image to copy in
  `width`, `height` and `depth`.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkBufferImageCopy-bufferRowLength-09101"}
`bufferRowLength` :normative{type="must"} be `0`, or greater than or equal to the
`width` member of `imageExtent`
::

::validity-field{name="VUID-VkBufferImageCopy-bufferImageHeight-09102"}
`bufferImageHeight` :normative{type="must"} be `0`, or greater than or equal to the
`height` member of `imageExtent`
::

::validity-field{name="VUID-VkBufferImageCopy-aspectMask-09103"}

The `aspectMask` member of `imageSubresource` :normative{type="must"} only have a
single bit set
::

::validity-field{name="VUID-VkBufferImageCopy-imageExtent-06659"}
`imageExtent.width` :normative{type="must"} not be 0
::

::validity-field{name="VUID-VkBufferImageCopy-imageExtent-06660"}
`imageExtent.height` :normative{type="must"} not be 0
::

::validity-field{name="VUID-VkBufferImageCopy-imageExtent-06661"}
`imageExtent.depth` :normative{type="must"} not be 0
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkBufferImageCopy-imageSubresource-parameter"}
 `imageSubresource` :normative{type="must"} be a valid [VkImageSubresourceLayers](/man/VkImageSubresourceLayers) structure
::

::






## Image Copies With Scaling

To copy regions of a source image into a destination image, potentially
performing format conversion, arbitrary scaling, and filtering, call:

[{generated}/api/protos/vkCmdBlitImage.adoc]({generated}/api/protos/vkCmdBlitImage.adoc)

- `commandBuffer` is the command buffer into which the command will be
  recorded.

- `srcImage` is the source image.

- `srcImageLayout` is the layout of the source image subresources for
  the blit.

- `dstImage` is the destination image.

- `dstImageLayout` is the layout of the destination image subresources
  for the blit.

- `regionCount` is the number of regions to blit.

- `pRegions` is a pointer to an array of [VkImageBlit](/man/VkImageBlit) structures
  specifying the regions to blit.

- `filter` is a [VkFilter](/man/VkFilter) specifying the filter to apply if the
  blits require scaling.

`vkCmdBlitImage` :normative{type="must"} not be used for multisampled source or
destination images.
Use [vkCmdResolveImage](/man/vkCmdResolveImage) for this purpose.

As the sizes of the source and destination extents :normative{type="can"} differ in any
dimension, texels in the source extent are scaled and filtered to the
destination extent.
Scaling occurs via the following operations:

- For each destination texel, the integer coordinate of that texel is
  converted to an unnormalized texture coordinate, using the effective
  inverse of the equations described in
  unnormalized to integer
  conversion:





- These base coordinates are then offset by the first destination offset:





- The scale is determined from the source and destination regions, and
  applied to the offset coordinates:





- Finally the source offset is added to the scaled coordinates, to
  determine the final unnormalized coordinates used to sample from
  `srcImage`:





These coordinates are used to sample from the source image, as described in
Image Operations chapter, with the filter mode equal to that
of `filter`, a mipmap mode of `VK_SAMPLER_MIPMAP_MODE_NEAREST` and
an address mode of `VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE`.
Implementations :normative{type="must"} clamp at the edge of the source image, and :normative{type="may"}
additionally clamp to the edge of the source region.


::note
Due to allowable rounding errors in the generation of the source texture
coordinates, it is not always possible to guarantee exactly which source
texels will be sampled for a given blit.
As rounding errors are implementation-dependent, the exact results of a
blitting operation are also implementation-dependent.
::


Blits are done layer by layer starting with the `baseArrayLayer` member
of `srcSubresource` for the source and `dstSubresource` for the
destination.
`layerCount` layers are blitted to the destination image.

When blitting 3D textures, slices in the destination region bounded by
`dstOffsets`\[0].z and `dstOffsets`\[1].z are sampled from slices in
the source region bounded by `srcOffsets`\[0].z and
`srcOffsets`\[1].z.
If the `filter` parameter is `VK_FILTER_LINEAR` then the value
sampled from the source image is taken by doing linear filtering using the
interpolated *z* coordinate represented by *w* in the previous equations.
If the `filter` parameter is `VK_FILTER_NEAREST` then the value
sampled from the source image is taken from the single nearest slice, with
an implementation-dependent arithmetic rounding mode.

The following filtering and conversion rules apply:

- Integer formats :normative{type="can"} only be converted to other integer formats with the
  same signedness.

- No format conversion is supported between depth/stencil images.
  The formats :normative{type="must"} match.

- Format conversions on unorm, snorm, scaled and packed float formats of
  the copied aspect of the image are performed by first converting the
  pixels to float values.

- For sRGB source formats, nonlinear RGB values are converted to linear
  representation prior to filtering.

- After filtering, the float values are first clamped and then cast to the
  destination image format.
  In case of sRGB destination format, linear RGB values are converted to
  nonlinear representation before writing the pixel to the image.

Signed and unsigned integers are converted by first clamping to the
representable range of the destination format, then casting the value.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdBlitImage-pRegions-00215"}

The source region specified by each element of `pRegions` :normative{type="must"} be a
region that is contained within `srcImage`
::

::validity-field{name="VUID-vkCmdBlitImage-pRegions-00216"}

The destination region specified by each element of `pRegions` :normative{type="must"}
be a region that is contained within `dstImage`
::

::validity-field{name="VUID-vkCmdBlitImage-pRegions-00217"}

The union of all destination regions, specified by the elements of
`pRegions`, :normative{type="must"} not overlap in memory with any texel that :normative{type="may"} be
sampled during the blit operation
::

::validity-field{name="VUID-vkCmdBlitImage-srcImage-01999"}

The format features of
`srcImage` :normative{type="must"} contain `VK_FORMAT_FEATURE_BLIT_SRC_BIT`
::

::validity-field{name="VUID-vkCmdBlitImage-srcImage-00219"}
`srcImage` :normative{type="must"} have been created with
`VK_IMAGE_USAGE_TRANSFER_SRC_BIT` usage flag
::

::validity-field{name="VUID-vkCmdBlitImage-srcImage-00220"}

If `srcImage` is non-sparse then it :normative{type="must"} be bound completely and
contiguously to a single `VkDeviceMemory` object
::

::validity-field{name="VUID-vkCmdBlitImage-srcImageLayout-00221"}
`srcImageLayout` :normative{type="must"} specify the layout of the image subresources
of `srcImage` specified in `pRegions` at the time this command
is executed on a `VkDevice`
::

::validity-field{name="VUID-vkCmdBlitImage-srcImageLayout-00222"}
`srcImageLayout` :normative{type="must"} be `VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL`
or `VK_IMAGE_LAYOUT_GENERAL`
::

::validity-field{name="VUID-vkCmdBlitImage-dstImage-02000"}

The format features of
`dstImage` :normative{type="must"} contain `VK_FORMAT_FEATURE_BLIT_DST_BIT`
::

::validity-field{name="VUID-vkCmdBlitImage-dstImage-00224"}
`dstImage` :normative{type="must"} have been created with
`VK_IMAGE_USAGE_TRANSFER_DST_BIT` usage flag
::

::validity-field{name="VUID-vkCmdBlitImage-dstImage-00225"}

If `dstImage` is non-sparse then it :normative{type="must"} be bound completely and
contiguously to a single `VkDeviceMemory` object
::

::validity-field{name="VUID-vkCmdBlitImage-dstImageLayout-00226"}
`dstImageLayout` :normative{type="must"} specify the layout of the image subresources
of `dstImage` specified in `pRegions` at the time this command
is executed on a `VkDevice`
::

::validity-field{name="VUID-vkCmdBlitImage-dstImageLayout-00227"}
`dstImageLayout` :normative{type="must"} be `VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`
or `VK_IMAGE_LAYOUT_GENERAL`
::

::validity-field{name="VUID-vkCmdBlitImage-srcImage-00229"}

If either of `srcImage` or `dstImage` was created with a signed
integer [VkFormat](/man/VkFormat), the other :normative{type="must"} also have been created with a
signed integer [VkFormat](/man/VkFormat)
::

::validity-field{name="VUID-vkCmdBlitImage-srcImage-00230"}

If either of `srcImage` or `dstImage` was created with an
unsigned integer [VkFormat](/man/VkFormat), the other :normative{type="must"} also have been created
with an unsigned integer [VkFormat](/man/VkFormat)
::

::validity-field{name="VUID-vkCmdBlitImage-srcImage-00231"}

If either of `srcImage` or `dstImage` was created with a
depth/stencil format, the other :normative{type="must"} have exactly the same format
::

::validity-field{name="VUID-vkCmdBlitImage-srcImage-00232"}

If `srcImage` was created with a depth/stencil format, `filter`
:normative{type="must"} be `VK_FILTER_NEAREST`
::

::validity-field{name="VUID-vkCmdBlitImage-srcImage-00233"}
`srcImage` :normative{type="must"} have been created with a `samples` value of
`VK_SAMPLE_COUNT_1_BIT`
::

::validity-field{name="VUID-vkCmdBlitImage-dstImage-00234"}
`dstImage` :normative{type="must"} have been created with a `samples` value of
`VK_SAMPLE_COUNT_1_BIT`
::

::validity-field{name="VUID-vkCmdBlitImage-filter-02001"}

If `filter` is `VK_FILTER_LINEAR`, then the
format features of `srcImage`
:normative{type="must"} contain `VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT`
::

::validity-field{name="VUID-vkCmdBlitImage-srcSubresource-01705"}

The `srcSubresource.mipLevel` member of each element of
`pRegions` :normative{type="must"} be less than the `mipLevels` specified in
[VkImageCreateInfo](/man/VkImageCreateInfo) when `srcImage` was created
::

::validity-field{name="VUID-vkCmdBlitImage-dstSubresource-01706"}

The `dstSubresource.mipLevel` member of each element of
`pRegions` :normative{type="must"} be less than the `mipLevels` specified in
[VkImageCreateInfo](/man/VkImageCreateInfo) when `dstImage` was created
::

::validity-field{name="VUID-vkCmdBlitImage-srcSubresource-01707"}
`srcSubresource.baseArrayLayer` + 
`srcSubresource.layerCount` of each element of `pRegions` :normative{type="must"}
be less than or equal to the `arrayLayers` specified in
[VkImageCreateInfo](/man/VkImageCreateInfo) when `srcImage` was created
::

::validity-field{name="VUID-vkCmdBlitImage-dstSubresource-01708"}
`dstSubresource.baseArrayLayer` + 
`dstSubresource.layerCount` of each element of `pRegions` :normative{type="must"}
be less than or equal to the `arrayLayers` specified in
[VkImageCreateInfo](/man/VkImageCreateInfo) when `dstImage` was created
::

::validity-field{name="VUID-vkCmdBlitImage-srcImage-00240"}

If either `srcImage` or `dstImage` is of type
`VK_IMAGE_TYPE_3D`, then for each element of `pRegions`,
`srcSubresource.baseArrayLayer` and
`dstSubresource.baseArrayLayer` :normative{type="must"} each be `0`, and
`srcSubresource.layerCount` and `dstSubresource.layerCount`
:normative{type="must"} each be `1`
::

::validity-field{name="VUID-vkCmdBlitImage-aspectMask-00241"}

For each element of `pRegions`, `srcSubresource.aspectMask`
:normative{type="must"} specify aspects present in `srcImage`
::

::validity-field{name="VUID-vkCmdBlitImage-aspectMask-00242"}

For each element of `pRegions`, `dstSubresource.aspectMask`
:normative{type="must"} specify aspects present in `dstImage`
::

::validity-field{name="VUID-vkCmdBlitImage-srcOffset-00243"}

For each element of `pRegions`, `srcOffsets`[0].x and
`srcOffsets`[1].x :normative{type="must"} both be greater than or equal to `0` and
less than or equal to the width of the specified `srcSubresource` of
`srcImage`
::

::validity-field{name="VUID-vkCmdBlitImage-srcOffset-00244"}

For each element of `pRegions`, `srcOffsets`[0].y and
`srcOffsets`[1].y :normative{type="must"} both be greater than or equal to `0` and
less than or equal to the height of the specified `srcSubresource`
of `srcImage`
::

::validity-field{name="VUID-vkCmdBlitImage-srcImage-00245"}

If `srcImage` is of type `VK_IMAGE_TYPE_1D`, then for each
element of `pRegions`, `srcOffsets`[0].y :normative{type="must"} be `0` and
`srcOffsets`[1].y :normative{type="must"} be `1`
::

::validity-field{name="VUID-vkCmdBlitImage-srcOffset-00246"}

For each element of `pRegions`, `srcOffsets`[0].z and
`srcOffsets`[1].z :normative{type="must"} both be greater than or equal to `0` and
less than or equal to the depth of the specified `srcSubresource` of
`srcImage`
::

::validity-field{name="VUID-vkCmdBlitImage-srcImage-00247"}

If `srcImage` is of type `VK_IMAGE_TYPE_1D` or
`VK_IMAGE_TYPE_2D`, then for each element of `pRegions`,
`srcOffsets`[0].z :normative{type="must"} be `0` and `srcOffsets`[1].z :normative{type="must"} be
`1`
::

::validity-field{name="VUID-vkCmdBlitImage-dstOffset-00248"}

For each element of `pRegions`, `dstOffsets`[0].x and
`dstOffsets`[1].x :normative{type="must"} both be greater than or equal to `0` and
less than or equal to the width of the specified `dstSubresource` of
`dstImage`
::

::validity-field{name="VUID-vkCmdBlitImage-dstOffset-00249"}

For each element of `pRegions`, `dstOffsets`[0].y and
`dstOffsets`[1].y :normative{type="must"} both be greater than or equal to `0` and
less than or equal to the height of the specified `dstSubresource`
of `dstImage`
::

::validity-field{name="VUID-vkCmdBlitImage-dstImage-00250"}

If `dstImage` is of type `VK_IMAGE_TYPE_1D`, then for each
element of `pRegions`, `dstOffsets`[0].y :normative{type="must"} be `0` and
`dstOffsets`[1].y :normative{type="must"} be `1`
::

::validity-field{name="VUID-vkCmdBlitImage-dstOffset-00251"}

For each element of `pRegions`, `dstOffsets`[0].z and
`dstOffsets`[1].z :normative{type="must"} both be greater than or equal to `0` and
less than or equal to the depth of the specified `dstSubresource` of
`dstImage`
::

::validity-field{name="VUID-vkCmdBlitImage-dstImage-00252"}

If `dstImage` is of type `VK_IMAGE_TYPE_1D` or
`VK_IMAGE_TYPE_2D`, then for each element of `pRegions`,
`dstOffsets`[0].z :normative{type="must"} be `0` and `dstOffsets`[1].z :normative{type="must"} be
`1`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdBlitImage-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdBlitImage-srcImage-parameter"}
 `srcImage` :normative{type="must"} be a valid [VkImage](/man/VkImage) handle
::

::validity-field{name="VUID-vkCmdBlitImage-srcImageLayout-parameter"}
 `srcImageLayout` :normative{type="must"} be a valid [VkImageLayout](/man/VkImageLayout) value
::

::validity-field{name="VUID-vkCmdBlitImage-dstImage-parameter"}
 `dstImage` :normative{type="must"} be a valid [VkImage](/man/VkImage) handle
::

::validity-field{name="VUID-vkCmdBlitImage-dstImageLayout-parameter"}
 `dstImageLayout` :normative{type="must"} be a valid [VkImageLayout](/man/VkImageLayout) value
::

::validity-field{name="VUID-vkCmdBlitImage-pRegions-parameter"}
 `pRegions` :normative{type="must"} be a valid pointer to an array of `regionCount` valid [VkImageBlit](/man/VkImageBlit) structures
::

::validity-field{name="VUID-vkCmdBlitImage-filter-parameter"}
 `filter` :normative{type="must"} be a valid [VkFilter](/man/VkFilter) value
::

::validity-field{name="VUID-vkCmdBlitImage-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdBlitImage-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics operations
::

::validity-field{name="VUID-vkCmdBlitImage-renderpass"}
 This command :normative{type="must"} only be called outside of a render pass instance
::

::validity-field{name="VUID-vkCmdBlitImage-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdBlitImage-regionCount-arraylength"}
 `regionCount` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-vkCmdBlitImage-commonparent"}
 Each of `commandBuffer`, `dstImage`, and `srcImage` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::






The `VkImageBlit` structure is defined as:

[{generated}/api/structs/VkImageBlit.adoc]({generated}/api/structs/VkImageBlit.adoc)

- `srcSubresource` is the subresource to blit from.

- `srcOffsets` is a pointer to an array of two [VkOffset3D](/man/VkOffset3D)
  structures specifying the bounds of the source region within
  `srcSubresource`.

- `dstSubresource` is the subresource to blit into.

- `dstOffsets` is a pointer to an array of two [VkOffset3D](/man/VkOffset3D)
  structures specifying the bounds of the destination region within
  `dstSubresource`.

For each element of the `pRegions` array, a blit operation is performed
for the specified source and destination regions.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkImageBlit-aspectMask-00238"}

The `aspectMask` member of `srcSubresource` and
`dstSubresource` :normative{type="must"} match
::

::validity-field{name="VUID-VkImageBlit-layerCount-08800"}

The
    `layerCount` members of `srcSubresource` or `dstSubresource`
    :normative{type="must"} match
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkImageBlit-srcSubresource-parameter"}
 `srcSubresource` :normative{type="must"} be a valid [VkImageSubresourceLayers](/man/VkImageSubresourceLayers) structure
::

::validity-field{name="VUID-VkImageBlit-dstSubresource-parameter"}
 `dstSubresource` :normative{type="must"} be a valid [VkImageSubresourceLayers](/man/VkImageSubresourceLayers) structure
::

::






## Resolving Multisample Images

To resolve a multisample color image to a non-multisample color image, call:

[{generated}/api/protos/vkCmdResolveImage.adoc]({generated}/api/protos/vkCmdResolveImage.adoc)

- `commandBuffer` is the command buffer into which the command will be
  recorded.

- `srcImage` is the source image.

- `srcImageLayout` is the layout of the source image subresources for
  the resolve.

- `dstImage` is the destination image.

- `dstImageLayout` is the layout of the destination image subresources
  for the resolve.

- `regionCount` is the number of regions to resolve.

- `pRegions` is a pointer to an array of [VkImageResolve](/man/VkImageResolve)
  structures specifying the regions to resolve.

During the resolve the samples corresponding to each pixel location in the
source are converted to a single sample before being written to the
destination.
If the source formats are floating-point or normalized types, the sample
values for each pixel are resolved in an implementation-dependent manner.
If the source formats are integer types, a single sample’s value is selected
for each pixel.

`srcOffset` and `dstOffset` select the initial `x`, `y`, and
`z` offsets in texels of the sub-regions of the source and destination
image data.
`extent` is the size in texels of the source image to resolve in
`width`, `height` and `depth`.
Each element of `pRegions` :normative{type="must"} be a region that is contained within
its corresponding image.

Resolves are done layer by layer starting with `baseArrayLayer` member
of `srcSubresource` for the source and `dstSubresource` for the
destination.
`layerCount` layers are resolved to the destination image.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdResolveImage-pRegions-00255"}

The union of all source regions, and the union of all destination
regions, specified by the elements of `pRegions`, :normative{type="must"} not overlap
in memory
::

::validity-field{name="VUID-vkCmdResolveImage-srcImage-00256"}

If `srcImage` is non-sparse then it :normative{type="must"} be bound completely and
contiguously to a single `VkDeviceMemory` object
::

::validity-field{name="VUID-vkCmdResolveImage-srcImage-00257"}
`srcImage` :normative{type="must"} have a sample count equal to any valid sample count
value other than `VK_SAMPLE_COUNT_1_BIT`
::

::validity-field{name="VUID-vkCmdResolveImage-dstImage-00258"}

If `dstImage` is non-sparse then it :normative{type="must"} be bound completely and
contiguously to a single `VkDeviceMemory` object
::

::validity-field{name="VUID-vkCmdResolveImage-dstImage-00259"}
`dstImage` :normative{type="must"} have a sample count equal to
`VK_SAMPLE_COUNT_1_BIT`
::

::validity-field{name="VUID-vkCmdResolveImage-srcImageLayout-00260"}
`srcImageLayout` :normative{type="must"} specify the layout of the image subresources
of `srcImage` specified in `pRegions` at the time this command
is executed on a `VkDevice`
::

::validity-field{name="VUID-vkCmdResolveImage-srcImageLayout-01400"}
`srcImageLayout` :normative{type="must"} be
`VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL` or
`VK_IMAGE_LAYOUT_GENERAL`
::

::validity-field{name="VUID-vkCmdResolveImage-dstImageLayout-00262"}
`dstImageLayout` :normative{type="must"} specify the layout of the image subresources
of `dstImage` specified in `pRegions` at the time this command
is executed on a `VkDevice`
::

::validity-field{name="VUID-vkCmdResolveImage-dstImageLayout-01401"}
`dstImageLayout` :normative{type="must"} be
`VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL` or
`VK_IMAGE_LAYOUT_GENERAL`
::

::validity-field{name="VUID-vkCmdResolveImage-dstImage-02003"}

The format features of
`dstImage` :normative{type="must"} contain
`VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT`
::

::validity-field{name="VUID-vkCmdResolveImage-srcImage-01386"}
`srcImage` and `dstImage` :normative{type="must"} have been created with the same
image format
::

::validity-field{name="VUID-vkCmdResolveImage-srcSubresource-01709"}

The `srcSubresource.mipLevel` member of each element of
`pRegions` :normative{type="must"} be less than the `mipLevels` specified in
[VkImageCreateInfo](/man/VkImageCreateInfo) when `srcImage` was created
::

::validity-field{name="VUID-vkCmdResolveImage-dstSubresource-01710"}

The `dstSubresource.mipLevel` member of each element of
`pRegions` :normative{type="must"} be less than the `mipLevels` specified in
[VkImageCreateInfo](/man/VkImageCreateInfo) when `dstImage` was created
::

::validity-field{name="VUID-vkCmdResolveImage-srcSubresource-01711"}
`srcSubresource.baseArrayLayer` + 
`srcSubresource.layerCount` of each element of `pRegions` :normative{type="must"}
be less than or equal to the `arrayLayers` specified in
[VkImageCreateInfo](/man/VkImageCreateInfo) when `srcImage` was created
::

::validity-field{name="VUID-vkCmdResolveImage-dstSubresource-01712"}
`dstSubresource.baseArrayLayer` + 
`dstSubresource.layerCount` of each element of `pRegions` :normative{type="must"}
be less than or equal to the `arrayLayers` specified in
[VkImageCreateInfo](/man/VkImageCreateInfo) when `dstImage` was created
::

::validity-field{name="VUID-vkCmdResolveImage-srcImage-04446"}

If `dstImage` is of type `VK_IMAGE_TYPE_3D`, then for each
element of `pRegions`, `srcSubresource.layerCount` :normative{type="must"} be `1`
::

::validity-field{name="VUID-vkCmdResolveImage-srcImage-04447"}

If `dstImage` is of type `VK_IMAGE_TYPE_3D`, then for each
element of `pRegions`, `dstSubresource.baseArrayLayer` :normative{type="must"} be
`0` and `dstSubresource.layerCount` :normative{type="must"} be `1`
::

::validity-field{name="VUID-vkCmdResolveImage-srcOffset-00269"}

For each element of `pRegions`, `srcOffset.x` and
(`extent.width` +  `srcOffset.x`) :normative{type="must"} both be
greater than or equal to `0` and less than or equal to the width of the
specified `srcSubresource` of `srcImage`
::

::validity-field{name="VUID-vkCmdResolveImage-srcOffset-00270"}

For each element of `pRegions`, `srcOffset.y` and
(`extent.height` +  `srcOffset.y`) :normative{type="must"} both be
greater than or equal to `0` and less than or equal to the height of the
specified `srcSubresource` of `srcImage`
::

::validity-field{name="VUID-vkCmdResolveImage-srcImage-00271"}

If `srcImage` is of type `VK_IMAGE_TYPE_1D`, then for each
element of `pRegions`, `srcOffset.y` :normative{type="must"} be `0` and
`extent.height` :normative{type="must"} be `1`
::

::validity-field{name="VUID-vkCmdResolveImage-srcOffset-00272"}

For each element of `pRegions`, `srcOffset.z` and
(`extent.depth` +  `srcOffset.z`) :normative{type="must"} both be
greater than or equal to `0` and less than or equal to the depth of the
specified `srcSubresource` of `srcImage`
::

::validity-field{name="VUID-vkCmdResolveImage-srcImage-00273"}

If `srcImage` is of type `VK_IMAGE_TYPE_1D` or
`VK_IMAGE_TYPE_2D`, then for each element of `pRegions`,
`srcOffset.z` :normative{type="must"} be `0` and `extent.depth` :normative{type="must"} be `1`
::

::validity-field{name="VUID-vkCmdResolveImage-dstOffset-00274"}

For each element of `pRegions`, `dstOffset.x` and
(`extent.width` +  `dstOffset.x`) :normative{type="must"} both be
greater than or equal to `0` and less than or equal to the width of the
specified `dstSubresource` of `dstImage`
::

::validity-field{name="VUID-vkCmdResolveImage-dstOffset-00275"}

For each element of `pRegions`, `dstOffset.y` and
(`extent.height` +  `dstOffset.y`) :normative{type="must"} both be
greater than or equal to `0` and less than or equal to the height of the
specified `dstSubresource` of `dstImage`
::

::validity-field{name="VUID-vkCmdResolveImage-dstImage-00276"}

If `dstImage` is of type `VK_IMAGE_TYPE_1D`, then for each
element of `pRegions`, `dstOffset.y` :normative{type="must"} be `0` and
`extent.height` :normative{type="must"} be `1`
::

::validity-field{name="VUID-vkCmdResolveImage-dstOffset-00277"}

For each element of `pRegions`, `dstOffset.z` and
(`extent.depth` +  `dstOffset.z`) :normative{type="must"} both be
greater than or equal to `0` and less than or equal to the depth of the
specified `dstSubresource` of `dstImage`
::

::validity-field{name="VUID-vkCmdResolveImage-dstImage-00278"}

If `dstImage` is of type `VK_IMAGE_TYPE_1D` or
`VK_IMAGE_TYPE_2D`, then for each element of `pRegions`,
`dstOffset.z` :normative{type="must"} be `0` and `extent.depth` :normative{type="must"} be `1`
::

::validity-field{name="VUID-vkCmdResolveImage-srcImage-06762"}
`srcImage` :normative{type="must"} have been created with
`VK_IMAGE_USAGE_TRANSFER_SRC_BIT` usage flag
::

::validity-field{name="VUID-vkCmdResolveImage-dstImage-06764"}
`dstImage` :normative{type="must"} have been created with
`VK_IMAGE_USAGE_TRANSFER_DST_BIT` usage flag
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdResolveImage-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdResolveImage-srcImage-parameter"}
 `srcImage` :normative{type="must"} be a valid [VkImage](/man/VkImage) handle
::

::validity-field{name="VUID-vkCmdResolveImage-srcImageLayout-parameter"}
 `srcImageLayout` :normative{type="must"} be a valid [VkImageLayout](/man/VkImageLayout) value
::

::validity-field{name="VUID-vkCmdResolveImage-dstImage-parameter"}
 `dstImage` :normative{type="must"} be a valid [VkImage](/man/VkImage) handle
::

::validity-field{name="VUID-vkCmdResolveImage-dstImageLayout-parameter"}
 `dstImageLayout` :normative{type="must"} be a valid [VkImageLayout](/man/VkImageLayout) value
::

::validity-field{name="VUID-vkCmdResolveImage-pRegions-parameter"}
 `pRegions` :normative{type="must"} be a valid pointer to an array of `regionCount` valid [VkImageResolve](/man/VkImageResolve) structures
::

::validity-field{name="VUID-vkCmdResolveImage-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdResolveImage-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics operations
::

::validity-field{name="VUID-vkCmdResolveImage-renderpass"}
 This command :normative{type="must"} only be called outside of a render pass instance
::

::validity-field{name="VUID-vkCmdResolveImage-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdResolveImage-regionCount-arraylength"}
 `regionCount` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-vkCmdResolveImage-commonparent"}
 Each of `commandBuffer`, `dstImage`, and `srcImage` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::






The `VkImageResolve` structure is defined as:

[{generated}/api/structs/VkImageResolve.adoc]({generated}/api/structs/VkImageResolve.adoc)

- `srcSubresource` and `dstSubresource` are
  [VkImageSubresourceLayers](/man/VkImageSubresourceLayers) structures specifying the image
  subresources of the images used for the source and destination image
  data, respectively.
  Resolve of depth/stencil images is not supported.

- `srcOffset` and `dstOffset` select the initial `x`, `y`,
  and `z` offsets in texels of the sub-regions of the source and
  destination image data.

- `extent` is the size in texels of the source image to resolve in
  `width`, `height` and `depth`.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkImageResolve-aspectMask-00266"}

The `aspectMask` member of `srcSubresource` and
`dstSubresource` :normative{type="must"} only contain `VK_IMAGE_ASPECT_COLOR_BIT`
::

::validity-field{name="VUID-VkImageResolve-layerCount-08803"}

The
    `layerCount` member of `srcSubresource` and `dstSubresource`
    :normative{type="must"} match
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkImageResolve-srcSubresource-parameter"}
 `srcSubresource` :normative{type="must"} be a valid [VkImageSubresourceLayers](/man/VkImageSubresourceLayers) structure
::

::validity-field{name="VUID-VkImageResolve-dstSubresource-parameter"}
 `dstSubresource` :normative{type="must"} be a valid [VkImageSubresourceLayers](/man/VkImageSubresourceLayers) structure
::

::








# Drawing Commands

*Drawing commands* (commands with `Draw` in the name) provoke work in a
graphics pipeline.
Drawing commands are recorded into a command buffer and when executed by a
queue, will produce work which executes according to the bound graphics
pipeline.
A graphics pipeline
:normative{type="must"} be bound to a command buffer before any drawing commands are recorded
in that command buffer.

Each draw is made up of zero or more vertices and zero or more instances,
which are processed by the device and result in the assembly of primitives.
Primitives are assembled according to the `pInputAssemblyState` member
of the [VkGraphicsPipelineCreateInfo](/man/VkGraphicsPipelineCreateInfo) structure, which is of type
`VkPipelineInputAssemblyStateCreateInfo`:

[{generated}/api/structs/VkPipelineInputAssemblyStateCreateInfo.adoc]({generated}/api/structs/VkPipelineInputAssemblyStateCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is reserved for future use.

- `topology` is a [VkPrimitiveTopology](/man/VkPrimitiveTopology) defining the primitive
  topology, as described below.

- `primitiveRestartEnable` controls whether a special vertex index
  value is treated as restarting the assembly of primitives.
  This enable only applies to indexed draws ([vkCmdDrawIndexed](/man/vkCmdDrawIndexed),
  and [vkCmdDrawIndexedIndirect](/man/vkCmdDrawIndexedIndirect)), and the special index value is
  either 0xFFFFFFFF when the `indexType` parameter of
  `vkCmdBindIndexBuffer` is equal to `VK_INDEX_TYPE_UINT32`,
  or 0xFFFF when `indexType` is equal to `VK_INDEX_TYPE_UINT16`.
  Primitive restart is not allowed for > list topologies.

Restarting the assembly of primitives discards the most recent index values
if those elements formed an incomplete primitive, and restarts the primitive
assembly using the subsequent indices, but only assembling the immediately
following element through the end of the originally specified elements.
The primitive restart index value comparison is performed before adding the
`vertexOffset` value to the index value.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkPipelineInputAssemblyStateCreateInfo-topology-06252"}

If
`topology` is `VK_PRIMITIVE_TOPOLOGY_POINT_LIST`,
`VK_PRIMITIVE_TOPOLOGY_LINE_LIST`,
`VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST`,
`VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY`, or
`VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY`,
`primitiveRestartEnable` :normative{type="must"} be `VK_FALSE`
::

::validity-field{name="VUID-VkPipelineInputAssemblyStateCreateInfo-topology-06253"}

If
`topology` is `VK_PRIMITIVE_TOPOLOGY_PATCH_LIST`,
`primitiveRestartEnable` :normative{type="must"} be `VK_FALSE`
::

::validity-field{name="VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00429"}

If the `geometryShader` feature is not
enabled, `topology` :normative{type="must"} not be any of
`VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY`,
`VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY`,
`VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY` or
`VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY`
::

::validity-field{name="VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00430"}

If the `tessellationShader` feature
is not enabled, `topology` :normative{type="must"} not be
`VK_PRIMITIVE_TOPOLOGY_PATCH_LIST`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkPipelineInputAssemblyStateCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO`
::

::validity-field{name="VUID-VkPipelineInputAssemblyStateCreateInfo-pNext-pNext"}
 `pNext` :normative{type="must"} be `NULL`
::

::validity-field{name="VUID-VkPipelineInputAssemblyStateCreateInfo-flags-zerobitmask"}
 `flags` :normative{type="must"} be `0`
::

::validity-field{name="VUID-VkPipelineInputAssemblyStateCreateInfo-topology-parameter"}
 `topology` :normative{type="must"} be a valid [VkPrimitiveTopology](/man/VkPrimitiveTopology) value
::

::


[{generated}/api/flags/VkPipelineInputAssemblyStateCreateFlags.adoc]({generated}/api/flags/VkPipelineInputAssemblyStateCreateFlags.adoc)

`VkPipelineInputAssemblyStateCreateFlags` is a bitmask type for setting
a mask, but is currently reserved for future use.



## Primitive Topologies

*Primitive topology* determines how consecutive vertices are organized into
primitives, and determines the type of primitive that is used at the
beginning of the graphics pipeline.
The effective topology for later stages of the pipeline is altered by
tessellation or geometry shading (if either is in use) and depends on the
execution modes of those shaders.

The primitive topologies defined by [VkPrimitiveTopology](/man/VkPrimitiveTopology) are:

[{generated}/api/enums/VkPrimitiveTopology.adoc]({generated}/api/enums/VkPrimitiveTopology.adoc)

- `VK_PRIMITIVE_TOPOLOGY_POINT_LIST` specifies a series of
  separate point primitives.

- `VK_PRIMITIVE_TOPOLOGY_LINE_LIST` specifies a series of
  separate line primitives.

- `VK_PRIMITIVE_TOPOLOGY_LINE_STRIP` specifies a series of
  connected line primitives with consecutive lines
  sharing a vertex.

- `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST` specifies a series of
  separate triangle primitives.

- `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP` specifies a series of
  connected triangle primitives with
  consecutive triangles sharing an edge.

- `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN` specifies a series of
  connected triangle primitives with all
  triangles sharing a common vertex.

- `VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY` specifies a series
  of separate line primitives with
  adjacency.

- `VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY` specifies a series
  of connected line primitives with
  adjacency, with consecutive primitives sharing three vertices.

- `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY` specifies a
  series of separate triangle
  primitives with adjacency.

- `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY` specifies
  connected triangle primitives
  with adjacency, with consecutive triangles sharing an edge.

- `VK_PRIMITIVE_TOPOLOGY_PATCH_LIST` specifies
  separate patch primitives.

Each primitive topology, and its construction from a list of vertices, is
described in detail below with a supporting diagram, according to the
following key:



The diagrams are supported with mathematical definitions where the vertices
(v) and primitives (p) are numbered starting from 0;
v\<sub>0\</sub> is the first vertex in the provided data and p\<sub>0\</sub> is the
first primitive in the set of primitives defined by the vertices and
topology.



### Point Lists

When the topology is `VK_PRIMITIVE_TOPOLOGY_POINT_LIST`, each
consecutive vertex defines a single point primitive, according to the
equation:



As there is only one vertex, that vertex is the provoking vertex.
The number of primitives generated is equal to `vertexCount`.







### Line Lists

When the primitive topology is `VK_PRIMITIVE_TOPOLOGY_LINE_LIST`, each
consecutive pair of vertices defines a single line primitive, according to
the equation:



The number of primitives generated is equal to
⌊`vertexCount`/2⌋.

The
provoking vertex for p\<sub>i\</sub> is v\<sub>2i\</sub>.







### Line Strips

When the primitive topology is `VK_PRIMITIVE_TOPOLOGY_LINE_STRIP`, one
line primitive is defined by each vertex and the following vertex, according
to the equation:



The number of primitives generated is equal to
max(0,`vertexCount`-1).

The
provoking vertex for p\<sub>i\</sub> is v\<sub>i\</sub>.







### Triangle Lists

When the primitive topology is `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST`,
each consecutive set of three vertices defines a single triangle primitive,
according to the equation:



The number of primitives generated is equal to
⌊`vertexCount`/3⌋.

The
provoking vertex for p\<sub>i\</sub> is v\<sub>3i\</sub>.







### Triangle Strips

When the primitive topology is `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP`,
one triangle primitive is defined by each vertex and the two vertices that
follow it, according to the equation:



The number of primitives generated is equal to
max(0,`vertexCount`-2).

The
provoking vertex for p\<sub>i\</sub> is v\<sub>i\</sub>.




::note
The ordering of the vertices in each successive triangle is reversed, so
that the winding order is consistent throughout the strip.
::






### Triangle Fans

When the primitive topology is `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN`,
triangle primitives are defined around a shared common vertex, according to
the equation:



The number of primitives generated is equal to
max(0,`vertexCount`-2).

The
provoking vertex for p\<sub>i\</sub> is v\<sub>i+1\</sub>.







### Line Lists With Adjacency

When the primitive topology is
`VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY`, each consecutive set
of four vertices defines a single line primitive with adjacency, according
to the equation:



A line primitive is described by the second and third vertices of the total
primitive, with the remaining two vertices only accessible in a
geometry shader.

The number of primitives generated is equal to
⌊`vertexCount`/4⌋.

The
provoking vertex for p\<sub>i\</sub> is v\<sub>4i+1\</sub>.







### Line Strips With Adjacency

When the primitive topology is
`VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY`, one line primitive
with adjacency is defined by each vertex and the following vertex, according
to the equation:



A line primitive is described by the second and third vertices of the total
primitive, with the remaining two vertices only accessible in a
geometry shader.

The number of primitives generated is equal to
max(0,`vertexCount`-3).

The
provoking vertex for p\<sub>i\</sub> is v\<sub>i+1\</sub>.







### Triangle Lists With Adjacency

When the primitive topology is
`VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY`, each consecutive
set of six vertices defines a single triangle primitive with adjacency,
according to the equations:



A triangle primitive is described by the first, third, and fifth vertices of
the total primitive, with the remaining three vertices only accessible in a
geometry shader.

The number of primitives generated is equal to
⌊`vertexCount`/6⌋.

The
provoking vertex for p\<sub>i\</sub> is v\<sub>6i\</sub>.







### Triangle Strips With Adjacency

When the primitive topology is
`VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY`, one triangle
primitive with adjacency is defined by each vertex and the following 5
vertices.

The number of primitives generated, n, is equal to ⌊max(0,
`vertexCount` - 4)/2⌋.

If n=1, the primitive is defined as:



If n>1, the total primitive consists of different vertices according
to where it is in the strip:



A triangle primitive is described by the first, third, and fifth vertices of
the total primitive in all cases, with the remaining three vertices only
accessible in a geometry shader.


::note
The ordering of the vertices in each successive triangle is altered so that
the winding order is consistent throughout the strip.
::


The
provoking vertex for p\<sub>i\</sub> is always v\<sub>2i\</sub>.







### Patch Lists

When the primitive topology is `VK_PRIMITIVE_TOPOLOGY_PATCH_LIST`, each
consecutive set of m vertices defines a single patch primitive,
according to the equation:



where m is equal to
[VkPipelineTessellationStateCreateInfo](/man/VkPipelineTessellationStateCreateInfo)::`patchControlPoints`.

Patch lists are never passed to vertex post-processing,
and as such no provoking vertex is defined for patch primitives.
The number of primitives generated is equal to
⌊`vertexCount`/m⌋.

The vertices comprising a patch have no implied geometry, and are used as
inputs to tessellation shaders and the fixed-function tessellator to
generate new point, line, or triangle primitives.







## Primitive Order

Primitives generated by drawing commands progress through the
stages of the graphics pipeline in
*primitive order*.
Primitive order is initially determined in the following way:

1) Submission order determines the initial ordering

2) For indirect drawing commands, the order in which accessed instances of
   the [VkDrawIndirectCommand](/man/VkDrawIndirectCommand) are stored in `buffer`, from lower
   indirect buffer addresses to higher addresses.

3) If a drawing command includes multiple instances, the order in which
   instances are executed, from lower numbered instances to higher.

4) The order in which primitives are specified by a drawing command:





   * For non-indexed draws, from vertices with a lower numbered
     `vertexIndex` to a higher numbered `vertexIndex`.

   * For indexed draws, vertices sourced from a lower index buffer addresses
     to higher addresses.

Within this order implementations further sort primitives:

1) If tessellation shading is active, by an implementation-dependent order
   of new primitives generated by tessellation.

2) If geometry shading is active, by the order new primitives are generated
   by geometry shading.

3) If the polygon mode is not
   `VK_POLYGON_MODE_FILL`,
   by an implementation-dependent ordering of the new primitives generated
   within the original primitive.

Primitive order is later used to define rasterization
order, which determines the order in which fragments output results to a
framebuffer.





## Programmable Primitive Shading

Once primitives are assembled, they proceed to the vertex shading stage of
the pipeline.
If the draw includes multiple instances, then the set of primitives is sent
to the vertex shading stage multiple times, once for each instance.

It is implementation-dependent whether vertex shading occurs on vertices
that are discarded as part of incomplete primitives, but if it does occur
then it operates as if they were vertices in complete primitives and such
invocations :normative{type="can"} have side effects.

Vertex shading receives two per-vertex inputs from the primitive assembly
stage - the `vertexIndex` and the `instanceIndex`.
How these values are generated is defined below, with each command.

Drawing commands fall roughly into two categories:

- Non-indexed drawing commands present a sequential `vertexIndex` to
  the vertex shader.
  The sequential index is generated automatically by the device (see
  Fixed-Function Vertex Processing for details on both
  specifying the vertex attributes indexed by `vertexIndex`, as well as
  binding vertex buffers containing those attributes to a command buffer).
  These commands are:





  * [vkCmdDraw](/man/vkCmdDraw)

  * [vkCmdDrawIndirect](/man/vkCmdDrawIndirect)

- Indexed drawing commands read index values from an *index buffer* and
  use this to compute the `vertexIndex` value for the vertex shader.
  These commands are:





  * [vkCmdDrawIndexed](/man/vkCmdDrawIndexed)

  * [vkCmdDrawIndexedIndirect](/man/vkCmdDrawIndexedIndirect)

To bind an index buffer to a command buffer, call:

[{generated}/api/protos/vkCmdBindIndexBuffer.adoc]({generated}/api/protos/vkCmdBindIndexBuffer.adoc)

- `commandBuffer` is the command buffer into which the command is
  recorded.

- `buffer` is the buffer being bound.

- `offset` is the starting offset in bytes within `buffer` used in
  index buffer address calculations.

- `indexType` is a [VkIndexType](/man/VkIndexType) value specifying the size of the
  indices.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdBindIndexBuffer-offset-08782"}
`offset` :normative{type="must"} be less than the size of `buffer`
::

::validity-field{name="VUID-vkCmdBindIndexBuffer-offset-08783"}

The sum of `offset` and the base address of the range of
`VkDeviceMemory` object that is backing `buffer`, :normative{type="must"} be a
multiple of the size of the type indicated by `indexType`
::

::validity-field{name="VUID-vkCmdBindIndexBuffer-buffer-08784"}
`buffer` :normative{type="must"} have been created with the
`VK_BUFFER_USAGE_INDEX_BUFFER_BIT` flag
::

::validity-field{name="VUID-vkCmdBindIndexBuffer-buffer-08785"}

If `buffer` is non-sparse then it :normative{type="must"} be bound completely and
contiguously to a single `VkDeviceMemory` object
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdBindIndexBuffer-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdBindIndexBuffer-buffer-parameter"}
 `buffer` :normative{type="must"} be a valid [VkBuffer](/man/VkBuffer) handle
::

::validity-field{name="VUID-vkCmdBindIndexBuffer-indexType-parameter"}
 `indexType` :normative{type="must"} be a valid [VkIndexType](/man/VkIndexType) value
::

::validity-field{name="VUID-vkCmdBindIndexBuffer-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdBindIndexBuffer-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics operations
::

::validity-field{name="VUID-vkCmdBindIndexBuffer-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdBindIndexBuffer-commonparent"}
 Both of `buffer`, and `commandBuffer` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::






Possible values of
[vkCmdBindIndexBuffer](/man/vkCmdBindIndexBuffer)::`indexType`, specifying the size of indices,
are:

[{generated}/api/enums/VkIndexType.adoc]({generated}/api/enums/VkIndexType.adoc)

- `VK_INDEX_TYPE_UINT16` specifies that indices are 16-bit unsigned
  integer values.

- `VK_INDEX_TYPE_UINT32` specifies that indices are 32-bit unsigned
  integer values.

The parameters for each drawing command are specified directly in the
command or read from buffer memory, depending on the command.
Drawing commands that source their parameters from buffer memory are known
as *indirect* drawing commands.

All drawing commands interact with the `robustBufferAccess` feature.

To record a non-indexed draw, call:

[{generated}/api/protos/vkCmdDraw.adoc]({generated}/api/protos/vkCmdDraw.adoc)

- `commandBuffer` is the command buffer into which the command is
  recorded.

- `vertexCount` is the number of vertices to draw.

- `instanceCount` is the number of instances to draw.

- `firstVertex` is the index of the first vertex to draw.

- `firstInstance` is the instance ID of the first instance to draw.

When the command is executed, primitives are assembled using the current
primitive topology and `vertexCount` consecutive vertex indices with the
first `vertexIndex` value equal to `firstVertex`.
The primitives are drawn `instanceCount` times with `instanceIndex`
starting with `firstInstance` and increasing sequentially for each
instance.
The assembled primitives execute the bound graphics pipeline.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdDraw-magFilter-04553"}

If a [VkSampler](/man/VkSampler) created with `magFilter` or `minFilter`
equal to `VK_FILTER_LINEAR` and `compareEnable` equal to
`VK_FALSE` is used to sample a [VkImageView](/man/VkImageView) as a result of this
command, then the image view’s
format features :normative{type="must"} contain
`VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT`
::

::validity-field{name="VUID-vkCmdDraw-mipmapMode-04770"}

If a [VkSampler](/man/VkSampler) created with `mipmapMode` equal to
`VK_SAMPLER_MIPMAP_MODE_LINEAR` and `compareEnable` equal to
`VK_FALSE` is used to sample a [VkImageView](/man/VkImageView) as a result of this
command, then the image view’s
format features :normative{type="must"} contain
`VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT`
::

::validity-field{name="VUID-vkCmdDraw-aspectMask-06478"}

If a [VkImageView](/man/VkImageView) is sampled with
depth comparison, the image view
:normative{type="must"} have been created with an `aspectMask` that contains
`VK_IMAGE_ASPECT_DEPTH_BIT`
::

::validity-field{name="VUID-vkCmdDraw-None-02691"}

If a [VkImageView](/man/VkImageView) is accessed using atomic operations as a result
of this command, then the image view’s
format features :normative{type="must"} contain
`VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT`
::

::validity-field{name="VUID-vkCmdDraw-None-07888"}

If a `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` descriptor is
accessed using atomic operations as a result of this command, then the
storage texel buffer’s format
features :normative{type="must"} contain
`VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT`
::

::validity-field{name="VUID-vkCmdDraw-None-02697"}

For each set *n* that is statically used by a bound
shader, a descriptor set :normative{type="must"} have been bound to *n* at the same
pipeline bind point, with a [VkPipelineLayout](/man/VkPipelineLayout) that is compatible
for set *n*, with the [VkPipelineLayout](/man/VkPipelineLayout) used to create the current
[VkPipeline](/man/VkPipeline), as described in 
::

::validity-field{name="VUID-vkCmdDraw-None-02698"}

For each push constant that is statically used by a
bound shader, a push constant value :normative{type="must"} have been set for the same
pipeline bind point, with a [VkPipelineLayout](/man/VkPipelineLayout) that is compatible
for push constants, with the [VkPipelineLayout](/man/VkPipelineLayout) used to create the
current [VkPipeline](/man/VkPipeline), as described in

::

::validity-field{name="VUID-vkCmdDraw-None-02699"}

Descriptors in each bound descriptor set, specified via
[vkCmdBindDescriptorSets](/man/vkCmdBindDescriptorSets), :normative{type="must"} be valid as described by
descriptor validity if they are statically used
by a bound shader
::

::validity-field{name="VUID-vkCmdDraw-None-02700"}

A valid pipeline :normative{type="must"} be bound to the pipeline bind point used by this
command
::

::validity-field{name="VUID-vkCmdDraw-None-02859"}

There :normative{type="must"} not have been any calls to dynamic state setting commands
for any state not specified as dynamic in the [VkPipeline](/man/VkPipeline) object
bound to the pipeline bind point used by this command, since that
pipeline was bound
::

::validity-field{name="VUID-vkCmdDraw-None-02702"}

If the [VkPipeline](/man/VkPipeline) object bound to the pipeline bind point used by
this command accesses a [VkSampler](/man/VkSampler) object that uses unnormalized
coordinates, that sampler :normative{type="must"} not be used to sample from any
[VkImage](/man/VkImage) with a [VkImageView](/man/VkImageView) of the type
`VK_IMAGE_VIEW_TYPE_3D`, `VK_IMAGE_VIEW_TYPE_CUBE`,
`VK_IMAGE_VIEW_TYPE_1D_ARRAY`, `VK_IMAGE_VIEW_TYPE_2D_ARRAY` or
`VK_IMAGE_VIEW_TYPE_CUBE_ARRAY`, in any shader stage
::

::validity-field{name="VUID-vkCmdDraw-None-02703"}

If the [VkPipeline](/man/VkPipeline) object bound to the pipeline bind point used by
this command accesses a [VkSampler](/man/VkSampler) object that uses unnormalized
coordinates, that sampler :normative{type="must"} not be used with any of the SPIR-V
`OpImageSample*` or `OpImageSparseSample*` instructions with
`ImplicitLod`, `Dref` or `Proj` in their name, in any shader
stage
::

::validity-field{name="VUID-vkCmdDraw-None-02704"}

If the [VkPipeline](/man/VkPipeline) object bound to the pipeline bind point used by
this command accesses a [VkSampler](/man/VkSampler) object that uses unnormalized
coordinates, that sampler :normative{type="must"} not be used with any of the SPIR-V
`OpImageSample*` or `OpImageSparseSample*` instructions that includes a
LOD bias or any offset values, in any shader stage
::

::validity-field{name="VUID-vkCmdDraw-None-02705"}

If the `robustBufferAccess` feature
is not enabled, and if the [VkPipeline](/man/VkPipeline) object bound to the pipeline
bind point used by this command accesses a uniform buffer, it :normative{type="must"} not
access values outside of the range of the buffer as specified in the
descriptor set bound to the same pipeline bind point
::

::validity-field{name="VUID-vkCmdDraw-None-02706"}

If the `robustBufferAccess` feature
is not enabled, and if the [VkPipeline](/man/VkPipeline) object bound to the pipeline
bind point used by this command accesses a storage buffer, it :normative{type="must"} not
access values outside of the range of the buffer as specified in the
descriptor set bound to the same pipeline bind point
::

::validity-field{name="VUID-vkCmdDraw-viewType-07752"}

If a [VkImageView](/man/VkImageView) is accessed as a result of this command, then the
image view’s `viewType` :normative{type="must"} match the `Dim` operand of the
`OpTypeImage` as described in 
::

::validity-field{name="VUID-vkCmdDraw-format-07753"}

If a [VkImageView](/man/VkImageView) is accessed as a result of this command, then the
numeric type of the image view’s `format`
and the `Sampled` `Type` operand of the `OpTypeImage` :normative{type="must"}
match
::

::validity-field{name="VUID-vkCmdDraw-OpImageWrite-08795"}

If a [VkImageView](/man/VkImageView)
is accessed using `OpImageWrite` as a result of this command, then
the `Type` of the `Texel` operand of that instruction :normative{type="must"} have
at least as many components as the image view’s format
::

::validity-field{name="VUID-vkCmdDraw-OpImageWrite-04469"}

If a [VkBufferView](/man/VkBufferView) is accessed using `OpImageWrite` as a result
of this command, then the `Type` of the `Texel` operand of that
instruction :normative{type="must"} have at least as many components as the buffer view’s
format
::

::validity-field{name="VUID-vkCmdDraw-None-07288"}

Any shader invocation executed by this command :normative{type="must"}
terminate
::

::validity-field{name="VUID-vkCmdDraw-renderPass-02684"}

The current render pass :normative{type="must"} be compatible
with the `renderPass` member of the
`VkGraphicsPipelineCreateInfo` structure specified when creating the
`VkPipeline` bound to `VK_PIPELINE_BIND_POINT_GRAPHICS`
::

::validity-field{name="VUID-vkCmdDraw-subpass-02685"}

The subpass index of the current render pass :normative{type="must"} be equal to the
`subpass` member of the `VkGraphicsPipelineCreateInfo` structure
specified when creating the `VkPipeline` bound to
`VK_PIPELINE_BIND_POINT_GRAPHICS`
::

::validity-field{name="VUID-vkCmdDraw-None-07748"}

If any shader statically accesses an input attachment, a valid
descriptor :normative{type="must"} be bound to the pipeline via a descriptor set
::

::validity-field{name="VUID-vkCmdDraw-OpTypeImage-07468"}

If any shader executed by this pipeline accesses an `OpTypeImage`
variable with a `Dim` operand of `SubpassData`, it :normative{type="must"} be
decorated with an `InputAttachmentIndex` that corresponds to a valid
input attachment in the current subpass
::

::validity-field{name="VUID-vkCmdDraw-None-07469"}

Input attachment views accessed in a subpass :normative{type="must"} be created with the
same [VkFormat](/man/VkFormat) as the corresponding subpass definition, and be
created with a [VkImageView](/man/VkImageView) that is compatible with the attachment
referenced by the subpass'
`pInputAttachments`[`InputAttachmentIndex`] in the currently
bound [VkFramebuffer](/man/VkFramebuffer) as specified by
Fragment Input Attachment
Compatibility
::

::validity-field{name="VUID-vkCmdDraw-None-06537"}

Memory backing image subresources used as attachments in the current
render pass :normative{type="must"} not be written in any way other than as an attachment
by this command
::

::validity-field{name="VUID-vkCmdDraw-None-09000"}

If a color attachment is written by any prior command in this subpass or
by the load, store, or resolve operations for this subpass,
it :normative{type="must"} not be accessed in any way other than as an attachment by this
command
::

::validity-field{name="VUID-vkCmdDraw-None-09001"}

If a depth attachment is written by any prior command in this subpass or
by the load, store, or resolve operations for this subpass,
it :normative{type="must"} not be accessed in any way other than as an attachment by this
command
::

::validity-field{name="VUID-vkCmdDraw-None-09002"}

If a stencil attachment is written by any prior command in this subpass
or by the load, store, or resolve operations for this subpass,
it :normative{type="must"} not be accessed in any way other than as an attachment by this
command
::

::validity-field{name="VUID-vkCmdDraw-None-06539"}

If any previously recorded command in the current subpass accessed an
image subresource used as an attachment in this subpass in any way other
than as an attachment, this command :normative{type="must"} not write to that image
subresource as an attachment
::

::validity-field{name="VUID-vkCmdDraw-None-06886"}

If the current render pass instance uses a depth/stencil attachment with
a read-only layout for the depth aspect, depth
writes :normative{type="must"} be disabled
::

::validity-field{name="VUID-vkCmdDraw-None-06887"}

If the current render pass instance uses a depth/stencil attachment with
a read-only layout for the stencil aspect, both front and back
`writeMask` are not zero, and stencil test is enabled,
all stencil ops :normative{type="must"} be `VK_STENCIL_OP_KEEP`
::

::validity-field{name="VUID-vkCmdDraw-None-07831"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_VIEWPORT` dynamic state enabled then
[vkCmdSetViewport](/man/vkCmdSetViewport) :normative{type="must"} have been called in the current command
buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDraw-None-07832"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_SCISSOR` dynamic state enabled then
[vkCmdSetScissor](/man/vkCmdSetScissor) :normative{type="must"} have been called in the current command
buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDraw-None-07833"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_LINE_WIDTH` dynamic state enabled then
[vkCmdSetLineWidth](/man/vkCmdSetLineWidth) :normative{type="must"} have been called in the current command
buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDraw-None-07834"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_DEPTH_BIAS` dynamic state enabled then
[vkCmdSetDepthBias](/man/vkCmdSetDepthBias)
:normative{type="must"} have been called in the current command buffer prior to this
drawing command
::

::validity-field{name="VUID-vkCmdDraw-None-07835"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_BLEND_CONSTANTS` dynamic state enabled then
[vkCmdSetBlendConstants](/man/vkCmdSetBlendConstants) :normative{type="must"} have been called in the current
command buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDraw-None-07836"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_DEPTH_BOUNDS` dynamic state enabled, and if the
current `depthBoundsTestEnable` state is `VK_TRUE`, then
[vkCmdSetDepthBounds](/man/vkCmdSetDepthBounds) :normative{type="must"} have been called in the current command
buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDraw-None-07837"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK` dynamic state enabled, and
if the current `stencilTestEnable` state is `VK_TRUE`, then
[vkCmdSetStencilCompareMask](/man/vkCmdSetStencilCompareMask) :normative{type="must"} have been called in the current
command buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDraw-None-07838"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_STENCIL_WRITE_MASK` dynamic state enabled, and if
the current `stencilTestEnable` state is `VK_TRUE`, then
[vkCmdSetStencilWriteMask](/man/vkCmdSetStencilWriteMask) :normative{type="must"} have been called in the current
command buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDraw-None-07839"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_STENCIL_REFERENCE` dynamic state enabled, and if
the current `stencilTestEnable` state is `VK_TRUE`, then
[vkCmdSetStencilReference](/man/vkCmdSetStencilReference) :normative{type="must"} have been called in the current
command buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDraw-blendEnable-04727"}

If rasterization is not disabled in the bound graphics pipeline, then
for each color attachment in the subpass, if the corresponding image
view’s format features do not
contain `VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT`, then the
`blendEnable` member of the corresponding element of the
`pAttachments` member of `pColorBlendState` :normative{type="must"} be
`VK_FALSE`
::

::validity-field{name="VUID-vkCmdDraw-rasterizationSamples-04740"}

If rasterization is not disabled in the bound graphics pipeline, and
neither the  nor the
 extensions are enabled, then
`rasterizationSamples` for the currently bound graphics pipeline
:normative{type="must"} be the same as the current subpass color and/or depth/stencil
attachments
::

::validity-field{name="VUID-vkCmdDraw-maxFragmentDualSrcAttachments-09239"}

If blending is enabled for any attachment where
either the source or destination blend factors for that attachment
use the secondary color input, the maximum value of
`Location` for any output attachment statically
used in the `Fragment` `Execution` `Model` executed by this command
:normative{type="must"} be less than `maxFragmentDualSrcAttachments`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdDraw-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdDraw-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdDraw-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics operations
::

::validity-field{name="VUID-vkCmdDraw-renderpass"}
 This command :normative{type="must"} only be called inside of a render pass instance
::

::validity-field{name="VUID-vkCmdDraw-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::






To record an indexed draw, call:

[{generated}/api/protos/vkCmdDrawIndexed.adoc]({generated}/api/protos/vkCmdDrawIndexed.adoc)

- `commandBuffer` is the command buffer into which the command is
  recorded.

- `indexCount` is the number of vertices to draw.

- `instanceCount` is the number of instances to draw.

- `firstIndex` is the base index within the index buffer.

- `vertexOffset` is the value added to the vertex index before
  indexing into the vertex buffer.

- `firstInstance` is the instance ID of the first instance to draw.

When the command is executed, primitives are assembled using the current
primitive topology and `indexCount` vertices whose indices are retrieved
from the index buffer.
The index buffer is treated as an array of tightly packed unsigned integers
of size defined by the
[vkCmdBindIndexBuffer](/man/vkCmdBindIndexBuffer)::`indexType` parameter with which the buffer
was bound.

The first vertex index is at an offset of `firstIndex` ×
`indexSize` +  `offset` within the bound index buffer, where
`offset` is the offset specified by `vkCmdBindIndexBuffer`
and `indexSize` is the byte size of the type specified by
`indexType`.
Subsequent index values are retrieved from consecutive locations in the
index buffer.
Indices are first compared to the primitive restart value, then zero
extended to 32 bits (if the `indexType` is
`VK_INDEX_TYPE_UINT16`) and have `vertexOffset` added to them,
before being supplied as the `vertexIndex` value.

The primitives are drawn `instanceCount` times with `instanceIndex`
starting with `firstInstance` and increasing sequentially for each
instance.
The assembled primitives execute the bound graphics pipeline.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdDrawIndexed-magFilter-04553"}

If a [VkSampler](/man/VkSampler) created with `magFilter` or `minFilter`
equal to `VK_FILTER_LINEAR` and `compareEnable` equal to
`VK_FALSE` is used to sample a [VkImageView](/man/VkImageView) as a result of this
command, then the image view’s
format features :normative{type="must"} contain
`VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT`
::

::validity-field{name="VUID-vkCmdDrawIndexed-mipmapMode-04770"}

If a [VkSampler](/man/VkSampler) created with `mipmapMode` equal to
`VK_SAMPLER_MIPMAP_MODE_LINEAR` and `compareEnable` equal to
`VK_FALSE` is used to sample a [VkImageView](/man/VkImageView) as a result of this
command, then the image view’s
format features :normative{type="must"} contain
`VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT`
::

::validity-field{name="VUID-vkCmdDrawIndexed-aspectMask-06478"}

If a [VkImageView](/man/VkImageView) is sampled with
depth comparison, the image view
:normative{type="must"} have been created with an `aspectMask` that contains
`VK_IMAGE_ASPECT_DEPTH_BIT`
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-02691"}

If a [VkImageView](/man/VkImageView) is accessed using atomic operations as a result
of this command, then the image view’s
format features :normative{type="must"} contain
`VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT`
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-07888"}

If a `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` descriptor is
accessed using atomic operations as a result of this command, then the
storage texel buffer’s format
features :normative{type="must"} contain
`VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT`
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-02697"}

For each set *n* that is statically used by a bound
shader, a descriptor set :normative{type="must"} have been bound to *n* at the same
pipeline bind point, with a [VkPipelineLayout](/man/VkPipelineLayout) that is compatible
for set *n*, with the [VkPipelineLayout](/man/VkPipelineLayout) used to create the current
[VkPipeline](/man/VkPipeline), as described in 
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-02698"}

For each push constant that is statically used by a
bound shader, a push constant value :normative{type="must"} have been set for the same
pipeline bind point, with a [VkPipelineLayout](/man/VkPipelineLayout) that is compatible
for push constants, with the [VkPipelineLayout](/man/VkPipelineLayout) used to create the
current [VkPipeline](/man/VkPipeline), as described in

::

::validity-field{name="VUID-vkCmdDrawIndexed-None-02699"}

Descriptors in each bound descriptor set, specified via
[vkCmdBindDescriptorSets](/man/vkCmdBindDescriptorSets), :normative{type="must"} be valid as described by
descriptor validity if they are statically used
by a bound shader
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-02700"}

A valid pipeline :normative{type="must"} be bound to the pipeline bind point used by this
command
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-02859"}

There :normative{type="must"} not have been any calls to dynamic state setting commands
for any state not specified as dynamic in the [VkPipeline](/man/VkPipeline) object
bound to the pipeline bind point used by this command, since that
pipeline was bound
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-02702"}

If the [VkPipeline](/man/VkPipeline) object bound to the pipeline bind point used by
this command accesses a [VkSampler](/man/VkSampler) object that uses unnormalized
coordinates, that sampler :normative{type="must"} not be used to sample from any
[VkImage](/man/VkImage) with a [VkImageView](/man/VkImageView) of the type
`VK_IMAGE_VIEW_TYPE_3D`, `VK_IMAGE_VIEW_TYPE_CUBE`,
`VK_IMAGE_VIEW_TYPE_1D_ARRAY`, `VK_IMAGE_VIEW_TYPE_2D_ARRAY` or
`VK_IMAGE_VIEW_TYPE_CUBE_ARRAY`, in any shader stage
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-02703"}

If the [VkPipeline](/man/VkPipeline) object bound to the pipeline bind point used by
this command accesses a [VkSampler](/man/VkSampler) object that uses unnormalized
coordinates, that sampler :normative{type="must"} not be used with any of the SPIR-V
`OpImageSample*` or `OpImageSparseSample*` instructions with
`ImplicitLod`, `Dref` or `Proj` in their name, in any shader
stage
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-02704"}

If the [VkPipeline](/man/VkPipeline) object bound to the pipeline bind point used by
this command accesses a [VkSampler](/man/VkSampler) object that uses unnormalized
coordinates, that sampler :normative{type="must"} not be used with any of the SPIR-V
`OpImageSample*` or `OpImageSparseSample*` instructions that includes a
LOD bias or any offset values, in any shader stage
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-02705"}

If the `robustBufferAccess` feature
is not enabled, and if the [VkPipeline](/man/VkPipeline) object bound to the pipeline
bind point used by this command accesses a uniform buffer, it :normative{type="must"} not
access values outside of the range of the buffer as specified in the
descriptor set bound to the same pipeline bind point
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-02706"}

If the `robustBufferAccess` feature
is not enabled, and if the [VkPipeline](/man/VkPipeline) object bound to the pipeline
bind point used by this command accesses a storage buffer, it :normative{type="must"} not
access values outside of the range of the buffer as specified in the
descriptor set bound to the same pipeline bind point
::

::validity-field{name="VUID-vkCmdDrawIndexed-viewType-07752"}

If a [VkImageView](/man/VkImageView) is accessed as a result of this command, then the
image view’s `viewType` :normative{type="must"} match the `Dim` operand of the
`OpTypeImage` as described in 
::

::validity-field{name="VUID-vkCmdDrawIndexed-format-07753"}

If a [VkImageView](/man/VkImageView) is accessed as a result of this command, then the
numeric type of the image view’s `format`
and the `Sampled` `Type` operand of the `OpTypeImage` :normative{type="must"}
match
::

::validity-field{name="VUID-vkCmdDrawIndexed-OpImageWrite-08795"}

If a [VkImageView](/man/VkImageView)
is accessed using `OpImageWrite` as a result of this command, then
the `Type` of the `Texel` operand of that instruction :normative{type="must"} have
at least as many components as the image view’s format
::

::validity-field{name="VUID-vkCmdDrawIndexed-OpImageWrite-04469"}

If a [VkBufferView](/man/VkBufferView) is accessed using `OpImageWrite` as a result
of this command, then the `Type` of the `Texel` operand of that
instruction :normative{type="must"} have at least as many components as the buffer view’s
format
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-07288"}

Any shader invocation executed by this command :normative{type="must"}
terminate
::

::validity-field{name="VUID-vkCmdDrawIndexed-renderPass-02684"}

The current render pass :normative{type="must"} be compatible
with the `renderPass` member of the
`VkGraphicsPipelineCreateInfo` structure specified when creating the
`VkPipeline` bound to `VK_PIPELINE_BIND_POINT_GRAPHICS`
::

::validity-field{name="VUID-vkCmdDrawIndexed-subpass-02685"}

The subpass index of the current render pass :normative{type="must"} be equal to the
`subpass` member of the `VkGraphicsPipelineCreateInfo` structure
specified when creating the `VkPipeline` bound to
`VK_PIPELINE_BIND_POINT_GRAPHICS`
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-07748"}

If any shader statically accesses an input attachment, a valid
descriptor :normative{type="must"} be bound to the pipeline via a descriptor set
::

::validity-field{name="VUID-vkCmdDrawIndexed-OpTypeImage-07468"}

If any shader executed by this pipeline accesses an `OpTypeImage`
variable with a `Dim` operand of `SubpassData`, it :normative{type="must"} be
decorated with an `InputAttachmentIndex` that corresponds to a valid
input attachment in the current subpass
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-07469"}

Input attachment views accessed in a subpass :normative{type="must"} be created with the
same [VkFormat](/man/VkFormat) as the corresponding subpass definition, and be
created with a [VkImageView](/man/VkImageView) that is compatible with the attachment
referenced by the subpass'
`pInputAttachments`[`InputAttachmentIndex`] in the currently
bound [VkFramebuffer](/man/VkFramebuffer) as specified by
Fragment Input Attachment
Compatibility
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-06537"}

Memory backing image subresources used as attachments in the current
render pass :normative{type="must"} not be written in any way other than as an attachment
by this command
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-09000"}

If a color attachment is written by any prior command in this subpass or
by the load, store, or resolve operations for this subpass,
it :normative{type="must"} not be accessed in any way other than as an attachment by this
command
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-09001"}

If a depth attachment is written by any prior command in this subpass or
by the load, store, or resolve operations for this subpass,
it :normative{type="must"} not be accessed in any way other than as an attachment by this
command
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-09002"}

If a stencil attachment is written by any prior command in this subpass
or by the load, store, or resolve operations for this subpass,
it :normative{type="must"} not be accessed in any way other than as an attachment by this
command
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-06539"}

If any previously recorded command in the current subpass accessed an
image subresource used as an attachment in this subpass in any way other
than as an attachment, this command :normative{type="must"} not write to that image
subresource as an attachment
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-06886"}

If the current render pass instance uses a depth/stencil attachment with
a read-only layout for the depth aspect, depth
writes :normative{type="must"} be disabled
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-06887"}

If the current render pass instance uses a depth/stencil attachment with
a read-only layout for the stencil aspect, both front and back
`writeMask` are not zero, and stencil test is enabled,
all stencil ops :normative{type="must"} be `VK_STENCIL_OP_KEEP`
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-07831"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_VIEWPORT` dynamic state enabled then
[vkCmdSetViewport](/man/vkCmdSetViewport) :normative{type="must"} have been called in the current command
buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-07832"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_SCISSOR` dynamic state enabled then
[vkCmdSetScissor](/man/vkCmdSetScissor) :normative{type="must"} have been called in the current command
buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-07833"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_LINE_WIDTH` dynamic state enabled then
[vkCmdSetLineWidth](/man/vkCmdSetLineWidth) :normative{type="must"} have been called in the current command
buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-07834"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_DEPTH_BIAS` dynamic state enabled then
[vkCmdSetDepthBias](/man/vkCmdSetDepthBias)
:normative{type="must"} have been called in the current command buffer prior to this
drawing command
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-07835"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_BLEND_CONSTANTS` dynamic state enabled then
[vkCmdSetBlendConstants](/man/vkCmdSetBlendConstants) :normative{type="must"} have been called in the current
command buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-07836"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_DEPTH_BOUNDS` dynamic state enabled, and if the
current `depthBoundsTestEnable` state is `VK_TRUE`, then
[vkCmdSetDepthBounds](/man/vkCmdSetDepthBounds) :normative{type="must"} have been called in the current command
buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-07837"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK` dynamic state enabled, and
if the current `stencilTestEnable` state is `VK_TRUE`, then
[vkCmdSetStencilCompareMask](/man/vkCmdSetStencilCompareMask) :normative{type="must"} have been called in the current
command buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-07838"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_STENCIL_WRITE_MASK` dynamic state enabled, and if
the current `stencilTestEnable` state is `VK_TRUE`, then
[vkCmdSetStencilWriteMask](/man/vkCmdSetStencilWriteMask) :normative{type="must"} have been called in the current
command buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndexed-None-07839"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_STENCIL_REFERENCE` dynamic state enabled, and if
the current `stencilTestEnable` state is `VK_TRUE`, then
[vkCmdSetStencilReference](/man/vkCmdSetStencilReference) :normative{type="must"} have been called in the current
command buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndexed-blendEnable-04727"}

If rasterization is not disabled in the bound graphics pipeline, then
for each color attachment in the subpass, if the corresponding image
view’s format features do not
contain `VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT`, then the
`blendEnable` member of the corresponding element of the
`pAttachments` member of `pColorBlendState` :normative{type="must"} be
`VK_FALSE`
::

::validity-field{name="VUID-vkCmdDrawIndexed-rasterizationSamples-04740"}

If rasterization is not disabled in the bound graphics pipeline, and
neither the  nor the
 extensions are enabled, then
`rasterizationSamples` for the currently bound graphics pipeline
:normative{type="must"} be the same as the current subpass color and/or depth/stencil
attachments
::

::validity-field{name="VUID-vkCmdDrawIndexed-maxFragmentDualSrcAttachments-09239"}

If blending is enabled for any attachment where
either the source or destination blend factors for that attachment
use the secondary color input, the maximum value of
`Location` for any output attachment statically
used in the `Fragment` `Execution` `Model` executed by this command
:normative{type="must"} be less than `maxFragmentDualSrcAttachments`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdDrawIndexed-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdDrawIndexed-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdDrawIndexed-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics operations
::

::validity-field{name="VUID-vkCmdDrawIndexed-renderpass"}
 This command :normative{type="must"} only be called inside of a render pass instance
::

::validity-field{name="VUID-vkCmdDrawIndexed-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::






To record a non-indexed indirect drawing command, call:

[{generated}/api/protos/vkCmdDrawIndirect.adoc]({generated}/api/protos/vkCmdDrawIndirect.adoc)

- `commandBuffer` is the command buffer into which the command is
  recorded.

- `buffer` is the buffer containing draw parameters.

- `offset` is the byte offset into `buffer` where parameters
  begin.

- `drawCount` is the number of draws to execute, and :normative{type="can"} be zero.

- `stride` is the byte stride between successive sets of draw
  parameters.

`vkCmdDrawIndirect` behaves similarly to [vkCmdDraw](/man/vkCmdDraw) except that the
parameters are read by the device from a buffer during execution.
`drawCount` draws are executed by the command, with parameters taken
from `buffer` starting at `offset` and increasing by `stride`
bytes for each successive draw.
The parameters of each draw are encoded in an array of
[VkDrawIndirectCommand](/man/VkDrawIndirectCommand) structures.
If `drawCount` is less than or equal to one, `stride` is ignored.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdDrawIndirect-magFilter-04553"}

If a [VkSampler](/man/VkSampler) created with `magFilter` or `minFilter`
equal to `VK_FILTER_LINEAR` and `compareEnable` equal to
`VK_FALSE` is used to sample a [VkImageView](/man/VkImageView) as a result of this
command, then the image view’s
format features :normative{type="must"} contain
`VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT`
::

::validity-field{name="VUID-vkCmdDrawIndirect-mipmapMode-04770"}

If a [VkSampler](/man/VkSampler) created with `mipmapMode` equal to
`VK_SAMPLER_MIPMAP_MODE_LINEAR` and `compareEnable` equal to
`VK_FALSE` is used to sample a [VkImageView](/man/VkImageView) as a result of this
command, then the image view’s
format features :normative{type="must"} contain
`VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT`
::

::validity-field{name="VUID-vkCmdDrawIndirect-aspectMask-06478"}

If a [VkImageView](/man/VkImageView) is sampled with
depth comparison, the image view
:normative{type="must"} have been created with an `aspectMask` that contains
`VK_IMAGE_ASPECT_DEPTH_BIT`
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-02691"}

If a [VkImageView](/man/VkImageView) is accessed using atomic operations as a result
of this command, then the image view’s
format features :normative{type="must"} contain
`VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT`
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-07888"}

If a `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` descriptor is
accessed using atomic operations as a result of this command, then the
storage texel buffer’s format
features :normative{type="must"} contain
`VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT`
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-02697"}

For each set *n* that is statically used by a bound
shader, a descriptor set :normative{type="must"} have been bound to *n* at the same
pipeline bind point, with a [VkPipelineLayout](/man/VkPipelineLayout) that is compatible
for set *n*, with the [VkPipelineLayout](/man/VkPipelineLayout) used to create the current
[VkPipeline](/man/VkPipeline), as described in 
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-02698"}

For each push constant that is statically used by a
bound shader, a push constant value :normative{type="must"} have been set for the same
pipeline bind point, with a [VkPipelineLayout](/man/VkPipelineLayout) that is compatible
for push constants, with the [VkPipelineLayout](/man/VkPipelineLayout) used to create the
current [VkPipeline](/man/VkPipeline), as described in

::

::validity-field{name="VUID-vkCmdDrawIndirect-None-02699"}

Descriptors in each bound descriptor set, specified via
[vkCmdBindDescriptorSets](/man/vkCmdBindDescriptorSets), :normative{type="must"} be valid as described by
descriptor validity if they are statically used
by a bound shader
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-02700"}

A valid pipeline :normative{type="must"} be bound to the pipeline bind point used by this
command
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-02859"}

There :normative{type="must"} not have been any calls to dynamic state setting commands
for any state not specified as dynamic in the [VkPipeline](/man/VkPipeline) object
bound to the pipeline bind point used by this command, since that
pipeline was bound
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-02702"}

If the [VkPipeline](/man/VkPipeline) object bound to the pipeline bind point used by
this command accesses a [VkSampler](/man/VkSampler) object that uses unnormalized
coordinates, that sampler :normative{type="must"} not be used to sample from any
[VkImage](/man/VkImage) with a [VkImageView](/man/VkImageView) of the type
`VK_IMAGE_VIEW_TYPE_3D`, `VK_IMAGE_VIEW_TYPE_CUBE`,
`VK_IMAGE_VIEW_TYPE_1D_ARRAY`, `VK_IMAGE_VIEW_TYPE_2D_ARRAY` or
`VK_IMAGE_VIEW_TYPE_CUBE_ARRAY`, in any shader stage
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-02703"}

If the [VkPipeline](/man/VkPipeline) object bound to the pipeline bind point used by
this command accesses a [VkSampler](/man/VkSampler) object that uses unnormalized
coordinates, that sampler :normative{type="must"} not be used with any of the SPIR-V
`OpImageSample*` or `OpImageSparseSample*` instructions with
`ImplicitLod`, `Dref` or `Proj` in their name, in any shader
stage
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-02704"}

If the [VkPipeline](/man/VkPipeline) object bound to the pipeline bind point used by
this command accesses a [VkSampler](/man/VkSampler) object that uses unnormalized
coordinates, that sampler :normative{type="must"} not be used with any of the SPIR-V
`OpImageSample*` or `OpImageSparseSample*` instructions that includes a
LOD bias or any offset values, in any shader stage
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-02705"}

If the `robustBufferAccess` feature
is not enabled, and if the [VkPipeline](/man/VkPipeline) object bound to the pipeline
bind point used by this command accesses a uniform buffer, it :normative{type="must"} not
access values outside of the range of the buffer as specified in the
descriptor set bound to the same pipeline bind point
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-02706"}

If the `robustBufferAccess` feature
is not enabled, and if the [VkPipeline](/man/VkPipeline) object bound to the pipeline
bind point used by this command accesses a storage buffer, it :normative{type="must"} not
access values outside of the range of the buffer as specified in the
descriptor set bound to the same pipeline bind point
::

::validity-field{name="VUID-vkCmdDrawIndirect-viewType-07752"}

If a [VkImageView](/man/VkImageView) is accessed as a result of this command, then the
image view’s `viewType` :normative{type="must"} match the `Dim` operand of the
`OpTypeImage` as described in 
::

::validity-field{name="VUID-vkCmdDrawIndirect-format-07753"}

If a [VkImageView](/man/VkImageView) is accessed as a result of this command, then the
numeric type of the image view’s `format`
and the `Sampled` `Type` operand of the `OpTypeImage` :normative{type="must"}
match
::

::validity-field{name="VUID-vkCmdDrawIndirect-OpImageWrite-08795"}

If a [VkImageView](/man/VkImageView)
is accessed using `OpImageWrite` as a result of this command, then
the `Type` of the `Texel` operand of that instruction :normative{type="must"} have
at least as many components as the image view’s format
::

::validity-field{name="VUID-vkCmdDrawIndirect-OpImageWrite-04469"}

If a [VkBufferView](/man/VkBufferView) is accessed using `OpImageWrite` as a result
of this command, then the `Type` of the `Texel` operand of that
instruction :normative{type="must"} have at least as many components as the buffer view’s
format
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-07288"}

Any shader invocation executed by this command :normative{type="must"}
terminate
::

::validity-field{name="VUID-vkCmdDrawIndirect-renderPass-02684"}

The current render pass :normative{type="must"} be compatible
with the `renderPass` member of the
`VkGraphicsPipelineCreateInfo` structure specified when creating the
`VkPipeline` bound to `VK_PIPELINE_BIND_POINT_GRAPHICS`
::

::validity-field{name="VUID-vkCmdDrawIndirect-subpass-02685"}

The subpass index of the current render pass :normative{type="must"} be equal to the
`subpass` member of the `VkGraphicsPipelineCreateInfo` structure
specified when creating the `VkPipeline` bound to
`VK_PIPELINE_BIND_POINT_GRAPHICS`
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-07748"}

If any shader statically accesses an input attachment, a valid
descriptor :normative{type="must"} be bound to the pipeline via a descriptor set
::

::validity-field{name="VUID-vkCmdDrawIndirect-OpTypeImage-07468"}

If any shader executed by this pipeline accesses an `OpTypeImage`
variable with a `Dim` operand of `SubpassData`, it :normative{type="must"} be
decorated with an `InputAttachmentIndex` that corresponds to a valid
input attachment in the current subpass
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-07469"}

Input attachment views accessed in a subpass :normative{type="must"} be created with the
same [VkFormat](/man/VkFormat) as the corresponding subpass definition, and be
created with a [VkImageView](/man/VkImageView) that is compatible with the attachment
referenced by the subpass'
`pInputAttachments`[`InputAttachmentIndex`] in the currently
bound [VkFramebuffer](/man/VkFramebuffer) as specified by
Fragment Input Attachment
Compatibility
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-06537"}

Memory backing image subresources used as attachments in the current
render pass :normative{type="must"} not be written in any way other than as an attachment
by this command
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-09000"}

If a color attachment is written by any prior command in this subpass or
by the load, store, or resolve operations for this subpass,
it :normative{type="must"} not be accessed in any way other than as an attachment by this
command
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-09001"}

If a depth attachment is written by any prior command in this subpass or
by the load, store, or resolve operations for this subpass,
it :normative{type="must"} not be accessed in any way other than as an attachment by this
command
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-09002"}

If a stencil attachment is written by any prior command in this subpass
or by the load, store, or resolve operations for this subpass,
it :normative{type="must"} not be accessed in any way other than as an attachment by this
command
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-06539"}

If any previously recorded command in the current subpass accessed an
image subresource used as an attachment in this subpass in any way other
than as an attachment, this command :normative{type="must"} not write to that image
subresource as an attachment
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-06886"}

If the current render pass instance uses a depth/stencil attachment with
a read-only layout for the depth aspect, depth
writes :normative{type="must"} be disabled
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-06887"}

If the current render pass instance uses a depth/stencil attachment with
a read-only layout for the stencil aspect, both front and back
`writeMask` are not zero, and stencil test is enabled,
all stencil ops :normative{type="must"} be `VK_STENCIL_OP_KEEP`
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-07831"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_VIEWPORT` dynamic state enabled then
[vkCmdSetViewport](/man/vkCmdSetViewport) :normative{type="must"} have been called in the current command
buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-07832"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_SCISSOR` dynamic state enabled then
[vkCmdSetScissor](/man/vkCmdSetScissor) :normative{type="must"} have been called in the current command
buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-07833"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_LINE_WIDTH` dynamic state enabled then
[vkCmdSetLineWidth](/man/vkCmdSetLineWidth) :normative{type="must"} have been called in the current command
buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-07834"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_DEPTH_BIAS` dynamic state enabled then
[vkCmdSetDepthBias](/man/vkCmdSetDepthBias)
:normative{type="must"} have been called in the current command buffer prior to this
drawing command
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-07835"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_BLEND_CONSTANTS` dynamic state enabled then
[vkCmdSetBlendConstants](/man/vkCmdSetBlendConstants) :normative{type="must"} have been called in the current
command buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-07836"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_DEPTH_BOUNDS` dynamic state enabled, and if the
current `depthBoundsTestEnable` state is `VK_TRUE`, then
[vkCmdSetDepthBounds](/man/vkCmdSetDepthBounds) :normative{type="must"} have been called in the current command
buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-07837"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK` dynamic state enabled, and
if the current `stencilTestEnable` state is `VK_TRUE`, then
[vkCmdSetStencilCompareMask](/man/vkCmdSetStencilCompareMask) :normative{type="must"} have been called in the current
command buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-07838"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_STENCIL_WRITE_MASK` dynamic state enabled, and if
the current `stencilTestEnable` state is `VK_TRUE`, then
[vkCmdSetStencilWriteMask](/man/vkCmdSetStencilWriteMask) :normative{type="must"} have been called in the current
command buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndirect-None-07839"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_STENCIL_REFERENCE` dynamic state enabled, and if
the current `stencilTestEnable` state is `VK_TRUE`, then
[vkCmdSetStencilReference](/man/vkCmdSetStencilReference) :normative{type="must"} have been called in the current
command buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndirect-blendEnable-04727"}

If rasterization is not disabled in the bound graphics pipeline, then
for each color attachment in the subpass, if the corresponding image
view’s format features do not
contain `VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT`, then the
`blendEnable` member of the corresponding element of the
`pAttachments` member of `pColorBlendState` :normative{type="must"} be
`VK_FALSE`
::

::validity-field{name="VUID-vkCmdDrawIndirect-rasterizationSamples-04740"}

If rasterization is not disabled in the bound graphics pipeline, and
neither the  nor the
 extensions are enabled, then
`rasterizationSamples` for the currently bound graphics pipeline
:normative{type="must"} be the same as the current subpass color and/or depth/stencil
attachments
::

::validity-field{name="VUID-vkCmdDrawIndirect-maxFragmentDualSrcAttachments-09239"}

If blending is enabled for any attachment where
either the source or destination blend factors for that attachment
use the secondary color input, the maximum value of
`Location` for any output attachment statically
used in the `Fragment` `Execution` `Model` executed by this command
:normative{type="must"} be less than `maxFragmentDualSrcAttachments`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdDrawIndirect-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdDrawIndirect-buffer-parameter"}
 `buffer` :normative{type="must"} be a valid [VkBuffer](/man/VkBuffer) handle
::

::validity-field{name="VUID-vkCmdDrawIndirect-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdDrawIndirect-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics operations
::

::validity-field{name="VUID-vkCmdDrawIndirect-renderpass"}
 This command :normative{type="must"} only be called inside of a render pass instance
::

::validity-field{name="VUID-vkCmdDrawIndirect-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdDrawIndirect-commonparent"}
 Both of `buffer`, and `commandBuffer` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::






The `VkDrawIndirectCommand` structure is defined as:

[{generated}/api/structs/VkDrawIndirectCommand.adoc]({generated}/api/structs/VkDrawIndirectCommand.adoc)

- `vertexCount` is the number of vertices to draw.

- `instanceCount` is the number of instances to draw.

- `firstVertex` is the index of the first vertex to draw.

- `firstInstance` is the instance ID of the first instance to draw.

The members of `VkDrawIndirectCommand` have the same meaning as the
similarly named parameters of [vkCmdDraw](/man/vkCmdDraw).


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkDrawIndirectCommand-None-00500"}

For a given vertex buffer binding, any attribute data fetched :normative{type="must"} be
entirely contained within the corresponding vertex buffer binding, as
described in 
::

::validity-field{name="VUID-VkDrawIndirectCommand-firstInstance-00501"}

If the `drawIndirectFirstInstance` feature is not enabled,
`firstInstance` :normative{type="must"} be `0`
::

::


To record an indexed indirect drawing command, call:

[{generated}/api/protos/vkCmdDrawIndexedIndirect.adoc]({generated}/api/protos/vkCmdDrawIndexedIndirect.adoc)

- `commandBuffer` is the command buffer into which the command is
  recorded.

- `buffer` is the buffer containing draw parameters.

- `offset` is the byte offset into `buffer` where parameters
  begin.

- `drawCount` is the number of draws to execute, and :normative{type="can"} be zero.

- `stride` is the byte stride between successive sets of draw
  parameters.

`vkCmdDrawIndexedIndirect` behaves similarly to [vkCmdDrawIndexed](/man/vkCmdDrawIndexed)
except that the parameters are read by the device from a buffer during
execution.
`drawCount` draws are executed by the command, with parameters taken
from `buffer` starting at `offset` and increasing by `stride`
bytes for each successive draw.
The parameters of each draw are encoded in an array of
[VkDrawIndexedIndirectCommand](/man/VkDrawIndexedIndirectCommand) structures.
If `drawCount` is less than or equal to one, `stride` is ignored.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-magFilter-04553"}

If a [VkSampler](/man/VkSampler) created with `magFilter` or `minFilter`
equal to `VK_FILTER_LINEAR` and `compareEnable` equal to
`VK_FALSE` is used to sample a [VkImageView](/man/VkImageView) as a result of this
command, then the image view’s
format features :normative{type="must"} contain
`VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT`
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-mipmapMode-04770"}

If a [VkSampler](/man/VkSampler) created with `mipmapMode` equal to
`VK_SAMPLER_MIPMAP_MODE_LINEAR` and `compareEnable` equal to
`VK_FALSE` is used to sample a [VkImageView](/man/VkImageView) as a result of this
command, then the image view’s
format features :normative{type="must"} contain
`VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT`
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-aspectMask-06478"}

If a [VkImageView](/man/VkImageView) is sampled with
depth comparison, the image view
:normative{type="must"} have been created with an `aspectMask` that contains
`VK_IMAGE_ASPECT_DEPTH_BIT`
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-02691"}

If a [VkImageView](/man/VkImageView) is accessed using atomic operations as a result
of this command, then the image view’s
format features :normative{type="must"} contain
`VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT`
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-07888"}

If a `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` descriptor is
accessed using atomic operations as a result of this command, then the
storage texel buffer’s format
features :normative{type="must"} contain
`VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT`
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-02697"}

For each set *n* that is statically used by a bound
shader, a descriptor set :normative{type="must"} have been bound to *n* at the same
pipeline bind point, with a [VkPipelineLayout](/man/VkPipelineLayout) that is compatible
for set *n*, with the [VkPipelineLayout](/man/VkPipelineLayout) used to create the current
[VkPipeline](/man/VkPipeline), as described in 
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-02698"}

For each push constant that is statically used by a
bound shader, a push constant value :normative{type="must"} have been set for the same
pipeline bind point, with a [VkPipelineLayout](/man/VkPipelineLayout) that is compatible
for push constants, with the [VkPipelineLayout](/man/VkPipelineLayout) used to create the
current [VkPipeline](/man/VkPipeline), as described in

::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-02699"}

Descriptors in each bound descriptor set, specified via
[vkCmdBindDescriptorSets](/man/vkCmdBindDescriptorSets), :normative{type="must"} be valid as described by
descriptor validity if they are statically used
by a bound shader
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-02700"}

A valid pipeline :normative{type="must"} be bound to the pipeline bind point used by this
command
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-02859"}

There :normative{type="must"} not have been any calls to dynamic state setting commands
for any state not specified as dynamic in the [VkPipeline](/man/VkPipeline) object
bound to the pipeline bind point used by this command, since that
pipeline was bound
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-02702"}

If the [VkPipeline](/man/VkPipeline) object bound to the pipeline bind point used by
this command accesses a [VkSampler](/man/VkSampler) object that uses unnormalized
coordinates, that sampler :normative{type="must"} not be used to sample from any
[VkImage](/man/VkImage) with a [VkImageView](/man/VkImageView) of the type
`VK_IMAGE_VIEW_TYPE_3D`, `VK_IMAGE_VIEW_TYPE_CUBE`,
`VK_IMAGE_VIEW_TYPE_1D_ARRAY`, `VK_IMAGE_VIEW_TYPE_2D_ARRAY` or
`VK_IMAGE_VIEW_TYPE_CUBE_ARRAY`, in any shader stage
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-02703"}

If the [VkPipeline](/man/VkPipeline) object bound to the pipeline bind point used by
this command accesses a [VkSampler](/man/VkSampler) object that uses unnormalized
coordinates, that sampler :normative{type="must"} not be used with any of the SPIR-V
`OpImageSample*` or `OpImageSparseSample*` instructions with
`ImplicitLod`, `Dref` or `Proj` in their name, in any shader
stage
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-02704"}

If the [VkPipeline](/man/VkPipeline) object bound to the pipeline bind point used by
this command accesses a [VkSampler](/man/VkSampler) object that uses unnormalized
coordinates, that sampler :normative{type="must"} not be used with any of the SPIR-V
`OpImageSample*` or `OpImageSparseSample*` instructions that includes a
LOD bias or any offset values, in any shader stage
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-02705"}

If the `robustBufferAccess` feature
is not enabled, and if the [VkPipeline](/man/VkPipeline) object bound to the pipeline
bind point used by this command accesses a uniform buffer, it :normative{type="must"} not
access values outside of the range of the buffer as specified in the
descriptor set bound to the same pipeline bind point
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-02706"}

If the `robustBufferAccess` feature
is not enabled, and if the [VkPipeline](/man/VkPipeline) object bound to the pipeline
bind point used by this command accesses a storage buffer, it :normative{type="must"} not
access values outside of the range of the buffer as specified in the
descriptor set bound to the same pipeline bind point
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-viewType-07752"}

If a [VkImageView](/man/VkImageView) is accessed as a result of this command, then the
image view’s `viewType` :normative{type="must"} match the `Dim` operand of the
`OpTypeImage` as described in 
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-format-07753"}

If a [VkImageView](/man/VkImageView) is accessed as a result of this command, then the
numeric type of the image view’s `format`
and the `Sampled` `Type` operand of the `OpTypeImage` :normative{type="must"}
match
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-OpImageWrite-08795"}

If a [VkImageView](/man/VkImageView)
is accessed using `OpImageWrite` as a result of this command, then
the `Type` of the `Texel` operand of that instruction :normative{type="must"} have
at least as many components as the image view’s format
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-OpImageWrite-04469"}

If a [VkBufferView](/man/VkBufferView) is accessed using `OpImageWrite` as a result
of this command, then the `Type` of the `Texel` operand of that
instruction :normative{type="must"} have at least as many components as the buffer view’s
format
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-07288"}

Any shader invocation executed by this command :normative{type="must"}
terminate
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-renderPass-02684"}

The current render pass :normative{type="must"} be compatible
with the `renderPass` member of the
`VkGraphicsPipelineCreateInfo` structure specified when creating the
`VkPipeline` bound to `VK_PIPELINE_BIND_POINT_GRAPHICS`
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-subpass-02685"}

The subpass index of the current render pass :normative{type="must"} be equal to the
`subpass` member of the `VkGraphicsPipelineCreateInfo` structure
specified when creating the `VkPipeline` bound to
`VK_PIPELINE_BIND_POINT_GRAPHICS`
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-07748"}

If any shader statically accesses an input attachment, a valid
descriptor :normative{type="must"} be bound to the pipeline via a descriptor set
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-OpTypeImage-07468"}

If any shader executed by this pipeline accesses an `OpTypeImage`
variable with a `Dim` operand of `SubpassData`, it :normative{type="must"} be
decorated with an `InputAttachmentIndex` that corresponds to a valid
input attachment in the current subpass
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-07469"}

Input attachment views accessed in a subpass :normative{type="must"} be created with the
same [VkFormat](/man/VkFormat) as the corresponding subpass definition, and be
created with a [VkImageView](/man/VkImageView) that is compatible with the attachment
referenced by the subpass'
`pInputAttachments`[`InputAttachmentIndex`] in the currently
bound [VkFramebuffer](/man/VkFramebuffer) as specified by
Fragment Input Attachment
Compatibility
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-06537"}

Memory backing image subresources used as attachments in the current
render pass :normative{type="must"} not be written in any way other than as an attachment
by this command
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-09000"}

If a color attachment is written by any prior command in this subpass or
by the load, store, or resolve operations for this subpass,
it :normative{type="must"} not be accessed in any way other than as an attachment by this
command
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-09001"}

If a depth attachment is written by any prior command in this subpass or
by the load, store, or resolve operations for this subpass,
it :normative{type="must"} not be accessed in any way other than as an attachment by this
command
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-09002"}

If a stencil attachment is written by any prior command in this subpass
or by the load, store, or resolve operations for this subpass,
it :normative{type="must"} not be accessed in any way other than as an attachment by this
command
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-06539"}

If any previously recorded command in the current subpass accessed an
image subresource used as an attachment in this subpass in any way other
than as an attachment, this command :normative{type="must"} not write to that image
subresource as an attachment
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-06886"}

If the current render pass instance uses a depth/stencil attachment with
a read-only layout for the depth aspect, depth
writes :normative{type="must"} be disabled
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-06887"}

If the current render pass instance uses a depth/stencil attachment with
a read-only layout for the stencil aspect, both front and back
`writeMask` are not zero, and stencil test is enabled,
all stencil ops :normative{type="must"} be `VK_STENCIL_OP_KEEP`
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-07831"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_VIEWPORT` dynamic state enabled then
[vkCmdSetViewport](/man/vkCmdSetViewport) :normative{type="must"} have been called in the current command
buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-07832"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_SCISSOR` dynamic state enabled then
[vkCmdSetScissor](/man/vkCmdSetScissor) :normative{type="must"} have been called in the current command
buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-07833"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_LINE_WIDTH` dynamic state enabled then
[vkCmdSetLineWidth](/man/vkCmdSetLineWidth) :normative{type="must"} have been called in the current command
buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-07834"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_DEPTH_BIAS` dynamic state enabled then
[vkCmdSetDepthBias](/man/vkCmdSetDepthBias)
:normative{type="must"} have been called in the current command buffer prior to this
drawing command
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-07835"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_BLEND_CONSTANTS` dynamic state enabled then
[vkCmdSetBlendConstants](/man/vkCmdSetBlendConstants) :normative{type="must"} have been called in the current
command buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-07836"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_DEPTH_BOUNDS` dynamic state enabled, and if the
current `depthBoundsTestEnable` state is `VK_TRUE`, then
[vkCmdSetDepthBounds](/man/vkCmdSetDepthBounds) :normative{type="must"} have been called in the current command
buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-07837"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK` dynamic state enabled, and
if the current `stencilTestEnable` state is `VK_TRUE`, then
[vkCmdSetStencilCompareMask](/man/vkCmdSetStencilCompareMask) :normative{type="must"} have been called in the current
command buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-07838"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_STENCIL_WRITE_MASK` dynamic state enabled, and if
the current `stencilTestEnable` state is `VK_TRUE`, then
[vkCmdSetStencilWriteMask](/man/vkCmdSetStencilWriteMask) :normative{type="must"} have been called in the current
command buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-None-07839"}

If the bound graphics pipeline state was created with the
`VK_DYNAMIC_STATE_STENCIL_REFERENCE` dynamic state enabled, and if
the current `stencilTestEnable` state is `VK_TRUE`, then
[vkCmdSetStencilReference](/man/vkCmdSetStencilReference) :normative{type="must"} have been called in the current
command buffer prior to this drawing command
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-blendEnable-04727"}

If rasterization is not disabled in the bound graphics pipeline, then
for each color attachment in the subpass, if the corresponding image
view’s format features do not
contain `VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT`, then the
`blendEnable` member of the corresponding element of the
`pAttachments` member of `pColorBlendState` :normative{type="must"} be
`VK_FALSE`
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-rasterizationSamples-04740"}

If rasterization is not disabled in the bound graphics pipeline, and
neither the  nor the
 extensions are enabled, then
`rasterizationSamples` for the currently bound graphics pipeline
:normative{type="must"} be the same as the current subpass color and/or depth/stencil
attachments
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-maxFragmentDualSrcAttachments-09239"}

If blending is enabled for any attachment where
either the source or destination blend factors for that attachment
use the secondary color input, the maximum value of
`Location` for any output attachment statically
used in the `Fragment` `Execution` `Model` executed by this command
:normative{type="must"} be less than `maxFragmentDualSrcAttachments`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-buffer-parameter"}
 `buffer` :normative{type="must"} be a valid [VkBuffer](/man/VkBuffer) handle
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics operations
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-renderpass"}
 This command :normative{type="must"} only be called inside of a render pass instance
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdDrawIndexedIndirect-commonparent"}
 Both of `buffer`, and `commandBuffer` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::






The `VkDrawIndexedIndirectCommand` structure is defined as:

[{generated}/api/structs/VkDrawIndexedIndirectCommand.adoc]({generated}/api/structs/VkDrawIndexedIndirectCommand.adoc)

- `indexCount` is the number of vertices to draw.

- `instanceCount` is the number of instances to draw.

- `firstIndex` is the base index within the index buffer.

- `vertexOffset` is the value added to the vertex index before
  indexing into the vertex buffer.

- `firstInstance` is the instance ID of the first instance to draw.

The members of `VkDrawIndexedIndirectCommand` have the same meaning as
the similarly named parameters of [vkCmdDrawIndexed](/man/vkCmdDrawIndexed).


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkDrawIndexedIndirectCommand-robustBufferAccess2-08798"}

If `robustBufferAccess2` is not
enabled, (`indexSize` × (`firstIndex` + 
`indexCount`) +  `offset`) :normative{type="must"} be less than or equal to
the size of the bound index buffer, with `indexSize` being based on
the type specified by `indexType`, where the index buffer,
`indexType`, and `offset` are specified via
`vkCmdBindIndexBuffer`
::

::validity-field{name="VUID-VkDrawIndexedIndirectCommand-None-00552"}

For a given vertex buffer binding, any attribute data fetched :normative{type="must"} be
entirely contained within the corresponding vertex buffer binding, as
described in 
::

::validity-field{name="VUID-VkDrawIndexedIndirectCommand-firstInstance-00554"}

If the `drawIndirectFirstInstance` feature is not enabled,
`firstInstance` :normative{type="must"} be `0`
::

::








# Fixed-Function Vertex Processing

Vertex fetching is controlled via configurable state, as a logically
distinct graphics pipeline stage.



## Vertex Attributes

Vertex shaders :normative{type="can"} define input variables, which receive *vertex attribute*
data transferred from one or more `VkBuffer`(s) by drawing commands.
Vertex shader input variables are bound to buffers via an indirect binding
where the vertex shader associates a *vertex input attribute* number with
each variable, vertex input attributes are associated to *vertex input
bindings* on a per-pipeline basis, and vertex input bindings are associated
with specific buffers on a per-draw basis via the
`vkCmdBindVertexBuffers` command.
Vertex input attribute and vertex input binding descriptions also contain
format information controlling how data is extracted from buffer memory and
converted to the format expected by the vertex shader.

There are `VkPhysicalDeviceLimits`::`maxVertexInputAttributes`
number of vertex input attributes and
`VkPhysicalDeviceLimits`::`maxVertexInputBindings` number of vertex
input bindings (each referred to by zero-based indices), where there are at
least as many vertex input attributes as there are vertex input bindings.
Applications :normative{type="can"} store multiple vertex input attributes interleaved in a
single buffer, and use a single vertex input binding to access those
attributes.

In GLSL, vertex shaders associate input variables with a vertex input
attribute number using the `location` layout qualifier.
The `Component` layout qualifier associates components of a vertex shader
input variable with components of a vertex input attribute.



In SPIR-V, vertex shaders associate input variables with a vertex input
attribute number using the `Location` decoration.
The `Component` decoration associates components of a vertex shader input
variable with components of a vertex input attribute.
The `Location` and `Component` decorations are specified via the
`OpDecorate` instruction.





### Attribute Location and Component Assignment

The `Location` decoration specifies which vertex input attribute is used
to read and interpret the data that a variable will consume.

When a vertex shader input variable declared using a 16- or 32-bit scalar or
vector data type is assigned a `Location`, its value(s) are taken from
the components of the input attribute specified with the corresponding
`VkVertexInputAttributeDescription`::`location`.
The components used depend on the type of variable and the `Component`
decoration specified in the variable declaration, as identified in
.
Any 16-bit or 32-bit scalar or vector input will consume a single
`Location`.
For 16-bit and 32-bit data types, missing components are filled in with
default values as described below.



Components indicated by > o are available for use by other input variables
which are sourced from the same attribute, and if used, are either filled
with the corresponding component from the input format (if present), or the
default value.

When a vertex shader input variable declared using a 32-bit floating point
matrix type is assigned a `Location` *i*, its values are taken from
consecutive input attributes starting with the corresponding
`VkVertexInputAttributeDescription`::`location`.
Such matrices are treated as an array of column vectors with values taken
from the input attributes identified in .
The `VkVertexInputAttributeDescription`::`format` :normative{type="must"} be specified
with a [VkFormat](/man/VkFormat) that corresponds to the appropriate type of column
vector.
The `Component` decoration :normative{type="must"} not be used with matrix types.



Components indicated by > o are available for use by other input variables
which are sourced from the same attribute, and if used, are either filled
with the corresponding component from the input (if present), or the default
value.

When a vertex shader input variable declared using a scalar or vector 64-bit
data type is assigned a `Location` *i*, its values are taken from
consecutive input attributes starting with the corresponding
`VkVertexInputAttributeDescription`::`location`.
The `Location` slots and `Component` words used depend on the type of
variable and the `Component` decoration specified in the variable
declaration, as identified in .
For 64-bit data types, no default attribute values are provided.
Input variables :normative{type="must"} not use more components than provided by the
attribute.



Components indicated by > o are available for use by other input variables
which are sourced from the same attribute.
Components indicated by > \- are not available for input variables as there
are no default values provided for 64-bit data types, and there is no data
provided by the input format.

When a vertex shader input variable declared using a 64-bit floating-point
matrix type is assigned a `Location` *i*, its values are taken from
consecutive input attribute locations.
Such matrices are treated as an array of column vectors with values taken
from the input attributes as shown in .
Each column vector starts at the `Location` immediately following the
last `Location` of the previous column vector.
The number of attributes and components assigned to each matrix is
determined by the matrix dimensions and ranges from two to eight locations.

When a vertex shader input variable declared using an array type is assigned
a location, its values are taken from consecutive input attributes starting
with the corresponding
`VkVertexInputAttributeDescription`::`location`.
The number of attributes and components assigned to each element are
determined according to the data type of the array elements and
`Component` decoration (if any) specified in the declaration of the
array, as described above.
Each element of the array, in order, is assigned to consecutive locations,
but all at the same specified component within each location.

Only input variables declared with the data types and component decorations
as specified above are supported.
Two variables are allowed to share the same `Location` slot only if their
`Component` words do not overlap.
If multiple variables share the same `Location` slot, they :normative{type="must"} all have
the same SPIR-V floating-point component type or all have the same width
scalar type components.







## Vertex Input Description

Applications specify vertex input attribute and vertex input binding
descriptions as part of graphics pipeline creation by setting the
[VkGraphicsPipelineCreateInfo](/man/VkGraphicsPipelineCreateInfo)::`pVertexInputState` pointer to a
[VkPipelineVertexInputStateCreateInfo](/man/VkPipelineVertexInputStateCreateInfo) structure.

The `VkPipelineVertexInputStateCreateInfo` structure is defined as:

[{generated}/api/structs/VkPipelineVertexInputStateCreateInfo.adoc]({generated}/api/structs/VkPipelineVertexInputStateCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is reserved for future use.

- `vertexBindingDescriptionCount` is the number of vertex binding
  descriptions provided in `pVertexBindingDescriptions`.

- `pVertexBindingDescriptions` is a pointer to an array of
  `VkVertexInputBindingDescription` structures.

- `vertexAttributeDescriptionCount` is the number of vertex attribute
  descriptions provided in `pVertexAttributeDescriptions`.

- `pVertexAttributeDescriptions` is a pointer to an array of
  `VkVertexInputAttributeDescription` structures.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkPipelineVertexInputStateCreateInfo-vertexBindingDescriptionCount-00613"}
`vertexBindingDescriptionCount` :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxVertexInputBindings`
::

::validity-field{name="VUID-VkPipelineVertexInputStateCreateInfo-vertexAttributeDescriptionCount-00614"}
`vertexAttributeDescriptionCount` :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxVertexInputAttributes`
::

::validity-field{name="VUID-VkPipelineVertexInputStateCreateInfo-binding-00615"}

For every `binding` specified by each element of
`pVertexAttributeDescriptions`, a
`VkVertexInputBindingDescription` :normative{type="must"} exist in
`pVertexBindingDescriptions` with the same value of `binding`
::

::validity-field{name="VUID-VkPipelineVertexInputStateCreateInfo-pVertexBindingDescriptions-00616"}

All elements of `pVertexBindingDescriptions` :normative{type="must"} describe distinct
binding numbers
::

::validity-field{name="VUID-VkPipelineVertexInputStateCreateInfo-pVertexAttributeDescriptions-00617"}

All elements of `pVertexAttributeDescriptions` :normative{type="must"} describe
distinct attribute locations
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkPipelineVertexInputStateCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO`
::

::validity-field{name="VUID-VkPipelineVertexInputStateCreateInfo-pNext-pNext"}
 `pNext` :normative{type="must"} be `NULL` or a pointer to a valid instance of [VkPipelineVertexInputDivisorStateCreateInfoEXT](/man/VkPipelineVertexInputDivisorStateCreateInfoEXT)
::

::validity-field{name="VUID-VkPipelineVertexInputStateCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkPipelineVertexInputStateCreateInfo-flags-zerobitmask"}
 `flags` :normative{type="must"} be `0`
::

::validity-field{name="VUID-VkPipelineVertexInputStateCreateInfo-pVertexBindingDescriptions-parameter"}
 If `vertexBindingDescriptionCount` is not `0`, `pVertexBindingDescriptions` :normative{type="must"} be a valid pointer to an array of `vertexBindingDescriptionCount` valid [VkVertexInputBindingDescription](/man/VkVertexInputBindingDescription) structures
::

::validity-field{name="VUID-VkPipelineVertexInputStateCreateInfo-pVertexAttributeDescriptions-parameter"}
 If `vertexAttributeDescriptionCount` is not `0`, `pVertexAttributeDescriptions` :normative{type="must"} be a valid pointer to an array of `vertexAttributeDescriptionCount` valid [VkVertexInputAttributeDescription](/man/VkVertexInputAttributeDescription) structures
::

::


[{generated}/api/flags/VkPipelineVertexInputStateCreateFlags.adoc]({generated}/api/flags/VkPipelineVertexInputStateCreateFlags.adoc)

`VkPipelineVertexInputStateCreateFlags` is a bitmask type for setting a
mask, but is currently reserved for future use.

Each vertex input binding is specified by the
`VkVertexInputBindingDescription` structure, defined as:

[{generated}/api/structs/VkVertexInputBindingDescription.adoc]({generated}/api/structs/VkVertexInputBindingDescription.adoc)

- `binding` is the binding number that this structure describes.

- `stride` is the byte stride between consecutive elements within the
  buffer.

- `inputRate` is a [VkVertexInputRate](/man/VkVertexInputRate) value specifying whether
  vertex attribute addressing is a function of the vertex index or of the
  instance index.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkVertexInputBindingDescription-binding-00618"}
`binding` :normative{type="must"} be less than
`VkPhysicalDeviceLimits`::`maxVertexInputBindings`
::

::validity-field{name="VUID-VkVertexInputBindingDescription-stride-00619"}
`stride` :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxVertexInputBindingStride`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkVertexInputBindingDescription-inputRate-parameter"}
 `inputRate` :normative{type="must"} be a valid [VkVertexInputRate](/man/VkVertexInputRate) value
::

::


Possible values of [VkVertexInputBindingDescription](/man/VkVertexInputBindingDescription)::`inputRate`,
specifying the rate at which vertex attributes are pulled from buffers, are:

[{generated}/api/enums/VkVertexInputRate.adoc]({generated}/api/enums/VkVertexInputRate.adoc)

- `VK_VERTEX_INPUT_RATE_VERTEX` specifies that vertex attribute
  addressing is a function of the vertex index.

- `VK_VERTEX_INPUT_RATE_INSTANCE` specifies that vertex attribute
  addressing is a function of the instance index.

Each vertex input attribute is specified by the
`VkVertexInputAttributeDescription` structure, defined as:

[{generated}/api/structs/VkVertexInputAttributeDescription.adoc]({generated}/api/structs/VkVertexInputAttributeDescription.adoc)

- `location` is the shader input location number for this attribute.

- `binding` is the binding number which this attribute takes its data
  from.

- `format` is the size and type of the vertex attribute data.

- `offset` is a byte offset of this attribute relative to the start of
  an element in the vertex input binding.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkVertexInputAttributeDescription-location-00620"}
`location` :normative{type="must"} be less than
`VkPhysicalDeviceLimits`::`maxVertexInputAttributes`
::

::validity-field{name="VUID-VkVertexInputAttributeDescription-binding-00621"}
`binding` :normative{type="must"} be less than
`VkPhysicalDeviceLimits`::`maxVertexInputBindings`
::

::validity-field{name="VUID-VkVertexInputAttributeDescription-offset-00622"}
`offset` :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxVertexInputAttributeOffset`
::

::validity-field{name="VUID-VkVertexInputAttributeDescription-format-00623"}

The format features of
`format` :normative{type="must"} contain `VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkVertexInputAttributeDescription-format-parameter"}
 `format` :normative{type="must"} be a valid [VkFormat](/man/VkFormat) value
::

::


To bind vertex buffers to a command buffer for use in subsequent drawing
commands, call:

[{generated}/api/protos/vkCmdBindVertexBuffers.adoc]({generated}/api/protos/vkCmdBindVertexBuffers.adoc)

- `commandBuffer` is the command buffer into which the command is
  recorded.

- `firstBinding` is the index of the first vertex input binding whose
  state is updated by the command.

- `bindingCount` is the number of vertex input bindings whose state is
  updated by the command.

- `pBuffers` is a pointer to an array of buffer handles.

- `pOffsets` is a pointer to an array of buffer offsets.

The values taken from elements i of `pBuffers` and `pOffsets`
replace the current state for the vertex input binding
`firstBinding` +  i, for i in \[0,
`bindingCount`).
The vertex input binding is updated to start at the offset indicated by
`pOffsets`\[i] from the start of the buffer `pBuffers`\[i].
All vertex input attributes that use each of these bindings will use these
updated addresses in their address calculations for subsequent drawing
commands.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdBindVertexBuffers-firstBinding-00624"}
`firstBinding` :normative{type="must"} be less than
`VkPhysicalDeviceLimits`::`maxVertexInputBindings`
::

::validity-field{name="VUID-vkCmdBindVertexBuffers-firstBinding-00625"}

The sum of `firstBinding` and `bindingCount` :normative{type="must"} be less than
or equal to `VkPhysicalDeviceLimits`::`maxVertexInputBindings`
::

::validity-field{name="VUID-vkCmdBindVertexBuffers-pOffsets-00626"}

All elements of `pOffsets` :normative{type="must"} be less than the size of the
corresponding element in `pBuffers`
::

::validity-field{name="VUID-vkCmdBindVertexBuffers-pBuffers-00627"}

All elements of `pBuffers` :normative{type="must"} have been created with the
`VK_BUFFER_USAGE_VERTEX_BUFFER_BIT` flag
::

::validity-field{name="VUID-vkCmdBindVertexBuffers-pBuffers-00628"}

Each element of `pBuffers` that is non-sparse :normative{type="must"} be bound
completely and contiguously to a single `VkDeviceMemory` object
::

::validity-field{name="VUID-vkCmdBindVertexBuffers-pBuffers-04001"}

If the `nullDescriptor` feature is not
enabled, all elements of `pBuffers` :normative{type="must"} not be
[VK_NULL_HANDLE](/man/VK_NULL_HANDLE)
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdBindVertexBuffers-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdBindVertexBuffers-pBuffers-parameter"}
 `pBuffers` :normative{type="must"} be a valid pointer to an array of `bindingCount` valid or [VK_NULL_HANDLE](/man/VK_NULL_HANDLE) [VkBuffer](/man/VkBuffer) handles
::

::validity-field{name="VUID-vkCmdBindVertexBuffers-pOffsets-parameter"}
 `pOffsets` :normative{type="must"} be a valid pointer to an array of `bindingCount` [VkDeviceSize](/man/VkDeviceSize) values
::

::validity-field{name="VUID-vkCmdBindVertexBuffers-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdBindVertexBuffers-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics operations
::

::validity-field{name="VUID-vkCmdBindVertexBuffers-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdBindVertexBuffers-bindingCount-arraylength"}
 `bindingCount` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-vkCmdBindVertexBuffers-commonparent"}
 Both of `commandBuffer`, and the elements of `pBuffers` that are valid handles of non-ignored parameters :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::










## Vertex Input Address Calculation

The address of each attribute for each `vertexIndex` and
`instanceIndex` is calculated as follows:

- Let `attribDesc` be the member of
  [VkPipelineVertexInputStateCreateInfo](/man/VkPipelineVertexInputStateCreateInfo)::`pVertexAttributeDescriptions`
  with `VkVertexInputAttributeDescription`::`location` equal to
  the vertex input attribute number.

- Let `bindingDesc` be the member of
  [VkPipelineVertexInputStateCreateInfo](/man/VkPipelineVertexInputStateCreateInfo)::`pVertexBindingDescriptions`
  with `VkVertexInputAttributeDescription`::`binding` equal to
  `attribDesc.binding`.

- Let `vertexIndex` be the index of the vertex within the draw (a value
  between `firstVertex` and `firstVertex`+`vertexCount` for
  `vkCmdDraw`, or a value taken from the index buffer plus
  `vertexOffset` for `vkCmdDrawIndexed`), and let
  `instanceIndex` be the instance number of the draw (a value between
  `firstInstance` and `firstInstance`+`instanceCount`).

- Let `offset` be an array of offsets into the currently bound vertex
  buffers specified during `vkCmdBindVertexBuffers`
  with `pOffsets`.





### Vertex Input Extraction

For each attribute, raw data is extracted starting at `attribAddress` and is
converted from the `VkVertexInputAttributeDescription`’s `format` to
either floating-point, unsigned integer, or signed integer based on the
numeric type of `format`.
The numeric type of `format` :normative{type="must"} match the numeric type of the input
variable in the shader.
The input variable in the shader :normative{type="must"} be declared as a 64-bit data type if
and only if `format` is a 64-bit data type.
If `format` is a packed format, `attribAddress` :normative{type="must"} be a multiple of
the size in bytes of the whole attribute data type as described in
Packed Formats.
Otherwise, `attribAddress` :normative{type="must"} be a multiple of the size in bytes of the
component type indicated by `format` (see Formats).
For attributes that are not 64-bit data types, each component is converted
to the format of the input variable based on its type and size (as defined
in the Format Definition section for each
[VkFormat](/man/VkFormat)), using the appropriate equations in 16-Bit Floating-Point Numbers, Unsigned 11-Bit
Floating-Point Numbers, Unsigned 10-Bit Floating-Point
Numbers, Fixed-Point Data Conversion, and
Shared Exponent to RGB.
Signed integer components smaller than 32 bits are sign-extended.
Attributes that are not 64-bit data types are expanded to four components in
the same way as described in conversion to
RGBA.
The number of components in the vertex shader input variable need not
exactly match the number of components in the format.
If the vertex shader has fewer components, the extra components are
discarded.









# Tessellation

Tessellation involves three pipeline stages.
First, a tessellation control shader
transforms control points of a patch and :normative{type="can"} produce per-patch data.
Second, a fixed-function tessellator generates multiple primitives
corresponding to a tessellation of the patch in (u,v) or (u,v,w) parameter
space.
Third, a tessellation evaluation shader
transforms the vertices of the tessellated patch, for example to compute
their positions and attributes as part of the tessellated surface.
The tessellator is enabled when the pipeline contains both a tessellation
control shader and a tessellation evaluation shader.



## Tessellator

If a pipeline includes both tessellation shaders (control and evaluation),
the tessellator consumes each input patch (after vertex shading) and
produces a new set of independent primitives (points, lines, or triangles).
These primitives are logically produced by subdividing a geometric primitive
(rectangle or triangle) according to the per-patch outer and inner
tessellation levels written by the tessellation control shader.
These levels are specified using the built-in
variables `TessLevelOuter` and `TessLevelInner`, respectively.
This subdivision is performed in an implementation-dependent manner.
If no tessellation shaders are present in the pipeline, the tessellator is
disabled and incoming primitives are passed through without modification.

The type of subdivision performed by the tessellator is specified by an
`OpExecutionMode` instruction using one of the `Triangles`,
`Quads`, or `IsoLines` execution modes.
This
instruction :normative{type="may"} be specified in either the tessellation evaluation or
tessellation control shader.
Other
tessellation-related execution modes :normative{type="can"} also be specified in either the
tessellation control or tessellation evaluation shaders.

Any tessellation-related modes specified in both the tessellation control
and tessellation evaluation shaders :normative{type="must"} be the same.

Tessellation execution modes include:

- `Triangles`, `Quads`, and `IsoLines`.
  &#x20;   These control the type of subdivision and topology of the output
  &#x20;   primitives.
  One
  &#x20;   mode :normative{type="must"} be set in at least one of the tessellation shader stages.

- `VertexOrderCw` and `VertexOrderCcw`.
  &#x20;   These control the orientation of triangles generated by the tessellator.
  One
  &#x20;   mode :normative{type="must"} be set in at least one of the tessellation shader stages.

- `PointMode`.
  Controls generation of points rather than triangles or lines.
  This functionality defaults to disabled, and is enabled if either shader
  stage includes the execution mode.

- `SpacingEqual`, `SpacingFractionalEven`, and
  &#x20;   `SpacingFractionalOdd`.
  &#x20;   Controls the spacing of segments on the edges of tessellated primitives.
  One
  &#x20;   mode :normative{type="must"} be set in at least one of the tessellation shader stages.

- `OutputVertices`.
  &#x20;   Controls the size of the output patch of the tessellation control
  &#x20;   shader.
  One
  &#x20;   value :normative{type="must"} be set in at least one of the tessellation shader stages.

For triangles, the tessellator subdivides a triangle primitive into smaller
triangles.
For quads, the tessellator subdivides a rectangle primitive into smaller
triangles.
For isolines, the tessellator subdivides a rectangle primitive into a
collection of line segments arranged in strips stretching across the
rectangle in the u dimension (i.e. the coordinates in `TessCoord`
are of the form (0,x) through (1,x) for all tessellation
evaluation shader invocations that share a line).

Each vertex produced by the tessellator has an associated (u,v,w) or (u,v)
position in a normalized parameter space, with parameter values in the range
\[0,1], as illustrated
in figure .
The domain space has an upper-left origin.





For triangles, the vertex’s position is a barycentric coordinate
(u,v,w), where u +  v +  w = 1.0, and indicates the
relative influence of the three vertices of the triangle on the position of
the vertex.
For quads and isolines, the position is a (u,v) coordinate indicating
the relative horizontal and vertical position of the vertex relative to the
subdivided rectangle.
The subdivision process is explained in more detail in subsequent sections.





## Tessellator Patch Discard

A patch is discarded by the tessellator if any relevant outer tessellation
level is less than or equal to zero.

Patches will also be discarded if any relevant outer tessellation level
corresponds to a floating-point NaN (not a number) in implementations
supporting NaN.

No new primitives are generated and the tessellation evaluation shader is
not executed for patches that are discarded.
For `Quads`, all four outer levels are relevant.
For `Triangles` and `IsoLines`, only the first three or two outer
levels, respectively, are relevant.
Negative inner levels will not cause a patch to be discarded; they will be
clamped as described below.





## Tessellator Spacing

Each of the tessellation levels is used to determine the number and spacing
of segments used to subdivide a corresponding edge.
The method used to derive the number and spacing of segments is specified by
an `OpExecutionMode` in the tessellation control or tessellation
evaluation shader using one of the identifiers `SpacingEqual`,
`SpacingFractionalEven`, or `SpacingFractionalOdd`.

If `SpacingEqual` is used, the floating-point tessellation level is first
clamped to \[1, `maxLevel`], where `maxLevel` is the
implementation-dependent maximum tessellation level
(`VkPhysicalDeviceLimits`::`maxTessellationGenerationLevel`).
The result is rounded up to the nearest integer n, and the
corresponding edge is divided into n segments of equal length in (u,v)
space.

If `SpacingFractionalEven` is used, the tessellation level is first
clamped to \[2, `maxLevel`] and then rounded up to the nearest even
integer n.
If `SpacingFractionalOdd` is used, the tessellation level is clamped to
\[1, `maxLevel` - 1] and then rounded up to the nearest odd integer
n.
If n is one, the edge will not be subdivided.
Otherwise, the corresponding edge will be divided into n - 2 segments
of equal length, and two additional segments of equal length that are
typically shorter than the other segments.
The length of the two additional segments relative to the others will
decrease monotonically with n - f, where f is the clamped
floating-point tessellation level.
When n - f is zero, the additional segments will have equal length to
the other segments.
As n - f approaches 2.0, the relative length of the additional
segments approaches zero.
The two additional segments :normative{type="must"} be placed symmetrically on opposite sides
of the subdivided edge.
The relative location of these two segments is implementation-dependent, but
:normative{type="must"} be identical for any pair of subdivided edges with identical values of
f.

When tessellating triangles or quads using point
mode with fractional odd spacing, the tessellator :normative{type="may"} produce *interior
vertices* that are positioned on the edge of the patch if an inner
tessellation level is less than or equal to one.
Such vertices are considered distinct from vertices produced by subdividing
the outer edge of the patch, even if there are pairs of vertices with
identical coordinates.





## Tessellation Primitive Ordering

Few guarantees are provided for the relative ordering of primitives produced
by tessellation, as they pertain to primitive
order.

- The output primitives generated from each input primitive are passed to
  subsequent pipeline stages in an implementation-dependent order.

- All output primitives generated from a given input primitive are passed
  to subsequent pipeline stages before any output primitives generated
  from subsequent input primitives.





## Tessellator Vertex Winding Order

When the tessellator produces triangles (in the `Triangles` or `Quads`
modes), the orientation of all triangles is specified with an
`OpExecutionMode` of `VertexOrderCw` or `VertexOrderCcw` in the
tessellation control or tessellation evaluation shaders.
If the order is `VertexOrderCw`, the vertices of all generated triangles
will have clockwise ordering in (u,v) or (u,v,w) space.
If the order is `VertexOrderCcw`, the vertices will have
counter-clockwise ordering in that space.

If the tessellation domain has an upper-left origin, the vertices of a
triangle have counter-clockwise ordering if



is negative, and clockwise ordering if a is positive.
u\<sub>i\</sub> and v\<sub>i\</sub> are the u and v coordinates in
normalized parameter space of the ith vertex of the triangle.


::note
The value a is proportional (with a positive factor) to the signed
area of the triangle.

In `Triangles` mode, even though the vertex coordinates have a w
value, it does not participate directly in the computation of a, being
an affine combination of u and v.
::






## Triangle Tessellation

If the tessellation primitive mode is `Triangles`, an equilateral
triangle is subdivided into a collection of triangles covering the area of
the original triangle.
First, the original triangle is subdivided into a collection of concentric
equilateral triangles.
The edges of each of these triangles are subdivided, and the area between
each triangle pair is filled by triangles produced by joining the vertices
on the subdivided edges.
The number of concentric triangles and the number of subdivisions along each
triangle except the outermost is derived from the first inner tessellation
level.
The edges of the outermost triangle are subdivided independently, using the
first, second, and third outer tessellation levels to control the number of
subdivisions of the u = 0 (left), v = 0 (bottom), and w =
0 (right) edges, respectively.
The second inner tessellation level and the fourth outer tessellation level
have no effect in this mode.

If the first inner tessellation level and all three outer tessellation
levels are exactly one after clamping and rounding, only a single triangle
with (u,v,w) coordinates of (0,0,1), (1,0,0), and
(0,1,0) is generated.
If the inner tessellation level is one and any of the outer tessellation
levels is greater than one, the inner tessellation level is treated as
though it were originally specified as 1 +  ε and will
result in a two- or three-segment subdivision depending on the tessellation
spacing.
When used with fractional odd spacing, the three-segment subdivision :normative{type="may"}
produce *inner vertices* positioned on the edge of the triangle.

If any tessellation level is greater than one, tessellation begins by
producing a set of concentric inner triangles and subdividing their edges.
First, the three outer edges are temporarily subdivided using the clamped
and rounded first inner tessellation level and the specified tessellation
spacing, generating n segments.
For the outermost inner triangle, the inner triangle is degenerate — a
single point at the center of the triangle — if n is two.
Otherwise, for each corner of the outer triangle, an inner triangle corner
is produced at the intersection of two lines extended perpendicular to the
corner’s two adjacent edges running through the vertex of the subdivided
outer edge nearest that corner.
If n is three, the edges of the inner triangle are not subdivided and
it is the final triangle in the set of concentric triangles.
Otherwise, each edge of the inner triangle is divided into n - 2
segments, with the n - 1 vertices of this subdivision produced by
intersecting the inner edge with lines perpendicular to the edge running
through the n - 1 innermost vertices of the subdivision of the outer
edge.
Once the outermost inner triangle is subdivided, the previous subdivision
process repeats itself, using the generated triangle as an outer triangle.
This subdivision process is illustrated in Inner Triangle
Tessellation.





Once all the concentric triangles are produced and their edges are
subdivided, the area between each pair of adjacent inner triangles is filled
completely with a set of non-overlapping triangles.
In this subdivision, two of the three vertices of each triangle are taken
from adjacent vertices on a subdivided edge of one triangle; the third is
one of the vertices on the corresponding edge of the other triangle.
If the innermost triangle is degenerate (i.e., a point), the triangle
containing it is subdivided into six triangles by connecting each of the six
vertices on that triangle with the center point.
If the innermost triangle is not degenerate, that triangle is added to the
set of generated triangles as-is.

After the area corresponding to any inner triangles is filled, the
tessellator generates triangles to cover the area between the outermost
triangle and the outermost inner triangle.
To do this, the temporary subdivision of the outer triangle edge above is
discarded.
Instead, the u = 0, v = 0, and w = 0 edges are subdivided
according to the first, second, and third outer tessellation levels,
respectively, and the tessellation spacing.
The original subdivision of the first inner triangle is retained.
The area between the outer and first inner triangles is completely filled by
non-overlapping triangles as described above.
If the first (and only) inner triangle is degenerate, a set of triangles is
produced by connecting each vertex on the outer triangle edges with the
center point.

After all triangles are generated, each vertex in the subdivided triangle is
assigned a barycentric (u,v,w) coordinate based on its location relative to
the three vertices of the outer triangle.

The algorithm used to subdivide the triangular domain in (u,v,w) space into
individual triangles is implementation-dependent.
However, the set of triangles produced will completely cover the domain, and
no portion of the domain will be covered by multiple triangles.

Output triangles are generated with a topology similar to
triangle lists, except that the order in which
each triangle is generated, and the order in which the vertices are
generated for each triangle, are implementation-dependent.
However, the order of vertices in each triangle is consistent across the
domain as described in .





## Quad Tessellation

If the tessellation primitive mode is `Quads`, a rectangle is subdivided
into a collection of triangles covering the area of the original rectangle.
First, the original rectangle is subdivided into a regular mesh of
rectangles, where the number of rectangles along the u = 0 and u
\= 1 (vertical) and v = 0 and v = 1 (horizontal) edges are
derived from the first and second inner tessellation levels, respectively.
All rectangles, except those adjacent to one of the outer rectangle edges,
are decomposed into triangle pairs.
The outermost rectangle edges are subdivided independently, using the first,
second, third, and fourth outer tessellation levels to control the number of
subdivisions of the u = 0 (left), v = 0 (bottom), u = 1
(right), and v = 1 (top) edges, respectively.
The area between the inner rectangles of the mesh and the outer rectangle
edges are filled by triangles produced by joining the vertices on the
subdivided outer edges to the vertices on the edge of the inner rectangle
mesh.

If both clamped inner tessellation levels and all four clamped outer
tessellation levels are exactly one, only a single triangle pair covering
the outer rectangle is generated.
Otherwise, if either clamped inner tessellation level is one, that
tessellation level is treated as though it was originally specified as
1 +  ε and will result in a two- or three-segment
subdivision depending on the tessellation spacing.
When used with fractional odd spacing, the three-segment subdivision :normative{type="may"}
produce *inner vertices* positioned on the edge of the rectangle.

If any tessellation level is greater than one, tessellation begins by
subdividing the u = 0 and u = 1 edges of the outer rectangle
into m segments using the clamped and rounded first inner tessellation
level and the tessellation spacing.
The v = 0 and v = 1 edges are subdivided into n segments
using the second inner tessellation level.
Each vertex on the u = 0 and v = 0 edges are joined with the
corresponding vertex on the u = 1 and v = 1 edges to produce a
set of vertical and horizontal lines that divide the rectangle into a grid
of smaller rectangles.
The primitive generator emits a pair of non-overlapping triangles covering
each such rectangle not adjacent to an edge of the outer rectangle.
The boundary of the region covered by these triangles forms an inner
rectangle, the edges of which are subdivided by the grid vertices that lie
on the edge.
If either m or n is two, the inner rectangle is degenerate, and
one or both of the rectangle’s *edges* consist of a single point.
This subdivision is illustrated in Figure Inner Quad
Tessellation.





After the area corresponding to the inner rectangle is filled, the
tessellator :normative{type="must"} produce triangles to cover the area between the inner and
outer rectangles.
To do this, the subdivision of the outer rectangle edge above is discarded.
Instead, the u = 0, v = 0, u = 1, and v = 1 edges
are subdivided according to the first, second, third, and fourth outer
tessellation levels, respectively, and the tessellation spacing.
The original subdivision of the inner rectangle is retained.
The area between the outer and inner rectangles is completely filled by
non-overlapping triangles.
Two of the three vertices of each triangle are adjacent vertices on a
subdivided edge of one rectangle; the third is one of the vertices on the
corresponding edge of the other rectangle.
If either edge of the innermost rectangle is degenerate, the area near the
corresponding outer edges is filled by connecting each vertex on the outer
edge with the single vertex making up the *inner edge*.

The algorithm used to subdivide the rectangular domain in (u,v) space into
individual triangles is implementation-dependent.
However, the set of triangles produced will completely cover the domain, and
no portion of the domain will be covered by multiple triangles.

Output triangles are generated with a topology similar to
triangle lists, except that the order in which
each triangle is generated, and the order in which the vertices are
generated for each triangle, are implementation-dependent.
However, the order of vertices in each triangle is consistent across the
domain as described in .





## Isoline Tessellation

If the tessellation primitive mode is `IsoLines`, a set of independent
horizontal line segments is drawn.
The segments are arranged into connected strips called *isolines*, where the
vertices of each isoline have a constant v coordinate and u coordinates
covering the full range \[0,1].
The number of isolines generated is derived from the first outer
tessellation level; the number of segments in each isoline is derived from
the second outer tessellation level.
Both inner tessellation levels and the third and fourth outer tessellation
levels have no effect in this mode.

As with quad tessellation above, isoline tessellation begins with a
rectangle.
The u = 0 and u = 1 edges of the rectangle are subdivided
according to the first outer tessellation level.
For the purposes of this subdivision, the tessellation spacing mode is
ignored and treated as equal\_spacing.
An isoline is drawn connecting each vertex on the u = 0 rectangle edge
to the corresponding vertex on the u = 1 rectangle edge, except that
no line is drawn between (0,1) and (1,1).
If the number of isolines on the subdivided u = 0 and u = 1
edges is n, this process will result in n equally spaced lines
with constant v coordinates of 0, .

Each of the n isolines is then subdivided according to the second
outer tessellation level and the tessellation spacing, resulting in m
line segments.
Each segment of each line is emitted by the tessellator.
These line segments are generated with a topology similar to
line lists, except that the order in which each line
is generated, and the order in which the vertices are generated for each
line segment, are implementation-dependent.





## Tessellation Point Mode

For all primitive modes, the tessellator is capable of generating points
instead of lines or triangles.
If the tessellation control or tessellation evaluation shader specifies the
`OpExecutionMode` `PointMode`, the primitive generator will generate
one point for each distinct vertex produced by tessellation, rather than
emitting triangles or lines.
Otherwise, the tessellator will produce a collection of line segments or
triangles according to the primitive mode.
These points are generated with a topology similar to point lists, except the order in which the points are generated for each
input primitive is undefined:.





## Tessellation Pipeline State

The `pTessellationState` member of [VkGraphicsPipelineCreateInfo](/man/VkGraphicsPipelineCreateInfo) is
a pointer to a `VkPipelineTessellationStateCreateInfo` structure.

The `VkPipelineTessellationStateCreateInfo` structure is defined as:

[{generated}/api/structs/VkPipelineTessellationStateCreateInfo.adoc]({generated}/api/structs/VkPipelineTessellationStateCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is reserved for future use.

- `patchControlPoints` is the number of control points per patch.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkPipelineTessellationStateCreateInfo-patchControlPoints-01214"}
`patchControlPoints` :normative{type="must"} be greater than zero and less than or
equal to `VkPhysicalDeviceLimits`::`maxTessellationPatchSize`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkPipelineTessellationStateCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO`
::

::validity-field{name="VUID-VkPipelineTessellationStateCreateInfo-pNext-pNext"}
 `pNext` :normative{type="must"} be `NULL` or a pointer to a valid instance of [VkPipelineTessellationDomainOriginStateCreateInfo](/man/VkPipelineTessellationDomainOriginStateCreateInfo)
::

::validity-field{name="VUID-VkPipelineTessellationStateCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkPipelineTessellationStateCreateInfo-flags-zerobitmask"}
 `flags` :normative{type="must"} be `0`
::

::


[{generated}/api/flags/VkPipelineTessellationStateCreateFlags.adoc]({generated}/api/flags/VkPipelineTessellationStateCreateFlags.adoc)

`VkPipelineTessellationStateCreateFlags` is a bitmask type for setting a
mask, but is currently reserved for future use.







# Geometry Shading

The geometry shader operates on a group of vertices and their associated
data assembled from a single input primitive, and emits zero or more output
primitives and the group of vertices and their associated data required for
each output primitive.
Geometry shading is enabled when a geometry shader is included in the
pipeline.



## Geometry Shader Input Primitives

Each geometry shader invocation has access to all vertices in the primitive
(and their associated data), which are presented to the shader as an array
of inputs.

The input primitive type expected by the geometry shader is specified with
an `OpExecutionMode` instruction in the geometry shader, and :normative{type="must"} match
the incoming primitive type specified by either the pipeline’s
primitive topology if tessellation is
inactive, or the tessellation mode if tessellation is
active, as follows:

- An input primitive type of `InputPoints` :normative{type="must"} only be used with a
  pipeline topology of `VK_PRIMITIVE_TOPOLOGY_POINT_LIST`, or with a
  tessellation shader specifying `PointMode`.
  The input arrays always contain one element, as described by the
  point list topology or
  tessellation in point mode.

- An input primitive type of `InputLines` :normative{type="must"} only be used with a
  pipeline topology of `VK_PRIMITIVE_TOPOLOGY_LINE_LIST` or
  `VK_PRIMITIVE_TOPOLOGY_LINE_STRIP`, or with a tessellation shader
  specifying `IsoLines` that does not specify `PointMode`.
  The input arrays always contain two elements, as described by the
  line list topology or line strip topology, or by isoline tessellation.

- An input primitive type of `InputLinesAdjacency` :normative{type="must"} only be used
  when tessellation is inactive, with a pipeline topology of
  `VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY` or
  `VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY`.
  The input arrays always contain four elements, as described by the
  line list with adjacency topology
  or line strip with adjacency
  topology.

- An input primitive type of `Triangles` :normative{type="must"} only be used with a
  pipeline topology of `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST`,
  `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP`, or
  `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN`; or with a tessellation shader
  specifying `Quads` or `Triangles` that does not specify
  `PointMode`.
  The input arrays always contain three elements, as described by the
  triangle list topology,
  triangle strip topology, or
  triangle fan topology, or by
  triangle or
  quad tessellation.
  Vertices :normative{type="may"} be in a different absolute order than specified by the
  topology, but :normative{type="must"} adhere to the specified winding order.

- An input primitive type of `InputTrianglesAdjacency` :normative{type="must"} only be
  used when tessellation is inactive, with a pipeline topology of
  `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY` or
  `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY`.
  The input arrays always contain six elements, as described by the
  triangle list with adjacency
  topology or triangle strip
  with adjacency topology.
  Vertices :normative{type="may"} be in a different absolute order than specified by the
  topology, but :normative{type="must"} adhere to the specified winding order, and the
  vertices making up the main primitive :normative{type="must"} still occur at the first,
  third, and fifth index.





## Geometry Shader Output Primitives

A geometry shader generates primitives in one of three output modes: points,
line strips, or triangle strips.
The primitive mode is specified in the shader using an `OpExecutionMode`
instruction with the `OutputPoints`, `OutputLineStrip` or
`OutputTriangleStrip` modes, respectively.
Each geometry shader :normative{type="must"} include exactly one output primitive mode.

The vertices output by the geometry shader are assembled into points, lines,
or triangles based on the output primitive type and the resulting primitives
are then further processed as described in .
If the number of vertices emitted by the geometry shader is not sufficient
to produce a single primitive, vertices corresponding to incomplete
primitives are not processed by subsequent pipeline stages.
The number of vertices output by the geometry shader is limited to a maximum
count specified in the shader.

The maximum output vertex count is specified in the shader using an
`OpExecutionMode` instruction with the mode set to `OutputVertices`
and the maximum number of vertices that will be produced by the geometry
shader specified as a literal.
Each geometry shader :normative{type="must"} specify a maximum output vertex count.





## Multiple Invocations of Geometry Shaders

Geometry shaders :normative{type="can"} be invoked more than one time for each input
primitive.
This is known as *geometry shader instancing* and is requested by including
an `OpExecutionMode` instruction with `mode` specified as
`Invocations` and the number of invocations specified as an integer
literal.

In this mode, the geometry shader will execute at least n times for
each input primitive, where n is the number of invocations specified
in the `OpExecutionMode` instruction.
The instance number is available to each invocation as a built-in input
using `InvocationId`.





## Geometry Shader Primitive Ordering

Limited guarantees are provided for the relative ordering of primitives
produced by a geometry shader, as they pertain to primitive order.

- For instanced geometry shaders, the output primitives generated from
  each input primitive are passed to subsequent pipeline stages using the
  invocation number to order the primitives, from least to greatest.

- All output primitives generated from a given input primitive are passed
  to subsequent pipeline stages before any output primitives generated
  from subsequent input primitives.







# Fixed-Function Vertex Post-Processing

After pre-rasterization
shader stages, the following fixed-function operations are applied to
vertices of the resulting primitives:

- Flat shading (see ).

- Primitive clipping, including client-defined half-spaces (see
  Primitive Clipping).

- Shader output attribute clipping (see
  Clipping Shader Outputs).

- Perspective division on clip coordinates (see
  Coordinate Transformations).

- Viewport mapping, including depth range scaling (see
  Controlling the Viewport).

- Front face determination for polygon primitives (see
  Basic Polygon Rasterization).

Next, rasterization is performed on primitives as described in chapter
Rasterization.



## Flat Shading

*Flat shading* a vertex output attribute means to assign all vertices of the
primitive the same value for that output.
The output values assigned are those of the *provoking vertex* of the
primitive.
Flat shading is applied to those vertex attributes that
match fragment input attributes which
are decorated as `Flat`.

If neither
geometry nor tessellation shading is active,
the provoking vertex is determined by the primitive topology defined by
[VkPipelineInputAssemblyStateCreateInfo](/man/VkPipelineInputAssemblyStateCreateInfo):`topology` used to execute
the drawing command.

If geometry shading is active, the provoking vertex is
determined by the primitive topology
defined by the `OutputPoints`,
`OutputLineStrip`, or `OutputTriangleStrip` execution mode.

If tessellation shading is active but geometry
shading is not, the provoking vertex :normative{type="may"} be any of the vertices in each
primitive.





## Primitive Clipping

Primitives are culled against the *cull volume* and then clipped to the
*clip volume*.
In clip coordinates, the *view volume* is defined by:



where
z\<sub>m\</sub> is equal to zero.

This view volume :normative{type="can"} be further restricted by as many as
`VkPhysicalDeviceLimits`::`maxClipDistances` client-defined
half-spaces.

The cull volume is the intersection of up to
`VkPhysicalDeviceLimits`::`maxCullDistances` client-defined
half-spaces (if no client-defined cull half-spaces are enabled, culling
against the cull volume is skipped).

A shader :normative{type="must"} write a single cull distance for each enabled cull half-space
to elements of the `CullDistance` array.
If the cull distance for any enabled cull half-space is negative for all of
the vertices of the primitive under consideration, the primitive is
discarded.
Otherwise the primitive is clipped against the clip volume as defined below.

The clip volume is the intersection of up to
`VkPhysicalDeviceLimits`::`maxClipDistances` client-defined
half-spaces with the view volume (if no client-defined clip half-spaces are
enabled, the clip volume is the view volume).

A shader :normative{type="must"} write a single clip distance for each enabled clip half-space
to elements of the `ClipDistance` array.
Clip half-space i is then given by the set of points satisfying the
inequality



where c\<sub>i\</sub>(*P*) is the clip distance i at point *P*.
For point primitives, c\<sub>i\</sub>(*P*) is simply the clip distance for the
vertex in question.
For line and triangle primitives, per-vertex clip distances are interpolated
using a weighted mean, with weights derived according to the algorithms
described in sections Basic Line Segment
Rasterization and Basic Polygon
Rasterization, using the perspective interpolation equations.

The number of client-defined clip and cull half-spaces that are enabled is
determined by the explicit size of the built-in arrays `ClipDistance` and
`CullDistance`, respectively, declared as an output in the interface of
the entry point of the final shader stage before clipping.

Depth clamping is enabled or disabled via the `depthClampEnable` enable
of the [VkPipelineRasterizationStateCreateInfo](/man/VkPipelineRasterizationStateCreateInfo) structure.
Depth clipping is disabled when `depthClampEnable` is `VK_TRUE`.

When depth clipping is disabled, the plane equation



(see the clip volume definition above) is ignored by view volume clipping
(effectively, there is no near or far plane clipping).

If the primitive under consideration is a point or line segment, then
clipping passes it unchanged if its vertices lie entirely within the clip
volume.

If a point’s vertex lies outside of the clip volume, the entire primitive
:normative{type="may"} be discarded.

If either of a line segment’s vertices lie outside of the clip volume, the
line segment :normative{type="may"} be clipped, with new vertex coordinates computed for each
vertex that lies outside the clip volume.
A clipped line segment endpoint lies on both the original line segment and
the boundary of the clip volume.

This clipping produces a value, 0 ≤ t ≤ 1, for each clipped
vertex.
If the coordinates of a clipped vertex are *P* and the unclipped
line segment’s vertex coordinates are *P*\<sub>1\</sub> and *P*\<sub>2\</sub>,
then t satisfies the following equation



t is used to clip vertex output attributes as described in
Clipping Shader Outputs.

If the primitive is a polygon, it passes unchanged if every one of its edges
lies entirely inside the clip volume, and is either clipped or discarded
otherwise.
If the edges of the polygon intersect the boundary of the clip volume, the
intersecting edges are reconnected by new edges that lie along the boundary
of the clip volume - in some cases requiring the introduction of new
vertices into a polygon.

If a polygon intersects an edge of the clip volume’s boundary, the clipped
polygon :normative{type="must"} include a point on this boundary edge.

Primitives rendered with user-defined half-spaces :normative{type="must"} satisfy a
complementarity criterion.
Suppose a series of primitives is drawn where each vertex i has a
single specified clip distance d\<sub>i\</sub> (or a number of similarly
specified clip distances, if multiple half-spaces are enabled).
Next, suppose that the same series of primitives are drawn again with each
such clip distance replaced by -d\<sub>i\</sub> (and the graphics pipeline is
otherwise the same).
In this case, primitives :normative{type="must"} not be missing any pixels, and pixels :normative{type="must"}
not be drawn twice in regions where those primitives are cut by the clip
planes.





## Clipping Shader Outputs

Next, vertex output attributes are clipped.
The output values associated with a vertex that lies within the clip volume
are unaffected by clipping.
If a primitive is clipped, however, the output values assigned to vertices
produced by clipping are clipped.

Let the output values assigned to the two vertices *P*\<sub>1\</sub> and
*P*\<sub>2\</sub> of an unclipped edge be *c*\<sub>1\</sub> and *c*\<sub>2\</sub>.
The value of t (see Primitive Clipping)
for a clipped point *P* is used to obtain the output value
associated with *P* as



(Multiplying an output value by a scalar means multiplying each of *x*, *y*,
*z*, and *w* by the scalar.)

Since this computation is performed in clip space before division by
w\<sub>c\</sub>, clipped output values are perspective-correct.

Polygon clipping creates a clipped vertex along an edge of the clip volume’s
boundary.
This situation is handled by noting that polygon clipping proceeds by
clipping against one half-space at a time.
Output value clipping is done in the same way, so that clipped points always
occur at the intersection of polygon edges (possibly already clipped) with
the clip volume’s boundary.

For vertex output attributes whose matching fragment input attributes are
decorated with `NoPerspective`, the value of t used to obtain the
output value associated with *P* will be adjusted to produce results
that vary linearly in framebuffer space.

Output attributes of integer or unsigned integer type :normative{type="must"} always be flat
shaded.
Flat shaded attributes are constant over the primitive being rasterized (see
Basic Line Segment Rasterization and
Basic Polygon Rasterization), and no
interpolation is performed.
The output value *c* is taken from either *c*\<sub>1\</sub> or
*c*\<sub>2\</sub>, since flat shading has already occurred and the two values
are identical.





## Coordinate Transformations

*Clip coordinates* for a vertex result from shader execution, which yields a
vertex coordinate `Position`.

Perspective division on clip coordinates yields *normalized device
coordinates*, followed by a *viewport* transformation (see
Controlling the Viewport) to convert these
coordinates into *framebuffer coordinates*.

If a vertex in clip coordinates has a position given by



then the vertex’s normalized device coordinates are







## Controlling the Viewport

The viewport transformation is determined by the selected viewport’s width
and height in pixels, p\<sub>x\</sub> and p\<sub>y\</sub>, respectively, and its
center (o\<sub>x\</sub>, o\<sub>y\</sub>) (also in pixels), as well as its depth range min
and max determining a depth range scale value p\<sub>z\</sub> and a depth range
bias value o\<sub>z\</sub> (defined below).
The vertex’s framebuffer coordinates (x\<sub>f\</sub>, y\<sub>f\</sub>, z\<sub>f\</sub>) are given by



Multiple viewports are available, numbered zero up to
`VkPhysicalDeviceLimits`::`maxViewports` minus one.
The number of viewports used by a pipeline is controlled by the
`viewportCount` member of the `VkPipelineViewportStateCreateInfo`
structure used in pipeline creation.

x\<sub>f\</sub> and y\<sub>f\</sub> have limited precision, where the number of
fractional bits retained is specified by
`VkPhysicalDeviceLimits`::`subPixelPrecisionBits`.

The `VkPipelineViewportStateCreateInfo` structure is defined as:

[{generated}/api/structs/VkPipelineViewportStateCreateInfo.adoc]({generated}/api/structs/VkPipelineViewportStateCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is reserved for future use.

- `viewportCount` is the number of viewports used by the pipeline.

- `pViewports` is a pointer to an array of [VkViewport](/man/VkViewport)
  structures, defining the viewport transforms.
  If the viewport state is dynamic, this member is ignored.

- `scissorCount` is the number of scissors and
  :normative{type="must"} match the number of viewports.

- `pScissors` is a pointer to an array of [VkRect2D](/man/VkRect2D) structures
  defining the rectangular bounds of the scissor for the corresponding
  viewport.
  If the scissor state is dynamic, this member is ignored.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkPipelineViewportStateCreateInfo-viewportCount-01216"}

If the `multiViewport` feature is not
enabled, `viewportCount` :normative{type="must"} not be greater than `1`
::

::validity-field{name="VUID-VkPipelineViewportStateCreateInfo-scissorCount-01217"}

If the `multiViewport` feature is not
enabled, `scissorCount` :normative{type="must"} not be greater than `1`
::

::validity-field{name="VUID-VkPipelineViewportStateCreateInfo-viewportCount-01218"}
`viewportCount` :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxViewports`
::

::validity-field{name="VUID-VkPipelineViewportStateCreateInfo-scissorCount-01219"}
`scissorCount` :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxViewports`
::

::validity-field{name="VUID-VkPipelineViewportStateCreateInfo-x-02821"}

The `x` and `y` members of `offset` member of any element of
`pScissors` :normative{type="must"} be greater than or equal to `0`
::

::validity-field{name="VUID-VkPipelineViewportStateCreateInfo-offset-02822"}

Evaluation of (`offset.x` +  `extent.width`) :normative{type="must"} not
cause a signed integer addition overflow for any element of
`pScissors`
::

::validity-field{name="VUID-VkPipelineViewportStateCreateInfo-offset-02823"}

Evaluation of (`offset.y` +  `extent.height`) :normative{type="must"}
not cause a signed integer addition overflow for any element of
`pScissors`
::

::validity-field{name="VUID-VkPipelineViewportStateCreateInfo-scissorCount-04134"}

If `scissorCount` and `viewportCount` are both not dynamic, then
`scissorCount` and `viewportCount` :normative{type="must"} be identical
::

::validity-field{name="VUID-VkPipelineViewportStateCreateInfo-viewportCount-arraylength"}
`viewportCount` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-VkPipelineViewportStateCreateInfo-scissorCount-arraylength"}
`scissorCount` :normative{type="must"} be greater than `0`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkPipelineViewportStateCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO`
::

::validity-field{name="VUID-VkPipelineViewportStateCreateInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkPipelineViewportCoarseSampleOrderStateCreateInfoNV](/man/VkPipelineViewportCoarseSampleOrderStateCreateInfoNV), [VkPipelineViewportDepthClipControlCreateInfoEXT](/man/VkPipelineViewportDepthClipControlCreateInfoEXT), [VkPipelineViewportExclusiveScissorStateCreateInfoNV](/man/VkPipelineViewportExclusiveScissorStateCreateInfoNV), [VkPipelineViewportShadingRateImageStateCreateInfoNV](/man/VkPipelineViewportShadingRateImageStateCreateInfoNV), [VkPipelineViewportSwizzleStateCreateInfoNV](/man/VkPipelineViewportSwizzleStateCreateInfoNV), or [VkPipelineViewportWScalingStateCreateInfoNV](/man/VkPipelineViewportWScalingStateCreateInfoNV)
::

::validity-field{name="VUID-VkPipelineViewportStateCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkPipelineViewportStateCreateInfo-flags-zerobitmask"}
 `flags` :normative{type="must"} be `0`
::

::


[{generated}/api/flags/VkPipelineViewportStateCreateFlags.adoc]({generated}/api/flags/VkPipelineViewportStateCreateFlags.adoc)

`VkPipelineViewportStateCreateFlags` is a bitmask type for setting a
mask, but is currently reserved for future use.

If a geometry shader is active and has an output variable decorated with
`ViewportIndex`, the viewport transformation uses the viewport
corresponding to the value assigned to `ViewportIndex` taken from an
implementation-dependent vertex of each primitive.
If `ViewportIndex` is outside the range zero to `viewportCount` minus
one for a primitive, or if the geometry shader did not assign a value to
`ViewportIndex` for all vertices of a primitive due to flow control, the
values resulting from the viewport transformation of the vertices of such
primitives are undefined:.
If no geometry shader is active, or if the geometry shader does not have an
output decorated with `ViewportIndex`, the viewport numbered zero is used
by the viewport transformation.

A single vertex :normative{type="can"} be used in more than one individual primitive, in
primitives such as `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP`.
In this case, the viewport transformation is applied separately for each
primitive.

To dynamically set the viewport transformation
parameters, call:

[{generated}/api/protos/vkCmdSetViewport.adoc]({generated}/api/protos/vkCmdSetViewport.adoc)

- `commandBuffer` is the command buffer into which the command will be
  recorded.

- `firstViewport` is the index of the first viewport whose parameters
  are updated by the command.

- `viewportCount` is the number of viewports whose parameters are
  updated by the command.

- `pViewports` is a pointer to an array of [VkViewport](/man/VkViewport) structures
  specifying viewport parameters.

This command sets the viewport transformation parameters state for
subsequent drawing commands
when the graphics pipeline is created with `VK_DYNAMIC_STATE_VIEWPORT`
set in [VkPipelineDynamicStateCreateInfo](/man/VkPipelineDynamicStateCreateInfo)::`pDynamicStates`.
Otherwise, this state is specified by the
`VkPipelineViewportStateCreateInfo`::`pViewports` values used to
create the currently active pipeline.

The viewport parameters taken from element i of `pViewports`
replace the current state for the viewport index `firstViewport`
\+  i, for i in \[0, `viewportCount`).


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdSetViewport-firstViewport-01223"}

The sum of `firstViewport` and `viewportCount` :normative{type="must"} be between
`1` and `VkPhysicalDeviceLimits`::`maxViewports`, inclusive
::

::validity-field{name="VUID-vkCmdSetViewport-firstViewport-01224"}

If the `multiViewport` feature is not
enabled, `firstViewport` :normative{type="must"} be `0`
::

::validity-field{name="VUID-vkCmdSetViewport-viewportCount-01225"}

If the `multiViewport` feature is not
enabled, `viewportCount` :normative{type="must"} be `1`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdSetViewport-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdSetViewport-pViewports-parameter"}
 `pViewports` :normative{type="must"} be a valid pointer to an array of `viewportCount` valid [VkViewport](/man/VkViewport) structures
::

::validity-field{name="VUID-vkCmdSetViewport-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdSetViewport-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics operations
::

::validity-field{name="VUID-vkCmdSetViewport-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdSetViewport-viewportCount-arraylength"}
 `viewportCount` :normative{type="must"} be greater than `0`
::

::






Both [VkPipelineViewportStateCreateInfo](/man/VkPipelineViewportStateCreateInfo) and [vkCmdSetViewport](/man/vkCmdSetViewport) use
`VkViewport` to set the viewport transformation parameters.

The `VkViewport` structure is defined as:

[{generated}/api/structs/VkViewport.adoc]({generated}/api/structs/VkViewport.adoc)

- `x` and `y` are the viewport’s upper left corner (x,y).

- `width` and `height` are the viewport’s width and height,
  respectively.

- `minDepth` and `maxDepth` are the depth range for the viewport.


::note
Despite their names, `minDepth` :normative{type="can"} be less than, equal to, or greater
than `maxDepth`.
::


The framebuffer depth coordinate `z`\<sub>f\</sub> :normative{type="may"} be represented using
either a fixed-point or floating-point representation.
However, a floating-point representation :normative{type="must"} be used if the depth/stencil
attachment has a floating-point depth component.
If an m-bit fixed-point representation is used, we assume that it
represents each value , where k ∈ {
0, 1, …​, 2\<sup>m\</sup>-1 }, as k (e.g. 1.0 is represented in binary as a
string of all ones).

The viewport parameters shown in the above equations are found from these
values as



The width and height of the implementation-dependent maximum viewport dimensions :normative{type="must"} be greater than
or equal to the width and height of the largest image which :normative{type="can"} be created
and attached to a framebuffer.

The floating-point viewport bounds are represented with an
implementation-dependent precision.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkViewport-width-01770"}
`width` :normative{type="must"} be greater than `0.0`
::

::validity-field{name="VUID-VkViewport-width-01771"}
`width` :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxViewportDimensions`[0]
::

::validity-field{name="VUID-VkViewport-apiVersion-07917"}

If the [VK_KHR_maintenance1](/man/VK_KHR_maintenance1) extension is not enabled, the
[VK_AMD_negative_viewport_height](/man/VK_AMD_negative_viewport_height) extension is not enabled, and
[VkPhysicalDeviceProperties](/man/VkPhysicalDeviceProperties)::`apiVersion` is less than Vulkan
1.1, `height` :normative{type="must"} be greater than `0.0`
::

::validity-field{name="VUID-VkViewport-height-01773"}

The absolute value of `height` :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxViewportDimensions`[1]
::

::validity-field{name="VUID-VkViewport-x-01774"}
`x` :normative{type="must"} be greater than or equal to `viewportBoundsRange`[0]
::

::validity-field{name="VUID-VkViewport-x-01232"}
(`x` +  `width`) :normative{type="must"} be less than or equal to
`viewportBoundsRange`[1]
::

::validity-field{name="VUID-VkViewport-y-01775"}
`y` :normative{type="must"} be greater than or equal to `viewportBoundsRange`[0]
::

::validity-field{name="VUID-VkViewport-y-01233"}
(`y` +  `height`) :normative{type="must"} be less than or equal to
`viewportBoundsRange`[1]
::

::validity-field{name="VUID-VkViewport-minDepth-02540"}
`minDepth` :normative{type="must"} be between `0.0` and `1.0`, inclusive
::

::validity-field{name="VUID-VkViewport-maxDepth-02541"}
`maxDepth` :normative{type="must"} be between `0.0` and `1.0`, inclusive
::

::








# Rasterization

Rasterization is the process by which a primitive is converted to a
two-dimensional image.
Each discrete location of this image contains associated data such as depth,
color, or other attributes.

Rasterizing a primitive begins by determining which squares of an integer
grid in framebuffer coordinates are occupied by the primitive, and assigning
one or more depth values to each such square.
This process is described below for points, lines, and polygons.

A grid square, including its (x,y) framebuffer coordinates, z
(depth), and associated data added by fragment shaders, is called a
fragment.
A fragment is located by its upper left corner, which lies on integer grid
coordinates.

Rasterization operations also refer to a fragment’s sample locations, which
are offset by fractional values from its upper left corner.
The rasterization rules for points, lines, and triangles involve testing
whether each sample location is inside the primitive.
Fragments need not actually be square, and rasterization rules are not
affected by the aspect ratio of fragments.
Display of non-square grids, however, will cause rasterized points and line
segments to appear fatter in one direction than the other.

We assume that fragments are square, since it simplifies antialiasing and
texturing.
After rasterization, fragments are processed by fragment
operations.

Several factors affect rasterization, including the members of
[VkPipelineRasterizationStateCreateInfo](/man/VkPipelineRasterizationStateCreateInfo) and
[VkPipelineMultisampleStateCreateInfo](/man/VkPipelineMultisampleStateCreateInfo).

The `VkPipelineRasterizationStateCreateInfo` structure is defined as:

[{generated}/api/structs/VkPipelineRasterizationStateCreateInfo.adoc]({generated}/api/structs/VkPipelineRasterizationStateCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is reserved for future use.

- `depthClampEnable` controls whether to clamp the fragment’s depth
  values as described in Depth Test.
  Enabling depth clamp will also disable clipping primitives to the z
  planes of the frustrum as described in Primitive Clipping.

- `rasterizerDiscardEnable` controls whether primitives are discarded
  immediately before the rasterization stage.

- `polygonMode` is the triangle rendering mode.
  See [VkPolygonMode](/man/VkPolygonMode).

- `cullMode` is the triangle facing direction used for primitive
  culling.
  See [VkCullModeFlagBits](/man/VkCullModeFlagBits).

- `frontFace` is a [VkFrontFace](/man/VkFrontFace) value specifying the front-facing
  triangle orientation to be used for culling.

- `depthBiasEnable` controls whether to bias fragment depth values.

- `depthBiasConstantFactor` is a scalar factor controlling the
  constant depth value added to each fragment.

- `depthBiasClamp` is the maximum (or minimum) depth bias of a
  fragment.

- `depthBiasSlopeFactor` is a scalar factor applied to a fragment’s
  slope in depth bias calculations.

- `lineWidth` is the width of rasterized line segments.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkPipelineRasterizationStateCreateInfo-depthClampEnable-00782"}

If the `depthClamp` feature is not enabled,
`depthClampEnable` :normative{type="must"} be `VK_FALSE`
::

::validity-field{name="VUID-VkPipelineRasterizationStateCreateInfo-polygonMode-01507"}

If the `fillModeNonSolid` feature is
not enabled, `polygonMode` :normative{type="must"} be `VK_POLYGON_MODE_FILL`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkPipelineRasterizationStateCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO`
::

::validity-field{name="VUID-VkPipelineRasterizationStateCreateInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkDepthBiasRepresentationInfoEXT](/man/VkDepthBiasRepresentationInfoEXT), [VkPipelineRasterizationConservativeStateCreateInfoEXT](/man/VkPipelineRasterizationConservativeStateCreateInfoEXT), [VkPipelineRasterizationDepthClipStateCreateInfoEXT](/man/VkPipelineRasterizationDepthClipStateCreateInfoEXT), [VkPipelineRasterizationLineStateCreateInfoEXT](/man/VkPipelineRasterizationLineStateCreateInfoEXT), [VkPipelineRasterizationProvokingVertexStateCreateInfoEXT](/man/VkPipelineRasterizationProvokingVertexStateCreateInfoEXT), [VkPipelineRasterizationStateRasterizationOrderAMD](/man/VkPipelineRasterizationStateRasterizationOrderAMD), or [VkPipelineRasterizationStateStreamCreateInfoEXT](/man/VkPipelineRasterizationStateStreamCreateInfoEXT)
::

::validity-field{name="VUID-VkPipelineRasterizationStateCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkPipelineRasterizationStateCreateInfo-flags-zerobitmask"}
 `flags` :normative{type="must"} be `0`
::

::validity-field{name="VUID-VkPipelineRasterizationStateCreateInfo-polygonMode-parameter"}
 `polygonMode` :normative{type="must"} be a valid [VkPolygonMode](/man/VkPolygonMode) value
::

::validity-field{name="VUID-VkPipelineRasterizationStateCreateInfo-cullMode-parameter"}
 `cullMode` :normative{type="must"} be a valid combination of [VkCullModeFlagBits](/man/VkCullModeFlagBits) values
::

::validity-field{name="VUID-VkPipelineRasterizationStateCreateInfo-frontFace-parameter"}
 `frontFace` :normative{type="must"} be a valid [VkFrontFace](/man/VkFrontFace) value
::

::


[{generated}/api/flags/VkPipelineRasterizationStateCreateFlags.adoc]({generated}/api/flags/VkPipelineRasterizationStateCreateFlags.adoc)

`VkPipelineRasterizationStateCreateFlags` is a bitmask type for setting
a mask, but is currently reserved for future use.

The `VkPipelineMultisampleStateCreateInfo` structure is defined as:

[{generated}/api/structs/VkPipelineMultisampleStateCreateInfo.adoc]({generated}/api/structs/VkPipelineMultisampleStateCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is reserved for future use.

- `rasterizationSamples` is a [VkSampleCountFlagBits](/man/VkSampleCountFlagBits) value
  specifying the number of samples used in rasterization.

- `sampleShadingEnable` :normative{type="can"} be used to enable
  Sample Shading.

- `minSampleShading` specifies a minimum fraction of sample shading if
  `sampleShadingEnable` is set to `VK_TRUE`.

- `pSampleMask` is a pointer to an array of [VkSampleMask](/man/VkSampleMask)
  values used in the sample mask test.

- `alphaToCoverageEnable` controls whether a temporary coverage value
  is generated based on the alpha component of the fragment’s first color
  output as specified in the Multisample Coverage
  section.

- `alphaToOneEnable` controls whether the alpha component of the
  fragment’s first color output is replaced with one as described in
  Multisample Coverage.

Each bit in the sample mask is associated with a unique
sample index as defined for the
coverage mask.
Each bit b for mask word w in the sample mask corresponds to
sample index i, where i = 32 × w +  b.
`pSampleMask` has a length equal to ⌈
`rasterizationSamples` / 32 ⌉ words.

If `pSampleMask` is `NULL`, it is treated as if the mask has all bits
set to `1`.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkPipelineMultisampleStateCreateInfo-sampleShadingEnable-00784"}

If the `sampleRateShading` feature
is not enabled, `sampleShadingEnable` :normative{type="must"} be `VK_FALSE`
::

::validity-field{name="VUID-VkPipelineMultisampleStateCreateInfo-alphaToOneEnable-00785"}

If the `alphaToOne` feature is not enabled,
`alphaToOneEnable` :normative{type="must"} be `VK_FALSE`
::

::validity-field{name="VUID-VkPipelineMultisampleStateCreateInfo-minSampleShading-00786"}
`minSampleShading` :normative{type="must"} be in the range [0,1]
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkPipelineMultisampleStateCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO`
::

::validity-field{name="VUID-VkPipelineMultisampleStateCreateInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkPipelineCoverageModulationStateCreateInfoNV](/man/VkPipelineCoverageModulationStateCreateInfoNV), [VkPipelineCoverageReductionStateCreateInfoNV](/man/VkPipelineCoverageReductionStateCreateInfoNV), [VkPipelineCoverageToColorStateCreateInfoNV](/man/VkPipelineCoverageToColorStateCreateInfoNV), or [VkPipelineSampleLocationsStateCreateInfoEXT](/man/VkPipelineSampleLocationsStateCreateInfoEXT)
::

::validity-field{name="VUID-VkPipelineMultisampleStateCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkPipelineMultisampleStateCreateInfo-flags-zerobitmask"}
 `flags` :normative{type="must"} be `0`
::

::validity-field{name="VUID-VkPipelineMultisampleStateCreateInfo-rasterizationSamples-parameter"}
 `rasterizationSamples` :normative{type="must"} be a valid [VkSampleCountFlagBits](/man/VkSampleCountFlagBits) value
::

::validity-field{name="VUID-VkPipelineMultisampleStateCreateInfo-pSampleMask-parameter"}
 If `pSampleMask` is not `NULL`, `pSampleMask` :normative{type="must"} be a valid pointer to an array of  [VkSampleMask](/man/VkSampleMask) values
::

::


[{generated}/api/flags/VkPipelineMultisampleStateCreateFlags.adoc]({generated}/api/flags/VkPipelineMultisampleStateCreateFlags.adoc)

`VkPipelineMultisampleStateCreateFlags` is a bitmask type for setting a
mask, but is currently reserved for future use.

The elements of the sample mask array are of type [VkSampleMask](/man/VkSampleMask),
each representing 32 bits of coverage information:

[{generated}/api/basetypes/VkSampleMask.adoc]({generated}/api/basetypes/VkSampleMask.adoc)

Rasterization only generates fragments which cover one or more pixels inside
the framebuffer.
Pixels outside the framebuffer are never considered covered in the fragment.
Fragments which would be produced by application of any of the primitive
rasterization rules described below but which lie outside the framebuffer
are not produced, nor are they processed by any later stage of the pipeline,
including any of the fragment operations.

Surviving fragments are processed by fragment shaders.
Fragment shaders determine associated data for fragments, and :normative{type="can"} also
modify or replace their assigned depth values.



## Discarding Primitives Before Rasterization

Primitives are discarded before rasterization if the
`rasterizerDiscardEnable` member of
[VkPipelineRasterizationStateCreateInfo](/man/VkPipelineRasterizationStateCreateInfo) is enabled.
When enabled, primitives are discarded after they are processed by the last
active shader stage in the pipeline before rasterization.





## Rasterization Order

Within a subpass of a render pass instance, for a given
(x,y,layer,sample) sample location, the following operations are guaranteed
to execute in *rasterization order*, for each separate primitive that
includes that sample location:

1) Fragment operations, in the order defined

2) Blending, logic
   operations, and color writes

Execution of these operations for each primitive in a subpass occurs in
primitive order.





## Multisampling

Multisampling is a mechanism to antialias all Vulkan primitives: points,
lines, and polygons.
The technique is to sample all primitives multiple times at each pixel.
Each sample in each framebuffer attachment has storage for a color, depth,
and/or stencil value, such that per-fragment operations apply to each sample
independently.
The color sample values :normative{type="can"} be later *resolved* to a single color (see
Resolving Multisample Images and the Render
Pass chapter for more details on how to resolve multisample images to
non-multisample images).

Vulkan defines rasterization rules for single-sample modes in a way that is
equivalent to a multisample mode with a single sample in the center of each
fragment.

Each fragment includes a coverage
mask with a single bit for each sample in the fragment, and a number of
depth values and associated data for each sample.

It is understood that each pixel has `rasterizationSamples` locations
associated with it.
These locations are exact positions, rather than regions or areas, and each
is referred to as a sample point.
The sample points associated with a pixel :normative{type="must"} be located inside or on the
boundary of the unit square that is considered to bound the pixel.
Furthermore, the relative locations of sample points :normative{type="may"} be identical for
each pixel in the framebuffer, or they :normative{type="may"} differ.

If the current pipeline includes a fragment shader with one or more
variables in its interface decorated with `Sample` and `Input`, the
data associated with those variables will be assigned independently for each
sample.
The values for each sample :normative{type="must"} be evaluated at the location of the sample.
The data associated with any other variables not decorated with `Sample`
and `Input` need not be evaluated independently for each sample.

A *coverage mask* is generated for each fragment, based on which samples
within that fragment are determined to be within the area of the primitive
that generated the fragment.

Single pixel fragments
have one set of samples.
Each set of samples has a number of samples determined by
[VkPipelineMultisampleStateCreateInfo](/man/VkPipelineMultisampleStateCreateInfo)::`rasterizationSamples`.
Each sample in a set is assigned a unique *sample index* i in the
range \[0, `rasterizationSamples`).

Each sample in a fragment is also assigned a unique *coverage index* j
in the range \[0, n × `rasterizationSamples`), where n
is the number of sets in the fragment.
If the fragment contains a single set of samples, the *coverage index* is
always equal to the *sample index*.

The coverage mask includes B bits packed into W words, defined
as:



Bit b in coverage mask word w is `1` if the sample with coverage
index j = 32×w + b is covered, and `0` otherwise.

If the `standardSampleLocations` member of [VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits)
is `VK_TRUE`, then the sample counts `VK_SAMPLE_COUNT_1_BIT`,
`VK_SAMPLE_COUNT_2_BIT`, `VK_SAMPLE_COUNT_4_BIT`,
`VK_SAMPLE_COUNT_8_BIT`, and `VK_SAMPLE_COUNT_16_BIT` have sample
locations as listed in the following table, with the ith entry in
the table corresponding to sample index i.
`VK_SAMPLE_COUNT_32_BIT` and `VK_SAMPLE_COUNT_64_BIT` do not have
standard sample locations.
Locations are defined relative to an origin in the upper left corner of the
fragment.









## Sample Shading

Sample shading :normative{type="can"} be used to specify a minimum number of unique samples to
process for each fragment.
If sample shading is enabled, an implementation :normative{type="must"} invoke the fragment
shader at least max(⌈
[VkPipelineMultisampleStateCreateInfo](/man/VkPipelineMultisampleStateCreateInfo)::`minSampleShading` ×
[VkPipelineMultisampleStateCreateInfo](/man/VkPipelineMultisampleStateCreateInfo)::`rasterizationSamples`
⌉, 1) times per fragment.
If [VkPipelineMultisampleStateCreateInfo](/man/VkPipelineMultisampleStateCreateInfo)::`sampleShadingEnable` is
set to `VK_TRUE`, sample shading is enabled.

If a fragment shader entry point statically uses an
input variable decorated with a `BuiltIn` of `SampleId` or
`SamplePosition`, sample shading is enabled and a value of `1.0` is used
instead of `minSampleShading`.
If a fragment shader entry point statically uses an
input variable decorated with `Sample`, sample shading :normative{type="may"} be enabled
and a value of `1.0` will be used instead of `minSampleShading` if it
is.


::note
If a shader decorates an input variable with `Sample` and that value
meaningfully impacts the output of a shader, sample shading will be enabled
to ensure that the input is in fact interpolated per-sample.
This is inherent to the specification and not spelled out here - if an
application simply declares such a variable it is implementation-defined
whether sample shading is enabled or not.
It is possible to see the effects of this by using atomics in the shader or
using a pipeline statistics query to query the number of fragment
invocations, even if the shader itself does not use any per-sample
variables.
::


If there are fewer fragment invocations than covered samples,
implementations :normative{type="may"} include those samples in fragment shader invocations in
any manner as long as covered samples are all shaded at least once, and each
invocation that is not a helper invocation
covers at least one sample.





## Points

A point is drawn by generating a set of fragments in the shape of a square
centered around the vertex of the point.
Each vertex has an associated point size controlling the width/height of
that square.
The point size is taken from the (potentially clipped) shader built-in
`PointSize` written by:

- the geometry shader, if active;

- the tessellation evaluation shader, if active and no geometry shader is
  active;

- the vertex shader, otherwise

and clamped to the implementation-dependent point size range
\[`pointSizeRange`\[0],`pointSizeRange`\[1]].
The value written to `PointSize` :normative{type="must"} be greater than zero.

Not all point sizes need be supported, but the size 1.0 :normative{type="must"} be supported.
The range of supported sizes and the size of evenly-spaced gradations within
that range are implementation-dependent.
The range and gradations are obtained from the `pointSizeRange` and
`pointSizeGranularity` members of [VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits).
If, for instance, the size range is from 0.1 to 2.0 and the gradation size
is 0.1, then the sizes 0.1, 0.2, …​, 1.9, 2.0 are supported.
Additional point sizes :normative{type="may"} also be supported.
There is no requirement that these sizes be equally spaced.
If an unsupported size is requested, the nearest supported size is used
instead.



### Basic Point Rasterization

Point rasterization produces a fragment for each fragment area group of
framebuffer pixels with one or more sample points that intersect a region
centered at the point’s (x\<sub>f\</sub>,y\<sub>f\</sub>).
This region is a square with side equal to the current point size.
Coverage bits that correspond to sample points that intersect the region are
1, other coverage bits are 0.
All fragments produced in rasterizing a point are assigned the same
associated data, which are those of the vertex corresponding to the point.
However, the fragment shader built-in `PointCoord` contains point sprite
texture coordinates.
The s and t point sprite texture coordinates vary from zero to
one across the point horizontally left-to-right and vertically
top-to-bottom, respectively.
The following formulas are used to evaluate s and t:





where size is the point’s size; (x\<sub>p\</sub>,y\<sub>p\</sub>) is the location at which
the point sprite coordinates are evaluated - this :normative{type="may"} be the framebuffer
coordinates of the fragment center, or the location of a sample; and
(x\<sub>f\</sub>,y\<sub>f\</sub>) is the exact, unrounded framebuffer coordinate of the
vertex for the point.







## Line Segments

To dynamically set the line width, call:

[{generated}/api/protos/vkCmdSetLineWidth.adoc]({generated}/api/protos/vkCmdSetLineWidth.adoc)

- `commandBuffer` is the command buffer into which the command will be
  recorded.

- `lineWidth` is the width of rasterized line segments.

This command sets the line width for subsequent drawing commands
when the graphics pipeline is created with `VK_DYNAMIC_STATE_LINE_WIDTH`
set in [VkPipelineDynamicStateCreateInfo](/man/VkPipelineDynamicStateCreateInfo)::`pDynamicStates`.
Otherwise, this state is specified by the
[VkPipelineRasterizationStateCreateInfo](/man/VkPipelineRasterizationStateCreateInfo)::`lineWidth` value used to
create the currently active pipeline.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdSetLineWidth-lineWidth-00788"}

If the `wideLines` feature is not enabled,
`lineWidth` :normative{type="must"} be `1.0`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdSetLineWidth-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdSetLineWidth-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdSetLineWidth-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics operations
::

::validity-field{name="VUID-vkCmdSetLineWidth-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::






Not all line widths need be supported for line segment rasterization, but
width 1.0 antialiased segments :normative{type="must"} be provided.
The range and gradations are obtained from the `lineWidthRange` and
`lineWidthGranularity` members of [VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits).
If, for instance, the size range is from 0.1 to 2.0 and the gradation size
is 0.1, then the sizes 0.1, 0.2, …​, 1.9, 2.0 are supported.
Additional line widths :normative{type="may"} also be supported.
There is no requirement that these widths be equally spaced.
If an unsupported width is requested, the nearest supported width is used
instead.



### Basic Line Segment Rasterization

Rasterized
line segments produce fragments which intersect a rectangle centered on the
line segment.
Two of the edges are parallel to the specified line segment; each is at a
distance of one-half the current width from that segment in directions
perpendicular to the direction of the line.
The other two edges pass through the line endpoints and are perpendicular to
the direction of the specified line segment.
Coverage bits that correspond to sample points that intersect the rectangle
are 1, other coverage bits are 0.

Next we specify how the data associated with each rasterized fragment are
obtained.
Let *p*\<sub>r\</sub> = (x\<sub>d\</sub>, y\<sub>d\</sub>) be the framebuffer coordinates at which
associated data are evaluated.
This :normative{type="may"} be the center of a fragment or the location of a sample within the
fragment.
When `rasterizationSamples` is `VK_SAMPLE_COUNT_1_BIT`, the fragment
center :normative{type="must"} be used.
Let *p*\<sub>a\</sub> = (x\<sub>a\</sub>, y\<sub>a\</sub>) and *p*\<sub>b\</sub> = (x\<sub>b\</sub>,y\<sub>b\</sub>) be
initial and final endpoints of the line segment, respectively.
Set



(Note that t = 0 at *p*\<sub>a\</sub> and t = 1 at *p*\<sub>b\</sub>.
Also note that this calculation projects the vector from *p*\<sub>a\</sub> to
*p*\<sub>r\</sub> onto the line, and thus computes the normalized distance of
the fragment along the line.)

If `strictLines` is `VK_TRUE`, line segments
are rasterized using perspective or linear interpolation.

*Perspective interpolation* for a line segment interpolates two values in a
manner that is correct when taking the perspective of the viewport into
consideration, by way of the line segment’s clip coordinates.
An interpolated value f can be determined by



where f\<sub>a\</sub> and f\<sub>b\</sub> are the data associated with the starting
and ending endpoints of the segment, respectively; w\<sub>a\</sub> and w\<sub>b\</sub>
are the clip w coordinates of the starting and ending endpoints of the
segment, respectively.

*Linear interpolation* for a line segment directly interpolates two values,
and an interpolated value f can be determined by



where f\<sub>a\</sub> and f\<sub>b\</sub> are the data associated with the starting
and ending endpoints of the segment, respectively.

The clip coordinate w for a sample is determined using perspective
interpolation.
The depth value z for a sample is determined using linear
interpolation.
Interpolation of fragment shader input values are determined by
Interpolation decorations.

The above description documents the preferred method of line rasterization,
and :normative{type="must"} be used when
the implementation advertises the `strictLines` limit in
[VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits) as `VK_TRUE`.

When
`strictLines` is `VK_FALSE`,
the edges of the lines are generated as a parallelogram surrounding the
original line.
The major axis is chosen by noting the axis in which there is the greatest
distance between the line start and end points.
If the difference is equal in both directions then the X axis is chosen as
the major axis.
Edges 2 and 3 are aligned to the minor axis and are centered on the
endpoints of the line as in , and each is
`lineWidth` long.
Edges 0 and 1 are parallel to the line and connect the endpoints of edges 2
and 3.
Coverage bits that correspond to sample points that intersect the
parallelogram are 1, other coverage bits are 0.

Samples that fall exactly on the edge of the parallelogram follow the
polygon rasterization rules.

Interpolation occurs as if the parallelogram was decomposed into two
triangles where each pair of vertices at each end of the line has identical
attributes.



Only when
`strictLines` is `VK_FALSE`
implementations :normative{type="may"} deviate from the non-strict line algorithm described
above in the following ways:

- Implementations :normative{type="may"} instead interpolate each fragment according to the
  formula in Basic Line Segment Rasterization
  using the original line segment endpoints.

- Rasterization of non-antialiased non-strict line segments :normative{type="may"} be
  performed using the rules defined in
  Bresenham Line Segment Rasterization.





### Bresenham Line Segment Rasterization

Non-strict lines :normative{type="may"} also follow these rasterization rules for
non-antialiased lines.

Line segment rasterization begins by characterizing the segment as either
*x-major* or *y-major*.
x-major line segments have slope in the closed interval \[-1,1]; all
other line segments are y-major (slope is determined by the segment’s
endpoints).
We specify rasterization only for x-major segments except in cases where the
modifications for y-major segments are not self-evident.

Ideally, Vulkan uses a *diamond-exit* rule to determine those fragments that
are produced by rasterizing a line segment.
For each fragment f with center at framebuffer coordinates x\<sub>f\</sub>
and y\<sub>f\</sub>, define a diamond-shaped region that is the intersection of
four half planes:



Essentially, a line segment starting at p\<sub>a\</sub> and ending at p\<sub>b\</sub>
produces those fragments f for which the segment intersects
R\<sub>f\</sub>, except if p\<sub>b\</sub> is contained in R\<sub>f\</sub>.



To avoid difficulties when an endpoint lies on a boundary of R\<sub>f\</sub> we
(in principle) perturb the supplied endpoints by a tiny amount.
Let p\<sub>a\</sub> and p\<sub>b\</sub> have framebuffer coordinates (x\<sub>a\</sub>,
y\<sub>a\</sub>) and (x\<sub>b\</sub>, y\<sub>b\</sub>), respectively.
Obtain the perturbed endpoints p\<sub>a\</sub>' given by (x\<sub>a\</sub>, y\<sub>a\</sub>) -
(ε, ε\<sup>2\</sup>) and p\<sub>b\</sub>' given by (x\<sub>b\</sub>, y\<sub>b\</sub>) -
(ε, ε\<sup>2\</sup>).
Rasterizing the line segment starting at p\<sub>a\</sub> and ending at p\<sub>b\</sub>
produces those fragments f for which the segment starting at
p\<sub>a\</sub>' and ending on p\<sub>b\</sub>' intersects R\<sub>f\</sub>, except if
p\<sub>b\</sub>' is contained in R\<sub>f\</sub>.
ε is chosen to be so small that rasterizing the line segment
produces the same fragments when δ is substituted for
ε for any 0 < δ ≤ ε.

When p\<sub>a\</sub> and p\<sub>b\</sub> lie on fragment centers, this
characterization of fragments reduces to Bresenham’s algorithm with one
modification: lines produced in this description are > half-open, meaning
that the final fragment (corresponding to p\<sub>b\</sub>) is not drawn.
This means that when rasterizing a series of connected line segments, shared
endpoints will be produced only once rather than twice (as would occur with
Bresenham’s algorithm).

Implementations :normative{type="may"} use other line segment rasterization algorithms,
subject to the following rules:

- The coordinates of a fragment produced by the algorithm :normative{type="must"} not
  deviate by more than one unit in either x or y framebuffer coordinates
  from a corresponding fragment produced by the diamond-exit rule.

- The total number of fragments produced by the algorithm :normative{type="must"} not differ
  from that produced by the diamond-exit rule by more than one.

- For an x-major line, two fragments that lie in the same
  framebuffer-coordinate column :normative{type="must"} not be produced (for a y-major line,
  two fragments that lie in the same framebuffer-coordinate row :normative{type="must"} not
  be produced).

- If two line segments share a common endpoint, and both segments are
  either x-major (both left-to-right or both right-to-left) or y-major
  (both bottom-to-top or both top-to-bottom), then rasterizing both
  segments :normative{type="must"} not produce duplicate fragments.
  Fragments also :normative{type="must"} not be omitted so as to interrupt continuity of the
  connected segments.

The actual width w of Bresenham lines is determined by rounding the
line width to the nearest integer, clamping it to the
implementation-dependent `lineWidthRange` (with both values rounded to
the nearest integer), then clamping it to be no less than 1.

Bresenham line segments of width other than one are rasterized by offsetting
them in the minor direction (for an x-major line, the minor direction is y,
and for a y-major line, the minor direction is x) and producing a row or
column of fragments in the minor direction.
If the line segment has endpoints given by (x\<sub>0\</sub>, y\<sub>0\</sub>) and
(x\<sub>1\</sub>, y\<sub>1\</sub>) in framebuffer coordinates, the segment with endpoints
&#x20;and  is rasterized, but instead of a single fragment, a column of
fragments of height w (a row of fragments of length w for a y-major segment)
is produced at each x (y for y-major) location.
The lowest fragment of this column is the fragment that would be produced by
rasterizing the segment of width 1 with the modified coordinates.

The preferred method of attribute interpolation for a wide line is to
generate the same attribute values for all fragments in the row or column
described above, as if the adjusted line was used for interpolation and
those values replicated to the other fragments, except for `FragCoord`
which is interpolated as usual.
Implementations :normative{type="may"} instead interpolate each fragment according to the
formula in Basic Line Segment Rasterization, using
the original line segment endpoints.

When Bresenham lines are being rasterized, sample locations :normative{type="may"} all be
treated as being at the pixel center (this :normative{type="may"} affect attribute and depth
interpolation).


::note
The sample locations described above are *not* used for determining
coverage, they are only used for things like attribute interpolation.
The rasterization rules that determine coverage are defined in terms of
whether the line intersects *pixels*, as opposed to the point sampling rules
used for other primitive types.
So these rules are independent of the sample locations.
One consequence of this is that Bresenham lines cover the same pixels
regardless of the number of rasterization samples, and cover all samples in
those pixels (unless masked out or killed).
::








## Polygons

A polygon results from the decomposition of a triangle strip, triangle fan
or a series of independent triangles.
Like points and line segments, polygon rasterization is controlled by
several variables in the [VkPipelineRasterizationStateCreateInfo](/man/VkPipelineRasterizationStateCreateInfo)
structure.



### Basic Polygon Rasterization

The first step of polygon rasterization is to determine whether the triangle
is *back-facing* or *front-facing*.
This determination is made based on the sign of the (clipped or unclipped)
polygon’s area computed in framebuffer coordinates.
One way to compute this area is:



where  and  are the x and y
framebuffer coordinates of the ith vertex of the n-vertex
polygon (vertices are numbered starting at zero for the purposes of this
computation) and i ⊕ 1 is (i +  1) mod n.

The interpretation of the sign of a is determined by the
[VkPipelineRasterizationStateCreateInfo](/man/VkPipelineRasterizationStateCreateInfo)::`frontFace` property of
the currently active pipeline.
Possible values are:

[{generated}/api/enums/VkFrontFace.adoc]({generated}/api/enums/VkFrontFace.adoc)

- `VK_FRONT_FACE_COUNTER_CLOCKWISE` specifies that a triangle with
  positive area is considered front-facing.

- `VK_FRONT_FACE_CLOCKWISE` specifies that a triangle with negative
  area is considered front-facing.

Any triangle which is not front-facing is back-facing, including zero-area
triangles.

Once the orientation of triangles is determined, they are culled according
to the [VkPipelineRasterizationStateCreateInfo](/man/VkPipelineRasterizationStateCreateInfo)::`cullMode` property
of the currently active pipeline.
Possible values are:

[{generated}/api/enums/VkCullModeFlagBits.adoc]({generated}/api/enums/VkCullModeFlagBits.adoc)

- `VK_CULL_MODE_NONE` specifies that no triangles are discarded

- `VK_CULL_MODE_FRONT_BIT` specifies that front-facing triangles are
  discarded

- `VK_CULL_MODE_BACK_BIT` specifies that back-facing triangles are
  discarded

- `VK_CULL_MODE_FRONT_AND_BACK` specifies that all triangles are
  discarded.

Following culling, fragments are produced for any triangles which have not
been discarded.

[{generated}/api/flags/VkCullModeFlags.adoc]({generated}/api/flags/VkCullModeFlags.adoc)

`VkCullModeFlags` is a bitmask type for setting a mask of zero or more
[VkCullModeFlagBits](/man/VkCullModeFlagBits).

The rule for determining which fragments are produced by polygon
rasterization is called *point sampling*.
The two-dimensional projection obtained by taking the x and y framebuffer
coordinates of the polygon’s vertices is formed.
Fragments are produced for any fragment area groups of pixels for which any
sample points lie inside of this polygon.
Coverage bits that correspond to sample points that satisfy the point
sampling criteria are 1, other coverage bits are 0.
Special treatment is given to a sample whose sample location lies on a
polygon edge.
In such a case, if two polygons lie on either side of a common edge (with
identical endpoints) on which a sample point lies, then exactly one of the
polygons :normative{type="must"} result in a covered sample for that fragment during
rasterization.
As for the data associated with each fragment produced by rasterizing a
polygon, we begin by specifying how these values are produced for fragments
in a triangle.

*Barycentric coordinates* are a set of three numbers, a, b, and
c, each in the range \[0,1], with a +  b +  c = 1.
These coordinates uniquely specify any point p within the triangle or
on the triangle’s boundary as



where p\<sub>a\</sub>, p\<sub>b\</sub>, and p\<sub>c\</sub> are the vertices of the
triangle.
a, b, and c are determined by:



where A(lmn) denotes the area in framebuffer coordinates of the
triangle with vertices l, m, and n.

Denote an associated datum at p\<sub>a\</sub>, p\<sub>b\</sub>, or p\<sub>c\</sub> as
f\<sub>a\</sub>, f\<sub>b\</sub>, or f\<sub>c\</sub>, respectively.

*Perspective interpolation* for a triangle interpolates three values in a
manner that is correct when taking the perspective of the viewport into
consideration, by way of the triangle’s clip coordinates.
An interpolated value f can be determined by



where w\<sub>a\</sub>, w\<sub>b\</sub>, and w\<sub>c\</sub> are the clip w
coordinates of p\<sub>a\</sub>, p\<sub>b\</sub>, and p\<sub>c\</sub>, respectively.
a, b, and c are the barycentric coordinates of the
location at which the data are produced.

*Linear interpolation* for a triangle directly interpolates three values,
and an interpolated value f can be determined by



where f\<sub>a\</sub>, f\<sub>b\</sub>, and f\<sub>c\</sub> are the data associated with
p\<sub>a\</sub>, p\<sub>b\</sub>, and p\<sub>c\</sub>, respectively.

The clip coordinate w for a sample is determined using perspective
interpolation.
The depth value z for a sample is determined using linear
interpolation.
Interpolation of fragment shader input values are determined by
Interpolation decorations.

For a polygon with more than three edges, such as are produced by clipping a
triangle, a convex combination of the values of the datum at the polygon’s
vertices :normative{type="must"} be used to obtain the value assigned to each fragment
produced by the rasterization algorithm.
That is, it :normative{type="must"} be the case that at every fragment



where n is the number of vertices in the polygon and f\<sub>i\</sub> is the
value of f at vertex i.
For each i, 0 ≤ a\<sub>i\</sub> ≤ 1 and
.
The values of a\<sub>i\</sub> :normative{type="may"} differ from fragment to fragment, but at
vertex i, a\<sub>i\</sub> = 1 and a\<sub>j\</sub> = 0 for j ≠ i.


::note
One algorithm that achieves the required behavior is to triangulate a
polygon (without adding any vertices) and then treat each triangle
individually as already discussed.
A scan-line rasterizer that linearly interpolates data along each edge and
then linearly interpolates data across each horizontal span from edge to
edge also satisfies the restrictions (in this case the numerator and
denominator of perspective
interpolation are iterated independently, and a division is performed for
each fragment).
::






### Polygon Mode

Possible values of the
[VkPipelineRasterizationStateCreateInfo](/man/VkPipelineRasterizationStateCreateInfo)::`polygonMode` property of
the currently active pipeline, specifying the method of rasterization for
polygons, are:

[{generated}/api/enums/VkPolygonMode.adoc]({generated}/api/enums/VkPolygonMode.adoc)

- `VK_POLYGON_MODE_POINT` specifies that polygon vertices are drawn as
  points.

- `VK_POLYGON_MODE_LINE` specifies that polygon edges are drawn as
  line segments.

- `VK_POLYGON_MODE_FILL` specifies that polygons are rendered using
  the polygon rasterization rules in this section.

These modes affect only the final rasterization of polygons: in particular,
a polygon’s vertices are shaded and the polygon is clipped and possibly
culled before these modes are applied.

The point size of the final rasterization of polygons when
polygon mode is `VK_POLYGON_MODE_POINT` is
implementation-dependent, and the point size :normative{type="may"} either be `PointSize`
or 1.0.





### Depth Bias

The depth values of all fragments generated by the rasterization of a
polygon :normative{type="can"} be biased (offset) by a single depth bias value&#x20;
that is computed for that polygon.



#### Depth Bias Enable

The depth bias computation is enabled by the
[VkPipelineRasterizationStateCreateInfo](/man/VkPipelineRasterizationStateCreateInfo)::`depthBiasEnable` value
used to create the currently active pipeline.
If the depth bias enable is `VK_FALSE`, no bias is applied and the
fragment’s depth values are unchanged.





#### Depth Bias Computation

The depth bias depends on three parameters:

- `depthBiasSlopeFactor` scales the maximum depth slope m of the
  polygon

- `depthBiasConstantFactor` scales the parameter r of the depth
  attachment

- the scaled terms are summed to produce a value which is then clamped to
  a minimum or maximum value specified by `depthBiasClamp`

`depthBiasSlopeFactor`, `depthBiasConstantFactor`, and
`depthBiasClamp` :normative{type="can"} each be positive, negative, or zero.
These parameters are set as described for [vkCmdSetDepthBias](/man/vkCmdSetDepthBias)
below.

The maximum depth slope m of a triangle is



where (x\<sub>f\</sub>, y\<sub>f\</sub>, z\<sub>f\</sub>) is a point on the triangle.
m :normative{type="may"} be approximated as



r is the minimum resolvable difference that depends on the depth
attachment representation.
It
is the smallest difference in framebuffer coordinate z values that is
guaranteed to remain distinct throughout polygon rasterization and in the
depth attachment.
All pairs of fragments generated by the rasterization of two polygons with
otherwise identical vertices, but `z`\<sub>f\</sub> values that differ by
r, will have distinct depth values.

For fixed-point depth attachment representations,
r is constant throughout the range of the entire depth attachment.

Its value is implementation-dependent but :normative{type="must"} be at most



where n is the number of bits used for the depth
aspect.

For
floating-point depth attachment, there is no single minimum resolvable
difference.
In this case, the minimum resolvable difference for a given polygon is
dependent on the maximum exponent, e, in the range of z values
spanned by the primitive.
If n is the number of bits in the floating-point mantissa, the minimum
resolvable difference, r, for the given primitive is defined as



If no depth attachment is present, r is undefined:.

The bias value o for a polygon is



m is computed as described above.
If the depth attachment uses a fixed-point representation, m is a
function of depth values in the range \[0,1], and o is applied to
depth values in the same range.

Depth bias is applied to triangle topology primitives received by the
rasterizer regardless of polygon mode.
Depth bias :normative{type="may"} also be applied to line and point topology primitives
received by the rasterizer.

To dynamically set the depth bias parameters,
call:

[{generated}/api/protos/vkCmdSetDepthBias.adoc]({generated}/api/protos/vkCmdSetDepthBias.adoc)

- `commandBuffer` is the command buffer into which the command will be
  recorded.

- `depthBiasConstantFactor` is a scalar factor controlling the
  constant depth value added to each fragment.

- `depthBiasClamp` is the maximum (or minimum) depth bias of a
  fragment.

- `depthBiasSlopeFactor` is a scalar factor applied to a fragment’s
  slope in depth bias calculations.

This command sets the depth bias parameters for subsequent drawing commands
when the graphics pipeline is created with `VK_DYNAMIC_STATE_DEPTH_BIAS`
set in [VkPipelineDynamicStateCreateInfo](/man/VkPipelineDynamicStateCreateInfo)::`pDynamicStates`.
Otherwise, this state is specified by the corresponding
[VkPipelineRasterizationStateCreateInfo](/man/VkPipelineRasterizationStateCreateInfo)::`depthBiasConstantFactor`,
`depthBiasClamp`, and `depthBiasSlopeFactor` values used to create
the currently active pipeline.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdSetDepthBias-depthBiasClamp-00790"}

If the `depthBiasClamp` feature is not
enabled, `depthBiasClamp` :normative{type="must"} be `0.0`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdSetDepthBias-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdSetDepthBias-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdSetDepthBias-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics operations
::

::validity-field{name="VUID-vkCmdSetDepthBias-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::
















# Fragment Operations

Fragments produced by rasterization go through a number of operations to
determine whether or how values produced by fragment shading are written to
the framebuffer.

The following fragment operations adhere to rasterization
order, and are typically performed in this order:

1) Scissor test

2) Sample mask test

3) Certain Fragment shading operations:





   * Sample Mask Accesses

   * Depth Replacement

4) Multisample coverage

5) Depth bounds test

6) Stencil test

7) Depth test

8) Sample counting

9) Coverage reduction

The coverage mask generated by
rasterization describes the initial coverage of each sample covered by the
fragment.
Fragment operations will update the coverage mask to add or subtract
coverage where appropriate.
If a fragment operation results in all bits of the coverage mask being `0`,
the fragment is discarded, and no further operations are performed.
Fragments can also be programmatically discarded in a fragment shader by
executing one of

- `OpKill`.

When one of the fragment operations in this chapter is described as
> replacing a fragment shader output, that output is replaced
unconditionally, even if no fragment shader previously wrote to that output.

If there is a fragment shader and it declares the
`EarlyFragmentTests` execution mode, fragment shading
and multisample coverage operations :normative{type="should"} instead be
performed after sample counting, and
sample mask test :normative{type="may"} instead be performed after
sample counting.

For a pipeline with the following properties:

- a fragment shader is specified

- the fragment shader
  does not write to storage resources;

- the fragment shader specifies the `DepthReplacing` execution mode;
  and

- either





  * the fragment shader specifies the `DepthUnchanged` execution mode;

  * the fragment shader specifies the `DepthLess` execution mode and the
    pipeline uses a
    [VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo)::`depthCompareOp` of
    `VK_COMPARE_OP_GREATER` or `VK_COMPARE_OP_GREATER_OR_EQUAL`; or

  * the fragment shader specifies the `DepthGreater` execution mode and
    the pipeline uses a
    [VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo)::`depthCompareOp` of
    `VK_COMPARE_OP_LESS` or `VK_COMPARE_OP_LESS_OR_EQUAL`

the implementation :normative{type="may"} perform depth bounds test before
fragment shading and perform an additional
depth test immediately after that using the interpolated
depth value generated by rasterization.

Once all fragment operations have completed, fragment shader outputs for
covered color attachment samples pass through framebuffer
operations.



## Scissor Test

The scissor test compares the framebuffer coordinates (x\<sub>f\</sub>,y\<sub>f\</sub>) of
each sample covered by a fragment against a *scissor rectangle* at the index
equal to the fragment’s `ViewportIndex`.

Each scissor rectangle is defined by a [VkRect2D](/man/VkRect2D).
These values are either set by the [VkPipelineViewportStateCreateInfo](/man/VkPipelineViewportStateCreateInfo)
structure during pipeline creation, or dynamically by the
[vkCmdSetScissor](/man/vkCmdSetScissor) command.

A given sample is considered inside a scissor rectangle if x\<sub>f\</sub> is in
the range \[[VkRect2D](/man/VkRect2D)::`offset.x`,
[VkRect2D](/man/VkRect2D)::`offset.x` +  [VkRect2D](/man/VkRect2D)::`extent.x`), and
y\<sub>f\</sub> is in the range \[[VkRect2D](/man/VkRect2D)::`offset.y`,
[VkRect2D](/man/VkRect2D)::`offset.y` +  [VkRect2D](/man/VkRect2D)::`extent.y`).
Samples with coordinates outside the scissor rectangle at the corresponding
`ViewportIndex` will have their coverage set to `0`.

To dynamically set the scissor rectangles,
call:

[{generated}/api/protos/vkCmdSetScissor.adoc]({generated}/api/protos/vkCmdSetScissor.adoc)

- `commandBuffer` is the command buffer into which the command will be
  recorded.

- `firstScissor` is the index of the first scissor whose state is
  updated by the command.

- `scissorCount` is the number of scissors whose rectangles are
  updated by the command.

- `pScissors` is a pointer to an array of [VkRect2D](/man/VkRect2D) structures
  defining scissor rectangles.

The scissor rectangles taken from element i of `pScissors` replace
the current state for the scissor index `firstScissor` +  i,
for i in \[0, `scissorCount`).

This command sets the scissor rectangles for subsequent drawing commands
when the graphics pipeline is created with `VK_DYNAMIC_STATE_SCISSOR`
set in [VkPipelineDynamicStateCreateInfo](/man/VkPipelineDynamicStateCreateInfo)::`pDynamicStates`.
Otherwise, this state is specified by the
[VkPipelineViewportStateCreateInfo](/man/VkPipelineViewportStateCreateInfo)::`pScissors` values used to
create the currently active pipeline.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdSetScissor-firstScissor-00592"}

The sum of `firstScissor` and `scissorCount` :normative{type="must"} be between
`1` and `VkPhysicalDeviceLimits`::`maxViewports`, inclusive
::

::validity-field{name="VUID-vkCmdSetScissor-firstScissor-00593"}

If the `multiViewport` feature is not
enabled, `firstScissor` :normative{type="must"} be `0`
::

::validity-field{name="VUID-vkCmdSetScissor-scissorCount-00594"}

If the `multiViewport` feature is not
enabled, `scissorCount` :normative{type="must"} be `1`
::

::validity-field{name="VUID-vkCmdSetScissor-x-00595"}

The `x` and `y` members of `offset` member of any element of
`pScissors` :normative{type="must"} be greater than or equal to `0`
::

::validity-field{name="VUID-vkCmdSetScissor-offset-00596"}

Evaluation of (`offset.x` +  `extent.width`) :normative{type="must"} not
cause a signed integer addition overflow for any element of
`pScissors`
::

::validity-field{name="VUID-vkCmdSetScissor-offset-00597"}

Evaluation of (`offset.y` +  `extent.height`) :normative{type="must"}
not cause a signed integer addition overflow for any element of
`pScissors`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdSetScissor-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdSetScissor-pScissors-parameter"}
 `pScissors` :normative{type="must"} be a valid pointer to an array of `scissorCount` [VkRect2D](/man/VkRect2D) structures
::

::validity-field{name="VUID-vkCmdSetScissor-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdSetScissor-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics operations
::

::validity-field{name="VUID-vkCmdSetScissor-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdSetScissor-scissorCount-arraylength"}
 `scissorCount` :normative{type="must"} be greater than `0`
::

::










## Sample Mask Test

The sample mask test compares the coverage mask for a fragment with the *sample mask* defined by
[VkPipelineMultisampleStateCreateInfo](/man/VkPipelineMultisampleStateCreateInfo)::`pSampleMask`.

Each bit of the coverage mask is associated with a sample index as described
in the rasterization chapter.
If the bit in [VkPipelineMultisampleStateCreateInfo](/man/VkPipelineMultisampleStateCreateInfo)::`pSampleMask`
which is associated with that same sample index is set to `0`, the coverage
mask bit is set to `0`.





## Fragment Shading

Fragment shaders are invoked for each fragment, or as
helper invocations.

Most operations in the fragment shader are not performed in
rasterization order, with exceptions called out in the
following sections.

For fragment shaders invoked by fragments, the following rules apply:

- A fragment shader :normative{type="must"} not be executed if a fragment
  operation that executes before fragment shading discards the fragment.

- A fragment shader :normative{type="may"} not be executed if:





  * An implementation determines that another fragment shader, invoked by a
    subsequent primitive in primitive order,
    overwrites all results computed by the shader (including writes to
    storage resources).

  * Any other fragment operation discards the fragment, and
    the shader does not write to any storage resources.

- Otherwise, at least one fragment shader :normative{type="must"} be executed.





  * If sample shading is enabled and multiple
    invocations per fragment are :normative{type="required"}, additional invocations :normative{type="must"} be
    executed as specified.

  * Each covered sample :normative{type="must"} be included in at least one fragment shader
    invocation.

If no fragment shader is included in the pipeline, no fragment shader is
executed, and undefined: values :normative{type="may"} be written to all color attachment
outputs during this fragment operation.


::note
Multiple fragment shader invocations may be executed for the same fragment
for any number of implementation-dependent reasons.
When there is more than one fragment shader invocation per fragment, the
association of samples to invocations is implementation-dependent.
Stores and atomics performed by these additional invocations have the normal
effect.
::




### Sample Mask

Reading from the `SampleMask` built-in in the `Input` storage class will return the
coverage mask for the current fragment as calculated by fragment operations
that executed prior to fragment shading.

If sample shading is enabled, fragment shaders
will only see values of `1` for samples being shaded - other bits will be
`0`.

Each bit of the coverage mask is associated with a sample index as described
in the rasterization chapter.
If the bit in `SampleMask` which is associated with that same sample
index is set to `0`, that coverage mask bit is set to `0`.

Values written to the `SampleMask` built-in in the `Output` storage class will be used by
the multisample coverage operation, with the same encoding
as the input built-in.





### Depth Replacement

Writing to the `FragDepth`
built-in will replace the fragment’s calculated depth values for each sample
in the input `SampleMask`.
Depth testing performed after the fragment shader for
this fragment will use this new value as z\<sub>f\</sub>.







## Multisample Coverage

If a fragment shader is active and its entry point’s interface includes a
built-in output variable decorated with `SampleMask`,
the coverage mask is `ANDed` with the bits of the `SampleMask`
built-in to generate a new coverage mask.
If sample shading is enabled, bits written to
`SampleMask` corresponding to samples that are not being shaded by the
fragment shader invocation are ignored.
If no fragment shader is active, or if the active fragment shader does not
include `SampleMask` in its interface, the coverage mask is not modified.

Next, the fragment alpha value and coverage mask are modified based on the
`alphaToCoverageEnable` and `alphaToOneEnable` members of the
[VkPipelineMultisampleStateCreateInfo](/man/VkPipelineMultisampleStateCreateInfo) structure.

All alpha values in this section refer only to the alpha component of the
fragment shader output that has a `Location` and `Index` decoration of
zero (see the Fragment Output Interface
section).
If that shader output has an integer or unsigned integer type, then these
operations are skipped.

If `alphaToCoverageEnable` is enabled, a temporary coverage mask is
generated where each bit is determined by the fragment’s alpha value, which
is ANDed with the fragment coverage mask.

No specific algorithm is specified for converting the alpha value to a
temporary coverage mask.
It is intended that the number of 1’s in this value be proportional to the
alpha value (clamped to \[0,1]), with all 1’s corresponding to a value
of 1.0 and all 0’s corresponding to 0.0.
The algorithm :normative{type="may"} be different at different framebuffer coordinates.


::note
Using different algorithms at different framebuffer coordinates :normative{type="may"} help to
avoid artifacts caused by regular coverage sample locations.
::


Finally, if `alphaToOneEnable` is enabled, each alpha value is replaced
by the maximum representable alpha value for fixed-point color attachments,
or by 1.0 for floating-point attachments.
Otherwise, the alpha values are not changed.





## Depth and Stencil Operations

Pipeline state controlling the depth bounds tests,
stencil test, and depth test is
specified through the members of the
`VkPipelineDepthStencilStateCreateInfo` structure.

The `VkPipelineDepthStencilStateCreateInfo` structure is defined as:

[{generated}/api/structs/VkPipelineDepthStencilStateCreateInfo.adoc]({generated}/api/structs/VkPipelineDepthStencilStateCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is reserved for future use.

- `depthTestEnable` controls whether depth testing
  is enabled.

- `depthWriteEnable` controls whether depth
  writes are enabled when `depthTestEnable` is `VK_TRUE`.
  Depth writes are always disabled when `depthTestEnable` is
  `VK_FALSE`.

- `depthCompareOp` is a [VkCompareOp](/man/VkCompareOp) value specifying the
  comparison operator to use in the Depth
  Comparison step of the depth test.

- `depthBoundsTestEnable` controls whether depth bounds
  testing is enabled.

- `stencilTestEnable` controls whether stencil
  testing is enabled.

- `front` and `back` are [VkStencilOpState](/man/VkStencilOpState) values controlling
  the corresponding parameters of the stencil test.

- `minDepthBounds` is the minimum depth bound used in the
  depth bounds test.

- `maxDepthBounds` is the maximum depth bound used in the
  depth bounds test.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkPipelineDepthStencilStateCreateInfo-depthBoundsTestEnable-00598"}

If the `depthBounds` feature is not
enabled, `depthBoundsTestEnable` :normative{type="must"} be `VK_FALSE`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkPipelineDepthStencilStateCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO`
::

::validity-field{name="VUID-VkPipelineDepthStencilStateCreateInfo-pNext-pNext"}
 `pNext` :normative{type="must"} be `NULL`
::

::validity-field{name="VUID-VkPipelineDepthStencilStateCreateInfo-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkPipelineDepthStencilStateCreateFlagBits](/man/VkPipelineDepthStencilStateCreateFlagBits) values
::

::validity-field{name="VUID-VkPipelineDepthStencilStateCreateInfo-depthCompareOp-parameter"}
 `depthCompareOp` :normative{type="must"} be a valid [VkCompareOp](/man/VkCompareOp) value
::

::validity-field{name="VUID-VkPipelineDepthStencilStateCreateInfo-front-parameter"}
 `front` :normative{type="must"} be a valid [VkStencilOpState](/man/VkStencilOpState) structure
::

::validity-field{name="VUID-VkPipelineDepthStencilStateCreateInfo-back-parameter"}
 `back` :normative{type="must"} be a valid [VkStencilOpState](/man/VkStencilOpState) structure
::

::


[{generated}/api/flags/VkPipelineDepthStencilStateCreateFlags.adoc]({generated}/api/flags/VkPipelineDepthStencilStateCreateFlags.adoc)

`VkPipelineDepthStencilStateCreateFlags` is a bitmask type for setting a
mask, but is currently reserved for future use.





## Depth Bounds Test

The depth bounds test compares the depth value z\<sub>a\</sub> in the
depth/stencil attachment at each sample’s framebuffer coordinates
(x\<sub>f\</sub>,y\<sub>f\</sub>) and sample
index i against a set of *depth bounds*.

The depth bounds are determined by two floating point values defining a
minimum (`minDepthBounds`) and maximum (`maxDepthBounds`) depth
value.
These values are either set by the
[VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo) structure during pipeline
creation, or dynamically by
[vkCmdSetDepthBounds](/man/vkCmdSetDepthBounds).

A given sample is considered within the depth bounds if z\<sub>a\</sub> is in the
range \[`minDepthBounds`,`maxDepthBounds`].
Samples with depth attachment values outside of the depth bounds will have
their coverage set to `0`.

If the depth bounds test is disabled, or if there is no depth attachment,
the coverage mask is unmodified by this operation.

To dynamically set the depth bounds range,
call:

[{generated}/api/protos/vkCmdSetDepthBounds.adoc]({generated}/api/protos/vkCmdSetDepthBounds.adoc)

- `commandBuffer` is the command buffer into which the command will be
  recorded.

- `minDepthBounds` is the minimum depth bound.

- `maxDepthBounds` is the maximum depth bound.

This command sets the depth bounds range for subsequent drawing commands
when the graphics pipeline is created with
`VK_DYNAMIC_STATE_DEPTH_BOUNDS` set in
[VkPipelineDynamicStateCreateInfo](/man/VkPipelineDynamicStateCreateInfo)::`pDynamicStates`.
Otherwise, this state is specified by the
[VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo)::`minDepthBounds` and
[VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo)::`maxDepthBounds` values
used to create the currently active pipeline.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdSetDepthBounds-minDepthBounds-00600"}
`minDepthBounds` :normative{type="must"} be between `0.0` and `1.0`, inclusive
::

::validity-field{name="VUID-vkCmdSetDepthBounds-maxDepthBounds-00601"}
`maxDepthBounds` :normative{type="must"} be between `0.0` and `1.0`, inclusive
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdSetDepthBounds-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdSetDepthBounds-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdSetDepthBounds-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics operations
::

::validity-field{name="VUID-vkCmdSetDepthBounds-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::










## Stencil Test

The stencil test compares the stencil attachment value s\<sub>a\</sub> in the
depth/stencil attachment at each sample’s framebuffer coordinates
(x\<sub>f\</sub>,y\<sub>f\</sub>) and sample
index i against a *stencil reference value*.

If the stencil test is not enabled, as specified by
[VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo)::`stencilTestEnable`, or if
there is no stencil attachment, the coverage mask is unmodified by this
operation.

The stencil test is controlled by one of two sets of stencil-related state,
the front stencil state and the back stencil state.
Stencil tests and writes use the back stencil state when processing
fragments generated by back-facing

polygons, and the front stencil state when processing
fragments generated by front-facing polygons or
any other primitives.

The comparison operation performed is determined by the [VkCompareOp](/man/VkCompareOp)
value set by
[VkStencilOpState](/man/VkStencilOpState)::`compareOp` during pipeline creation.

The compare mask s\<sub>c\</sub> and stencil reference value s\<sub>r\</sub> of the
front or the back stencil state set determine arguments of the comparison
operation.
s\<sub>c\</sub> is set by the [VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo)
structure during pipeline creation, or by the
[vkCmdSetStencilCompareMask](/man/vkCmdSetStencilCompareMask) command.
s\<sub>r\</sub> is set by [VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo) or by
[vkCmdSetStencilReference](/man/vkCmdSetStencilReference).

s\<sub>r\</sub> and s\<sub>a\</sub> are each independently combined with s\<sub>c\</sub>
using a bitwise `AND` operation to create masked reference and attachment
values s'\<sub>r\</sub> and s'\<sub>a\</sub>.
s'\<sub>r\</sub> and s'\<sub>a\</sub> are used as the *reference* and *test* values,
respectively, in the operation specified by the [VkCompareOp](/man/VkCompareOp).

If the comparison evaluates to false, the coverage for the sample is set to
`0`.

A new stencil value s\<sub>g\</sub> is generated according to a stencil operation
defined by [VkStencilOp](/man/VkStencilOp) parameters set by
[VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo).
If the stencil test fails, `failOp` defines the stencil operation used.
If the stencil test passes however, the stencil op used is based on the
depth test - if it passes,
[VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo)::`passOp` is used, otherwise
[VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo)::`depthFailOp` is used.

The stencil attachment value s\<sub>a\</sub> is then updated with the generated
stencil value s\<sub>g\</sub> according to the write mask s\<sub>w\</sub> defined by
`writeMask` in [VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo)::`front`
and [VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo)::`back` as:



The `VkStencilOpState` structure is defined as:

[{generated}/api/structs/VkStencilOpState.adoc]({generated}/api/structs/VkStencilOpState.adoc)

- `failOp` is a [VkStencilOp](/man/VkStencilOp) value specifying the action
  performed on samples that fail the stencil test.

- `passOp` is a [VkStencilOp](/man/VkStencilOp) value specifying the action
  performed on samples that pass both the depth and stencil tests.

- `depthFailOp` is a [VkStencilOp](/man/VkStencilOp) value specifying the action
  performed on samples that pass the stencil test and fail the depth test.

- `compareOp` is a [VkCompareOp](/man/VkCompareOp) value specifying the comparison
  operator used in the stencil test.

- `compareMask` selects the bits of the unsigned integer stencil
  values participating in the stencil test.

- `writeMask` selects the bits of the unsigned integer stencil values
  updated by the stencil test in the stencil framebuffer attachment.

- `reference` is an integer stencil reference value that is used in
  the unsigned stencil comparison.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkStencilOpState-failOp-parameter"}
 `failOp` :normative{type="must"} be a valid [VkStencilOp](/man/VkStencilOp) value
::

::validity-field{name="VUID-VkStencilOpState-passOp-parameter"}
 `passOp` :normative{type="must"} be a valid [VkStencilOp](/man/VkStencilOp) value
::

::validity-field{name="VUID-VkStencilOpState-depthFailOp-parameter"}
 `depthFailOp` :normative{type="must"} be a valid [VkStencilOp](/man/VkStencilOp) value
::

::validity-field{name="VUID-VkStencilOpState-compareOp-parameter"}
 `compareOp` :normative{type="must"} be a valid [VkCompareOp](/man/VkCompareOp) value
::

::


To dynamically set the stencil compare mask,
call:

[{generated}/api/protos/vkCmdSetStencilCompareMask.adoc]({generated}/api/protos/vkCmdSetStencilCompareMask.adoc)

- `commandBuffer` is the command buffer into which the command will be
  recorded.

- `faceMask` is a bitmask of [VkStencilFaceFlagBits](/man/VkStencilFaceFlagBits) specifying
  the set of stencil state for which to update the compare mask.

- `compareMask` is the new value to use as the stencil compare mask.

This command sets the stencil compare mask for subsequent drawing commands
when the graphics pipeline is created with
`VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK` set in
[VkPipelineDynamicStateCreateInfo](/man/VkPipelineDynamicStateCreateInfo)::`pDynamicStates`.
Otherwise, this state is specified by the
[VkStencilOpState](/man/VkStencilOpState)::`compareMask` value used to create the currently
active pipeline, for both front and back faces.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdSetStencilCompareMask-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdSetStencilCompareMask-faceMask-parameter"}
 `faceMask` :normative{type="must"} be a valid combination of [VkStencilFaceFlagBits](/man/VkStencilFaceFlagBits) values
::

::validity-field{name="VUID-vkCmdSetStencilCompareMask-faceMask-requiredbitmask"}
 `faceMask` :normative{type="must"} not be `0`
::

::validity-field{name="VUID-vkCmdSetStencilCompareMask-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdSetStencilCompareMask-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics operations
::

::validity-field{name="VUID-vkCmdSetStencilCompareMask-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::






`VkStencilFaceFlagBits` values are:

[{generated}/api/enums/VkStencilFaceFlagBits.adoc]({generated}/api/enums/VkStencilFaceFlagBits.adoc)

- `VK_STENCIL_FACE_FRONT_BIT` specifies that only the front set of
  stencil state is updated.

- `VK_STENCIL_FACE_BACK_BIT` specifies that only the back set of
  stencil state is updated.

- `VK_STENCIL_FACE_FRONT_AND_BACK` is the combination of
  `VK_STENCIL_FACE_FRONT_BIT` and `VK_STENCIL_FACE_BACK_BIT`, and
  specifies that both sets of stencil state are updated.

[{generated}/api/flags/VkStencilFaceFlags.adoc]({generated}/api/flags/VkStencilFaceFlags.adoc)

`VkStencilFaceFlags` is a bitmask type for setting a mask of zero or
more [VkStencilFaceFlagBits](/man/VkStencilFaceFlagBits).

To dynamically set the stencil write mask,
call:

[{generated}/api/protos/vkCmdSetStencilWriteMask.adoc]({generated}/api/protos/vkCmdSetStencilWriteMask.adoc)

- `commandBuffer` is the command buffer into which the command will be
  recorded.

- `faceMask` is a bitmask of [VkStencilFaceFlagBits](/man/VkStencilFaceFlagBits) specifying
  the set of stencil state for which to update the write mask, as
  described above for [vkCmdSetStencilCompareMask](/man/vkCmdSetStencilCompareMask).

- `writeMask` is the new value to use as the stencil write mask.

This command sets the stencil write mask for subsequent drawing commands
when the graphics pipeline is created with
`VK_DYNAMIC_STATE_STENCIL_WRITE_MASK` set in
[VkPipelineDynamicStateCreateInfo](/man/VkPipelineDynamicStateCreateInfo)::`pDynamicStates`.
Otherwise, this state is specified by the `writeMask` value used to
create the currently active pipeline, for both
[VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo)::`front` and
[VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo)::`back` faces.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdSetStencilWriteMask-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdSetStencilWriteMask-faceMask-parameter"}
 `faceMask` :normative{type="must"} be a valid combination of [VkStencilFaceFlagBits](/man/VkStencilFaceFlagBits) values
::

::validity-field{name="VUID-vkCmdSetStencilWriteMask-faceMask-requiredbitmask"}
 `faceMask` :normative{type="must"} not be `0`
::

::validity-field{name="VUID-vkCmdSetStencilWriteMask-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdSetStencilWriteMask-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics operations
::

::validity-field{name="VUID-vkCmdSetStencilWriteMask-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::






To dynamically set the stencil reference value,
call:

[{generated}/api/protos/vkCmdSetStencilReference.adoc]({generated}/api/protos/vkCmdSetStencilReference.adoc)

- `commandBuffer` is the command buffer into which the command will be
  recorded.

- `faceMask` is a bitmask of [VkStencilFaceFlagBits](/man/VkStencilFaceFlagBits) specifying
  the set of stencil state for which to update the reference value, as
  described above for [vkCmdSetStencilCompareMask](/man/vkCmdSetStencilCompareMask).

- `reference` is the new value to use as the stencil reference value.

This command sets the stencil reference value for subsequent drawing
commands
when the graphics pipeline is created with
`VK_DYNAMIC_STATE_STENCIL_REFERENCE` set in
[VkPipelineDynamicStateCreateInfo](/man/VkPipelineDynamicStateCreateInfo)::`pDynamicStates`.
Otherwise, this state is specified by the
[VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo)::`reference` value used to
create the currently active pipeline, for both front and back faces.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdSetStencilReference-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdSetStencilReference-faceMask-parameter"}
 `faceMask` :normative{type="must"} be a valid combination of [VkStencilFaceFlagBits](/man/VkStencilFaceFlagBits) values
::

::validity-field{name="VUID-vkCmdSetStencilReference-faceMask-requiredbitmask"}
 `faceMask` :normative{type="must"} not be `0`
::

::validity-field{name="VUID-vkCmdSetStencilReference-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdSetStencilReference-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics operations
::

::validity-field{name="VUID-vkCmdSetStencilReference-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::






Possible values of the `failOp`, `passOp`, and `depthFailOp`
members of [VkStencilOpState](/man/VkStencilOpState), specifying what happens to the stored
stencil value if this or certain subsequent tests fail or pass, are:

[{generated}/api/enums/VkStencilOp.adoc]({generated}/api/enums/VkStencilOp.adoc)

- `VK_STENCIL_OP_KEEP` keeps the current value.

- `VK_STENCIL_OP_ZERO` sets the value to 0.

- `VK_STENCIL_OP_REPLACE` sets the value to `reference`.

- `VK_STENCIL_OP_INCREMENT_AND_CLAMP` increments the current value and
  clamps to the maximum representable unsigned value.

- `VK_STENCIL_OP_DECREMENT_AND_CLAMP` decrements the current value and
  clamps to 0.

- `VK_STENCIL_OP_INVERT` bitwise-inverts the current value.

- `VK_STENCIL_OP_INCREMENT_AND_WRAP` increments the current value and
  wraps to 0 when the maximum value would have been exceeded.

- `VK_STENCIL_OP_DECREMENT_AND_WRAP` decrements the current value and
  wraps to the maximum possible value when the value would go below 0.

For purposes of increment and decrement, the stencil bits are considered as
an unsigned integer.





## Depth Test

The depth test compares the depth value z\<sub>a\</sub> in the depth/stencil
attachment at each sample’s framebuffer coordinates (x\<sub>f\</sub>,y\<sub>f\</sub>) and
sample index i against the
sample’s depth value z\<sub>f\</sub>.
If there is no depth attachment then the depth test is skipped.

The depth test occurs in three stages, as detailed in the following
sections.



### Depth Clamping and Range Adjustment

If [VkPipelineRasterizationStateCreateInfo](/man/VkPipelineRasterizationStateCreateInfo)::`depthClampEnable` is
enabled, z\<sub>f\</sub> is clamped to \[z\<sub>min\</sub>, z\<sub>max\</sub>], where z\<sub>min\</sub>
\= min(n,f), z\<sub>max\</sub> = max(n,f)], and n and f are the
`minDepth` and `maxDepth` depth range values of the viewport used by
this fragment, respectively.

Following depth clamping:

- If z\<sub>f\</sub> is not in the range \[z\<sub>min\</sub>, z\<sub>max\</sub>], then
  z\<sub>f\</sub> is undefined: following this step.





### Depth Comparison

If the depth test is not enabled, as specified by
[VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo)::`depthTestEnable`, then
this step is skipped.

The comparison operation performed is determined by the [VkCompareOp](/man/VkCompareOp)
value set by
[VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo)::`depthCompareOp` during
pipeline creation.
z\<sub>f\</sub> and z\<sub>a\</sub> are used as the *reference* and *test* values,
respectively, in the operation specified by the [VkCompareOp](/man/VkCompareOp).

If the comparison evaluates to false, the coverage for the sample is set to
`0`.





### Depth Attachment Writes

If depth writes are enabled, as specified by
[VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo)::`depthWriteEnable`, and the
comparison evaluated to true, the depth attachment value z\<sub>a\</sub> is set
to the sample’s depth value z\<sub>f\</sub>.
If there is no depth attachment, no value is written.







## Sample Counting

Occlusion queries use query pool entries to track the number of samples that
pass all the per-fragment tests.
The mechanism of collecting an occlusion query value is described in
Occlusion Queries.

The occlusion query sample counter increments by one for each sample with a
coverage value of 1 in each fragment that survives all the per-fragment
tests, including scissor,
sample mask, alpha to coverage, stencil, and depth tests.





## Coverage Reduction

Coverage reduction takes the coverage information for a fragment and
converts that to a boolean coverage value for each color sample in each
pixel covered by the fragment.



### Pixel Coverage

Coverage for each pixel is first extracted from the total fragment coverage
mask.
This consists of `rasterizationSamples` unique coverage samples for each
pixel in the fragment area, each with a unique
sample index.
If the fragment only contains a single pixel, coverage for the pixel is
equivalent to the fragment coverage.





### Color Sample Coverage

Once pixel coverage is determined, coverage for each individual color sample
corresponding to that pixel is determined.

The
number of `rasterizationSamples` is identical to the number of samples
in the color
attachments. A
color sample is covered if the pixel coverage sample with the same
sample index i is covered.









# The Framebuffer



## Blending

Blending combines the incoming *source* fragment’s R, G, B, and A values
with the *destination* R, G, B, and A values of each sample stored in the
framebuffer at the fragment’s (x\<sub>f\</sub>,y\<sub>f\</sub>) location.
Blending is performed for each color sample covered by the fragment, rather
than just once for each fragment.

Source and destination values are combined according to the
blend operation, quadruplets of source and
destination weighting factors determined by the blend factors, and a blend constant, to
obtain a new set of R, G, B, and A values, as described below.

Blending is computed and applied separately to each color attachment used by
the subpass, with separate controls for each attachment.

Prior to performing the blend operation, signed and unsigned normalized
fixed-point color components undergo an implied conversion to floating-point
as specified by Conversion from Normalized
Fixed-Point to Floating-Point.
Blending computations are treated as if carried out in floating-point, and
basic blend operations are performed with a precision and dynamic range no
lower than that used to represent destination components.


::note
Blending is only defined for floating-point, UNORM, SNORM, and sRGB formats.
Within those formats, the implementation may only support blending on some
subset of them.
Which formats support blending is indicated by
`VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT`.
::


The pipeline blend state is included in the
`VkPipelineColorBlendStateCreateInfo` structure during graphics pipeline
creation:

The `VkPipelineColorBlendStateCreateInfo` structure is defined as:

[{generated}/api/structs/VkPipelineColorBlendStateCreateInfo.adoc]({generated}/api/structs/VkPipelineColorBlendStateCreateInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `flags` is reserved for future use.

- `logicOpEnable` controls whether to apply Logical Operations.

- `logicOp` selects which logical operation to apply.

- `attachmentCount` is the number of
  [VkPipelineColorBlendAttachmentState](/man/VkPipelineColorBlendAttachmentState) elements in
  `pAttachments`.

- `pAttachments` is a pointer to an array of
  [VkPipelineColorBlendAttachmentState](/man/VkPipelineColorBlendAttachmentState) structures defining blend
  state for each color attachment.

- `blendConstants` is a pointer to an array of four values used as the
  R, G, B, and A components of the blend constant that are used in
  blending, depending on the blend factor.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkPipelineColorBlendStateCreateInfo-pAttachments-00605"}

If the `independentBlend` feature is
not enabled, all elements of `pAttachments` :normative{type="must"} be identical
::

::validity-field{name="VUID-VkPipelineColorBlendStateCreateInfo-logicOpEnable-00606"}

If the `logicOp` feature is not enabled,
`logicOpEnable` :normative{type="must"} be `VK_FALSE`
::

::validity-field{name="VUID-VkPipelineColorBlendStateCreateInfo-logicOpEnable-00607"}

If `logicOpEnable` is `VK_TRUE`, `logicOp` :normative{type="must"} be a valid
[VkLogicOp](/man/VkLogicOp) value
::

::validity-field{name="VUID-VkPipelineColorBlendStateCreateInfo-pAttachments-07353"}

If `attachmentCount` is not `0`

`pAttachments` :normative{type="must"} be a valid pointer to an array of
`attachmentCount` valid [VkPipelineColorBlendAttachmentState](/man/VkPipelineColorBlendAttachmentState)
structures
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkPipelineColorBlendStateCreateInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO`
::

::validity-field{name="VUID-VkPipelineColorBlendStateCreateInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkPipelineColorBlendAdvancedStateCreateInfoEXT](/man/VkPipelineColorBlendAdvancedStateCreateInfoEXT) or [VkPipelineColorWriteCreateInfoEXT](/man/VkPipelineColorWriteCreateInfoEXT)
::

::validity-field{name="VUID-VkPipelineColorBlendStateCreateInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkPipelineColorBlendStateCreateInfo-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkPipelineColorBlendStateCreateFlagBits](/man/VkPipelineColorBlendStateCreateFlagBits) values
::

::validity-field{name="VUID-VkPipelineColorBlendStateCreateInfo-pAttachments-parameter"}
 If `attachmentCount` is not `0`, and `pAttachments` is not `NULL`, `pAttachments` :normative{type="must"} be a valid pointer to an array of `attachmentCount` valid [VkPipelineColorBlendAttachmentState](/man/VkPipelineColorBlendAttachmentState) structures
::

::


[{generated}/api/flags/VkPipelineColorBlendStateCreateFlags.adoc]({generated}/api/flags/VkPipelineColorBlendStateCreateFlags.adoc)

`VkPipelineColorBlendStateCreateFlags` is a bitmask type for setting a
mask, but is currently reserved for future use.

The `VkPipelineColorBlendAttachmentState` structure is defined as:

[{generated}/api/structs/VkPipelineColorBlendAttachmentState.adoc]({generated}/api/structs/VkPipelineColorBlendAttachmentState.adoc)

- `blendEnable` controls whether blending is enabled for the
  corresponding color attachment.
  If blending is not enabled, the source fragment’s color for that
  attachment is passed through unmodified.

- `srcColorBlendFactor` selects which blend factor is used to
  determine the source factors (S\<sub>r\</sub>,S\<sub>g\</sub>,S\<sub>b\</sub>).

- `dstColorBlendFactor` selects which blend factor is used to
  determine the destination factors (D\<sub>r\</sub>,D\<sub>g\</sub>,D\<sub>b\</sub>).

- `colorBlendOp` selects which blend operation is used to calculate
  the RGB values to write to the color attachment.

- `srcAlphaBlendFactor` selects which blend factor is used to
  determine the source factor S\<sub>a\</sub>.

- `dstAlphaBlendFactor` selects which blend factor is used to
  determine the destination factor D\<sub>a\</sub>.

- `alphaBlendOp` selects which blend operation is used to calculate
  the alpha values to write to the color attachment.

- `colorWriteMask` is a bitmask of [VkColorComponentFlagBits](/man/VkColorComponentFlagBits)
  specifying which of the R, G, B, and/or A components are enabled for
  writing, as described for the Color Write
  Mask.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkPipelineColorBlendAttachmentState-srcColorBlendFactor-00608"}

If the `dualSrcBlend` feature is not
enabled, `srcColorBlendFactor` :normative{type="must"} not be
`VK_BLEND_FACTOR_SRC1_COLOR`,
`VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR`,
`VK_BLEND_FACTOR_SRC1_ALPHA`, or
`VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA`
::

::validity-field{name="VUID-VkPipelineColorBlendAttachmentState-dstColorBlendFactor-00609"}

If the `dualSrcBlend` feature is not
enabled, `dstColorBlendFactor` :normative{type="must"} not be
`VK_BLEND_FACTOR_SRC1_COLOR`,
`VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR`,
`VK_BLEND_FACTOR_SRC1_ALPHA`, or
`VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA`
::

::validity-field{name="VUID-VkPipelineColorBlendAttachmentState-srcAlphaBlendFactor-00610"}

If the `dualSrcBlend` feature is not
enabled, `srcAlphaBlendFactor` :normative{type="must"} not be
`VK_BLEND_FACTOR_SRC1_COLOR`,
`VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR`,
`VK_BLEND_FACTOR_SRC1_ALPHA`, or
`VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA`
::

::validity-field{name="VUID-VkPipelineColorBlendAttachmentState-dstAlphaBlendFactor-00611"}

If the `dualSrcBlend` feature is not
enabled, `dstAlphaBlendFactor` :normative{type="must"} not be
`VK_BLEND_FACTOR_SRC1_COLOR`,
`VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR`,
`VK_BLEND_FACTOR_SRC1_ALPHA`, or
`VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkPipelineColorBlendAttachmentState-srcColorBlendFactor-parameter"}
 `srcColorBlendFactor` :normative{type="must"} be a valid [VkBlendFactor](/man/VkBlendFactor) value
::

::validity-field{name="VUID-VkPipelineColorBlendAttachmentState-dstColorBlendFactor-parameter"}
 `dstColorBlendFactor` :normative{type="must"} be a valid [VkBlendFactor](/man/VkBlendFactor) value
::

::validity-field{name="VUID-VkPipelineColorBlendAttachmentState-colorBlendOp-parameter"}
 `colorBlendOp` :normative{type="must"} be a valid [VkBlendOp](/man/VkBlendOp) value
::

::validity-field{name="VUID-VkPipelineColorBlendAttachmentState-srcAlphaBlendFactor-parameter"}
 `srcAlphaBlendFactor` :normative{type="must"} be a valid [VkBlendFactor](/man/VkBlendFactor) value
::

::validity-field{name="VUID-VkPipelineColorBlendAttachmentState-dstAlphaBlendFactor-parameter"}
 `dstAlphaBlendFactor` :normative{type="must"} be a valid [VkBlendFactor](/man/VkBlendFactor) value
::

::validity-field{name="VUID-VkPipelineColorBlendAttachmentState-alphaBlendOp-parameter"}
 `alphaBlendOp` :normative{type="must"} be a valid [VkBlendOp](/man/VkBlendOp) value
::

::validity-field{name="VUID-VkPipelineColorBlendAttachmentState-colorWriteMask-parameter"}
 `colorWriteMask` :normative{type="must"} be a valid combination of [VkColorComponentFlagBits](/man/VkColorComponentFlagBits) values
::

::




### Blend Factors

The source and destination color and alpha blending factors are selected
from the enum:

[{generated}/api/enums/VkBlendFactor.adoc]({generated}/api/enums/VkBlendFactor.adoc)

The semantics of the enum values are described in the table below:



In this table, the following conventions are used:

- R\<sub>s0\</sub>,G\<sub>s0\</sub>,B\<sub>s0\</sub> and A\<sub>s0\</sub> represent the first source color
  R, G, B, and A components, respectively, for the fragment output
  location corresponding to the color attachment being blended.

- R\<sub>s1\</sub>,G\<sub>s1\</sub>,B\<sub>s1\</sub> and A\<sub>s1\</sub> represent the second source
  color R, G, B, and A components, respectively, used in dual source
  blending modes, for the fragment output location corresponding to the
  color attachment being blended.

- R\<sub>d\</sub>,G\<sub>d\</sub>,B\<sub>d\</sub> and A\<sub>d\</sub> represent the R, G, B, and A
  components of the destination color.
  That is, the color currently in the corresponding color attachment for
  this fragment/sample.

- R\<sub>c\</sub>,G\<sub>c\</sub>,B\<sub>c\</sub> and A\<sub>c\</sub> represent the blend constant R, G,
  B, and A components, respectively.

To dynamically set and change the blend
constants, call:

[{generated}/api/protos/vkCmdSetBlendConstants.adoc]({generated}/api/protos/vkCmdSetBlendConstants.adoc)

- `commandBuffer` is the command buffer into which the command will be
  recorded.

- `blendConstants` is a pointer to an array of four values specifying
  the R\<sub>c\</sub>, G\<sub>c\</sub>, B\<sub>c\</sub>, and A\<sub>c\</sub> components of the
  blend constant color used in blending, depending on the
  blend factor.

This command sets blend constants for subsequent drawing commands when
the graphics pipeline is created with `VK_DYNAMIC_STATE_BLEND_CONSTANTS`
set in [VkPipelineDynamicStateCreateInfo](/man/VkPipelineDynamicStateCreateInfo)::`pDynamicStates`.
Otherwise, this state is specified by the
[VkPipelineColorBlendStateCreateInfo](/man/VkPipelineColorBlendStateCreateInfo)::`blendConstants` values used
to create the currently active pipeline.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdSetBlendConstants-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdSetBlendConstants-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdSetBlendConstants-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support graphics operations
::

::validity-field{name="VUID-vkCmdSetBlendConstants-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::










### Dual-Source Blending

Blend factors that use the secondary color input
(R\<sub>s1\</sub>,G\<sub>s1\</sub>,B\<sub>s1\</sub>,A\<sub>s1\</sub>) (`VK_BLEND_FACTOR_SRC1_COLOR`,
`VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR`,
`VK_BLEND_FACTOR_SRC1_ALPHA`, and
`VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA`) :normative{type="may"} consume implementation
resources that could otherwise be used for rendering to multiple color
attachments.
Therefore, the number of color attachments that :normative{type="can"} be used in a
framebuffer :normative{type="may"} be lower when using dual-source blending.

Dual-source blending is only supported if the `dualSrcBlend` feature is enabled.

The maximum number of color attachments that :normative{type="can"} be used in a subpass when
using dual-source blending functions is implementation-dependent and is
reported as the `maxFragmentDualSrcAttachments` member of
`VkPhysicalDeviceLimits`.

Color outputs :normative{type="can"} be bound to the first and second inputs of the blender
using the `Index` decoration, as described in
Fragment Output Interface.
If the second color input to the blender is not written in the shader, or if
no output is bound to the second input of a blender, the value of the second
input is undefined:.





### Blend Operations

Once the source and destination blend factors have been selected, they along
with the source and destination components are passed to the blending
operations.
RGB and alpha components :normative{type="can"} use different operations.
Possible values of [VkBlendOp](/man/VkBlendOp), specifying the operations, are:

[{generated}/api/enums/VkBlendOp.adoc]({generated}/api/enums/VkBlendOp.adoc)



The semantics of the basic blend operations are described in the table
below:



In this table, the following conventions are used:

- R\<sub>s0\</sub>, G\<sub>s0\</sub>, B\<sub>s0\</sub> and A\<sub>s0\</sub> represent the first source
  color R, G, B, and A components, respectively.

- R\<sub>d\</sub>, G\<sub>d\</sub>, B\<sub>d\</sub> and A\<sub>d\</sub> represent the R, G, B, and A
  components of the destination color.
  That is, the color currently in the corresponding color attachment for
  this fragment/sample.

- S\<sub>r\</sub>, S\<sub>g\</sub>, S\<sub>b\</sub> and S\<sub>a\</sub> represent the source blend factor
  R, G, B, and A components, respectively.

- D\<sub>r\</sub>, D\<sub>g\</sub>, D\<sub>b\</sub> and D\<sub>a\</sub> represent the destination blend
  factor R, G, B, and A components, respectively.

The blending operation produces a new set of values R, G, B and
A, which are written to the framebuffer attachment.
If blending is not enabled for this attachment, then R, G, B and
A are assigned R\<sub>s0\</sub>, G\<sub>s0\</sub>, B\<sub>s0\</sub> and A\<sub>s0\</sub>,
respectively.

If the color attachment is fixed-point, the components of the source and
destination values and blend factors are each clamped to \[0,1] or
\[-1,1] respectively for an unsigned normalized or signed normalized
color attachment prior to evaluating the blend operations.
If the color attachment is floating-point, no clamping occurs.

If the numeric format of a framebuffer attachment
uses sRGB encoding, the R, G, and B destination color values (after
conversion from fixed-point to floating-point) are considered to be encoded
for the sRGB color space and hence are linearized prior to their use in
blending.
Each R, G, and B component is converted from nonlinear to linear as
described in the > sRGB EOTF section of the Khronos Data
Format Specification.
If the format is not sRGB, no linearization is performed.

If the numeric format of a framebuffer attachment
uses sRGB encoding, then the final R, G and B values are converted into the
nonlinear sRGB representation before being written to the framebuffer
attachment as described in the > sRGB EOTF
>
> \<sup>
>
>  -1
>
> \</sup> section of the
Khronos Data Format Specification.

If the numeric format of a framebuffer color
attachment is not sRGB encoded then the resulting c\<sub>s\</sub> values for R, G
and B are unmodified.
The value of A is never sRGB encoded.
That is, the alpha component is always stored in memory as linear.

If the framebuffer color attachment is `VK_ATTACHMENT_UNUSED`, no writes
are performed through that attachment.
Writes are not performed to framebuffer color attachments greater than or
equal to the `VkSubpassDescription`::`colorAttachmentCount`
value.







## Logical Operations

The application :normative{type="can"} enable a *logical operation* between the fragment’s
color values and the existing value in the framebuffer attachment.
This logical operation is applied prior to updating the framebuffer
attachment.
Logical operations are applied only for signed and unsigned integer and
normalized integer framebuffers.
Logical operations are not applied to floating-point or sRGB format color
attachments.

Logical operations are controlled by the `logicOpEnable` and
`logicOp` members of [VkPipelineColorBlendStateCreateInfo](/man/VkPipelineColorBlendStateCreateInfo).
If `logicOpEnable` is `VK_TRUE`, then a logical operation selected
by `logicOp` is applied between each color attachment and the fragment’s
corresponding output value, and blending of all attachments is treated as if
it were disabled.
Any attachments using color formats for which logical operations are not
supported simply pass through the color values unmodified.
The logical operation is applied independently for each of the red, green,
blue, and alpha components.
The `logicOp` is selected from the following operations:

[{generated}/api/enums/VkLogicOp.adoc]({generated}/api/enums/VkLogicOp.adoc)



The logical operations supported by Vulkan are summarized in the following
table in which

- ¬ is bitwise invert,

- ∧ is bitwise and,

- ∨ is bitwise or,

- ⊕ is bitwise exclusive or,

- s is the fragment’s R\<sub>s0\</sub>, G\<sub>s0\</sub>, B\<sub>s0\</sub> or A\<sub>s0\</sub>
  component value for the fragment output corresponding to the color
  attachment being updated, and

- d is the color attachment’s R, G, B or A component
  value:



The result of the logical operation is then written to the color attachment
as controlled by the component write mask, described in
Blend Operations.





## Color Write Mask

Bits which :normative{type="can"} be set in
[VkPipelineColorBlendAttachmentState](/man/VkPipelineColorBlendAttachmentState)::`colorWriteMask`, determining
whether the final color values R, G, B and A are written to the
framebuffer attachment, are:

[{generated}/api/enums/VkColorComponentFlagBits.adoc]({generated}/api/enums/VkColorComponentFlagBits.adoc)

- `VK_COLOR_COMPONENT_R_BIT` specifies that the R value is
  written to the color attachment for the appropriate sample.
  Otherwise, the value in memory is unmodified.

- `VK_COLOR_COMPONENT_G_BIT` specifies that the G value is
  written to the color attachment for the appropriate sample.
  Otherwise, the value in memory is unmodified.

- `VK_COLOR_COMPONENT_B_BIT` specifies that the B value is
  written to the color attachment for the appropriate sample.
  Otherwise, the value in memory is unmodified.

- `VK_COLOR_COMPONENT_A_BIT` specifies that the A value is
  written to the color attachment for the appropriate sample.
  Otherwise, the value in memory is unmodified.

The color write mask operation is applied regardless of whether blending is
enabled.

[{generated}/api/flags/VkColorComponentFlags.adoc]({generated}/api/flags/VkColorComponentFlags.adoc)

`VkColorComponentFlags` is a bitmask type for setting a mask of zero or
more [VkColorComponentFlagBits](/man/VkColorComponentFlagBits).







# Dispatching Commands

*Dispatching commands* (commands with `Dispatch` in the name) provoke
work in a compute pipeline.
Dispatching commands are recorded into a command buffer and when executed by
a queue, will produce work which executes according to the bound compute
pipeline.
A compute pipeline :normative{type="must"} be bound to a command buffer before any dispatching
commands are recorded in that command buffer.

To record a dispatch, call:

[{generated}/api/protos/vkCmdDispatch.adoc]({generated}/api/protos/vkCmdDispatch.adoc)

- `commandBuffer` is the command buffer into which the command will be
  recorded.

- `groupCountX` is the number of local workgroups to dispatch in the X
  dimension.

- `groupCountY` is the number of local workgroups to dispatch in the Y
  dimension.

- `groupCountZ` is the number of local workgroups to dispatch in the Z
  dimension.

When the command is executed, a global workgroup consisting of
`groupCountX` × `groupCountY` × `groupCountZ`
local workgroups is assembled.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdDispatch-magFilter-04553"}

If a [VkSampler](/man/VkSampler) created with `magFilter` or `minFilter`
equal to `VK_FILTER_LINEAR` and `compareEnable` equal to
`VK_FALSE` is used to sample a [VkImageView](/man/VkImageView) as a result of this
command, then the image view’s
format features :normative{type="must"} contain
`VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT`
::

::validity-field{name="VUID-vkCmdDispatch-mipmapMode-04770"}

If a [VkSampler](/man/VkSampler) created with `mipmapMode` equal to
`VK_SAMPLER_MIPMAP_MODE_LINEAR` and `compareEnable` equal to
`VK_FALSE` is used to sample a [VkImageView](/man/VkImageView) as a result of this
command, then the image view’s
format features :normative{type="must"} contain
`VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT`
::

::validity-field{name="VUID-vkCmdDispatch-aspectMask-06478"}

If a [VkImageView](/man/VkImageView) is sampled with
depth comparison, the image view
:normative{type="must"} have been created with an `aspectMask` that contains
`VK_IMAGE_ASPECT_DEPTH_BIT`
::

::validity-field{name="VUID-vkCmdDispatch-None-02691"}

If a [VkImageView](/man/VkImageView) is accessed using atomic operations as a result
of this command, then the image view’s
format features :normative{type="must"} contain
`VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT`
::

::validity-field{name="VUID-vkCmdDispatch-None-07888"}

If a `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` descriptor is
accessed using atomic operations as a result of this command, then the
storage texel buffer’s format
features :normative{type="must"} contain
`VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT`
::

::validity-field{name="VUID-vkCmdDispatch-None-02697"}

For each set *n* that is statically used by a bound
shader, a descriptor set :normative{type="must"} have been bound to *n* at the same
pipeline bind point, with a [VkPipelineLayout](/man/VkPipelineLayout) that is compatible
for set *n*, with the [VkPipelineLayout](/man/VkPipelineLayout) used to create the current
[VkPipeline](/man/VkPipeline), as described in 
::

::validity-field{name="VUID-vkCmdDispatch-None-02698"}

For each push constant that is statically used by a
bound shader, a push constant value :normative{type="must"} have been set for the same
pipeline bind point, with a [VkPipelineLayout](/man/VkPipelineLayout) that is compatible
for push constants, with the [VkPipelineLayout](/man/VkPipelineLayout) used to create the
current [VkPipeline](/man/VkPipeline), as described in

::

::validity-field{name="VUID-vkCmdDispatch-None-02699"}

Descriptors in each bound descriptor set, specified via
[vkCmdBindDescriptorSets](/man/vkCmdBindDescriptorSets), :normative{type="must"} be valid as described by
descriptor validity if they are statically used
by a bound shader
::

::validity-field{name="VUID-vkCmdDispatch-None-02700"}

A valid pipeline :normative{type="must"} be bound to the pipeline bind point used by this
command
::

::validity-field{name="VUID-vkCmdDispatch-None-02859"}

There :normative{type="must"} not have been any calls to dynamic state setting commands
for any state not specified as dynamic in the [VkPipeline](/man/VkPipeline) object
bound to the pipeline bind point used by this command, since that
pipeline was bound
::

::validity-field{name="VUID-vkCmdDispatch-None-02702"}

If the [VkPipeline](/man/VkPipeline) object bound to the pipeline bind point used by
this command accesses a [VkSampler](/man/VkSampler) object that uses unnormalized
coordinates, that sampler :normative{type="must"} not be used to sample from any
[VkImage](/man/VkImage) with a [VkImageView](/man/VkImageView) of the type
`VK_IMAGE_VIEW_TYPE_3D`, `VK_IMAGE_VIEW_TYPE_CUBE`,
`VK_IMAGE_VIEW_TYPE_1D_ARRAY`, `VK_IMAGE_VIEW_TYPE_2D_ARRAY` or
`VK_IMAGE_VIEW_TYPE_CUBE_ARRAY`, in any shader stage
::

::validity-field{name="VUID-vkCmdDispatch-None-02703"}

If the [VkPipeline](/man/VkPipeline) object bound to the pipeline bind point used by
this command accesses a [VkSampler](/man/VkSampler) object that uses unnormalized
coordinates, that sampler :normative{type="must"} not be used with any of the SPIR-V
`OpImageSample*` or `OpImageSparseSample*` instructions with
`ImplicitLod`, `Dref` or `Proj` in their name, in any shader
stage
::

::validity-field{name="VUID-vkCmdDispatch-None-02704"}

If the [VkPipeline](/man/VkPipeline) object bound to the pipeline bind point used by
this command accesses a [VkSampler](/man/VkSampler) object that uses unnormalized
coordinates, that sampler :normative{type="must"} not be used with any of the SPIR-V
`OpImageSample*` or `OpImageSparseSample*` instructions that includes a
LOD bias or any offset values, in any shader stage
::

::validity-field{name="VUID-vkCmdDispatch-None-02705"}

If the `robustBufferAccess` feature
is not enabled, and if the [VkPipeline](/man/VkPipeline) object bound to the pipeline
bind point used by this command accesses a uniform buffer, it :normative{type="must"} not
access values outside of the range of the buffer as specified in the
descriptor set bound to the same pipeline bind point
::

::validity-field{name="VUID-vkCmdDispatch-None-02706"}

If the `robustBufferAccess` feature
is not enabled, and if the [VkPipeline](/man/VkPipeline) object bound to the pipeline
bind point used by this command accesses a storage buffer, it :normative{type="must"} not
access values outside of the range of the buffer as specified in the
descriptor set bound to the same pipeline bind point
::

::validity-field{name="VUID-vkCmdDispatch-viewType-07752"}

If a [VkImageView](/man/VkImageView) is accessed as a result of this command, then the
image view’s `viewType` :normative{type="must"} match the `Dim` operand of the
`OpTypeImage` as described in 
::

::validity-field{name="VUID-vkCmdDispatch-format-07753"}

If a [VkImageView](/man/VkImageView) is accessed as a result of this command, then the
numeric type of the image view’s `format`
and the `Sampled` `Type` operand of the `OpTypeImage` :normative{type="must"}
match
::

::validity-field{name="VUID-vkCmdDispatch-OpImageWrite-08795"}

If a [VkImageView](/man/VkImageView)
is accessed using `OpImageWrite` as a result of this command, then
the `Type` of the `Texel` operand of that instruction :normative{type="must"} have
at least as many components as the image view’s format
::

::validity-field{name="VUID-vkCmdDispatch-OpImageWrite-04469"}

If a [VkBufferView](/man/VkBufferView) is accessed using `OpImageWrite` as a result
of this command, then the `Type` of the `Texel` operand of that
instruction :normative{type="must"} have at least as many components as the buffer view’s
format
::

::validity-field{name="VUID-vkCmdDispatch-None-07288"}

Any shader invocation executed by this command :normative{type="must"}
terminate
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdDispatch-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdDispatch-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdDispatch-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support compute operations
::

::validity-field{name="VUID-vkCmdDispatch-renderpass"}
 This command :normative{type="must"} only be called outside of a render pass instance
::

::validity-field{name="VUID-vkCmdDispatch-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::






To record an indirect dispatching command, call:

[{generated}/api/protos/vkCmdDispatchIndirect.adoc]({generated}/api/protos/vkCmdDispatchIndirect.adoc)

- `commandBuffer` is the command buffer into which the command will be
  recorded.

- `buffer` is the buffer containing dispatch parameters.

- `offset` is the byte offset into `buffer` where parameters
  begin.

`vkCmdDispatchIndirect` behaves similarly to [vkCmdDispatch](/man/vkCmdDispatch) except
that the parameters are read by the device from a buffer during execution.
The parameters of the dispatch are encoded in a
[VkDispatchIndirectCommand](/man/VkDispatchIndirectCommand) structure taken from `buffer` starting
at `offset`.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkCmdDispatchIndirect-magFilter-04553"}

If a [VkSampler](/man/VkSampler) created with `magFilter` or `minFilter`
equal to `VK_FILTER_LINEAR` and `compareEnable` equal to
`VK_FALSE` is used to sample a [VkImageView](/man/VkImageView) as a result of this
command, then the image view’s
format features :normative{type="must"} contain
`VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT`
::

::validity-field{name="VUID-vkCmdDispatchIndirect-mipmapMode-04770"}

If a [VkSampler](/man/VkSampler) created with `mipmapMode` equal to
`VK_SAMPLER_MIPMAP_MODE_LINEAR` and `compareEnable` equal to
`VK_FALSE` is used to sample a [VkImageView](/man/VkImageView) as a result of this
command, then the image view’s
format features :normative{type="must"} contain
`VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT`
::

::validity-field{name="VUID-vkCmdDispatchIndirect-aspectMask-06478"}

If a [VkImageView](/man/VkImageView) is sampled with
depth comparison, the image view
:normative{type="must"} have been created with an `aspectMask` that contains
`VK_IMAGE_ASPECT_DEPTH_BIT`
::

::validity-field{name="VUID-vkCmdDispatchIndirect-None-02691"}

If a [VkImageView](/man/VkImageView) is accessed using atomic operations as a result
of this command, then the image view’s
format features :normative{type="must"} contain
`VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT`
::

::validity-field{name="VUID-vkCmdDispatchIndirect-None-07888"}

If a `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` descriptor is
accessed using atomic operations as a result of this command, then the
storage texel buffer’s format
features :normative{type="must"} contain
`VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT`
::

::validity-field{name="VUID-vkCmdDispatchIndirect-None-02697"}

For each set *n* that is statically used by a bound
shader, a descriptor set :normative{type="must"} have been bound to *n* at the same
pipeline bind point, with a [VkPipelineLayout](/man/VkPipelineLayout) that is compatible
for set *n*, with the [VkPipelineLayout](/man/VkPipelineLayout) used to create the current
[VkPipeline](/man/VkPipeline), as described in 
::

::validity-field{name="VUID-vkCmdDispatchIndirect-None-02698"}

For each push constant that is statically used by a
bound shader, a push constant value :normative{type="must"} have been set for the same
pipeline bind point, with a [VkPipelineLayout](/man/VkPipelineLayout) that is compatible
for push constants, with the [VkPipelineLayout](/man/VkPipelineLayout) used to create the
current [VkPipeline](/man/VkPipeline), as described in

::

::validity-field{name="VUID-vkCmdDispatchIndirect-None-02699"}

Descriptors in each bound descriptor set, specified via
[vkCmdBindDescriptorSets](/man/vkCmdBindDescriptorSets), :normative{type="must"} be valid as described by
descriptor validity if they are statically used
by a bound shader
::

::validity-field{name="VUID-vkCmdDispatchIndirect-None-02700"}

A valid pipeline :normative{type="must"} be bound to the pipeline bind point used by this
command
::

::validity-field{name="VUID-vkCmdDispatchIndirect-None-02859"}

There :normative{type="must"} not have been any calls to dynamic state setting commands
for any state not specified as dynamic in the [VkPipeline](/man/VkPipeline) object
bound to the pipeline bind point used by this command, since that
pipeline was bound
::

::validity-field{name="VUID-vkCmdDispatchIndirect-None-02702"}

If the [VkPipeline](/man/VkPipeline) object bound to the pipeline bind point used by
this command accesses a [VkSampler](/man/VkSampler) object that uses unnormalized
coordinates, that sampler :normative{type="must"} not be used to sample from any
[VkImage](/man/VkImage) with a [VkImageView](/man/VkImageView) of the type
`VK_IMAGE_VIEW_TYPE_3D`, `VK_IMAGE_VIEW_TYPE_CUBE`,
`VK_IMAGE_VIEW_TYPE_1D_ARRAY`, `VK_IMAGE_VIEW_TYPE_2D_ARRAY` or
`VK_IMAGE_VIEW_TYPE_CUBE_ARRAY`, in any shader stage
::

::validity-field{name="VUID-vkCmdDispatchIndirect-None-02703"}

If the [VkPipeline](/man/VkPipeline) object bound to the pipeline bind point used by
this command accesses a [VkSampler](/man/VkSampler) object that uses unnormalized
coordinates, that sampler :normative{type="must"} not be used with any of the SPIR-V
`OpImageSample*` or `OpImageSparseSample*` instructions with
`ImplicitLod`, `Dref` or `Proj` in their name, in any shader
stage
::

::validity-field{name="VUID-vkCmdDispatchIndirect-None-02704"}

If the [VkPipeline](/man/VkPipeline) object bound to the pipeline bind point used by
this command accesses a [VkSampler](/man/VkSampler) object that uses unnormalized
coordinates, that sampler :normative{type="must"} not be used with any of the SPIR-V
`OpImageSample*` or `OpImageSparseSample*` instructions that includes a
LOD bias or any offset values, in any shader stage
::

::validity-field{name="VUID-vkCmdDispatchIndirect-None-02705"}

If the `robustBufferAccess` feature
is not enabled, and if the [VkPipeline](/man/VkPipeline) object bound to the pipeline
bind point used by this command accesses a uniform buffer, it :normative{type="must"} not
access values outside of the range of the buffer as specified in the
descriptor set bound to the same pipeline bind point
::

::validity-field{name="VUID-vkCmdDispatchIndirect-None-02706"}

If the `robustBufferAccess` feature
is not enabled, and if the [VkPipeline](/man/VkPipeline) object bound to the pipeline
bind point used by this command accesses a storage buffer, it :normative{type="must"} not
access values outside of the range of the buffer as specified in the
descriptor set bound to the same pipeline bind point
::

::validity-field{name="VUID-vkCmdDispatchIndirect-viewType-07752"}

If a [VkImageView](/man/VkImageView) is accessed as a result of this command, then the
image view’s `viewType` :normative{type="must"} match the `Dim` operand of the
`OpTypeImage` as described in 
::

::validity-field{name="VUID-vkCmdDispatchIndirect-format-07753"}

If a [VkImageView](/man/VkImageView) is accessed as a result of this command, then the
numeric type of the image view’s `format`
and the `Sampled` `Type` operand of the `OpTypeImage` :normative{type="must"}
match
::

::validity-field{name="VUID-vkCmdDispatchIndirect-OpImageWrite-08795"}

If a [VkImageView](/man/VkImageView)
is accessed using `OpImageWrite` as a result of this command, then
the `Type` of the `Texel` operand of that instruction :normative{type="must"} have
at least as many components as the image view’s format
::

::validity-field{name="VUID-vkCmdDispatchIndirect-OpImageWrite-04469"}

If a [VkBufferView](/man/VkBufferView) is accessed using `OpImageWrite` as a result
of this command, then the `Type` of the `Texel` operand of that
instruction :normative{type="must"} have at least as many components as the buffer view’s
format
::

::validity-field{name="VUID-vkCmdDispatchIndirect-None-07288"}

Any shader invocation executed by this command :normative{type="must"}
terminate
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkCmdDispatchIndirect-commandBuffer-parameter"}
 `commandBuffer` :normative{type="must"} be a valid [VkCommandBuffer](/man/VkCommandBuffer) handle
::

::validity-field{name="VUID-vkCmdDispatchIndirect-buffer-parameter"}
 `buffer` :normative{type="must"} be a valid [VkBuffer](/man/VkBuffer) handle
::

::validity-field{name="VUID-vkCmdDispatchIndirect-commandBuffer-recording"}
 `commandBuffer` :normative{type="must"} be in the recording state
::

::validity-field{name="VUID-vkCmdDispatchIndirect-commandBuffer-cmdpool"}
 The `VkCommandPool` that `commandBuffer` was allocated from :normative{type="must"} support compute operations
::

::validity-field{name="VUID-vkCmdDispatchIndirect-renderpass"}
 This command :normative{type="must"} only be called outside of a render pass instance
::

::validity-field{name="VUID-vkCmdDispatchIndirect-videocoding"}
 This command :normative{type="must"} only be called outside of a video coding scope
::

::validity-field{name="VUID-vkCmdDispatchIndirect-commonparent"}
 Both of `buffer`, and `commandBuffer` :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::






The `VkDispatchIndirectCommand` structure is defined as:

[{generated}/api/structs/VkDispatchIndirectCommand.adoc]({generated}/api/structs/VkDispatchIndirectCommand.adoc)

- `x` is the number of local workgroups to dispatch in the X
  dimension.

- `y` is the number of local workgroups to dispatch in the Y
  dimension.

- `z` is the number of local workgroups to dispatch in the Z
  dimension.

The members of `VkDispatchIndirectCommand` have the same meaning as the
corresponding parameters of [vkCmdDispatch](/man/vkCmdDispatch).


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkDispatchIndirectCommand-x-00417"}
`x` :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxComputeWorkGroupCount`[0]
::

::validity-field{name="VUID-VkDispatchIndirectCommand-y-00418"}
`y` :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxComputeWorkGroupCount`[1]
::

::validity-field{name="VUID-VkDispatchIndirectCommand-z-00419"}
`z` :normative{type="must"} be less than or equal to
`VkPhysicalDeviceLimits`::`maxComputeWorkGroupCount`[2]
::

::






# Sparse Resources

As documented in Resource Memory Association,
`VkBuffer` and `VkImage` resources in Vulkan :normative{type="must"} be bound
completely and contiguously to a single `VkDeviceMemory` object.
This binding :normative{type="must"} be done before the resource is used, and the binding is
immutable for the lifetime of the resource.

*Sparse resources* relax these restrictions and provide these additional
features:

- Sparse resources :normative{type="can"} be bound non-contiguously to one or more
  `VkDeviceMemory` allocations.

- Sparse resources :normative{type="can"} be re-bound to different memory allocations over
  the lifetime of the resource.

- Sparse resources :normative{type="can"} have descriptors generated and used orthogonally
  with memory binding commands.



## Sparse Resource Features

Sparse resources have several features that :normative{type="must"} be enabled explicitly at
resource creation time.
The features are enabled by including bits in the `flags` parameter of
[VkImageCreateInfo](/man/VkImageCreateInfo) or [VkBufferCreateInfo](/man/VkBufferCreateInfo).
Each feature also has one or more corresponding feature enables specified in
[VkPhysicalDeviceFeatures](/man/VkPhysicalDeviceFeatures).

- The `sparseBinding` feature is the base,
  and provides the following capabilities:





  * Resources :normative{type="can"} be bound at some defined (sparse block) granularity.

  * The entire resource :normative{type="must"} be bound to memory before use regardless of
    regions actually accessed.

  * No specific mapping of image region to memory offset is defined, i.e.
    the location that each texel corresponds to in memory is
    implementation-dependent.

  * Sparse buffers have a well-defined mapping of buffer range to memory
    range, where an offset into a range of the buffer that is bound to a
    single contiguous range of memory corresponds to an identical offset
    within that range of memory.

  * Requested via the `VK_IMAGE_CREATE_SPARSE_BINDING_BIT` and
    `VK_BUFFER_CREATE_SPARSE_BINDING_BIT` bits.

  * A sparse image created using `VK_IMAGE_CREATE_SPARSE_BINDING_BIT`
    (but not `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`) supports all
    formats that non-sparse usage supports, and supports both
    `VK_IMAGE_TILING_OPTIMAL` and `VK_IMAGE_TILING_LINEAR` tiling.

- *Sparse Residency* builds on (and requires) the `sparseBinding`
  feature.
  It includes the following capabilities:





  * Resources do not have to be completely bound to memory before use on
    the device.

  * Images have a prescribed sparse image block layout, allowing specific
    rectangular regions of the image to be bound to specific offsets in
    memory allocations.

  * Consistency of access to unbound regions of the resource is defined by
    the absence or presence of
    `VkPhysicalDeviceSparseProperties`::`residencyNonResidentStrict`.
    If this property is present, accesses to unbound regions of the
    resource are well defined and behave as if the data bound is populated
    with all zeros; writes are discarded.
    When this property is absent, accesses are considered safe, but reads
    will return undefined: values.

  * Requested via the `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` and
    `VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT` bits.

  * [features-sparseResidency](#features-sparseResidency) Sparse residency support is advertised on
    a finer grain via the following features:





    * The `sparseResidencyBuffer`
      feature provides support for creating `VkBuffer` objects with the
      `VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT`.

    * The `sparseResidencyImage2D`
      feature provides support for creating 2D single-sampled `VkImage`
      objects with `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`.

    * The `sparseResidencyImage3D`
      feature provides support for creating 3D `VkImage` objects with
      `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`.

    * The `sparseResidency2Samples` feature provides support for creating
      2D `VkImage` objects with 2 samples and
      `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`.

    * The `sparseResidency4Samples` feature provides support for creating
      2D `VkImage` objects with 4 samples and
      `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`.

    * The `sparseResidency8Samples` feature provides support for creating
      2D `VkImage` objects with 8 samples and
      `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`.

    * The `sparseResidency16Samples` feature provides support for creating
      2D `VkImage` objects with 16 samples and
      `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`.





    Implementations supporting `sparseResidencyImage2D` are only :normative{type="required"}
    to support sparse 2D, single-sampled images.
    Support for sparse 3D and MSAA images is :normative{type="optional"} and :normative{type="can"} be enabled via
    `sparseResidencyImage3D`, `sparseResidency2Samples`,
    `sparseResidency4Samples`, `sparseResidency8Samples`, and
    `sparseResidency16Samples`.

  * A sparse image created using `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`
    supports all non-compressed color formats with power-of-two element
    size that non-sparse usage supports.
    Additional formats :normative{type="may"} also be supported and :normative{type="can"} be queried via
    [vkGetPhysicalDeviceSparseImageFormatProperties](/man/vkGetPhysicalDeviceSparseImageFormatProperties).
    `VK_IMAGE_TILING_LINEAR` tiling is not supported.

- The `sparseResidencyAliased`
  feature provides the following capability that :normative{type="can"} be enabled per
  resource:





  Allows physical memory ranges to be shared between multiple locations in the
  same sparse resource or between multiple sparse resources, with each binding
  of a memory location observing a consistent interpretation of the memory
  contents.





  See Sparse Memory Aliasing for more
  information.





## Sparse Buffers and Fully-Resident Images

Both `VkBuffer` and `VkImage` objects created with the
`VK_IMAGE_CREATE_SPARSE_BINDING_BIT` or
`VK_BUFFER_CREATE_SPARSE_BINDING_BIT` bits :normative{type="can"} be thought of as a
linear region of address space.
In the `VkImage` case if `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` is
not used, this linear region is entirely opaque, meaning that there is no
application-visible mapping between texel location and memory offset.

Unless `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` or
`VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT` are also used, the entire
resource :normative{type="must"} be bound to one or more `VkDeviceMemory` objects before
use.



### Sparse Buffer and Fully-Resident Image Block Size

The sparse block size in bytes for sparse buffers and fully-resident images
is reported as `VkMemoryRequirements`::`alignment`.
`alignment` represents both the memory alignment requirement and the
binding granularity (in bytes) for sparse resources.







## Sparse Partially-Resident Buffers

`VkBuffer` objects created with the
`VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT` bit allow the buffer to be made
only partially resident.
Partially resident `VkBuffer` objects are allocated and bound
identically to `VkBuffer` objects using only the
`VK_BUFFER_CREATE_SPARSE_BINDING_BIT` feature.
The only difference is the ability for some regions of the buffer to be
unbound during device use.





## Sparse Partially-Resident Images

`VkImage` objects created with the
`VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` bit allow specific rectangular
regions of the image called sparse image blocks to be bound to specific
ranges of memory.
This allows the application to manage residency at either image subresource
or sparse image block granularity.
Each image subresource (outside of the mip tail)
starts on a sparse block boundary and has dimensions that are integer
multiples of the corresponding dimensions of the sparse image block.


::note
Applications :normative{type="can"} use these types of images to control LOD based on total
memory consumption.
If memory pressure becomes an issue the application :normative{type="can"} unbind and disable
specific mipmap levels of images without having to recreate resources or
modify texel data of unaffected levels.

The application :normative{type="can"} also use this functionality to access subregions of the
image in a > megatexture fashion.
The application :normative{type="can"} create a large image and only populate the region of
the image that is currently being used in the scene.
::




### Accessing Unbound Regions

The following member of `VkPhysicalDeviceSparseProperties` affects how
data in unbound regions of sparse resources are handled by the
implementation:

- `residencyNonResidentStrict`

If this property is not present, reads of unbound regions of the image will
return undefined: values.
Both reads and writes are still considered *safe* and will not affect other
resources or populated regions of the image.

If this property is present, all reads of unbound regions of the image will
behave as if the region was bound to memory populated with all zeros; writes
will be discarded.

Image operations performed on unbound memory :normative{type="may"} still alter
some component values in the natural way for those accesses, e.g.
substituting a value of one for alpha in formats that do not have an alpha
component.



See Physical Device
Enumeration for instructions for retrieving physical device properties.





### Mip Tail Regions

Sparse images created using `VK_IMAGE_CREATE_SPARSE_BINDING_BIT`
(without also using `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`) have no
specific mapping of image region or image subresource to memory offset
defined, so the entire image :normative{type="can"} be thought of as a linear opaque address
region.
However, images created with `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` do
have a prescribed sparse image block layout, and hence each image
subresource :normative{type="must"} start on a sparse block boundary.
Within each array layer, the set of mip levels that have a smaller size than
the sparse block size in bytes are grouped together into a *mip tail
region*.

If the `VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT` flag is present in
the `flags` member of `VkSparseImageFormatProperties`, for the
image’s `format`, then any mip level which has dimensions that are not
integer multiples of the corresponding dimensions of the sparse image block,
and all subsequent mip levels, are also included in the mip tail region.

The following member of `VkPhysicalDeviceSparseProperties` :normative{type="may"} affect
how the implementation places mip levels in the mip tail region:

- `residencyAlignedMipSize`

Each mip tail region is bound to memory as an opaque region (i.e. :normative{type="must"} be
bound using a [VkSparseImageOpaqueMemoryBindInfo](/man/VkSparseImageOpaqueMemoryBindInfo) structure) and :normative{type="may"} be
of a size greater than or equal to the sparse block size in bytes.
This size is guaranteed to be an integer multiple of the sparse block size
in bytes.

An implementation :normative{type="may"} choose to allow each array-layer’s mip tail region to
be bound to memory independently or require that all array-layer’s mip tail
regions be treated as one.
This is dictated by `VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT` in
`VkSparseImageMemoryRequirements`::`flags`.

The following diagrams depict how
`VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT` and
`VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT` alter memory usage and
requirements.



In the absence of `VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT` and
`VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT`, each array layer contains a
mip tail region containing texel data for all mip levels smaller than the
sparse image block in any dimension.

Mip levels that are as large or larger than a sparse image block in all
dimensions :normative{type="can"} be bound individually.
Right-edges and bottom-edges of each level are allowed to have partially
used sparse blocks.
Any bound partially-used-sparse-blocks :normative{type="must"} still have their full sparse
block size in bytes allocated in memory.



When `VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT` is present all array
layers will share a single mip tail region.




::note
The mip tail regions are presented here in 2D arrays simply for figure size
reasons.
Each mip tail is logically a single array of sparse blocks with an
implementation-dependent mapping of texels or compressed texel blocks to
sparse blocks.
::


When `VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT` is present the first
mip level that would contain partially used sparse blocks begins the mip
tail region.
This level and all subsequent levels are placed in the mip tail.
Only the first N mip levels whose dimensions are an exact multiple of
the sparse image block dimensions :normative{type="can"} be bound and unbound on a sparse
block basis.




::note
The mip tail region is presented here in a 2D array simply for figure size
reasons.
It is logically a single array of sparse blocks with an
implementation-dependent mapping of texels or compressed texel blocks to
sparse blocks.
::


When both `VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT` and
`VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT` are present the constraints
from each of these flags are in effect.





### Standard Sparse Image Block Shapes

Standard sparse image block shapes define a standard set of dimensions for
sparse image blocks that depend on the format of the image.
Layout of texels or compressed texel blocks within a sparse image block is
implementation-dependent.
All currently defined standard sparse image block shapes are 64 KB in size.

For block-compressed formats (e.g. `VK_FORMAT_BC5_UNORM_BLOCK`), the
texel size is the size of the compressed texel block (e.g. 128-bit for
`BC5`) thus the dimensions of the standard sparse image block shapes
apply in terms of compressed texel blocks.


::note
For block-compressed formats, the dimensions of a sparse image block in
terms of texels :normative{type="can"} be calculated by multiplying the sparse image block
dimensions by the compressed texel block dimensions.
::








Implementations that support the standard sparse image block shape for all
formats listed in the  and
&#x20;tables :normative{type="may"} advertise the following
`VkPhysicalDeviceSparseProperties`:

- `residencyStandard2DBlockShape`

- `residencyStandard2DMultisampleBlockShape`

- `residencyStandard3DBlockShape`

Reporting each of these features does *not* imply that all possible image
types are supported as sparse.
Instead, this indicates that no supported sparse image of the corresponding
type will use custom sparse image block dimensions for any formats that have
a corresponding standard sparse image block shape.





### Custom Sparse Image Block Shapes

An implementation that does not support a standard image block shape for a
particular sparse partially-resident image :normative{type="may"} choose to support a custom
sparse image block shape for it instead.
The dimensions of such a custom sparse image block shape are reported in
`VkSparseImageFormatProperties`::`imageGranularity`.
As with standard sparse image block shapes, the size in bytes of the custom
sparse image block shape will be reported in
`VkMemoryRequirements`::`alignment`.

Custom sparse image block dimensions are reported through
`vkGetPhysicalDeviceSparseImageFormatProperties` and
`vkGetImageSparseMemoryRequirements`.

An implementation :normative{type="must"} not support both the standard sparse image block
shape and a custom sparse image block shape for the same image.
The standard sparse image block shape :normative{type="must"} be used if it is supported.





### Multiple Aspects

Partially resident images are allowed to report separate sparse properties
for different aspects of the image.
One example is for depth/stencil images where the implementation separates
the depth and stencil data into separate planes.
Another reason for multiple aspects is to allow the application to manage
memory allocation for implementation-private *metadata* associated with the
image.
See the figure below:




::note
The mip tail regions are presented here in 2D arrays simply for figure size
reasons.
Each mip tail is logically a single array of sparse blocks with an
implementation-dependent mapping of texels or compressed texel blocks to
sparse blocks.
::


In the figure above the depth, stencil, and metadata aspects all have unique
sparse properties.
The per-texel stencil data is ¼ the size of the depth data,
hence the stencil sparse blocks include 4 × the number of
texels.
The sparse block size in bytes for all of the aspects is identical and
defined by `VkMemoryRequirements`::`alignment`.



#### Metadata

The metadata aspect of an image has the following constraints:

- All metadata is reported in the mip tail region of the metadata aspect.

- All metadata :normative{type="must"} be bound prior to device use of the sparse image.









## Sparse Memory Aliasing

By default sparse resources have the same aliasing rules as non-sparse
resources.
See Memory Aliasing for more information.

`VkDevice` objects that have the `sparseResidencyAliased` feature enabled are able to use the
`VK_BUFFER_CREATE_SPARSE_ALIASED_BIT` and
`VK_IMAGE_CREATE_SPARSE_ALIASED_BIT` flags for resource creation.
These flags allow resources to access physical memory bound into multiple
locations within one or more sparse resources in a *data consistent*
fashion.
This means that reading physical memory from multiple aliased locations will
return the same value.

Care :normative{type="must"} be taken when performing a write operation to aliased physical
memory.
Memory dependencies :normative{type="must"} be used to separate writes to one alias from reads
or writes to another alias.
Writes to aliased memory that are not properly guarded against accesses to
different aliases will have undefined: results for all accesses to the
aliased memory.

Applications that wish to make use of data consistent sparse memory aliasing
:normative{type="must"} abide by the following guidelines:

- All sparse resources that are bound to aliased physical memory :normative{type="must"} be
  created with the `VK_BUFFER_CREATE_SPARSE_ALIASED_BIT` /
  `VK_IMAGE_CREATE_SPARSE_ALIASED_BIT` flag.

- All resources that access aliased physical memory :normative{type="must"} interpret the
  memory in the same way.
  This implies the following:





  * Buffers and images :normative{type="cannot"} alias the same physical memory in a data
    consistent fashion.
    The physical memory ranges :normative{type="must"} be used exclusively by buffers or used
    exclusively by images for data consistency to be guaranteed.

  * Memory in sparse image mip tail regions :normative{type="cannot"} access aliased memory
    in a data consistent fashion.

  * Sparse images that alias the same physical memory :normative{type="must"} have compatible
    formats and be using the same sparse image block shape in order to
    access aliased memory in a data consistent fashion.

Failure to follow any of the above guidelines will require the application
to abide by the normal, non-sparse resource aliasing rules.
In this case memory :normative{type="cannot"} be accessed in a data consistent fashion.


::note
Enabling sparse resource memory aliasing :normative{type="can"} be a way to lower physical
memory use, but it :normative{type="may"} reduce performance on some implementations.
An application developer :normative{type="can"} test on their target HW and balance the memory
/ performance trade-offs measured.
::






## Sparse Resource API

The APIs related to sparse resources are grouped into the following
categories:

- Physical Device Features

- Physical Device Sparse Properties

- Sparse Image Format Properties

- Sparse Resource Creation

- Sparse Resource Memory Requirements

- Binding Resource Memory



### Physical Device Features

Some sparse-resource related features are reported and enabled in
`VkPhysicalDeviceFeatures`.
These features :normative{type="must"} be supported and enabled on the `VkDevice` object
before applications :normative{type="can"} use them.
See Physical Device Features for information on how to get and
set enabled device features, and for more detailed explanations of these
features.



#### Sparse Physical Device Features

- `sparseBinding`: Support for creating [VkBuffer](/man/VkBuffer) and
  `VkImage` objects with the `VK_BUFFER_CREATE_SPARSE_BINDING_BIT`
  and `VK_IMAGE_CREATE_SPARSE_BINDING_BIT` flags, respectively.

- `sparseResidencyBuffer`: Support for creating [VkBuffer](/man/VkBuffer) objects
  with the `VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT` flag.

- `sparseResidencyImage2D`: Support for creating 2D single-sampled
  `VkImage` objects with `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`.

- `sparseResidencyImage3D`: Support for creating 3D [VkImage](/man/VkImage)
  objects with `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`.

- `sparseResidency2Samples`: Support for creating 2D [VkImage](/man/VkImage)
  objects with 2 samples and `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`.

- `sparseResidency4Samples`: Support for creating 2D [VkImage](/man/VkImage)
  objects with 4 samples and `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`.

- `sparseResidency8Samples`: Support for creating 2D [VkImage](/man/VkImage)
  objects with 8 samples and `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`.

- `sparseResidency16Samples`: Support for creating 2D [VkImage](/man/VkImage)
  objects with 16 samples and `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`.

- `sparseResidencyAliased`: Support for creating [VkBuffer](/man/VkBuffer) and
  `VkImage` objects with the `VK_BUFFER_CREATE_SPARSE_ALIASED_BIT`
  and `VK_IMAGE_CREATE_SPARSE_ALIASED_BIT` flags, respectively.







### Physical Device Sparse Properties

Some features of the implementation are not possible to disable, and are
reported to allow applications to alter their sparse resource usage
accordingly.
These read-only capabilities are reported in the
[VkPhysicalDeviceProperties](/man/VkPhysicalDeviceProperties)::`sparseProperties` member, which is a
`VkPhysicalDeviceSparseProperties` structure.

The `VkPhysicalDeviceSparseProperties` structure is defined as:

[{generated}/api/structs/VkPhysicalDeviceSparseProperties.adoc]({generated}/api/structs/VkPhysicalDeviceSparseProperties.adoc)

- `residencyStandard2DBlockShape`
  is `VK_TRUE` if the physical device will access all single-sample 2D
  sparse resources using the standard sparse image block shapes (based on
  image format), as described in the
  Standard Sparse Image Block
  Shapes (Single Sample) table.
  If this property is not supported the value returned in the
  `imageGranularity` member of the `VkSparseImageFormatProperties`
  structure for single-sample 2D images is not :normative{type="required"} to match the
  standard sparse image block dimensions listed in the table.

- `residencyStandard2DMultisampleBlockShape`
  is `VK_TRUE` if the physical device will access all multisample 2D
  sparse resources using the standard sparse image block shapes (based on
  image format), as described in the
  Standard Sparse Image Block Shapes
  (MSAA) table.
  If this property is not supported, the value returned in the
  `imageGranularity` member of the `VkSparseImageFormatProperties`
  structure for multisample 2D images is not :normative{type="required"} to match the
  standard sparse image block dimensions listed in the table.

- `residencyStandard3DBlockShape`
  is `VK_TRUE` if the physical device will access all 3D sparse
  resources using the standard sparse image block shapes (based on image
  format), as described in the
  Standard Sparse Image Block
  Shapes (Single Sample) table.
  If this property is not supported, the value returned in the
  `imageGranularity` member of the `VkSparseImageFormatProperties`
  structure for 3D images is not :normative{type="required"} to match the standard sparse
  image block dimensions listed in the table.

- `residencyAlignedMipSize`
  is `VK_TRUE` if images with mip level dimensions that are not
  integer multiples of the corresponding dimensions of the sparse image
  block :normative{type="may"} be placed in the mip tail.
  If this property is not reported, only mip levels with dimensions
  smaller than the `imageGranularity` member of the
  `VkSparseImageFormatProperties` structure will be placed in the mip
  tail.
  If this property is reported the implementation is allowed to return
  `VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT` in the `flags`
  member of `VkSparseImageFormatProperties`, indicating that mip level
  dimensions that are not integer multiples of the corresponding
  dimensions of the sparse image block will be placed in the mip tail.

- `residencyNonResidentStrict`
  specifies whether the physical device :normative{type="can"} consistently access
  non-resident regions of a resource.
  If this property is `VK_TRUE`, access to non-resident regions of
  resources will be guaranteed to return values as if the resource was
  populated with 0; writes to non-resident regions will be discarded.





### Sparse Image Format Properties

Given that certain aspects of sparse image support, including the sparse
image block dimensions, :normative{type="may"} be implementation-dependent,
[vkGetPhysicalDeviceSparseImageFormatProperties](/man/vkGetPhysicalDeviceSparseImageFormatProperties) :normative{type="can"} be used to query
for sparse image format properties prior to resource creation.
This command is used to check whether a given set of sparse image parameters
is supported and what the sparse image block shape will be.



#### Sparse Image Format Properties API

The `VkSparseImageFormatProperties` structure is defined as:

[{generated}/api/structs/VkSparseImageFormatProperties.adoc]({generated}/api/structs/VkSparseImageFormatProperties.adoc)

- `aspectMask` is a bitmask [VkImageAspectFlagBits](/man/VkImageAspectFlagBits) specifying
  which aspects of the image the properties apply to.

- `imageGranularity` is the width, height, and depth of the sparse
  image block in texels or compressed texel blocks.

- `flags` is a bitmask of [VkSparseImageFormatFlagBits](/man/VkSparseImageFormatFlagBits) specifying
  additional information about the sparse resource.

Bits which :normative{type="may"} be set in [VkSparseImageFormatProperties](/man/VkSparseImageFormatProperties)::`flags`,
specifying additional information about the sparse resource, are:

[{generated}/api/enums/VkSparseImageFormatFlagBits.adoc]({generated}/api/enums/VkSparseImageFormatFlagBits.adoc)

- `VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT` specifies that the image
  uses a single mip tail region for all array layers.

- `VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT` specifies that the
  first mip level whose dimensions are not integer multiples of the
  corresponding dimensions of the sparse image block begins the mip tail
  region.

- `VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT` specifies that
  the image uses non-standard sparse image block dimensions, and the
  `imageGranularity` values do not match the standard sparse image
  block dimensions for the given format.

[{generated}/api/flags/VkSparseImageFormatFlags.adoc]({generated}/api/flags/VkSparseImageFormatFlags.adoc)

`VkSparseImageFormatFlags` is a bitmask type for setting a mask of zero
or more [VkSparseImageFormatFlagBits](/man/VkSparseImageFormatFlagBits).

`vkGetPhysicalDeviceSparseImageFormatProperties` returns an array of
[VkSparseImageFormatProperties](/man/VkSparseImageFormatProperties).
Each element will describe properties for one set of image aspects that are
bound simultaneously in the image.
This is usually one element for each aspect in the image, but for
interleaved depth/stencil images there is only one element describing the
combined aspects.

[{generated}/api/protos/vkGetPhysicalDeviceSparseImageFormatProperties.adoc]({generated}/api/protos/vkGetPhysicalDeviceSparseImageFormatProperties.adoc)

- `physicalDevice` is the physical device from which to query the
  sparse image format properties.

- `format` is the image format.

- `type` is the dimensionality of image.

- `samples` is a [VkSampleCountFlagBits](/man/VkSampleCountFlagBits) value specifying the
  number of samples per texel.

- `usage` is a bitmask describing the intended usage of the image.

- `tiling` is the tiling arrangement of the texel blocks in memory.

- `pPropertyCount` is a pointer to an integer related to the number of
  sparse format properties available or queried, as described below.

- `pProperties` is either `NULL` or a pointer to an array of
  [VkSparseImageFormatProperties](/man/VkSparseImageFormatProperties) structures.

If `pProperties` is `NULL`, then the number of sparse format properties
available is returned in `pPropertyCount`.
Otherwise, `pPropertyCount` :normative{type="must"} point to a variable set by the user to
the number of elements in the `pProperties` array, and on return the
variable is overwritten with the number of structures actually written to
`pProperties`.
If `pPropertyCount` is less than the number of sparse format properties
available, at most `pPropertyCount` structures will be written.

If `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` is not supported for the given
arguments, `pPropertyCount` will be set to zero upon return, and no data
will be written to `pProperties`.

Multiple aspects are returned for depth/stencil images that are implemented
as separate planes by the implementation.
The depth and stencil data planes each have unique
`VkSparseImageFormatProperties` data.

Depth/stencil images with depth and stencil data interleaved into a single
plane will return a single `VkSparseImageFormatProperties` structure
with the `aspectMask` set to `VK_IMAGE_ASPECT_DEPTH_BIT` |
`VK_IMAGE_ASPECT_STENCIL_BIT`.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkGetPhysicalDeviceSparseImageFormatProperties-samples-01094"}
`samples` :normative{type="must"} be a bit value that is set in
`VkImageFormatProperties`::`sampleCounts` returned by
`vkGetPhysicalDeviceImageFormatProperties` with `format`,
`type`, `tiling`, and `usage` equal to those in this command
and `flags` equal to the value that is set in
[VkImageCreateInfo](/man/VkImageCreateInfo)::`flags` when the image is created
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkGetPhysicalDeviceSparseImageFormatProperties-physicalDevice-parameter"}
 `physicalDevice` :normative{type="must"} be a valid [VkPhysicalDevice](/man/VkPhysicalDevice) handle
::

::validity-field{name="VUID-vkGetPhysicalDeviceSparseImageFormatProperties-format-parameter"}
 `format` :normative{type="must"} be a valid [VkFormat](/man/VkFormat) value
::

::validity-field{name="VUID-vkGetPhysicalDeviceSparseImageFormatProperties-type-parameter"}
 `type` :normative{type="must"} be a valid [VkImageType](/man/VkImageType) value
::

::validity-field{name="VUID-vkGetPhysicalDeviceSparseImageFormatProperties-samples-parameter"}
 `samples` :normative{type="must"} be a valid [VkSampleCountFlagBits](/man/VkSampleCountFlagBits) value
::

::validity-field{name="VUID-vkGetPhysicalDeviceSparseImageFormatProperties-usage-parameter"}
 `usage` :normative{type="must"} be a valid combination of [VkImageUsageFlagBits](/man/VkImageUsageFlagBits) values
::

::validity-field{name="VUID-vkGetPhysicalDeviceSparseImageFormatProperties-usage-requiredbitmask"}
 `usage` :normative{type="must"} not be `0`
::

::validity-field{name="VUID-vkGetPhysicalDeviceSparseImageFormatProperties-tiling-parameter"}
 `tiling` :normative{type="must"} be a valid [VkImageTiling](/man/VkImageTiling) value
::

::validity-field{name="VUID-vkGetPhysicalDeviceSparseImageFormatProperties-pPropertyCount-parameter"}
 `pPropertyCount` :normative{type="must"} be a valid pointer to a `uint32_t` value
::

::validity-field{name="VUID-vkGetPhysicalDeviceSparseImageFormatProperties-pProperties-parameter"}
 If the value referenced by `pPropertyCount` is not `0`, and `pProperties` is not `NULL`, `pProperties` :normative{type="must"} be a valid pointer to an array of `pPropertyCount` [VkSparseImageFormatProperties](/man/VkSparseImageFormatProperties) structures
::

::








### Sparse Resource Creation

Sparse resources require that one or more sparse feature flags be specified
(as part of the `VkPhysicalDeviceFeatures` structure described
previously in the Physical Device Features
section) when calling [vkCreateDevice](/man/vkCreateDevice).
When the appropriate device features are enabled, the
`VK_BUFFER_CREATE_SPARSE_*` and `VK_IMAGE_CREATE_SPARSE_*` flags
:normative{type="can"} be used.
See [vkCreateBuffer](/man/vkCreateBuffer) and [vkCreateImage](/man/vkCreateImage) for details of the resource
creation APIs.


::note
Specifying `VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT` or
`VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` requires specifying
`VK_BUFFER_CREATE_SPARSE_BINDING_BIT` or
`VK_IMAGE_CREATE_SPARSE_BINDING_BIT`, respectively, as well.
This means that resources :normative{type="must"} be created with the appropriate
`*_SPARSE_BINDING_BIT` to be used with the sparse binding command
(`vkQueueBindSparse`).
::






### Sparse Resource Memory Requirements

Sparse resources have specific memory requirements related to binding sparse
memory.
These memory requirements are reported differently for `VkBuffer`
objects and `VkImage` objects.



#### Buffer and Fully-Resident Images

Buffers (both fully and partially resident) and fully-resident images :normative{type="can"}
be bound to memory using only the data from `VkMemoryRequirements`.
For all sparse resources the `VkMemoryRequirements`::`alignment`
member specifies both the bindable sparse block size in bytes and :normative{type="required"}
alignment of `VkDeviceMemory`.





#### Partially Resident Images

Partially resident images have a different method for binding memory.
As with buffers and fully resident images, the
`VkMemoryRequirements`::`alignment` field specifies the bindable
sparse block size in bytes for the image.

Requesting sparse memory requirements for `VkImage` objects using
`vkGetImageSparseMemoryRequirements` will return an array of one or more
`VkSparseImageMemoryRequirements` structures.
Each structure describes the sparse memory requirements for a group of
aspects of the image.

The sparse image :normative{type="must"} have been created using the
`VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` flag to retrieve valid sparse
image memory requirements.





#### Sparse Image Memory Requirements

The `VkSparseImageMemoryRequirements` structure is defined as:

[{generated}/api/structs/VkSparseImageMemoryRequirements.adoc]({generated}/api/structs/VkSparseImageMemoryRequirements.adoc)

- `formatProperties` is a [VkSparseImageFormatProperties](/man/VkSparseImageFormatProperties)
  structure specifying properties of the image format.

- `imageMipTailFirstLod` is the first mip level at which image
  subresources are included in the mip tail region.

- `imageMipTailSize` is the memory size (in bytes) of the mip tail
  region.
  If `formatProperties.flags` contains
  `VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT`, this is the size of the
  whole mip tail, otherwise this is the size of the mip tail of a single
  array layer.
  This value is guaranteed to be a multiple of the sparse block size in
  bytes.

- `imageMipTailOffset` is the opaque memory offset used with
  [VkSparseImageOpaqueMemoryBindInfo](/man/VkSparseImageOpaqueMemoryBindInfo) to bind the mip tail region(s).

- `imageMipTailStride` is the offset stride between each array-layer’s
  mip tail, if `formatProperties.flags` does not contain
  `VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT` (otherwise the value is
  undefined:).

To query sparse memory requirements for an image, call:

[{generated}/api/protos/vkGetImageSparseMemoryRequirements.adoc]({generated}/api/protos/vkGetImageSparseMemoryRequirements.adoc)

- `device` is the logical device that owns the image.

- `image` is the [VkImage](/man/VkImage) object to get the memory requirements
  for.

- `pSparseMemoryRequirementCount` is a pointer to an integer related
  to the number of sparse memory requirements available or queried, as
  described below.

- `pSparseMemoryRequirements` is either `NULL` or a pointer to an
  array of `VkSparseImageMemoryRequirements` structures.

If `pSparseMemoryRequirements` is `NULL`, then the number of sparse
memory requirements available is returned in
`pSparseMemoryRequirementCount`.
Otherwise, `pSparseMemoryRequirementCount` :normative{type="must"} point to a variable set
by the user to the number of elements in the `pSparseMemoryRequirements`
array, and on return the variable is overwritten with the number of
structures actually written to `pSparseMemoryRequirements`.
If `pSparseMemoryRequirementCount` is less than the number of sparse
memory requirements available, at most `pSparseMemoryRequirementCount`
structures will be written.

If the image was not created with `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT`
then `pSparseMemoryRequirementCount` will be set to zero and
`pSparseMemoryRequirements` will not be written to.


::note
It is legal for an implementation to report a larger value in
`VkMemoryRequirements`::`size` than would be obtained by adding
together memory sizes for all `VkSparseImageMemoryRequirements` returned
by `vkGetImageSparseMemoryRequirements`.
This :normative{type="may"} occur when the implementation requires unused padding in the
address range describing the resource.
::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkGetImageSparseMemoryRequirements-device-parameter"}
 `device` :normative{type="must"} be a valid [VkDevice](/man/VkDevice) handle
::

::validity-field{name="VUID-vkGetImageSparseMemoryRequirements-image-parameter"}
 `image` :normative{type="must"} be a valid [VkImage](/man/VkImage) handle
::

::validity-field{name="VUID-vkGetImageSparseMemoryRequirements-pSparseMemoryRequirementCount-parameter"}
 `pSparseMemoryRequirementCount` :normative{type="must"} be a valid pointer to a `uint32_t` value
::

::validity-field{name="VUID-vkGetImageSparseMemoryRequirements-pSparseMemoryRequirements-parameter"}
 If the value referenced by `pSparseMemoryRequirementCount` is not `0`, and `pSparseMemoryRequirements` is not `NULL`, `pSparseMemoryRequirements` :normative{type="must"} be a valid pointer to an array of `pSparseMemoryRequirementCount` [VkSparseImageMemoryRequirements](/man/VkSparseImageMemoryRequirements) structures
::

::validity-field{name="VUID-vkGetImageSparseMemoryRequirements-image-parent"}
 `image` :normative{type="must"} have been created, allocated, or retrieved from `device`
::

::








### Binding Resource Memory

Non-sparse resources are backed by a single physical allocation prior to
device use (via `vkBindImageMemory` or `vkBindBufferMemory`), and
their backing :normative{type="must"} not be changed.
On the other hand, sparse resources :normative{type="can"} be bound to memory non-contiguously
and these bindings :normative{type="can"} be altered during the lifetime of the resource.


::note
It is important to note that freeing a `VkDeviceMemory` object with
`vkFreeMemory` will not cause resources (or resource regions) bound to
the memory object to become unbound.
Applications :normative{type="must"} not access resources bound to memory that has been freed.
::


Sparse memory bindings execute on a queue that includes the
`VK_QUEUE_SPARSE_BINDING_BIT` bit.
Applications :normative{type="must"} use synchronization primitives to
guarantee that other queues do not access ranges of memory concurrently with
a binding change.
Applications :normative{type="can"} access other ranges of the same resource while a bind
operation is executing.


::note
Implementations :normative{type="must"} provide a guarantee that simultaneously binding sparse
blocks while another queue accesses those same sparse blocks via a sparse
resource :normative{type="must"} not access memory owned by another process or otherwise
corrupt the system.
::


While some implementations :normative{type="may"} include `VK_QUEUE_SPARSE_BINDING_BIT`
support in queue families that also include graphics and compute support,
other implementations :normative{type="may"} only expose a
`VK_QUEUE_SPARSE_BINDING_BIT-only` queue family.
In either case, applications :normative{type="must"} use synchronization
primitives to explicitly request any ordering dependencies between sparse
memory binding operations and other graphics/compute/transfer operations, as
sparse binding operations are not automatically ordered against command
buffer execution, even within a single queue.

When binding memory explicitly for the `VK_IMAGE_ASPECT_METADATA_BIT`
the application :normative{type="must"} use the `VK_SPARSE_MEMORY_BIND_METADATA_BIT` in
the `VkSparseMemoryBind`::`flags` field when binding memory.
Binding memory for metadata is done the same way as binding memory for the
mip tail, with the addition of the `VK_SPARSE_MEMORY_BIND_METADATA_BIT`
flag.

Binding the mip tail for any aspect :normative{type="must"} only be performed using
[VkSparseImageOpaqueMemoryBindInfo](/man/VkSparseImageOpaqueMemoryBindInfo).
If `formatProperties.flags` contains
`VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT`, then it :normative{type="can"} be bound with
a single [VkSparseMemoryBind](/man/VkSparseMemoryBind) structure, with `resourceOffset` =
`imageMipTailOffset` and `size` = `imageMipTailSize`.

If `formatProperties.flags` does not contain
`VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT` then the offset for the mip
tail in each array layer is given as:



and the mip tail :normative{type="can"} be bound with `layerCount` [VkSparseMemoryBind](/man/VkSparseMemoryBind)
structures, each using `size` = `imageMipTailSize` and
`resourceOffset` = `arrayMipTailOffset` as defined above.

Sparse memory binding is handled by the following APIs and related data
structures.



#### Sparse Memory Binding Functions

The `VkSparseMemoryBind` structure is defined as:

[{generated}/api/structs/VkSparseMemoryBind.adoc]({generated}/api/structs/VkSparseMemoryBind.adoc)

- `resourceOffset` is the offset into the resource.

- `size` is the size of the memory region to be bound.

- `memory` is the [VkDeviceMemory](/man/VkDeviceMemory) object that the range of the
  resource is bound to.
  If `memory` is [VK\_NULL\_HANDLE](/man/VK_NULL_HANDLE), the range is unbound.

- `memoryOffset` is the offset into the [VkDeviceMemory](/man/VkDeviceMemory) object to
  bind the resource range to.
  If `memory` is [VK\_NULL\_HANDLE](/man/VK_NULL_HANDLE), this value is ignored.

- `flags` is a bitmask of [VkSparseMemoryBindFlagBits](/man/VkSparseMemoryBindFlagBits) specifying
  usage of the binding operation.

The *binding range* \[`resourceOffset`, `resourceOffset` +&#x20;
`size`) has different constraints based on `flags`.
If `flags` contains `VK_SPARSE_MEMORY_BIND_METADATA_BIT`, the
binding range :normative{type="must"} be within the mip tail region of the metadata aspect.
This metadata region is defined by:



and `imageMipTailOffset`, `imageMipTailSize`, and
`imageMipTailStride` values are from the
[VkSparseImageMemoryRequirements](/man/VkSparseImageMemoryRequirements) corresponding to the metadata aspect
of the image, and n is a valid array layer index for the image,

`imageMipTailStride` is considered to be zero for aspects where
`VkSparseImageMemoryRequirements`::`formatProperties.flags` contains
`VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT`.

If `flags` does not contain `VK_SPARSE_MEMORY_BIND_METADATA_BIT`,
the binding range :normative{type="must"} be within the range
\[0,[VkMemoryRequirements](/man/VkMemoryRequirements)::`size`).


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkSparseMemoryBind-memory-01096"}

If `memory` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `memory` and
`memoryOffset` :normative{type="must"} match the memory requirements of the resource,
as described in section 
::

::validity-field{name="VUID-VkSparseMemoryBind-memory-01097"}

If `memory` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `memory` :normative{type="must"} not have
been created with a memory type that reports
`VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT` bit set
::

::validity-field{name="VUID-VkSparseMemoryBind-size-01098"}
`size` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-VkSparseMemoryBind-resourceOffset-01099"}
`resourceOffset` :normative{type="must"} be less than the size of the resource
::

::validity-field{name="VUID-VkSparseMemoryBind-size-01100"}
`size` :normative{type="must"} be less than or equal to the size of the resource minus
`resourceOffset`
::

::validity-field{name="VUID-VkSparseMemoryBind-memoryOffset-01101"}
`memoryOffset` :normative{type="must"} be less than the size of `memory`
::

::validity-field{name="VUID-VkSparseMemoryBind-size-01102"}
`size` :normative{type="must"} be less than or equal to the size of `memory` minus
`memoryOffset`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkSparseMemoryBind-memory-parameter"}
 If `memory` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `memory` :normative{type="must"} be a valid [VkDeviceMemory](/man/VkDeviceMemory) handle
::

::validity-field{name="VUID-VkSparseMemoryBind-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkSparseMemoryBindFlagBits](/man/VkSparseMemoryBindFlagBits) values
::

::


Bits which :normative{type="can"} be set in [VkSparseMemoryBind](/man/VkSparseMemoryBind)::`flags`, specifying
usage of a sparse memory binding operation, are:

[{generated}/api/enums/VkSparseMemoryBindFlagBits.adoc]({generated}/api/enums/VkSparseMemoryBindFlagBits.adoc)

- `VK_SPARSE_MEMORY_BIND_METADATA_BIT` specifies that the memory being
  bound is only for the metadata aspect.

[{generated}/api/flags/VkSparseMemoryBindFlags.adoc]({generated}/api/flags/VkSparseMemoryBindFlags.adoc)

`VkSparseMemoryBindFlags` is a bitmask type for setting a mask of zero
or more [VkSparseMemoryBindFlagBits](/man/VkSparseMemoryBindFlagBits).

Memory is bound to `VkBuffer` objects created with the
`VK_BUFFER_CREATE_SPARSE_BINDING_BIT` flag using the following
structure:

[{generated}/api/structs/VkSparseBufferMemoryBindInfo.adoc]({generated}/api/structs/VkSparseBufferMemoryBindInfo.adoc)

- `buffer` is the [VkBuffer](/man/VkBuffer) object to be bound.

- `bindCount` is the number of [VkSparseMemoryBind](/man/VkSparseMemoryBind) structures in
  the `pBinds` array.

- `pBinds` is a pointer to an array of [VkSparseMemoryBind](/man/VkSparseMemoryBind)
  structures.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkSparseBufferMemoryBindInfo-buffer-parameter"}
 `buffer` :normative{type="must"} be a valid [VkBuffer](/man/VkBuffer) handle
::

::validity-field{name="VUID-VkSparseBufferMemoryBindInfo-pBinds-parameter"}
 `pBinds` :normative{type="must"} be a valid pointer to an array of `bindCount` valid [VkSparseMemoryBind](/man/VkSparseMemoryBind) structures
::

::validity-field{name="VUID-VkSparseBufferMemoryBindInfo-bindCount-arraylength"}
 `bindCount` :normative{type="must"} be greater than `0`
::

::


Memory is bound to opaque regions of `VkImage` objects created with the
`VK_IMAGE_CREATE_SPARSE_BINDING_BIT` flag using the following structure:

[{generated}/api/structs/VkSparseImageOpaqueMemoryBindInfo.adoc]({generated}/api/structs/VkSparseImageOpaqueMemoryBindInfo.adoc)

- `image` is the [VkImage](/man/VkImage) object to be bound.

- `bindCount` is the number of [VkSparseMemoryBind](/man/VkSparseMemoryBind) structures in
  the `pBinds` array.

- `pBinds` is a pointer to an array of [VkSparseMemoryBind](/man/VkSparseMemoryBind)
  structures.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkSparseImageOpaqueMemoryBindInfo-pBinds-01103"}

If the `flags` member of any element of `pBinds` contains
`VK_SPARSE_MEMORY_BIND_METADATA_BIT`, the binding range defined
:normative{type="must"} be within the mip tail region of the metadata aspect of
`image`
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkSparseImageOpaqueMemoryBindInfo-image-parameter"}
 `image` :normative{type="must"} be a valid [VkImage](/man/VkImage) handle
::

::validity-field{name="VUID-VkSparseImageOpaqueMemoryBindInfo-pBinds-parameter"}
 `pBinds` :normative{type="must"} be a valid pointer to an array of `bindCount` valid [VkSparseMemoryBind](/man/VkSparseMemoryBind) structures
::

::validity-field{name="VUID-VkSparseImageOpaqueMemoryBindInfo-bindCount-arraylength"}
 `bindCount` :normative{type="must"} be greater than `0`
::

::



::note
This operation is normally used to bind memory to fully-resident sparse
images or for mip tail regions of partially resident images.
However, it :normative{type="can"} also be used to bind memory for the entire binding range of
partially resident images.

In case `flags` does not contain
`VK_SPARSE_MEMORY_BIND_METADATA_BIT`, the `resourceOffset` is in the
range \[0, [VkMemoryRequirements](/man/VkMemoryRequirements)::`size`), This range includes
data from all aspects of the image, including metadata.
For most implementations this will probably mean that the
`resourceOffset` is a simple device address offset within the resource.
It is possible for an application to bind a range of memory that includes
both resource data and metadata.
However, the application would not know what part of the image the memory is
used for, or if any range is being used for metadata.

When `flags` contains `VK_SPARSE_MEMORY_BIND_METADATA_BIT`, the
binding range specified :normative{type="must"} be within the mip tail region of the metadata
aspect.
In this case the `resourceOffset` is not :normative{type="required"} to be a simple device
address offset within the resource.
However, it *is* defined to be within \[`imageMipTailOffset`,
`imageMipTailOffset` +  `imageMipTailSize`) for the metadata
aspect.
See [VkSparseMemoryBind](/man/VkSparseMemoryBind) for the full constraints on binding region with
this flag present.
::


Memory :normative{type="can"} be bound to sparse image blocks of `VkImage` objects created
with the `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` flag using the following
structure:

[{generated}/api/structs/VkSparseImageMemoryBindInfo.adoc]({generated}/api/structs/VkSparseImageMemoryBindInfo.adoc)

- `image` is the [VkImage](/man/VkImage) object to be bound

- `bindCount` is the number of [VkSparseImageMemoryBind](/man/VkSparseImageMemoryBind)
  structures in `pBinds` array

- `pBinds` is a pointer to an array of [VkSparseImageMemoryBind](/man/VkSparseImageMemoryBind)
  structures


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkSparseImageMemoryBindInfo-subresource-01722"}

The `subresource.mipLevel` member of each element of `pBinds`
:normative{type="must"} be less than the `mipLevels` specified in
[VkImageCreateInfo](/man/VkImageCreateInfo) when `image` was created
::

::validity-field{name="VUID-VkSparseImageMemoryBindInfo-subresource-01723"}

The `subresource.arrayLayer` member of each element of `pBinds`
:normative{type="must"} be less than the `arrayLayers` specified in
[VkImageCreateInfo](/man/VkImageCreateInfo) when `image` was created
::

::validity-field{name="VUID-VkSparseImageMemoryBindInfo-image-02901"}
`image` :normative{type="must"} have been created with
`VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` set
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkSparseImageMemoryBindInfo-image-parameter"}
 `image` :normative{type="must"} be a valid [VkImage](/man/VkImage) handle
::

::validity-field{name="VUID-VkSparseImageMemoryBindInfo-pBinds-parameter"}
 `pBinds` :normative{type="must"} be a valid pointer to an array of `bindCount` valid [VkSparseImageMemoryBind](/man/VkSparseImageMemoryBind) structures
::

::validity-field{name="VUID-VkSparseImageMemoryBindInfo-bindCount-arraylength"}
 `bindCount` :normative{type="must"} be greater than `0`
::

::


The `VkSparseImageMemoryBind` structure is defined as:

[{generated}/api/structs/VkSparseImageMemoryBind.adoc]({generated}/api/structs/VkSparseImageMemoryBind.adoc)

- `subresource` is the image *aspect* and region of interest in the
  image.

- `offset` are the coordinates of the first texel within the image
  subresource to bind.

- `extent` is the size in texels of the region within the image
  subresource to bind.
  The extent :normative{type="must"} be a multiple of the sparse image block dimensions,
  except when binding sparse image blocks along the edge of an image
  subresource it :normative{type="can"} instead be such that any coordinate of
  `offset` +  `extent` equals the corresponding
  dimensions of the image subresource.

- `memory` is the [VkDeviceMemory](/man/VkDeviceMemory) object that the sparse image
  blocks of the image are bound to.
  If `memory` is [VK\_NULL\_HANDLE](/man/VK_NULL_HANDLE), the sparse image blocks are
  unbound.

- `memoryOffset` is an offset into [VkDeviceMemory](/man/VkDeviceMemory) object.
  If `memory` is [VK\_NULL\_HANDLE](/man/VK_NULL_HANDLE), this value is ignored.

- `flags` are sparse memory binding flags.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-VkSparseImageMemoryBind-memory-01104"}

If the `sparseResidencyAliased`
feature is not enabled, and if any other resources are bound to ranges
of `memory`, the range of `memory` being bound :normative{type="must"} not overlap
with those bound ranges
::

::validity-field{name="VUID-VkSparseImageMemoryBind-memory-01105"}
`memory` and `memoryOffset` :normative{type="must"} match the memory requirements
of the calling command’s `image`, as described in section

::

::validity-field{name="VUID-VkSparseImageMemoryBind-subresource-01106"}
`subresource` :normative{type="must"} be a valid image subresource for `image`
(see )
::

::validity-field{name="VUID-VkSparseImageMemoryBind-offset-01107"}
`offset.x` :normative{type="must"} be a multiple of the sparse image block width
(`VkSparseImageFormatProperties`::`imageGranularity.width`) of
the image
::

::validity-field{name="VUID-VkSparseImageMemoryBind-extent-09388"}
`extent.width` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-VkSparseImageMemoryBind-extent-01108"}
`extent.width` :normative{type="must"} either be a multiple of the sparse image block
width of the image, or else (`extent.width` + 
`offset.x`) :normative{type="must"} equal the width of the image subresource
::

::validity-field{name="VUID-VkSparseImageMemoryBind-offset-01109"}
`offset.y` :normative{type="must"} be a multiple of the sparse image block height
(`VkSparseImageFormatProperties`::`imageGranularity.height`) of
the image
::

::validity-field{name="VUID-VkSparseImageMemoryBind-extent-09389"}
`extent.height` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-VkSparseImageMemoryBind-extent-01110"}
`extent.height` :normative{type="must"} either be a multiple of the sparse image block
height of the image, or else (`extent.height` + 
`offset.y`) :normative{type="must"} equal the height of the image subresource
::

::validity-field{name="VUID-VkSparseImageMemoryBind-offset-01111"}
`offset.z` :normative{type="must"} be a multiple of the sparse image block depth
(`VkSparseImageFormatProperties`::`imageGranularity.depth`) of
the image
::

::validity-field{name="VUID-VkSparseImageMemoryBind-extent-09390"}
`extent.depth` :normative{type="must"} be greater than `0`
::

::validity-field{name="VUID-VkSparseImageMemoryBind-extent-01112"}
`extent.depth` :normative{type="must"} either be a multiple of the sparse image block
depth of the image, or else (`extent.depth` + 
`offset.z`) :normative{type="must"} equal the depth of the image subresource
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkSparseImageMemoryBind-subresource-parameter"}
 `subresource` :normative{type="must"} be a valid [VkImageSubresource](/man/VkImageSubresource) structure
::

::validity-field{name="VUID-VkSparseImageMemoryBind-memory-parameter"}
 If `memory` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `memory` :normative{type="must"} be a valid [VkDeviceMemory](/man/VkDeviceMemory) handle
::

::validity-field{name="VUID-VkSparseImageMemoryBind-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkSparseMemoryBindFlagBits](/man/VkSparseMemoryBindFlagBits) values
::

::


To submit sparse binding operations to a queue, call:

[{generated}/api/protos/vkQueueBindSparse.adoc]({generated}/api/protos/vkQueueBindSparse.adoc)

- `queue` is the queue that the sparse binding operations will be
  submitted to.

- `bindInfoCount` is the number of elements in the `pBindInfo`
  array.

- `pBindInfo` is a pointer to an array of [VkBindSparseInfo](/man/VkBindSparseInfo)
  structures, each specifying a sparse binding submission batch.

- `fence` is an :normative{type="optional"} handle to a fence to be signaled.
  If `fence` is not [VK\_NULL\_HANDLE](/man/VK_NULL_HANDLE), it defines a
  fence signal operation.

`vkQueueBindSparse` is a queue submission
command, with each batch defined by an element of `pBindInfo` as a
[VkBindSparseInfo](/man/VkBindSparseInfo) structure.
Batches begin execution in the order they appear in `pBindInfo`, but
:normative{type="may"} complete out of order.

Within a batch, a given range of a resource :normative{type="must"} not be bound more than
once.
Across batches, if a range is to be bound to one allocation and offset and
then to another allocation and offset, then the application :normative{type="must"} guarantee
(usually using semaphores) that the binding operations are executed in the
correct order, as well as to order binding operations against the execution
of command buffer submissions.

As no operation to [vkQueueBindSparse](/man/vkQueueBindSparse) causes any pipeline stage to
access memory, synchronization primitives used in this command effectively
only define execution dependencies.

Additional information about fence and semaphore operation is described in
the synchronization chapter.


::validity-group{name="Valid Usage"}

::validity-field{name="VUID-vkQueueBindSparse-fence-01113"}

If `fence` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `fence` :normative{type="must"} be
unsignaled
::

::validity-field{name="VUID-vkQueueBindSparse-fence-01114"}

If `fence` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `fence` :normative{type="must"} not be
associated with any other queue command that has not yet completed
execution on that queue
::

::validity-field{name="VUID-vkQueueBindSparse-pSignalSemaphores-01115"}

Each element of the `pSignalSemaphores` member of each element of
`pBindInfo` :normative{type="must"} be unsignaled when the semaphore signal operation
it defines is executed on the device
::

::validity-field{name="VUID-vkQueueBindSparse-pWaitSemaphores-01116"}

When a semaphore wait operation referring to a binary semaphore defined
by any element of the `pWaitSemaphores` member of any element of
`pBindInfo` executes on `queue`, there :normative{type="must"} be no other queues
waiting on the same semaphore
::

::validity-field{name="VUID-vkQueueBindSparse-pWaitSemaphores-01117"}

All elements of the `pWaitSemaphores` member of all elements of the
`pBindInfo` parameter referring to a binary semaphore :normative{type="must"} be
semaphores that are signaled, or have
semaphore signal operations
previously submitted for execution
::

::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkQueueBindSparse-queue-parameter"}
 `queue` :normative{type="must"} be a valid [VkQueue](/man/VkQueue) handle
::

::validity-field{name="VUID-vkQueueBindSparse-pBindInfo-parameter"}
 If `bindInfoCount` is not `0`, `pBindInfo` :normative{type="must"} be a valid pointer to an array of `bindInfoCount` valid [VkBindSparseInfo](/man/VkBindSparseInfo) structures
::

::validity-field{name="VUID-vkQueueBindSparse-fence-parameter"}
 If `fence` is not [VK_NULL_HANDLE](/man/VK_NULL_HANDLE), `fence` :normative{type="must"} be a valid [VkFence](/man/VkFence) handle
::

::validity-field{name="VUID-vkQueueBindSparse-queuetype"}
 The `queue` :normative{type="must"} support sparse binding operations
::

::validity-field{name="VUID-vkQueueBindSparse-commonparent"}
 Both of `fence`, and `queue` that are valid handles of non-ignored parameters :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::








The `VkBindSparseInfo` structure is defined as:

[{generated}/api/structs/VkBindSparseInfo.adoc]({generated}/api/structs/VkBindSparseInfo.adoc)

- `sType` is a [VkStructureType](/man/VkStructureType) value identifying this structure.

- `pNext` is `NULL` or a pointer to a structure extending this
  structure.

- `waitSemaphoreCount` is the number of semaphores upon which to wait
  before executing the sparse binding operations for the batch.

- `pWaitSemaphores` is a pointer to an array of semaphores upon which
  to wait on before the sparse binding operations for this batch begin
  execution.
  If semaphores to wait on are provided, they define a
  semaphore wait operation.

- `bufferBindCount` is the number of sparse buffer bindings to perform
  in the batch.

- `pBufferBinds` is a pointer to an array of
  [VkSparseBufferMemoryBindInfo](/man/VkSparseBufferMemoryBindInfo) structures.

- `imageOpaqueBindCount` is the number of opaque sparse image bindings
  to perform.

- `pImageOpaqueBinds` is a pointer to an array of
  [VkSparseImageOpaqueMemoryBindInfo](/man/VkSparseImageOpaqueMemoryBindInfo) structures, indicating opaque
  sparse image bindings to perform.

- `imageBindCount` is the number of sparse image bindings to perform.

- `pImageBinds` is a pointer to an array of
  [VkSparseImageMemoryBindInfo](/man/VkSparseImageMemoryBindInfo) structures, indicating sparse image
  bindings to perform.

- `signalSemaphoreCount` is the number of semaphores to be signaled
  once the sparse binding operations specified by the structure have
  completed execution.

- `pSignalSemaphores` is a pointer to an array of semaphores which
  will be signaled when the sparse binding operations for this batch have
  completed execution.
  If semaphores to be signaled are provided, they define a
  semaphore signal operation.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-VkBindSparseInfo-sType-sType"}
 `sType` :normative{type="must"} be `VK_STRUCTURE_TYPE_BIND_SPARSE_INFO`
::

::validity-field{name="VUID-VkBindSparseInfo-pNext-pNext"}
 Each `pNext` member of any structure (including this one) in the `pNext` chain :normative{type="must"} be either `NULL` or a pointer to a valid instance of [VkDeviceGroupBindSparseInfo](/man/VkDeviceGroupBindSparseInfo), [VkFrameBoundaryEXT](/man/VkFrameBoundaryEXT), or [VkTimelineSemaphoreSubmitInfo](/man/VkTimelineSemaphoreSubmitInfo)
::

::validity-field{name="VUID-VkBindSparseInfo-sType-unique"}
 The `sType` value of each struct in the `pNext` chain :normative{type="must"} be unique
::

::validity-field{name="VUID-VkBindSparseInfo-pWaitSemaphores-parameter"}
 If `waitSemaphoreCount` is not `0`, `pWaitSemaphores` :normative{type="must"} be a valid pointer to an array of `waitSemaphoreCount` valid [VkSemaphore](/man/VkSemaphore) handles
::

::validity-field{name="VUID-VkBindSparseInfo-pBufferBinds-parameter"}
 If `bufferBindCount` is not `0`, `pBufferBinds` :normative{type="must"} be a valid pointer to an array of `bufferBindCount` valid [VkSparseBufferMemoryBindInfo](/man/VkSparseBufferMemoryBindInfo) structures
::

::validity-field{name="VUID-VkBindSparseInfo-pImageOpaqueBinds-parameter"}
 If `imageOpaqueBindCount` is not `0`, `pImageOpaqueBinds` :normative{type="must"} be a valid pointer to an array of `imageOpaqueBindCount` valid [VkSparseImageOpaqueMemoryBindInfo](/man/VkSparseImageOpaqueMemoryBindInfo) structures
::

::validity-field{name="VUID-VkBindSparseInfo-pImageBinds-parameter"}
 If `imageBindCount` is not `0`, `pImageBinds` :normative{type="must"} be a valid pointer to an array of `imageBindCount` valid [VkSparseImageMemoryBindInfo](/man/VkSparseImageMemoryBindInfo) structures
::

::validity-field{name="VUID-VkBindSparseInfo-pSignalSemaphores-parameter"}
 If `signalSemaphoreCount` is not `0`, `pSignalSemaphores` :normative{type="must"} be a valid pointer to an array of `signalSemaphoreCount` valid [VkSemaphore](/man/VkSemaphore) handles
::

::validity-field{name="VUID-VkBindSparseInfo-commonparent"}
 Both of the elements of `pSignalSemaphores`, and the elements of `pWaitSemaphores` that are valid handles of non-ignored parameters :normative{type="must"} have been created, allocated, or retrieved from the same [VkDevice](/man/VkDevice)
::

::












# Extending Vulkan

New functionality :normative{type="may"} be added to Vulkan via either new extensions or new
versions of the core, or new versions of an extension in some cases.

This chapter describes how Vulkan is versioned, how compatibility is
affected between different versions, and compatibility rules that are
followed by the Vulkan Working Group.



## Instance and Device Functionality

Commands that enumerate instance properties, or that accept a
[VkInstance](/man/VkInstance) object as a parameter, are considered instance-level
functionality.

Commands that dispatch from a [VkDevice](/man/VkDevice) object or a child object of a
[VkDevice](/man/VkDevice), or take any of them as a parameter, are considered
device-level functionality.
Types defined by a device extension
are also considered device-level functionality.

Commands that dispatch from [VkPhysicalDevice](/man/VkPhysicalDevice), or accept a
[VkPhysicalDevice](/man/VkPhysicalDevice) object as a parameter, are considered either
instance-level or device-level functionality depending if the functionality
is specified by an instance
extension or device extension
respectively.





## Core Versions

The Vulkan Specification is regularly updated with bug fixes and
clarifications.
Occasionally new functionality is added to the core and at some point it is
expected that there will be a desire to perform a large, breaking change to
the API.
In order to indicate to developers how and when these changes are made to
the specification, and to provide a way to identify each set of changes, the
Vulkan API maintains a version number.



### Version Numbers

The Vulkan version number comprises four parts indicating the variant,
major, minor and patch version of the Vulkan API Specification.

The *variant* indicates the variant of the Vulkan API supported by the
implementation.
This is always 0 for the Vulkan API.


::note
A non-zero variant indicates the API is a variant of the Vulkan API and
applications will typically need to be modified to run against it.
The variant field was a later addition to the version number, added in
version 1.2.175 of the
Specification.
As Vulkan uses variant 0, this change is fully backwards compatible with the
previous version number format for Vulkan implementations.
New version number macros have been added for this change and the old macros
deprecated.
For existing applications using the older format and macros, an
implementation with non-zero variant will decode as a very high Vulkan
version.
The high version number should be detectable by applications performing
suitable version checking.
::


The *major version* indicates a significant change in the API, which will
encompass a wholly new version of the specification.

The *minor version* indicates the incorporation of new functionality into
the core specification.

The *patch version* indicates bug fixes, clarifications, and language
improvements have been incorporated into the specification.

Compatibility guarantees made about versions of the API sharing any of the
same version numbers are documented in


The version number is used in several places in the API.
In each such use, the version numbers are packed into a 32-bit integer as
follows:

- The variant is a 3-bit integer packed into bits 31-29.

- The major version is a 7-bit integer packed into bits 28-22.

- The minor version number is a 10-bit integer packed into bits 21-12.

- The patch version number is a 12-bit integer packed into bits 11-0.

`VK_API_VERSION_VARIANT` extracts the API variant number from a packed
version number:

[{generated}/api/defines/VK\_API\_VERSION\_VARIANT.adoc]({generated}/api/defines/VK_API_VERSION_VARIANT.adoc)

`VK_API_VERSION_MAJOR` extracts the API major version number from a
packed version number:

[{generated}/api/defines/VK\_API\_VERSION\_MAJOR.adoc]({generated}/api/defines/VK_API_VERSION_MAJOR.adoc)

`VK_VERSION_MAJOR` extracts the API major version number from a packed
version number:

[{generated}/api/defines/VK\_VERSION\_MAJOR.adoc]({generated}/api/defines/VK_VERSION_MAJOR.adoc)

`VK_API_VERSION_MINOR` extracts the API minor version number from a
packed version number:

[{generated}/api/defines/VK\_API\_VERSION\_MINOR.adoc]({generated}/api/defines/VK_API_VERSION_MINOR.adoc)

`VK_VERSION_MINOR` extracts the API minor version number from a packed
version number:

[{generated}/api/defines/VK\_VERSION\_MINOR.adoc]({generated}/api/defines/VK_VERSION_MINOR.adoc)

`VK_API_VERSION_PATCH` extracts the API patch version number from a
packed version number:

[{generated}/api/defines/VK\_API\_VERSION\_PATCH.adoc]({generated}/api/defines/VK_API_VERSION_PATCH.adoc)

`VK_VERSION_PATCH` extracts the API patch version number from a packed
version number:

[{generated}/api/defines/VK\_VERSION\_PATCH.adoc]({generated}/api/defines/VK_VERSION_PATCH.adoc)

`VK_MAKE_API_VERSION` constructs an API version number.

[{generated}/api/defines/VK\_MAKE\_API\_VERSION.adoc]({generated}/api/defines/VK_MAKE_API_VERSION.adoc)

- `variant` is the variant number.

- `major` is the major version number.

- `minor` is the minor version number.

- `patch` is the patch version number.

`VK_MAKE_VERSION` constructs an API version number.

[{generated}/api/defines/VK\_MAKE\_VERSION.adoc]({generated}/api/defines/VK_MAKE_VERSION.adoc)

- `major` is the major version number.

- `minor` is the minor version number.

- `patch` is the patch version number.

`VK_API_VERSION_1_0` returns the API version number for Vulkan 1.0.0.

[{generated}/api/defines/VK\_API\_VERSION\_1\_0.adoc]({generated}/api/defines/VK_API_VERSION_1_0.adoc)





### Querying Version Support


::note
In Vulkan 1.0, there is no mechanism to detect the separate versions of
instance-level and
device-level functionality supported.
However, the `vkEnumerateInstanceVersion` command was added in Vulkan
1.1 to determine the supported version of instance-level functionality -
querying for this function via [vkGetInstanceProcAddr](/man/vkGetInstanceProcAddr) will return
`NULL` on implementations that only support Vulkan 1.0 functionality.
For more information on this, please refer to the Vulkan 1.1 specification.
::


The version of device-level functionality can be queried by calling
[vkGetPhysicalDeviceProperties](/man/vkGetPhysicalDeviceProperties)
and is returned in [VkPhysicalDeviceProperties](/man/VkPhysicalDeviceProperties)::`apiVersion`,
encoded as described in .







## Layers

When a layer is enabled, it inserts itself into the call chain for Vulkan
commands the layer is interested in.
Layers :normative{type="can"} be used for a variety of tasks that extend the base behavior of
Vulkan beyond what is required by the specification - such as call logging,
tracing, validation, or providing additional extensions.


::note
For example, an implementation is not expected to check that the value of
enums used by the application fall within allowed ranges.
Instead, a validation layer would do those checks and flag issues.
This avoids a performance penalty during production use of the application
because those layers would not be enabled in production.
::



::note
Vulkan layers :normative{type="may"} wrap object handles (i.e. return a different handle value
to the application than that generated by the implementation).
This is generally discouraged, as it increases the probability of
incompatibilities with new extensions.
The validation layers wrap handles in order to track the proper use and
destruction of each object.
See the > Architecture of the Vulkan Loader
> Interfaces document for additional information.
::


To query the available layers, call:

[{generated}/api/protos/vkEnumerateInstanceLayerProperties.adoc]({generated}/api/protos/vkEnumerateInstanceLayerProperties.adoc)

- `pPropertyCount` is a pointer to an integer related to the number of
  layer properties available or queried, as described below.

- `pProperties` is either `NULL` or a pointer to an array of
  [VkLayerProperties](/man/VkLayerProperties) structures.

If `pProperties` is `NULL`, then the number of layer properties
available is returned in `pPropertyCount`.
Otherwise, `pPropertyCount` :normative{type="must"} point to a variable set by the user to
the number of elements in the `pProperties` array, and on return the
variable is overwritten with the number of structures actually written to
`pProperties`.
If `pPropertyCount` is less than the number of layer properties
available, at most `pPropertyCount` structures will be written, and
`VK_INCOMPLETE` will be returned instead of `VK_SUCCESS`, to
indicate that not all the available properties were returned.

The list of available layers may change at any time due to actions outside
of the Vulkan implementation, so two calls to
`vkEnumerateInstanceLayerProperties` with the same parameters :normative{type="may"}
return different results, or retrieve different `pPropertyCount` values
or `pProperties` contents.
Once an instance has been created, the layers enabled for that instance will
continue to be enabled and valid for the lifetime of that instance, even if
some of them become unavailable for future instances.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkEnumerateInstanceLayerProperties-pPropertyCount-parameter"}
 `pPropertyCount` :normative{type="must"} be a valid pointer to a `uint32_t` value
::

::validity-field{name="VUID-vkEnumerateInstanceLayerProperties-pProperties-parameter"}
 If the value referenced by `pPropertyCount` is not `0`, and `pProperties` is not `NULL`, `pProperties` :normative{type="must"} be a valid pointer to an array of `pPropertyCount` [VkLayerProperties](/man/VkLayerProperties) structures
::

::




The `VkLayerProperties` structure is defined as:

[{generated}/api/structs/VkLayerProperties.adoc]({generated}/api/structs/VkLayerProperties.adoc)

- `layerName` is an array of `VK_MAX_EXTENSION_NAME_SIZE`

  `char` containing a null-terminated UTF-8 string which is the name of
  the layer.
  Use this name in the `ppEnabledLayerNames` array passed in the
  [VkInstanceCreateInfo](/man/VkInstanceCreateInfo) structure to enable this layer for an
  instance.

- `specVersion` is the Vulkan version the layer was written to,
  encoded as described in .

- `implementationVersion` is the version of this layer.
  It is an integer, increasing with backward compatible changes.

- `description` is an array of `VK_MAX_DESCRIPTION_SIZE` `char`
  containing a null-terminated UTF-8 string which provides additional
  details that :normative{type="can"} be used by the application to identify the layer.

`VK_MAX_EXTENSION_NAME_SIZE` is the length in `char` values of an
array containing a layer or extension name string, as returned in
[VkLayerProperties](/man/VkLayerProperties)::`layerName`,
[VkExtensionProperties](/man/VkExtensionProperties)::`extensionName`, and other queries.

[{generated}/api/enums/VK\_MAX\_EXTENSION\_NAME\_SIZE.adoc]({generated}/api/enums/VK_MAX_EXTENSION_NAME_SIZE.adoc)

`VK_MAX_DESCRIPTION_SIZE` is the length in `char` values of an array
containing a string with additional descriptive information about a query,
as returned in [VkLayerProperties](/man/VkLayerProperties)::`description` and other queries.

[{generated}/api/enums/VK\_MAX\_DESCRIPTION\_SIZE.adoc]({generated}/api/enums/VK_MAX_DESCRIPTION_SIZE.adoc)

To enable a layer, the name of the layer :normative{type="should"} be added to the
`ppEnabledLayerNames` member of [VkInstanceCreateInfo](/man/VkInstanceCreateInfo) when creating
a `VkInstance`.

Loader implementations :normative{type="may"} provide mechanisms outside the Vulkan API for
enabling specific layers.
Layers enabled through such a mechanism are *implicitly enabled*, while
layers enabled by including the layer name in the `ppEnabledLayerNames`
member of [VkInstanceCreateInfo](/man/VkInstanceCreateInfo) are *explicitly enabled*.
Implicitly enabled layers are loaded before explicitly enabled layers, such
that implicitly enabled layers are closer to the application, and explicitly
enabled layers are closer to the driver.
Except where otherwise specified, implicitly enabled and explicitly enabled
layers differ only in the way they are enabled, and the order in which they
are loaded.
Explicitly enabling a layer that is implicitly enabled results in this layer
being loaded as an implicitly enabled layer; it has no additional effect.



### Device Layer Deprecation

Previous versions of this specification distinguished between instance and
device layers.
Instance layers were only able to intercept commands that operate on
`VkInstance` and `VkPhysicalDevice`, except they were not able to
intercept [vkCreateDevice](/man/vkCreateDevice).
Device layers were enabled for individual devices when they were created,
and could only intercept commands operating on that device or its child
objects.

Device-only layers are now deprecated, and this specification no longer
distinguishes between instance and device layers.
Layers are enabled during instance creation, and are able to intercept all
commands operating on that instance or any of its child objects.
At the time of deprecation there were no known device-only layers and no
compelling reason to create one.

In order to maintain compatibility with implementations released prior to
device-layer deprecation, applications :normative{type="should"} still enumerate and enable
device layers.
The behavior of `vkEnumerateDeviceLayerProperties` and valid usage of
the `ppEnabledLayerNames` member of [VkDeviceCreateInfo](/man/VkDeviceCreateInfo) maximizes
compatibility with applications written to work with the previous
requirements.

To enumerate device layers, call:

[{generated}/api/protos/vkEnumerateDeviceLayerProperties.adoc]({generated}/api/protos/vkEnumerateDeviceLayerProperties.adoc)

- `physicalDevice` is the physical device that will be queried.

- `pPropertyCount` is a pointer to an integer related to the number of
  layer properties available or queried.

- `pProperties` is either `NULL` or a pointer to an array of
  [VkLayerProperties](/man/VkLayerProperties) structures.

If `pProperties` is `NULL`, then the number of layer properties
available is returned in `pPropertyCount`.
Otherwise, `pPropertyCount` :normative{type="must"} point to a variable set by the user to
the number of elements in the `pProperties` array, and on return the
variable is overwritten with the number of structures actually written to
`pProperties`.
If `pPropertyCount` is less than the number of layer properties
available, at most `pPropertyCount` structures will be written, and
`VK_INCOMPLETE` will be returned instead of `VK_SUCCESS`, to
indicate that not all the available properties were returned.

The list of layers enumerated by `vkEnumerateDeviceLayerProperties`
:normative{type="must"} be exactly the sequence of layers enabled for the instance.
The members of `VkLayerProperties` for each enumerated layer :normative{type="must"} be
the same as the properties when the layer was enumerated by
`vkEnumerateInstanceLayerProperties`.


::note
Due to platform details on Android, `vkEnumerateDeviceLayerProperties`
may be called with `physicalDevice` equal to `NULL` during layer
discovery.
This behaviour will only be observed by layer implementations, and not the
underlying Vulkan driver.
::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkEnumerateDeviceLayerProperties-physicalDevice-parameter"}
 `physicalDevice` :normative{type="must"} be a valid [VkPhysicalDevice](/man/VkPhysicalDevice) handle
::

::validity-field{name="VUID-vkEnumerateDeviceLayerProperties-pPropertyCount-parameter"}
 `pPropertyCount` :normative{type="must"} be a valid pointer to a `uint32_t` value
::

::validity-field{name="VUID-vkEnumerateDeviceLayerProperties-pProperties-parameter"}
 If the value referenced by `pPropertyCount` is not `0`, and `pProperties` is not `NULL`, `pProperties` :normative{type="must"} be a valid pointer to an array of `pPropertyCount` [VkLayerProperties](/man/VkLayerProperties) structures
::

::




The `ppEnabledLayerNames` and `enabledLayerCount` members of
[VkDeviceCreateInfo](/man/VkDeviceCreateInfo) are deprecated and their values :normative{type="must"} be ignored by
implementations.
However, for compatibility, only an empty list of layers or a list that
exactly matches the sequence enabled at instance creation time are valid,
and validation layers :normative{type="should"} issue diagnostics for other cases.

Regardless of the enabled layer list provided in [VkDeviceCreateInfo](/man/VkDeviceCreateInfo),
the
sequence of layers active for a device will be exactly the sequence of
layers enabled when the parent instance was created.







## Extensions

Extensions :normative{type="may"} define new Vulkan commands, structures, and enumerants.
For compilation purposes, the interfaces defined by registered extensions,
including new structures and enumerants as well as function pointer types
for new commands, are defined in the Khronos-supplied `vulkan_core.h`
together with the core API.
However, commands defined by extensions :normative{type="may"} not be available for static
linking - in which case function pointers to these commands :normative{type="should"} be
queried at runtime as described in .
Extensions :normative{type="may"} be provided by layers as well as by a Vulkan implementation.

Because extensions :normative{type="may"} extend or change the behavior of the Vulkan API,
extension authors :normative{type="should"} add support for their extensions to the Khronos
validation layers.
This is especially important for new commands whose parameters have been
wrapped by the validation layers.
See the > Architecture of the Vulkan Loader
> Interfaces document for additional information.


::note
To enable an instance extension, the name of the extension :normative{type="can"} be added to
the `ppEnabledExtensionNames` member of [VkInstanceCreateInfo](/man/VkInstanceCreateInfo) when
creating a `VkInstance`.

To enable a device extension, the name of the extension :normative{type="can"} be added to the
`ppEnabledExtensionNames` member of [VkDeviceCreateInfo](/man/VkDeviceCreateInfo) when
creating a `VkDevice`.

Enabling an extension (with no further use of that extension) does not
change the behavior of functionality exposed by the core Vulkan API or any
other extension, other than making valid the use of the commands, enums and
structures defined by that extension.

Valid Usage sections for individual commands and structures do not currently
contain which extensions have to be enabled in order to make their use
valid, although they might do so in the future.
It is defined only in the  section.
::




### Instance Extensions

Instance extensions add new
instance-level
functionality to the API, outside of the core specification.

To query the available instance extensions, call:

[{generated}/api/protos/vkEnumerateInstanceExtensionProperties.adoc]({generated}/api/protos/vkEnumerateInstanceExtensionProperties.adoc)

- `pLayerName` is either `NULL` or a pointer to a null-terminated
  UTF-8 string naming the layer to retrieve extensions from.

- `pPropertyCount` is a pointer to an integer related to the number of
  extension properties available or queried, as described below.

- `pProperties` is either `NULL` or a pointer to an array of
  [VkExtensionProperties](/man/VkExtensionProperties) structures.

When `pLayerName` parameter is `NULL`, only extensions provided by the
Vulkan implementation or by implicitly enabled layers are returned.
When `pLayerName` is the name of a layer, the instance extensions
provided by that layer are returned.

If `pProperties` is `NULL`, then the number of extensions properties
available is returned in `pPropertyCount`.
Otherwise, `pPropertyCount` :normative{type="must"} point to a variable set by the user to
the number of elements in the `pProperties` array, and on return the
variable is overwritten with the number of structures actually written to
`pProperties`.
If `pPropertyCount` is less than the number of extension properties
available, at most `pPropertyCount` structures will be written, and
`VK_INCOMPLETE` will be returned instead of `VK_SUCCESS`, to
indicate that not all the available properties were returned.

Because the list of available layers may change externally between calls to
[vkEnumerateInstanceExtensionProperties](/man/vkEnumerateInstanceExtensionProperties), two calls may retrieve
different results if a `pLayerName` is available in one call but not in
another.
The extensions supported by a layer may also change between two calls, e.g.
if the layer implementation is replaced by a different version between those
calls.

Implementations :normative{type="must"} not advertise any pair of extensions that cannot be
enabled together due to behavioral differences, or any extension that cannot
be enabled against the advertised version.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkEnumerateInstanceExtensionProperties-pLayerName-parameter"}
 If `pLayerName` is not `NULL`, `pLayerName` :normative{type="must"} be a null-terminated UTF-8 string
::

::validity-field{name="VUID-vkEnumerateInstanceExtensionProperties-pPropertyCount-parameter"}
 `pPropertyCount` :normative{type="must"} be a valid pointer to a `uint32_t` value
::

::validity-field{name="VUID-vkEnumerateInstanceExtensionProperties-pProperties-parameter"}
 If the value referenced by `pPropertyCount` is not `0`, and `pProperties` is not `NULL`, `pProperties` :normative{type="must"} be a valid pointer to an array of `pPropertyCount` [VkExtensionProperties](/man/VkExtensionProperties) structures
::

::








### Device Extensions

Device extensions add new
device-level
functionality to the API, outside of the core specification.

To query the extensions available to a given physical device, call:

[{generated}/api/protos/vkEnumerateDeviceExtensionProperties.adoc]({generated}/api/protos/vkEnumerateDeviceExtensionProperties.adoc)

- `physicalDevice` is the physical device that will be queried.

- `pLayerName` is either `NULL` or a pointer to a null-terminated
  UTF-8 string naming the layer to retrieve extensions from.

- `pPropertyCount` is a pointer to an integer related to the number of
  extension properties available or queried, and is treated in the same
  fashion as the
  [vkEnumerateInstanceExtensionProperties](/man/vkEnumerateInstanceExtensionProperties)::`pPropertyCount`
  parameter.

- `pProperties` is either `NULL` or a pointer to an array of
  [VkExtensionProperties](/man/VkExtensionProperties) structures.

When `pLayerName` parameter is `NULL`, only extensions provided by the
Vulkan implementation or by implicitly enabled layers are returned.
When `pLayerName` is the name of a layer, the device extensions provided
by that layer are returned.

Implementations :normative{type="must"} not advertise any pair of extensions that cannot be
enabled together due to behavioral differences, or any extension that cannot
be enabled against the advertised version.


::note
Due to platform details on Android,
`vkEnumerateDeviceExtensionProperties` may be called with
`physicalDevice` equal to `NULL` during layer discovery.
This behaviour will only be observed by layer implementations, and not the
underlying Vulkan driver.
::



::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkEnumerateDeviceExtensionProperties-physicalDevice-parameter"}
 `physicalDevice` :normative{type="must"} be a valid [VkPhysicalDevice](/man/VkPhysicalDevice) handle
::

::validity-field{name="VUID-vkEnumerateDeviceExtensionProperties-pLayerName-parameter"}
 If `pLayerName` is not `NULL`, `pLayerName` :normative{type="must"} be a null-terminated UTF-8 string
::

::validity-field{name="VUID-vkEnumerateDeviceExtensionProperties-pPropertyCount-parameter"}
 `pPropertyCount` :normative{type="must"} be a valid pointer to a `uint32_t` value
::

::validity-field{name="VUID-vkEnumerateDeviceExtensionProperties-pProperties-parameter"}
 If the value referenced by `pPropertyCount` is not `0`, and `pProperties` is not `NULL`, `pProperties` :normative{type="must"} be a valid pointer to an array of `pPropertyCount` [VkExtensionProperties](/man/VkExtensionProperties) structures
::

::




The `VkExtensionProperties` structure is defined as:

[{generated}/api/structs/VkExtensionProperties.adoc]({generated}/api/structs/VkExtensionProperties.adoc)

- `extensionName` is an array of `VK_MAX_EXTENSION_NAME_SIZE`

  `char` containing a null-terminated UTF-8 string which is the name of
  the extension.

- `specVersion` is the version of this extension.
  It is an integer, incremented with backward compatible changes.



#### Accessing Device-Level Functionality From a [VkPhysicalDevice](/man/VkPhysicalDevice)

Some device extensions also add support for physical-device-level
functionality.
Physical-device-level functionality :normative{type="can"} be used, if the required extension
is supported as advertised by [vkEnumerateDeviceExtensionProperties](/man/vkEnumerateDeviceExtensionProperties) for
a given [VkPhysicalDevice](/man/VkPhysicalDevice).





#### Accessing Device-Level Functionality From a [VkDevice](/man/VkDevice)

For commands that are dispatched from a [VkDevice](/man/VkDevice), or from a child
object of a [VkDevice](/man/VkDevice), device extensions :normative{type="must"} be enabled in
[vkCreateDevice](/man/vkCreateDevice).









## Extension Dependencies

Some extensions are dependent on other extensions, or on specific core API
versions, to function.
To enable extensions with dependencies, any *required extensions* :normative{type="must"} also
be enabled through the same API mechanisms when creating an instance with
[vkCreateInstance](/man/vkCreateInstance) or a device with [vkCreateDevice](/man/vkCreateDevice).
Each extension which has such dependencies documents them in the
appendix summarizing that extension.

If an extension is supported (as queried by
[vkEnumerateInstanceExtensionProperties](/man/vkEnumerateInstanceExtensionProperties) or
[vkEnumerateDeviceExtensionProperties](/man/vkEnumerateDeviceExtensionProperties)), then *required extensions* of
that extension :normative{type="must"} also be supported for the same instance or physical
device.

Any device extension that has an instance extension dependency that is not
enabled by [vkCreateInstance](/man/vkCreateInstance) is considered to be unsupported, hence it
:normative{type="must"} not be returned by [vkEnumerateDeviceExtensionProperties](/man/vkEnumerateDeviceExtensionProperties) for any
[VkPhysicalDevice](/man/VkPhysicalDevice) child of the instance.
Instance extensions do not have dependencies on device extensions.

If a required extension has been promoted to another extension or to a core API version, then as a
*general* rule, the dependency is also satisfied by the promoted extension
or core version.
This will be true so long as any features required by the original extension
are also required or enabled by the promoted extension or core version.
However, in some cases an extension is promoted while making some of its
features optional in the promoted extension or core version.
In this case, the dependency :normative{type="may"} not be satisfied.
The only way to be certain is to look at the descriptions of the original
dependency and the promoted version in the Layers &
Extensions and Core Revisions appendices.


::note
There is metadata in `vk.xml` describing some aspects of promotion,
especially `requires`, `promotedto` and `deprecatedby` attributes of
`<extension>` tags.
However, the metadata does not yet fully describe this scenario.
In the future, we may extend the XML schema to describe the full set of
extensions and versions satisfying a dependency.
::






## Compatibility Guarantees (Informative)

This section is marked as informal as there is no binding responsibility on
implementations of the Vulkan API - these guarantees are however a contract
between the Vulkan Working Group and developers using this Specification.



### Core Versions

Each of the major, minor, and patch
versions of the Vulkan specification provide different compatibility
guarantees.



#### Patch Versions

A difference in the patch version indicates that a set of bug fixes or
clarifications have been made to the Specification.
Informative enums returned by Vulkan commands that will not affect the
runtime behavior of a valid application may be added in a patch version
(e.g. [VkVendorId](/man/VkVendorId)).

The specification’s patch version is strictly increasing for a given major
version of the specification; any change to a specification as described
above will result in the patch version being increased by 1.
Patch versions are applied to all minor versions, even if a given minor
version is not affected by the provoking change.

Specifications with different patch versions but the same major and minor
version are *fully compatible* with each other - such that a valid
application written against one will work with an implementation of another.


::note
If a patch version includes a bug fix or clarification that could have a
significant impact on developer expectations, these will be highlighted in
the change log.
Generally the Vulkan Working Group tries to avoid these kinds of changes,
instead fixing them in either an extension or core version.
::






#### Minor Versions

Changes in the minor version of the specification indicate that new
functionality has been added to the core specification.
This will usually include new interfaces in the header, and :normative{type="may"} also
include behavior changes and bug fixes.
Core functionality :normative{type="may"} be deprecated in a minor version, but will not be
obsoleted or removed.

The specification’s minor version is strictly increasing for a given major
version of the specification; any change to a specification as described
above will result in the minor version being increased by 1.
Changes that can be accommodated in a patch version will not increase the
minor version.

Specifications with a lower minor version are *backwards compatible* with an
implementation of a specification with a higher minor version for core
functionality and extensions issued with the KHR vendor tag.
Vendor and multi-vendor extensions are not guaranteed to remain functional
across minor versions, though in general they are with few exceptions - see
&#x20;for more information.





#### Major Versions

A difference in the major version of specifications indicates a large set of
changes which will likely include interface changes, behavioral changes,
removal of deprecated
functionality, and the modification, addition, or replacement of other
functionality.

The specification’s major version is monotonically increasing; any change to
the specification as described above will result in the major version being
increased.
Changes that can be accommodated in a patch or minor version will not
increase the major version.

The Vulkan Working Group intends to only issue a new major version of the
Specification in order to realise significant improvements to the Vulkan API
that will necessarily require breaking compatibility.

A new major version will likely include a wholly new version of the
specification to be issued - which could include an overhaul of the
versioning semantics for the minor and patch versions.
The patch and minor versions of a specification are therefore not meaningful
across major versions.
If a major version of the specification includes similar versioning
semantics, it is expected that the patch and the minor version will be reset
to 0 for that major version.







### Extensions

A KHR extension :normative{type="must"} be able to be enabled alongside any other KHR
extension, and for any minor or patch version of the core Specification
beyond the minimum version it requires.
A multi-vendor extension :normative{type="should"} be able to be enabled alongside any KHR
extension or other multi-vendor extension, and for any minor or patch
version of the core Specification beyond the minimum version it requires.
A vendor extension :normative{type="should"} be able to be enabled alongside any KHR
extension, multi-vendor extension, or other vendor extension from the same
vendor, and for any minor or patch version of the core Specification beyond
the minimum version it requires.
A vendor extension :normative{type="may"} be able to be enabled alongside vendor extensions
from another vendor.

The one other exception to this is if a vendor or multi-vendor extension is
made obsolete by either a core
version or another extension, which will be highlighted in the
extension appendix.



#### Promotion

Extensions, or features of an extension, :normative{type="may"} be promoted to a new
core version of the API, or a newer extension which an equal or
greater number of implementors are in favour of.

When extension functionality is promoted, minor changes :normative{type="may"} be introduced,
limited to the following:

- Naming

- Non-intrusive parameters changes

- Feature advertisement/enablement

- Combining structure parameters into larger structures

- Author ID suffixes changed or removed


::note
If extension functionality is promoted, there is no guarantee of direct
compatibility, however it should require little effort to port code from the
original feature to the promoted one.

The Vulkan Working Group endeavours to ensure that larger changes are marked
as either deprecated or
obsoleted as appropriate, and
can do so retroactively if necessary.
::


Extensions that are promoted are listed as being promoted in their extension
appendices, with reference to where they were promoted to.

When an extension is promoted, any backwards compatibility aliases which
exist in the extension will *not* be promoted.


::note
As a hypothetical example, if the  extension were
promoted to part of a future core version, the
`VK_COLOR_SPACE_SRGB_NONLINEAR_KHR` token defined by that extension
would be promoted to `VK_COLOR_SPACE_SRGB_NONLINEAR`.
However, the `VK_COLORSPACE_SRGB_NONLINEAR_KHR` token aliases
`VK_COLOR_SPACE_SRGB_NONLINEAR_KHR`.
The `VK_COLORSPACE_SRGB_NONLINEAR_KHR` would not be promoted, because it
is a backwards compatibility alias that exists only due to a naming mistake
when the extension was initially published.
::






#### Deprecation

Extensions :normative{type="may"} be marked as deprecated when the intended use cases either
become irrelevant or can be solved in other ways.
Generally, a new feature will become available to solve the use case in
another extension or core version of the API, but it is not guaranteed.


::note
Features that are intended to replace deprecated functionality have no
guarantees of compatibility, and applications may require drastic
modification in order to make use of the new features.
::


Extensions that are deprecated are listed as being deprecated in their
extension appendices, with an explanation of the deprecation and any
features that are relevant.





#### Obsoletion

Occasionally, an extension will be marked as obsolete if a new version of
the core API or a new extension is fundamentally incompatible with it.
An obsoleted extension :normative{type="must"} not be used with the extension or core version
that obsoleted it.

Extensions that are obsoleted are listed as being obsoleted in their
extension appendices, with reference to what they were obsoleted by.





#### Aliases

When an extension is promoted or deprecated by a newer feature, some or all
of its functionality :normative{type="may"} be replicated into the newer feature.
Rather than duplication of all the documentation and definitions, the
specification instead identifies the identical commands and types as
*aliases* of one another.
Each alias is mentioned together with the definition it aliases, with the
older aliases marked as > equivalents.
Each alias of the same command has identical behavior, and each alias of the
same type has identical meaning - they can be used interchangeably in an
application with no compatibility issues.


::note
For promoted types, the aliased extension type is semantically identical to
the new core type.
The C99 headers simply `typedef` the older aliases to the promoted types.

For promoted command aliases, however, there are two separate entry point
definitions, due to the fact that the C99 ABI has no way to alias command
definitions without resorting to macros.
Calling via either entry point definition will produce identical behavior
within the bounds of the specification, and should still invoke the same
entry point in the implementation.
Debug tools may use separate entry points with different debug behavior; to
write the appropriate command name to an output log, for instance.
::






#### Special Use Extensions

Some extensions exist only to support a specific purpose or specific class
of application.
These are referred to as > special use extensions.
Use of these extensions in applications not meeting the special use criteria
is not recommended.

Special use cases are restricted, and only those defined below are used to
describe extensions:



Special use extensions are identified in the metadata for each such
extension in the Layers & Extensions appendix, using the
name in the > Special Use column above.

Special use extensions are also identified in `vk.xml` with the short name
in > XML Tag column above, as described in the > API Extensions
> (
>
> `extension`
>
> &#x20;tag) section of the registry schema
documentation.











# Features

*Features* describe functionality which is not supported on all
implementations.
Features are properties of the physical device.
Features are :normative{type="optional"}, and :normative{type="must"} be explicitly enabled before use.
Support for features is reported and enabled on a per-feature basis.

For convenience, new core versions of Vulkan :normative{type="may"} introduce new unified
feature structures for features promoted from extensions.
At the same time, the extension’s original feature structure (if any) is
also promoted to the core API, and is an alias of the extension’s structure.
This results in multiple names for the same feature: in the original
extension’s feature structure and the promoted structure alias, in the
unified feature structure.
When a feature was implicitly supported and enabled in the extension, but an
explicit name was added during promotion, then the extension itself acts as
an alias for the feature as listed in the table below.

All aliases of the same feature in the core API :normative{type="must"} be reported
consistently: either all :normative{type="must"} be reported as supported, or none of them.
When a promoted extension is available, any corresponding feature aliases
:normative{type="must"} be supported.



To query supported features, call:

[{generated}/api/protos/vkGetPhysicalDeviceFeatures.adoc]({generated}/api/protos/vkGetPhysicalDeviceFeatures.adoc)

- `physicalDevice` is the physical device from which to query the
  supported features.

- `pFeatures` is a pointer to a [VkPhysicalDeviceFeatures](/man/VkPhysicalDeviceFeatures)
  structure in which the physical device features are returned.
  For each feature, a value of `VK_TRUE` specifies that the feature is
  supported on this physical device, and `VK_FALSE` specifies that the
  feature is not supported.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkGetPhysicalDeviceFeatures-physicalDevice-parameter"}
 `physicalDevice` :normative{type="must"} be a valid [VkPhysicalDevice](/man/VkPhysicalDevice) handle
::

::validity-field{name="VUID-vkGetPhysicalDeviceFeatures-pFeatures-parameter"}
 `pFeatures` :normative{type="must"} be a valid pointer to a [VkPhysicalDeviceFeatures](/man/VkPhysicalDeviceFeatures) structure
::

::


Fine-grained features used by a logical device :normative{type="must"} be enabled at
`VkDevice` creation time.
If a feature is enabled that the physical device does not support,
`VkDevice` creation will fail and return
`VK_ERROR_FEATURE_NOT_PRESENT`.

The fine-grained features are enabled by passing a pointer to the
`VkPhysicalDeviceFeatures` structure via the `pEnabledFeatures`
member of the [VkDeviceCreateInfo](/man/VkDeviceCreateInfo) structure that is passed into the
`vkCreateDevice` call.
If a member of `pEnabledFeatures` is set to `VK_TRUE` or
`VK_FALSE`, then the device will be created with the indicated feature
enabled or disabled, respectively.

If an application wishes to enable all features supported by a device, it
:normative{type="can"} simply pass in the `VkPhysicalDeviceFeatures` structure that was
previously returned by `vkGetPhysicalDeviceFeatures`.
To disable an individual feature, the application :normative{type="can"} set the desired
member to `VK_FALSE` in the same structure.
Setting `pEnabledFeatures` to `NULL`
is equivalent to setting all members of the structure to `VK_FALSE`.


::note
Some features, such as `robustBufferAccess`, :normative{type="may"} incur a runtime
performance cost.
Application writers :normative{type="should"} carefully consider the implications of enabling
all supported features.
::


The `VkPhysicalDeviceFeatures` structure is defined as:

[{generated}/api/structs/VkPhysicalDeviceFeatures.adoc]({generated}/api/structs/VkPhysicalDeviceFeatures.adoc)

This structure describes the following features:

- [features-robustBufferAccess](#features-robustBufferAccess) `robustBufferAccess` specifies that
  accesses to buffers are bounds-checked against the range of the buffer
  descriptor (as determined by `VkDescriptorBufferInfo`::`range`,
  [VkBufferViewCreateInfo](/man/VkBufferViewCreateInfo)::`range`, or the size of the buffer).
  Out of bounds accesses :normative{type="must"} not cause application termination, and the
  effects of shader loads, stores, and atomics :normative{type="must"} conform to an
  implementation-dependent behavior as described below.





  * A buffer access is considered to be out of bounds if any of the
    following are true:





    * The pointer was formed by `OpImageTexelPointer` and the coordinate
      is less than zero or greater than or equal to the number of whole
      elements in the bound range.

    * The pointer was not formed by `OpImageTexelPointer` and the object
      pointed to is not wholly contained within the bound range.






      ::note


      If a SPIR-V `OpLoad` instruction loads a structure and the tail end of
      the structure is out of bounds, then all members of the structure are
      considered out of bounds even if the members at the end are not statically
      used.


      ::


    * If
      any buffer access is determined to be out of bounds, then any other
      access of the same type (load, store, or atomic) to the same buffer
      that accesses an address less than 16 bytes away from the out of
      bounds address :normative{type="may"} also be considered out of bounds.

    * If the access is a load that reads from the same memory locations as a
      prior store in the same shader invocation, with no other intervening
      accesses to the same memory locations in that shader invocation, then
      the result of the load :normative{type="may"} be the value stored by the store
      instruction, even if the access is out of bounds.
      If the load is `Volatile`, then an out of bounds load :normative{type="must"} return
      the appropriate out of bounds value.

  * Out-of-bounds buffer loads will return any of the following values:





    * Values from anywhere within the memory range(s) bound to the buffer
      (possibly including bytes of memory past the end of the buffer, up to
      the end of the bound range).

    * Zero values, or (0,0,0,x) vectors for vector reads where x is a
      valid value represented in the type of the vector components and :normative{type="may"}
      be any of:





      * 0, 1, or the maximum representable positive integer value, for signed
        or unsigned integer components

      * 0.0 or 1.0, for floating-point components

  * Out-of-bounds writes :normative{type="may"} modify values within the memory range(s)
    bound to the buffer, but :normative{type="must"} not modify any other memory.

  * Out-of-bounds atomics :normative{type="may"} modify values within the memory range(s)
    bound to the buffer, but :normative{type="must"} not modify any other memory, and return
    an undefined: value.

  * Vertex
    input attributes are considered out of bounds if the offset of the
    attribute in the bound vertex buffer range plus the size of the
    attribute is greater than either:





    * `vertexBufferRangeSize`, if `bindingStride` == 0; or

    * (`vertexBufferRangeSize` - (`vertexBufferRangeSize` %
      `bindingStride`))





    where `vertexBufferRangeSize` is the byte size of the memory range bound
    to the vertex buffer binding and `bindingStride` is the byte stride of
    the corresponding vertex input binding.
    Further, if any vertex input attribute using a specific vertex input binding
    is out of bounds, then all vertex input attributes using that vertex input
    binding for that vertex shader invocation are considered out of bounds.





    * If a vertex input attribute is out of bounds, it will be assigned one
      of the following values:





      * Values from anywhere within the memory range(s) bound to the buffer,
        converted according to the format of the attribute.

      * Zero values, format converted according to the format of the
        attribute.

      * Zero values, or (0,0,0,x) vectors, as described above.

  * If `robustBufferAccess` is not enabled, applications :normative{type="must"} not
    perform out of bounds accesses
    .

- [features-fullDrawIndexUint32](#features-fullDrawIndexUint32) `fullDrawIndexUint32` specifies the
  full 32-bit range of indices is supported for indexed draw calls when
  using a [VkIndexType](/man/VkIndexType) of `VK_INDEX_TYPE_UINT32`.
  `maxDrawIndexedIndexValue` is the maximum index value that :normative{type="may"} be
  used (aside from the primitive restart index, which is always 2\<sup>32\</sup>-1
  when the [VkIndexType](/man/VkIndexType) is `VK_INDEX_TYPE_UINT32`).
  If this feature is supported, `maxDrawIndexedIndexValue` :normative{type="must"} be
  2\<sup>32\</sup>-1; otherwise it :normative{type="must"} be no smaller than 2\<sup>24\</sup>-1.
  See `maxDrawIndexedIndexValue`.

- [features-imageCubeArray](#features-imageCubeArray) `imageCubeArray` specifies whether image
  views with a [VkImageViewType](/man/VkImageViewType) of
  `VK_IMAGE_VIEW_TYPE_CUBE_ARRAY` :normative{type="can"} be created, and that the
  corresponding `SampledCubeArray` and `ImageCubeArray` SPIR-V
  capabilities :normative{type="can"} be used in shader code.

- [features-independentBlend](#features-independentBlend) `independentBlend` specifies whether
  the `VkPipelineColorBlendAttachmentState` settings are controlled
  independently per-attachment.
  If this feature is not enabled, the
  `VkPipelineColorBlendAttachmentState` settings for all color
  attachments :normative{type="must"} be identical.
  Otherwise, a different `VkPipelineColorBlendAttachmentState` :normative{type="can"} be
  provided for each bound color attachment.

- [features-geometryShader](#features-geometryShader) `geometryShader` specifies whether
  geometry shaders are supported.
  If this feature is not enabled, the `VK_SHADER_STAGE_GEOMETRY_BIT`
  and `VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT` enum values :normative{type="must"} not be
  used.
  This also specifies whether shader modules :normative{type="can"} declare the
  `Geometry` capability.

- [features-tessellationShader](#features-tessellationShader) `tessellationShader` specifies
  whether tessellation control and evaluation shaders are supported.
  If this feature is not enabled, the
  `VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT`,
  `VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT`,
  `VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT`,
  `VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT`, and
  `VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO` enum
  values :normative{type="must"} not be used.
  This also specifies whether shader modules :normative{type="can"} declare the
  `Tessellation` capability.

- [features-sampleRateShading](#features-sampleRateShading) `sampleRateShading` specifies whether
  Sample Shading and multisample interpolation
  are supported.
  If this feature is not enabled, the `sampleShadingEnable` member of
  the [VkPipelineMultisampleStateCreateInfo](/man/VkPipelineMultisampleStateCreateInfo) structure :normative{type="must"} be set to
  `VK_FALSE` and the `minSampleShading` member is ignored.
  This also specifies whether shader modules :normative{type="can"} declare the
  `SampleRateShading` capability.

- [features-dualSrcBlend](#features-dualSrcBlend) `dualSrcBlend` specifies whether blend
  operations which take two sources are supported.
  If this feature is not enabled, the `VK_BLEND_FACTOR_SRC1_COLOR`,
  `VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR`,
  `VK_BLEND_FACTOR_SRC1_ALPHA`, and
  `VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA` enum values :normative{type="must"} not be used
  as source or destination blending factors.
  See .

- [features-logicOp](#features-logicOp) `logicOp` specifies whether logic operations
  are supported.
  If this feature is not enabled, the `logicOpEnable` member of the
  [VkPipelineColorBlendStateCreateInfo](/man/VkPipelineColorBlendStateCreateInfo) structure :normative{type="must"} be set to
  `VK_FALSE`, and the `logicOp` member is ignored.

- [features-multiDrawIndirect](#features-multiDrawIndirect) `multiDrawIndirect` specifies whether
  multiple draw indirect is supported.
  If this feature is not enabled, the `drawCount` parameter to the
  `vkCmdDrawIndirect` and `vkCmdDrawIndexedIndirect` commands
  :normative{type="must"} be 0 or 1.
  The `maxDrawIndirectCount` member of the
  `VkPhysicalDeviceLimits` structure :normative{type="must"} also be 1 if this feature
  is not supported.
  See `maxDrawIndirectCount`.

- [features-drawIndirectFirstInstance](#features-drawIndirectFirstInstance) `drawIndirectFirstInstance`
  specifies whether indirect drawing calls support the `firstInstance`
  parameter.
  If this feature is not enabled, the `firstInstance` member of all
  `VkDrawIndirectCommand` and `VkDrawIndexedIndirectCommand`
  structures that are provided to the `vkCmdDrawIndirect` and
  `vkCmdDrawIndexedIndirect` commands :normative{type="must"} be 0.

- [features-depthClamp](#features-depthClamp) `depthClamp` specifies whether depth
  clamping is supported.
  If this feature is not enabled, the `depthClampEnable` member of the
  [VkPipelineRasterizationStateCreateInfo](/man/VkPipelineRasterizationStateCreateInfo) structure :normative{type="must"} be set to
  `VK_FALSE`.
  Otherwise, setting `depthClampEnable` to `VK_TRUE` will enable
  depth clamping.

- [features-depthBiasClamp](#features-depthBiasClamp) `depthBiasClamp` specifies whether depth
  bias clamping is supported.
  If this feature is not enabled, the `depthBiasClamp` member of the
  [VkPipelineRasterizationStateCreateInfo](/man/VkPipelineRasterizationStateCreateInfo) structure :normative{type="must"} be set to
  0.0 unless the `VK_DYNAMIC_STATE_DEPTH_BIAS` dynamic state is
  enabled, and the `depthBiasClamp` parameter to
  `vkCmdSetDepthBias` :normative{type="must"} be set to 0.0.

- [features-fillModeNonSolid](#features-fillModeNonSolid) `fillModeNonSolid` specifies whether
  point and wireframe fill modes are supported.
  If this feature is not enabled, the `VK_POLYGON_MODE_POINT` and
  `VK_POLYGON_MODE_LINE` enum values :normative{type="must"} not be used.

- [features-depthBounds](#features-depthBounds) `depthBounds` specifies whether depth
  bounds tests are supported.
  If this feature is not enabled, the `depthBoundsTestEnable` member
  of the [VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo) structure :normative{type="must"} be
  set to `VK_FALSE`.
  When `depthBoundsTestEnable` is set to `VK_FALSE`, the
  `minDepthBounds` and `maxDepthBounds` members of the
  [VkPipelineDepthStencilStateCreateInfo](/man/VkPipelineDepthStencilStateCreateInfo) structure are ignored.

- [features-wideLines](#features-wideLines) `wideLines` specifies whether lines with
  width other than 1.0 are supported.
  If this feature is not enabled, the `lineWidth` member of the
  [VkPipelineRasterizationStateCreateInfo](/man/VkPipelineRasterizationStateCreateInfo) structure :normative{type="must"} be set to
  1.0 unless the `VK_DYNAMIC_STATE_LINE_WIDTH` dynamic state is
  enabled, and the `lineWidth` parameter to `vkCmdSetLineWidth`
  :normative{type="must"} be set to 1.0.
  When this feature is supported, the range and granularity of supported
  line widths are indicated by the `lineWidthRange` and
  `lineWidthGranularity` members of the `VkPhysicalDeviceLimits`
  structure, respectively.

- [features-largePoints](#features-largePoints) `largePoints` specifies whether points with
  size greater than 1.0 are supported.
  If this feature is not enabled, only a point size of 1.0 written by a
  shader is supported.
  The range and granularity of supported point sizes are indicated by the
  `pointSizeRange` and `pointSizeGranularity` members of the
  `VkPhysicalDeviceLimits` structure, respectively.

- [features-alphaToOne](#features-alphaToOne) `alphaToOne` specifies whether the
  implementation is able to replace the alpha value of the fragment shader
  color output in the Multisample Coverage fragment
  operation.
  If this feature is not enabled, then the `alphaToOneEnable` member
  of the [VkPipelineMultisampleStateCreateInfo](/man/VkPipelineMultisampleStateCreateInfo) structure :normative{type="must"} be set
  to `VK_FALSE`.
  Otherwise setting `alphaToOneEnable` to `VK_TRUE` will enable
  alpha-to-one behavior.

- [features-multiViewport](#features-multiViewport) `multiViewport` specifies whether more
  than one viewport is supported.
  If this feature is not enabled:





  * The `viewportCount` and `scissorCount` members of the
    [VkPipelineViewportStateCreateInfo](/man/VkPipelineViewportStateCreateInfo) structure :normative{type="must"} be set to 1.

  * The `firstViewport` and `viewportCount` parameters to the
    `vkCmdSetViewport` command :normative{type="must"} be set to 0 and 1, respectively.

  * The `firstScissor` and `scissorCount` parameters to the
    `vkCmdSetScissor` command :normative{type="must"} be set to 0 and 1, respectively.

- [features-samplerAnisotropy](#features-samplerAnisotropy) `samplerAnisotropy` specifies whether
  anisotropic filtering is supported.
  If this feature is not enabled, the `anisotropyEnable` member of the
  [VkSamplerCreateInfo](/man/VkSamplerCreateInfo) structure :normative{type="must"} be `VK_FALSE`.

- [features-textureCompressionETC2](#features-textureCompressionETC2) `textureCompressionETC2`
  specifies whether all of the ETC2 and EAC compressed texture formats are
  supported.
  If this feature is enabled, then the
  `VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT`,
  `VK_FORMAT_FEATURE_BLIT_SRC_BIT` and
  `VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT` features :normative{type="must"}
  be supported in `optimalTilingFeatures` for the following formats:





  * `VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK`

  * `VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK`

  * `VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK`

  * `VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK`

  * `VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK`

  * `VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK`

  * `VK_FORMAT_EAC_R11_UNORM_BLOCK`

  * `VK_FORMAT_EAC_R11_SNORM_BLOCK`

  * `VK_FORMAT_EAC_R11G11_UNORM_BLOCK`

  * `VK_FORMAT_EAC_R11G11_SNORM_BLOCK`





  To query for additional properties, or if the feature is not enabled,
  [vkGetPhysicalDeviceFormatProperties](/man/vkGetPhysicalDeviceFormatProperties) and
  [vkGetPhysicalDeviceImageFormatProperties](/man/vkGetPhysicalDeviceImageFormatProperties) :normative{type="can"} be used to check for
  supported properties of individual formats as normal.

- [features-textureCompressionASTC\_LDR](#features-textureCompressionASTC_LDR) `textureCompressionASTC_LDR`
  specifies whether all of the ASTC LDR compressed texture formats are
  supported.
  If this feature is enabled, then the
  `VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT`,
  `VK_FORMAT_FEATURE_BLIT_SRC_BIT` and
  `VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT` features :normative{type="must"}
  be supported in `optimalTilingFeatures` for the following formats:





  * `VK_FORMAT_ASTC_4x4_UNORM_BLOCK`

  * `VK_FORMAT_ASTC_4x4_SRGB_BLOCK`

  * `VK_FORMAT_ASTC_5x4_UNORM_BLOCK`

  * `VK_FORMAT_ASTC_5x4_SRGB_BLOCK`

  * `VK_FORMAT_ASTC_5x5_UNORM_BLOCK`

  * `VK_FORMAT_ASTC_5x5_SRGB_BLOCK`

  * `VK_FORMAT_ASTC_6x5_UNORM_BLOCK`

  * `VK_FORMAT_ASTC_6x5_SRGB_BLOCK`

  * `VK_FORMAT_ASTC_6x6_UNORM_BLOCK`

  * `VK_FORMAT_ASTC_6x6_SRGB_BLOCK`

  * `VK_FORMAT_ASTC_8x5_UNORM_BLOCK`

  * `VK_FORMAT_ASTC_8x5_SRGB_BLOCK`

  * `VK_FORMAT_ASTC_8x6_UNORM_BLOCK`

  * `VK_FORMAT_ASTC_8x6_SRGB_BLOCK`

  * `VK_FORMAT_ASTC_8x8_UNORM_BLOCK`

  * `VK_FORMAT_ASTC_8x8_SRGB_BLOCK`

  * `VK_FORMAT_ASTC_10x5_UNORM_BLOCK`

  * `VK_FORMAT_ASTC_10x5_SRGB_BLOCK`

  * `VK_FORMAT_ASTC_10x6_UNORM_BLOCK`

  * `VK_FORMAT_ASTC_10x6_SRGB_BLOCK`

  * `VK_FORMAT_ASTC_10x8_UNORM_BLOCK`

  * `VK_FORMAT_ASTC_10x8_SRGB_BLOCK`

  * `VK_FORMAT_ASTC_10x10_UNORM_BLOCK`

  * `VK_FORMAT_ASTC_10x10_SRGB_BLOCK`

  * `VK_FORMAT_ASTC_12x10_UNORM_BLOCK`

  * `VK_FORMAT_ASTC_12x10_SRGB_BLOCK`

  * `VK_FORMAT_ASTC_12x12_UNORM_BLOCK`

  * `VK_FORMAT_ASTC_12x12_SRGB_BLOCK`





  To query for additional properties, or if the feature is not enabled,
  [vkGetPhysicalDeviceFormatProperties](/man/vkGetPhysicalDeviceFormatProperties) and
  [vkGetPhysicalDeviceImageFormatProperties](/man/vkGetPhysicalDeviceImageFormatProperties) :normative{type="can"} be used to check for
  supported properties of individual formats as normal.

- [features-textureCompressionBC](#features-textureCompressionBC) `textureCompressionBC` specifies
  whether all of the BC compressed texture formats are supported.
  If this feature is enabled, then the
  `VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT`,
  `VK_FORMAT_FEATURE_BLIT_SRC_BIT` and
  `VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT` features :normative{type="must"}
  be supported in `optimalTilingFeatures` for the following formats:





  * `VK_FORMAT_BC1_RGB_UNORM_BLOCK`

  * `VK_FORMAT_BC1_RGB_SRGB_BLOCK`

  * `VK_FORMAT_BC1_RGBA_UNORM_BLOCK`

  * `VK_FORMAT_BC1_RGBA_SRGB_BLOCK`

  * `VK_FORMAT_BC2_UNORM_BLOCK`

  * `VK_FORMAT_BC2_SRGB_BLOCK`

  * `VK_FORMAT_BC3_UNORM_BLOCK`

  * `VK_FORMAT_BC3_SRGB_BLOCK`

  * `VK_FORMAT_BC4_UNORM_BLOCK`

  * `VK_FORMAT_BC4_SNORM_BLOCK`

  * `VK_FORMAT_BC5_UNORM_BLOCK`

  * `VK_FORMAT_BC5_SNORM_BLOCK`

  * `VK_FORMAT_BC6H_UFLOAT_BLOCK`

  * `VK_FORMAT_BC6H_SFLOAT_BLOCK`

  * `VK_FORMAT_BC7_UNORM_BLOCK`

  * `VK_FORMAT_BC7_SRGB_BLOCK`





  To query for additional properties, or if the feature is not enabled,
  [vkGetPhysicalDeviceFormatProperties](/man/vkGetPhysicalDeviceFormatProperties) and
  [vkGetPhysicalDeviceImageFormatProperties](/man/vkGetPhysicalDeviceImageFormatProperties) :normative{type="can"} be used to check for
  supported properties of individual formats as normal.

- [features-occlusionQueryPrecise](#features-occlusionQueryPrecise) `occlusionQueryPrecise` specifies
  whether occlusion queries returning actual sample counts are supported.
  Occlusion queries are created in a `VkQueryPool` by specifying the
  `queryType` of `VK_QUERY_TYPE_OCCLUSION` in the
  [VkQueryPoolCreateInfo](/man/VkQueryPoolCreateInfo) structure which is passed to
  `vkCreateQueryPool`.
  If this feature is enabled, queries of this type :normative{type="can"} enable
  `VK_QUERY_CONTROL_PRECISE_BIT` in the `flags` parameter to
  `vkCmdBeginQuery`.
  If this feature is not supported, the implementation supports only
  boolean occlusion queries.
  When any samples are passed, boolean queries will return a non-zero
  result value, otherwise a result value of zero is returned.
  When this feature is enabled and `VK_QUERY_CONTROL_PRECISE_BIT` is
  set, occlusion queries will report the actual number of samples passed.

- [features-pipelineStatisticsQuery](#features-pipelineStatisticsQuery) `pipelineStatisticsQuery`
  specifies whether the pipeline statistics queries are supported.
  If this feature is not enabled, queries of type
  `VK_QUERY_TYPE_PIPELINE_STATISTICS` :normative{type="cannot"} be created, and none of
  the [VkQueryPipelineStatisticFlagBits](/man/VkQueryPipelineStatisticFlagBits) bits :normative{type="can"} be set in the
  `pipelineStatistics` member of the [VkQueryPoolCreateInfo](/man/VkQueryPoolCreateInfo)
  structure.

- [features-vertexPipelineStoresAndAtomics](#features-vertexPipelineStoresAndAtomics)

  `vertexPipelineStoresAndAtomics` specifies whether storage buffers
  and images support stores and atomic operations in the vertex,
  tessellation, and geometry shader stages.
  If this feature is not enabled, all storage image, storage texel buffer,
  and storage buffer variables used by these stages in shader modules
  :normative{type="must"} be decorated with the `NonWritable` decoration (or the
  `readonly` memory qualifier in GLSL).

- [features-fragmentStoresAndAtomics](#features-fragmentStoresAndAtomics) `fragmentStoresAndAtomics`
  specifies whether storage buffers and images support stores and atomic
  operations in the fragment shader stage.
  If this feature is not enabled, all storage image, storage texel buffer,
  and storage buffer variables used by the fragment stage in shader
  modules :normative{type="must"} be decorated with the `NonWritable` decoration (or the
  `readonly` memory qualifier in GLSL).

- [features-shaderTessellationAndGeometryPointSize](#features-shaderTessellationAndGeometryPointSize)

  `shaderTessellationAndGeometryPointSize` specifies whether the
  `PointSize` built-in decoration is available in the tessellation
  control, tessellation evaluation, and geometry shader stages.
  If this feature is not enabled, members decorated with the
  `PointSize` built-in decoration :normative{type="must"} not be read from or written to
  and all points written from a tessellation or geometry shader will have
  a size of 1.0.
  This also specifies whether shader modules :normative{type="can"} declare the
  `TessellationPointSize` capability for tessellation control and
  evaluation shaders, or if the shader modules :normative{type="can"} declare the
  `GeometryPointSize` capability for geometry shaders.
  An implementation supporting this feature :normative{type="must"} also support one or both
  of the `tessellationShader` or
  `geometryShader` features.

- [features-shaderImageGatherExtended](#features-shaderImageGatherExtended) `shaderImageGatherExtended`
  specifies whether the extended set of image gather instructions are
  available in shader code.
  If this feature is not enabled, the `OpImage*Gather` instructions do
  not support the `Offset` and `ConstOffsets` operands.
  This also specifies whether shader modules :normative{type="can"} declare the
  `ImageGatherExtended` capability.

- [features-shaderStorageImageExtendedFormats](#features-shaderStorageImageExtendedFormats)

  `shaderStorageImageExtendedFormats` specifies whether all the
  > storage image extended formats below are supported; if this feature
  is supported, then the `VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT` :normative{type="must"}
  be supported in `optimalTilingFeatures` for the following formats:





  * `VK_FORMAT_R16G16_SFLOAT`

  * `VK_FORMAT_B10G11R11_UFLOAT_PACK32`

  * `VK_FORMAT_R16_SFLOAT`

  * `VK_FORMAT_R16G16B16A16_UNORM`

  * `VK_FORMAT_A2B10G10R10_UNORM_PACK32`

  * `VK_FORMAT_R16G16_UNORM`

  * `VK_FORMAT_R8G8_UNORM`

  * `VK_FORMAT_R16_UNORM`

  * `VK_FORMAT_R8_UNORM`

  * `VK_FORMAT_R16G16B16A16_SNORM`

  * `VK_FORMAT_R16G16_SNORM`

  * `VK_FORMAT_R8G8_SNORM`

  * `VK_FORMAT_R16_SNORM`

  * `VK_FORMAT_R8_SNORM`

  * `VK_FORMAT_R16G16_SINT`

  * `VK_FORMAT_R8G8_SINT`

  * `VK_FORMAT_R16_SINT`

  * `VK_FORMAT_R8_SINT`

  * `VK_FORMAT_A2B10G10R10_UINT_PACK32`

  * `VK_FORMAT_R16G16_UINT`

  * `VK_FORMAT_R8G8_UINT`

  * `VK_FORMAT_R16_UINT`

  * `VK_FORMAT_R8_UINT`






  ::note


  `shaderStorageImageExtendedFormats` feature only adds a guarantee of
  format support, which is specified for the whole physical device.
  Therefore enabling or disabling the feature via [vkCreateDevice](/man/vkCreateDevice) has no
  practical effect.





  To query for additional properties, or if the feature is not supported,
  [vkGetPhysicalDeviceFormatProperties](/man/vkGetPhysicalDeviceFormatProperties) and
  [vkGetPhysicalDeviceImageFormatProperties](/man/vkGetPhysicalDeviceImageFormatProperties) :normative{type="can"} be used to check for
  supported properties of individual formats, as usual rules allow.





  `VK_FORMAT_R32G32_UINT`, `VK_FORMAT_R32G32_SINT`, and
  `VK_FORMAT_R32G32_SFLOAT` from `StorageImageExtendedFormats` SPIR-V
  capability, are already covered by core Vulkan
  mandatory format support.


  ::


- [features-shaderStorageImageMultisample](#features-shaderStorageImageMultisample)

  `shaderStorageImageMultisample` specifies whether multisampled
  storage images are supported.
  If this feature is not enabled, images that are created with a
  `usage` that includes `VK_IMAGE_USAGE_STORAGE_BIT` :normative{type="must"} be
  created with `samples` equal to `VK_SAMPLE_COUNT_1_BIT`.
  This also specifies whether shader modules :normative{type="can"} declare the
  `StorageImageMultisample` and `ImageMSArray` capabilities.

- [features-shaderStorageImageReadWithoutFormat](#features-shaderStorageImageReadWithoutFormat)

  `shaderStorageImageReadWithoutFormat` specifies whether storage
  images and storage texel buffers require a format qualifier to be
  specified when reading.

- [features-shaderStorageImageWriteWithoutFormat](#features-shaderStorageImageWriteWithoutFormat)

  `shaderStorageImageWriteWithoutFormat` specifies whether storage
  images and storage texel buffers require a format qualifier to be
  specified when writing.

- [features-shaderUniformBufferArrayDynamicIndexing](#features-shaderUniformBufferArrayDynamicIndexing)

  `shaderUniformBufferArrayDynamicIndexing` specifies whether arrays
  of uniform buffers :normative{type="can"} be indexed by *dynamically uniform* integer
  expressions in shader code.
  If this feature is not enabled, resources with a descriptor type of
  `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or
  `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` :normative{type="must"} be indexed only by
  constant integral expressions when aggregated into arrays in shader
  code.
  This also specifies whether shader modules :normative{type="can"} declare the
  `UniformBufferArrayDynamicIndexing` capability.

- [features-shaderSampledImageArrayDynamicIndexing](#features-shaderSampledImageArrayDynamicIndexing)

  `shaderSampledImageArrayDynamicIndexing` specifies whether arrays of
  samplers or sampled images :normative{type="can"} be indexed by dynamically uniform
  integer expressions in shader code.
  If this feature is not enabled, resources with a descriptor type of
  `VK_DESCRIPTOR_TYPE_SAMPLER`,
  `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`, or
  `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE` :normative{type="must"} be indexed only by constant
  integral expressions when aggregated into arrays in shader code.
  This also specifies whether shader modules :normative{type="can"} declare the
  `SampledImageArrayDynamicIndexing` capability.

- [features-shaderStorageBufferArrayDynamicIndexing](#features-shaderStorageBufferArrayDynamicIndexing)

  `shaderStorageBufferArrayDynamicIndexing` specifies whether arrays
  of storage buffers :normative{type="can"} be indexed by dynamically uniform integer
  expressions in shader code.
  If this feature is not enabled, resources with a descriptor type of
  `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or
  `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC` :normative{type="must"} be indexed only by
  constant integral expressions when aggregated into arrays in shader
  code.
  This also specifies whether shader modules :normative{type="can"} declare the
  `StorageBufferArrayDynamicIndexing` capability.

- [features-shaderStorageImageArrayDynamicIndexing](#features-shaderStorageImageArrayDynamicIndexing)

  `shaderStorageImageArrayDynamicIndexing` specifies whether arrays of
  storage images :normative{type="can"} be indexed by dynamically uniform integer
  expressions in shader code.
  If this feature is not enabled, resources with a descriptor type of
  `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE` :normative{type="must"} be indexed only by constant
  integral expressions when aggregated into arrays in shader code.
  This also specifies whether shader modules :normative{type="can"} declare the
  `StorageImageArrayDynamicIndexing` capability.

- [features-shaderClipDistance](#features-shaderClipDistance) `shaderClipDistance` specifies
  whether clip distances are supported in shader code.
  If this feature is not enabled, any members decorated with the
  `ClipDistance` built-in decoration :normative{type="must"} not be read from or written
  to in shader modules.
  This also specifies whether shader modules :normative{type="can"} declare the
  `ClipDistance` capability.

- [features-shaderCullDistance](#features-shaderCullDistance) `shaderCullDistance` specifies
  whether cull distances are supported in shader code.
  If this feature is not enabled, any members decorated with the
  `CullDistance` built-in decoration :normative{type="must"} not be read from or written
  to in shader modules.
  This also specifies whether shader modules :normative{type="can"} declare the
  `CullDistance` capability.

- [features-shaderFloat64](#features-shaderFloat64) `shaderFloat64` specifies whether 64-bit
  floats (doubles) are supported in shader code.
  If this feature is not enabled, 64-bit floating-point types :normative{type="must"} not be
  used in shader code.
  This also specifies whether shader modules :normative{type="can"} declare the `Float64`
  capability.
  Declaring and using 64-bit floats is enabled for all storage classes
  that SPIR-V allows with the `Float64` capability.

- [features-shaderInt64](#features-shaderInt64) `shaderInt64` specifies whether 64-bit
  integers (signed and unsigned) are supported in shader code.
  If this feature is not enabled, 64-bit integer types :normative{type="must"} not be used
  in shader code.
  This also specifies whether shader modules :normative{type="can"} declare the `Int64`
  capability.
  Declaring and using 64-bit integers is enabled for all storage classes
  that SPIR-V allows with the `Int64` capability.

- [features-shaderInt16](#features-shaderInt16) `shaderInt16` specifies whether 16-bit
  integers (signed and unsigned) are supported in shader code.
  If this feature is not enabled, 16-bit integer types :normative{type="must"} not be used
  in shader code.
  This also specifies whether shader modules :normative{type="can"} declare the `Int16`
  capability.
  However, this only enables a subset of the storage classes that SPIR-V
  allows for the `Int16` SPIR-V capability: Declaring and using 16-bit
  integers in the `Private`,
  `Workgroup`,
  and `Function` storage classes is enabled, while declaring them in
  the interface storage classes (e.g., `UniformConstant`, `Uniform`,
  `StorageBuffer`, `Input`, `Output`, and `PushConstant`) is
  not enabled.

- [features-shaderResourceResidency](#features-shaderResourceResidency) `shaderResourceResidency`
  specifies whether image operations that return resource residency
  information are supported in shader code.
  If this feature is not enabled, the `OpImageSparse*` instructions
  :normative{type="must"} not be used in shader code.
  This also specifies whether shader modules :normative{type="can"} declare the
  `SparseResidency` capability.
  The feature requires at least one of the `sparseResidency*` features
  to be supported.

- [features-shaderResourceMinLod](#features-shaderResourceMinLod) `shaderResourceMinLod` specifies
  whether image operations specifying the minimum resource LOD are
  supported in shader code.
  If this feature is not enabled, the `MinLod` image operand :normative{type="must"} not
  be used in shader code.
  This also specifies whether shader modules :normative{type="can"} declare the `MinLod`
  capability.

- [features-sparseBinding](#features-sparseBinding) `sparseBinding` specifies whether
  resource memory :normative{type="can"} be managed at opaque sparse block level instead of
  at the object level.
  If this feature is not enabled, resource memory :normative{type="must"} be bound only on a
  per-object basis using the `vkBindBufferMemory` and
  `vkBindImageMemory` commands.
  In this case, buffers and images :normative{type="must"} not be created with
  `VK_BUFFER_CREATE_SPARSE_BINDING_BIT` and
  `VK_IMAGE_CREATE_SPARSE_BINDING_BIT` set in the `flags` member
  of the [VkBufferCreateInfo](/man/VkBufferCreateInfo) and [VkImageCreateInfo](/man/VkImageCreateInfo) structures,
  respectively.
  Otherwise resource memory :normative{type="can"} be managed as described in
  Sparse Resource Features.

- [features-sparseResidencyBuffer](#features-sparseResidencyBuffer) `sparseResidencyBuffer` specifies
  whether the device :normative{type="can"} access partially resident buffers.
  If this feature is not enabled, buffers :normative{type="must"} not be created with
  `VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT` set in the `flags`
  member of the [VkBufferCreateInfo](/man/VkBufferCreateInfo) structure.

- [features-sparseResidencyImage2D](#features-sparseResidencyImage2D) `sparseResidencyImage2D`
  specifies whether the device :normative{type="can"} access partially resident 2D images
  with 1 sample per pixel.
  If this feature is not enabled, images with an `imageType` of
  `VK_IMAGE_TYPE_2D` and `samples` set to
  `VK_SAMPLE_COUNT_1_BIT` :normative{type="must"} not be created with
  `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` set in the `flags` member
  of the [VkImageCreateInfo](/man/VkImageCreateInfo) structure.

- [features-sparseResidencyImage3D](#features-sparseResidencyImage3D) `sparseResidencyImage3D`
  specifies whether the device :normative{type="can"} access partially resident 3D images.
  If this feature is not enabled, images with an `imageType` of
  `VK_IMAGE_TYPE_3D` :normative{type="must"} not be created with
  `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` set in the `flags` member
  of the [VkImageCreateInfo](/man/VkImageCreateInfo) structure.

- [features-sparseResidency2Samples](#features-sparseResidency2Samples) `sparseResidency2Samples`
  specifies whether the physical device :normative{type="can"} access partially resident 2D
  images with 2 samples per pixel.
  If this feature is not enabled, images with an `imageType` of
  `VK_IMAGE_TYPE_2D` and `samples` set to
  `VK_SAMPLE_COUNT_2_BIT` :normative{type="must"} not be created with
  `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` set in the `flags` member
  of the [VkImageCreateInfo](/man/VkImageCreateInfo) structure.

- [features-sparseResidency4Samples](#features-sparseResidency4Samples) `sparseResidency4Samples`
  specifies whether the physical device :normative{type="can"} access partially resident 2D
  images with 4 samples per pixel.
  If this feature is not enabled, images with an `imageType` of
  `VK_IMAGE_TYPE_2D` and `samples` set to
  `VK_SAMPLE_COUNT_4_BIT` :normative{type="must"} not be created with
  `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` set in the `flags` member
  of the [VkImageCreateInfo](/man/VkImageCreateInfo) structure.

- [features-sparseResidency8Samples](#features-sparseResidency8Samples) `sparseResidency8Samples`
  specifies whether the physical device :normative{type="can"} access partially resident 2D
  images with 8 samples per pixel.
  If this feature is not enabled, images with an `imageType` of
  `VK_IMAGE_TYPE_2D` and `samples` set to
  `VK_SAMPLE_COUNT_8_BIT` :normative{type="must"} not be created with
  `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` set in the `flags` member
  of the [VkImageCreateInfo](/man/VkImageCreateInfo) structure.

- [features-sparseResidency16Samples](#features-sparseResidency16Samples) `sparseResidency16Samples`
  specifies whether the physical device :normative{type="can"} access partially resident 2D
  images with 16 samples per pixel.
  If this feature is not enabled, images with an `imageType` of
  `VK_IMAGE_TYPE_2D` and `samples` set to
  `VK_SAMPLE_COUNT_16_BIT` :normative{type="must"} not be created with
  `VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT` set in the `flags` member
  of the [VkImageCreateInfo](/man/VkImageCreateInfo) structure.

- [features-sparseResidencyAliased](#features-sparseResidencyAliased) `sparseResidencyAliased`
  specifies whether the physical device :normative{type="can"} correctly access data aliased
  into multiple locations.
  If this feature is not enabled, the
  `VK_BUFFER_CREATE_SPARSE_ALIASED_BIT` and
  `VK_IMAGE_CREATE_SPARSE_ALIASED_BIT` enum values :normative{type="must"} not be used
  in `flags` members of the [VkBufferCreateInfo](/man/VkBufferCreateInfo) and
  [VkImageCreateInfo](/man/VkImageCreateInfo) structures, respectively.

- [features-variableMultisampleRate](#features-variableMultisampleRate) `variableMultisampleRate`
  specifies whether all pipelines that will be bound to a command buffer
  during a subpass which uses no attachments
  :normative{type="must"} have the same value for
  [VkPipelineMultisampleStateCreateInfo](/man/VkPipelineMultisampleStateCreateInfo)::`rasterizationSamples`.
  If set to `VK_TRUE`, the implementation supports variable
  multisample rates in a subpass which uses no attachments.
  If set to `VK_FALSE`, then all pipelines bound in such a subpass
  :normative{type="must"} have the same multisample rate.
  This has no effect in situations where a subpass uses any attachments.

- [features-inheritedQueries](#features-inheritedQueries) `inheritedQueries` specifies whether a
  secondary command buffer :normative{type="may"} be executed while a query is active.

[features-nullDescriptor](#features-nullDescriptor) nullDescriptor support requires the
&#x20;extension.



## Feature Requirements

All Vulkan graphics implementations :normative{type="must"} support the following features:

- `robustBufferAccess`

All other features defined in the Specification are :normative{type="optional"}.







# Limits

*Limits* are implementation-dependent minimums, maximums, and other device
characteristics that an application :normative{type="may"} need to be aware of.

The `VkPhysicalDeviceLimits` structure is defined as:

[{generated}/api/structs/VkPhysicalDeviceLimits.adoc]({generated}/api/structs/VkPhysicalDeviceLimits.adoc)

The `VkPhysicalDeviceLimits` are properties of the physical device.
These are available in the `limits` member of the
[VkPhysicalDeviceProperties](/man/VkPhysicalDeviceProperties) structure which is returned from
[vkGetPhysicalDeviceProperties](/man/vkGetPhysicalDeviceProperties).

- [limits-maxImageDimension1D](#limits-maxImageDimension1D) `maxImageDimension1D` is the largest
  dimension (`width`) that is guaranteed to be supported for all
  images created with an `imageType` of `VK_IMAGE_TYPE_1D`.
  Some combinations of image parameters (format, usage, etc.) :normative{type="may"} allow
  support for larger dimensions, which :normative{type="can"} be queried using
  [vkGetPhysicalDeviceImageFormatProperties](/man/vkGetPhysicalDeviceImageFormatProperties).

- [limits-maxImageDimension2D](#limits-maxImageDimension2D) `maxImageDimension2D` is the largest
  dimension (`width` or `height`) that is guaranteed to be
  supported for all images created with an `imageType` of
  `VK_IMAGE_TYPE_2D` and without
  `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT` set in `flags`.
  Some combinations of image parameters (format, usage, etc.) :normative{type="may"} allow
  support for larger dimensions, which :normative{type="can"} be queried using
  [vkGetPhysicalDeviceImageFormatProperties](/man/vkGetPhysicalDeviceImageFormatProperties).

- [limits-maxImageDimension3D](#limits-maxImageDimension3D) `maxImageDimension3D` is the largest
  dimension (`width`, `height`, or `depth`) that is guaranteed
  to be supported for all images created with an `imageType` of
  `VK_IMAGE_TYPE_3D`.
  Some combinations of image parameters (format, usage, etc.) :normative{type="may"} allow
  support for larger dimensions, which :normative{type="can"} be queried using
  [vkGetPhysicalDeviceImageFormatProperties](/man/vkGetPhysicalDeviceImageFormatProperties).

- [limits-maxImageDimensionCube](#limits-maxImageDimensionCube) `maxImageDimensionCube` is the
  largest dimension (`width` or `height`) that is guaranteed to be
  supported for all images created with an `imageType` of
  `VK_IMAGE_TYPE_2D` and with
  `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT` set in `flags`.
  Some combinations of image parameters (format, usage, etc.) :normative{type="may"} allow
  support for larger dimensions, which :normative{type="can"} be queried using
  [vkGetPhysicalDeviceImageFormatProperties](/man/vkGetPhysicalDeviceImageFormatProperties).

- [limits-maxImageArrayLayers](#limits-maxImageArrayLayers) `maxImageArrayLayers` is the maximum
  number of layers (`arrayLayers`) for an image.

- [limits-maxTexelBufferElements](#limits-maxTexelBufferElements) `maxTexelBufferElements` is the
  maximum number of addressable texels for a buffer view created on a
  buffer which was created with the
  `VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT` or
  `VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT` set in the `usage`
  member of the [VkBufferCreateInfo](/man/VkBufferCreateInfo) structure.

- [limits-maxUniformBufferRange](#limits-maxUniformBufferRange) `maxUniformBufferRange` is the
  maximum value that :normative{type="can"} be specified in the `range` member of a
  [VkDescriptorBufferInfo](/man/VkDescriptorBufferInfo) structure passed to
  [vkUpdateDescriptorSets](/man/vkUpdateDescriptorSets) for descriptors of type
  `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or
  `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`.

- [limits-maxStorageBufferRange](#limits-maxStorageBufferRange) `maxStorageBufferRange` is the
  maximum value that :normative{type="can"} be specified in the `range` member of a
  [VkDescriptorBufferInfo](/man/VkDescriptorBufferInfo) structure passed to
  [vkUpdateDescriptorSets](/man/vkUpdateDescriptorSets) for descriptors of type
  `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or
  `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`.

- [limits-maxPushConstantsSize](#limits-maxPushConstantsSize) `maxPushConstantsSize` is the
  maximum size, in bytes, of the pool of push constant memory.
  For each of the push constant ranges indicated by the
  `pPushConstantRanges` member of the [VkPipelineLayoutCreateInfo](/man/VkPipelineLayoutCreateInfo)
  structure, (`offset` +  `size`) :normative{type="must"} be less than or
  equal to this limit.

- [limits-maxMemoryAllocationCount](#limits-maxMemoryAllocationCount) `maxMemoryAllocationCount` is
  the maximum number of device memory allocations, as created by
  [vkAllocateMemory](/man/vkAllocateMemory), which :normative{type="can"} simultaneously exist.

- [limits-maxSamplerAllocationCount](#limits-maxSamplerAllocationCount) `maxSamplerAllocationCount` is
  the maximum number of sampler objects, as created by
  [vkCreateSampler](/man/vkCreateSampler), which :normative{type="can"} simultaneously exist on a device.

- [limits-bufferImageGranularity](#limits-bufferImageGranularity) `bufferImageGranularity` is the
  granularity, in bytes, at which buffer or linear image resources, and
  optimal image resources :normative{type="can"} be bound to adjacent offsets in the same
  `VkDeviceMemory` object without aliasing.
  See Buffer-Image Granularity for
  more details.

- [limits-sparseAddressSpaceSize](#limits-sparseAddressSpaceSize) `sparseAddressSpaceSize` is the
  total amount of address space available, in bytes, for sparse memory
  resources.
  This is an upper bound on the sum of the sizes of all sparse resources,
  regardless of whether any memory is bound to them.

- [limits-maxBoundDescriptorSets](#limits-maxBoundDescriptorSets) `maxBoundDescriptorSets` is the
  maximum number of descriptor sets that :normative{type="can"} be simultaneously used by a
  pipeline.
  All `DescriptorSet` decorations in shader modules :normative{type="must"} have a value
  less than `maxBoundDescriptorSets`.
  See .

- [limits-maxPerStageDescriptorSamplers](#limits-maxPerStageDescriptorSamplers)

  `maxPerStageDescriptorSamplers` is the maximum number of samplers
  that :normative{type="can"} be accessible to a single shader stage in a pipeline layout.
  Descriptors with a type of `VK_DESCRIPTOR_TYPE_SAMPLER` or
  `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` count against this
  limit.
  A descriptor is accessible to a shader stage when the `stageFlags`
  member of the `VkDescriptorSetLayoutBinding` structure has the bit
  for that shader stage set.
  See  and
  .

- [limits-maxPerStageDescriptorUniformBuffers](#limits-maxPerStageDescriptorUniformBuffers)

  `maxPerStageDescriptorUniformBuffers` is the maximum number of
  uniform buffers that :normative{type="can"} be accessible to a single shader stage in a
  pipeline layout.
  Descriptors with a type of `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or
  `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` count against this
  limit.
  A descriptor is accessible to a shader stage when the `stageFlags`
  member of the `VkDescriptorSetLayoutBinding` structure has the bit
  for that shader stage set.
  See  and
  .

- [limits-maxPerStageDescriptorStorageBuffers](#limits-maxPerStageDescriptorStorageBuffers)

  `maxPerStageDescriptorStorageBuffers` is the maximum number of
  storage buffers that :normative{type="can"} be accessible to a single shader stage in a
  pipeline layout.
  Descriptors with a type of `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or
  `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC` count against this
  limit.
  A descriptor is accessible to a pipeline shader stage when the
  `stageFlags` member of the `VkDescriptorSetLayoutBinding`
  structure has the bit for that shader stage set.
  See  and
  .

- [limits-maxPerStageDescriptorSampledImages](#limits-maxPerStageDescriptorSampledImages)

  `maxPerStageDescriptorSampledImages` is the maximum number of
  sampled images that :normative{type="can"} be accessible to a single shader stage in a
  pipeline layout.
  Descriptors with a type of
  `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`,
  `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`, or
  `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER` count against this limit.
  A descriptor is accessible to a pipeline shader stage when the
  `stageFlags` member of the `VkDescriptorSetLayoutBinding`
  structure has the bit for that shader stage set.
  See ,
  , and
  .

- [limits-maxPerStageDescriptorStorageImages](#limits-maxPerStageDescriptorStorageImages)

  `maxPerStageDescriptorStorageImages` is the maximum number of
  storage images that :normative{type="can"} be accessible to a single shader stage in a
  pipeline layout.
  Descriptors with a type of `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`, or
  `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` count against this limit.
  A descriptor is accessible to a pipeline shader stage when the
  `stageFlags` member of the `VkDescriptorSetLayoutBinding`
  structure has the bit for that shader stage set.
  See , and
  .

- [limits-maxPerStageDescriptorInputAttachments](#limits-maxPerStageDescriptorInputAttachments)

  `maxPerStageDescriptorInputAttachments` is the maximum number of
  input attachments that :normative{type="can"} be accessible to a single shader stage in a
  pipeline layout.
  Descriptors with a type of `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`
  count against this limit.
  A descriptor is accessible to a pipeline shader stage when the
  `stageFlags` member of the `VkDescriptorSetLayoutBinding`
  structure has the bit for that shader stage set.
  These are only supported for the fragment stage.
  See .

- [limits-maxPerStageResources](#limits-maxPerStageResources) `maxPerStageResources` is the
  maximum number of resources that :normative{type="can"} be accessible to a single shader
  stage in a pipeline layout.
  Descriptors with a type of
  `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`,
  `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`,
  `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`,
  `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER`,
  `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER`,
  `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER`,
  `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER`,
  `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC`,
  `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC`, or
  `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT` count against this limit.
  For the fragment shader stage the framebuffer color attachments also
  count against this limit.

- [limits-maxDescriptorSetSamplers](#limits-maxDescriptorSetSamplers) `maxDescriptorSetSamplers` is
  the maximum number of samplers that :normative{type="can"} be included in a pipeline
  layout.
  Descriptors with a type of `VK_DESCRIPTOR_TYPE_SAMPLER` or
  `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` count against this
  limit.
  See  and
  .

- [limits-maxDescriptorSetUniformBuffers](#limits-maxDescriptorSetUniformBuffers)

  `maxDescriptorSetUniformBuffers` is the maximum number of uniform
  buffers that :normative{type="can"} be included in a pipeline layout.
  Descriptors with a type of `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or
  `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` count against this
  limit.
  See  and
  .

- [limits-maxDescriptorSetUniformBuffersDynamic](#limits-maxDescriptorSetUniformBuffersDynamic)

  `maxDescriptorSetUniformBuffersDynamic` is the maximum number of
  dynamic uniform buffers that :normative{type="can"} be included in a pipeline layout.
  Descriptors with a type of
  `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` count against this
  limit.
  See .

- [limits-maxDescriptorSetStorageBuffers](#limits-maxDescriptorSetStorageBuffers)

  `maxDescriptorSetStorageBuffers` is the maximum number of storage
  buffers that :normative{type="can"} be included in a pipeline layout.
  Descriptors with a type of `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or
  `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC` count against this
  limit.
  See  and
  .

- [limits-maxDescriptorSetStorageBuffersDynamic](#limits-maxDescriptorSetStorageBuffersDynamic)

  `maxDescriptorSetStorageBuffersDynamic` is the maximum number of
  dynamic storage buffers that :normative{type="can"} be included in a pipeline layout.
  Descriptors with a type of
  `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC` count against this
  limit.
  See .

- [limits-maxDescriptorSetSampledImages](#limits-maxDescriptorSetSampledImages)

  `maxDescriptorSetSampledImages` is the maximum number of sampled
  images that :normative{type="can"} be included in a pipeline layout.
  Descriptors with a type of
  `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`,
  `VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE`, or
  `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER` count against this limit.
  See ,
  , and
  .

- [limits-maxDescriptorSetStorageImages](#limits-maxDescriptorSetStorageImages)

  `maxDescriptorSetStorageImages` is the maximum number of storage
  images that :normative{type="can"} be included in a pipeline layout.
  Descriptors with a type of `VK_DESCRIPTOR_TYPE_STORAGE_IMAGE`, or
  `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` count against this limit.
  See , and
  .

- [limits-maxDescriptorSetInputAttachments](#limits-maxDescriptorSetInputAttachments)

  `maxDescriptorSetInputAttachments` is the maximum number of input
  attachments that :normative{type="can"} be included in a pipeline layout.
  Descriptors with a type of `VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT`
  count against this limit.
  See .

- [limits-maxVertexInputAttributes](#limits-maxVertexInputAttributes) `maxVertexInputAttributes` is
  the maximum number of vertex input attributes that :normative{type="can"} be specified for
  a graphics pipeline.
  These are described in the array of
  `VkVertexInputAttributeDescription` structures that are provided at
  graphics pipeline creation time via the
  `pVertexAttributeDescriptions` member of the
  [VkPipelineVertexInputStateCreateInfo](/man/VkPipelineVertexInputStateCreateInfo) structure.
  See  and .

- [limits-maxVertexInputBindings](#limits-maxVertexInputBindings) `maxVertexInputBindings` is the
  maximum number of vertex buffers that :normative{type="can"} be specified for providing
  vertex attributes to a graphics pipeline.
  These are described in the array of
  `VkVertexInputBindingDescription` structures that are provided at
  graphics pipeline creation time via the `pVertexBindingDescriptions`
  member of the [VkPipelineVertexInputStateCreateInfo](/man/VkPipelineVertexInputStateCreateInfo) structure.
  The `binding` member of `VkVertexInputBindingDescription` :normative{type="must"}
  be less than this limit.
  See .

- [limits-maxVertexInputAttributeOffset](#limits-maxVertexInputAttributeOffset)

  `maxVertexInputAttributeOffset` is the maximum vertex input
  attribute offset that :normative{type="can"} be added to the vertex input binding stride.
  The `offset` member of the `VkVertexInputAttributeDescription`
  structure :normative{type="must"} be less than or equal to this limit.
  See .

- [limits-maxVertexInputBindingStride](#limits-maxVertexInputBindingStride) `maxVertexInputBindingStride`
  is the maximum vertex input binding stride that :normative{type="can"} be specified in a
  vertex input binding.
  The `stride` member of the `VkVertexInputBindingDescription`
  structure :normative{type="must"} be less than or equal to this limit.
  See .

- [limits-maxVertexOutputComponents](#limits-maxVertexOutputComponents) `maxVertexOutputComponents` is
  the maximum number of components of output variables which :normative{type="can"} be
  output by a vertex shader.
  See .

- [limits-maxTessellationGenerationLevel](#limits-maxTessellationGenerationLevel)

  `maxTessellationGenerationLevel` is the maximum tessellation
  generation level supported by the fixed-function tessellation primitive
  generator.
  See .

- [limits-maxTessellationPatchSize](#limits-maxTessellationPatchSize) `maxTessellationPatchSize` is
  the maximum patch size, in vertices, of patches that :normative{type="can"} be processed
  by the tessellation control shader and tessellation primitive generator.
  The `patchControlPoints` member of the
  [VkPipelineTessellationStateCreateInfo](/man/VkPipelineTessellationStateCreateInfo) structure specified at
  pipeline creation time and the value provided in the `OutputVertices`
  execution mode of shader modules :normative{type="must"} be less than or equal to this
  limit.
  See .

- [limits-maxTessellationControlPerVertexInputComponents](#limits-maxTessellationControlPerVertexInputComponents)

  `maxTessellationControlPerVertexInputComponents` is the maximum
  number of components of input variables which :normative{type="can"} be provided as
  per-vertex inputs to the tessellation control shader stage.

- [limits-maxTessellationControlPerVertexOutputComponents](#limits-maxTessellationControlPerVertexOutputComponents)

  `maxTessellationControlPerVertexOutputComponents` is the maximum
  number of components of per-vertex output variables which :normative{type="can"} be output
  from the tessellation control shader stage.

- [limits-maxTessellationControlPerPatchOutputComponents](#limits-maxTessellationControlPerPatchOutputComponents)

  `maxTessellationControlPerPatchOutputComponents` is the maximum
  number of components of per-patch output variables which :normative{type="can"} be output
  from the tessellation control shader stage.

- [limits-maxTessellationControlTotalOutputComponents](#limits-maxTessellationControlTotalOutputComponents)

  `maxTessellationControlTotalOutputComponents` is the maximum total
  number of components of per-vertex and per-patch output variables which
  :normative{type="can"} be output from the tessellation control shader stage.

- [limits-maxTessellationEvaluationInputComponents](#limits-maxTessellationEvaluationInputComponents)

  `maxTessellationEvaluationInputComponents` is the maximum number of
  components of input variables which :normative{type="can"} be provided as per-vertex
  inputs to the tessellation evaluation shader stage.

- [limits-maxTessellationEvaluationOutputComponents](#limits-maxTessellationEvaluationOutputComponents)

  `maxTessellationEvaluationOutputComponents` is the maximum number of
  components of per-vertex output variables which :normative{type="can"} be output from the
  tessellation evaluation shader stage.

- [limits-maxGeometryShaderInvocations](#limits-maxGeometryShaderInvocations)

  `maxGeometryShaderInvocations` is the maximum invocation count
  supported for instanced geometry shaders.
  The value provided in the `Invocations` execution mode of shader
  modules :normative{type="must"} be less than or equal to this limit.
  See .

- [limits-maxGeometryInputComponents](#limits-maxGeometryInputComponents) `maxGeometryInputComponents`
  is the maximum number of components of input variables which :normative{type="can"} be
  provided as inputs to the geometry shader stage.

- [limits-maxGeometryOutputComponents](#limits-maxGeometryOutputComponents) `maxGeometryOutputComponents`
  is the maximum number of components of output variables which :normative{type="can"} be
  output from the geometry shader stage.

- [limits-maxGeometryOutputVertices](#limits-maxGeometryOutputVertices) `maxGeometryOutputVertices` is
  the maximum number of vertices which :normative{type="can"} be emitted by any geometry
  shader.

- [limits-maxGeometryTotalOutputComponents](#limits-maxGeometryTotalOutputComponents)

  `maxGeometryTotalOutputComponents` is the maximum total number of
  components of output variables, across all emitted vertices, which :normative{type="can"}
  be output from the geometry shader stage.

- [limits-maxFragmentInputComponents](#limits-maxFragmentInputComponents) `maxFragmentInputComponents`
  is the maximum number of components of input variables which :normative{type="can"} be
  provided as inputs to the fragment shader stage.

- [limits-maxFragmentOutputAttachments](#limits-maxFragmentOutputAttachments)

  `maxFragmentOutputAttachments` is the maximum number of output
  attachments which :normative{type="can"} be written to by the fragment shader stage.

- [limits-maxFragmentDualSrcAttachments](#limits-maxFragmentDualSrcAttachments)

  `maxFragmentDualSrcAttachments` is the maximum number of output
  attachments which :normative{type="can"} be written to by the fragment shader stage when
  blending is enabled and one of the dual source blend modes is in use.
  See  and `dualSrcBlend`.

- [limits-maxFragmentCombinedOutputResources](#limits-maxFragmentCombinedOutputResources)

  `maxFragmentCombinedOutputResources` is the total number of storage
  buffers, storage images, and output `Location` decorated color
  attachments (described in Fragment Output
  Interface) which :normative{type="can"} be used in the fragment shader stage.

- [limits-maxComputeSharedMemorySize](#limits-maxComputeSharedMemorySize) `maxComputeSharedMemorySize`
  is the maximum total storage size, in bytes, available for variables
  declared with the `Workgroup` storage class in shader modules (or
  with the `shared` storage qualifier in GLSL) in the compute shader
  stage.

- [limits-maxComputeWorkGroupCount](#limits-maxComputeWorkGroupCount) `maxComputeWorkGroupCount`\[3] is
  the maximum number of local workgroups that :normative{type="can"} be dispatched by a
  single dispatching command.
  These three values represent the maximum number of local workgroups for
  the X, Y, and Z dimensions, respectively.
  The workgroup count parameters to the dispatching commands :normative{type="must"} be less
  than or equal to the corresponding limit.
  See .

- [limits-maxComputeWorkGroupInvocations](#limits-maxComputeWorkGroupInvocations)

  `maxComputeWorkGroupInvocations` is the maximum total number of
  compute shader invocations in a single local workgroup.
  The product of the X, Y, and Z sizes, as specified by the `LocalSize`
  execution mode in shader modules or by the object decorated by the
  `WorkgroupSize` decoration, :normative{type="must"} be less than or equal to this
  limit.

- [limits-maxComputeWorkGroupSize](#limits-maxComputeWorkGroupSize) `maxComputeWorkGroupSize`\[3] is
  the maximum size of a local compute workgroup, per dimension.
  These three values represent the maximum local workgroup size in the X,
  Y, and Z dimensions, respectively.
  The `x`, `y`, and `z` sizes, as specified by the
  `LocalSize`
  execution mode or by the object decorated by the `WorkgroupSize`
  decoration in shader modules, :normative{type="must"} be less than or equal to the
  corresponding limit.

- [limits-subPixelPrecisionBits](#limits-subPixelPrecisionBits) `subPixelPrecisionBits` is the
  number of bits of subpixel precision in framebuffer coordinates
  x\<sub>f\</sub> and y\<sub>f\</sub>.
  See .

- [limits-subTexelPrecisionBits](#limits-subTexelPrecisionBits) `subTexelPrecisionBits` is the
  number of bits of precision in the division along an axis of an image
  used for minification and magnification filters.
  2\<sup>`subTexelPrecisionBits`\</sup> is the actual number of divisions
  along each axis of the image represented.
  Sub-texel values calculated during image sampling will snap to these
  locations when generating the filtered results.

- [limits-mipmapPrecisionBits](#limits-mipmapPrecisionBits) `mipmapPrecisionBits` is the number
  of bits of division that the LOD calculation for mipmap fetching get
  snapped to when determining the contribution from each mip level to the
  mip filtered results.
  2\<sup>`mipmapPrecisionBits`\</sup> is the actual number of divisions.

- [limits-maxDrawIndexedIndexValue](#limits-maxDrawIndexedIndexValue) `maxDrawIndexedIndexValue` is
  the maximum index value that :normative{type="can"} be used for indexed draw calls when
  using 32-bit indices.
  This excludes the primitive restart index value of 0xFFFFFFFF.
  See `fullDrawIndexUint32`.

- [limits-maxDrawIndirectCount](#limits-maxDrawIndirectCount) `maxDrawIndirectCount` is the
  maximum draw count that is supported for indirect drawing calls.
  See `multiDrawIndirect`.

- [limits-maxSamplerLodBias](#limits-maxSamplerLodBias) `maxSamplerLodBias` is the maximum
  absolute sampler LOD bias.
  The sum of the `mipLodBias` member of the [VkSamplerCreateInfo](/man/VkSamplerCreateInfo)
  structure and the `Bias` operand of image sampling operations in
  shader modules (or 0 if no `Bias` operand is provided to an image
  sampling operation) are clamped to the range
  \[-`maxSamplerLodBias`,+`maxSamplerLodBias`].
  See .

- [limits-maxSamplerAnisotropy](#limits-maxSamplerAnisotropy) `maxSamplerAnisotropy` is the
  maximum degree of sampler anisotropy.
  The maximum degree of anisotropic filtering used for an image sampling
  operation is the minimum of the `maxAnisotropy` member of the
  [VkSamplerCreateInfo](/man/VkSamplerCreateInfo) structure and this limit.
  See .

- [limits-maxViewports](#limits-maxViewports) `maxViewports` is the maximum number of
  active viewports.
  The `viewportCount` member of the
  [VkPipelineViewportStateCreateInfo](/man/VkPipelineViewportStateCreateInfo) structure that is provided at
  pipeline creation :normative{type="must"} be less than or equal to this limit.

- [limits-maxViewportDimensions](#limits-maxViewportDimensions) `maxViewportDimensions`\[2] are the
  maximum viewport dimensions in the X (width) and Y (height) dimensions,
  respectively.
  The maximum viewport dimensions :normative{type="must"} be greater than or equal to the
  largest image which :normative{type="can"} be created and used as a framebuffer
  attachment.
  See Controlling the Viewport.

- [limits-viewportboundsrange](#limits-viewportboundsrange) `viewportBoundsRange`\[2] is the
  \[minimum, maximum] range that the corners of a viewport :normative{type="must"} be
  contained in.
  This range :normative{type="must"} be at least \[-2 × `size`, 2 ×
  `size` - 1], where `size` =
  max(`maxViewportDimensions`\[0], `maxViewportDimensions`\[1]).
  See Controlling the Viewport.






  ::note


  The intent of the `viewportBoundsRange` limit is to allow a maximum
  sized viewport to be arbitrarily shifted relative to the output target as
  long as at least some portion intersects.
  This would give a bounds limit of \[-`size` +  1, 2 ×
  `size` - 1] which would allow all possible non-empty-set intersections
  of the output target and the viewport.
  Since these numbers are typically powers of two, picking the signed number
  range using the smallest possible number of bits ends up with the specified
  range.


  ::


- [limits-viewportSubPixelBits](#limits-viewportSubPixelBits) `viewportSubPixelBits` is the number
  of bits of subpixel precision for viewport bounds.
  The subpixel precision that floating-point viewport bounds are
  interpreted at is given by this limit.

- [limits-minMemoryMapAlignment](#limits-minMemoryMapAlignment) `minMemoryMapAlignment` is the
  minimum :normative{type="required"} alignment, in bytes, of host visible memory
  allocations within the host address space.
  When mapping a memory allocation with [vkMapMemory](/man/vkMapMemory), subtracting
  `offset` bytes from the returned pointer will always produce an
  integer multiple of this limit.
  See .
  The value :normative{type="must"} be a power of two.

- [limits-minTexelBufferOffsetAlignment](#limits-minTexelBufferOffsetAlignment)

  `minTexelBufferOffsetAlignment` is the minimum :normative{type="required"} alignment,
  in bytes, for the `offset` member of the
  [VkBufferViewCreateInfo](/man/VkBufferViewCreateInfo) structure for texel buffers.
  The value :normative{type="must"} be a power of two.
  [VkBufferViewCreateInfo](/man/VkBufferViewCreateInfo)::`offset` :normative{type="must"} be a multiple of this
  value.

- [limits-minUniformBufferOffsetAlignment](#limits-minUniformBufferOffsetAlignment)

  `minUniformBufferOffsetAlignment` is the minimum :normative{type="required"}
  alignment, in bytes, for the `offset` member of the
  `VkDescriptorBufferInfo` structure for uniform buffers.
  When a descriptor of type `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER` or
  `VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC` is updated, the
  `offset` :normative{type="must"} be an integer multiple of this limit.
  Similarly, dynamic offsets for uniform buffers :normative{type="must"} be multiples of
  this limit.
  The value :normative{type="must"} be a power of two.

- [limits-minStorageBufferOffsetAlignment](#limits-minStorageBufferOffsetAlignment)

  `minStorageBufferOffsetAlignment` is the minimum :normative{type="required"}
  alignment, in bytes, for the `offset` member of the
  `VkDescriptorBufferInfo` structure for storage buffers.
  When a descriptor of type `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER` or
  `VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC` is updated, the
  `offset` :normative{type="must"} be an integer multiple of this limit.
  Similarly, dynamic offsets for storage buffers :normative{type="must"} be multiples of
  this limit.
  The value :normative{type="must"} be a power of two.

- [limits-minTexelOffset](#limits-minTexelOffset) `minTexelOffset` is the minimum offset
  value for the `ConstOffset` image operand of any of the
  `OpImageSample*` or `OpImageFetch*` image instructions.

- [limits-maxTexelOffset](#limits-maxTexelOffset) `maxTexelOffset` is the maximum offset
  value for the `ConstOffset` image operand of any of the
  `OpImageSample*` or `OpImageFetch*` image instructions.

- [limits-minTexelGatherOffset](#limits-minTexelGatherOffset) `minTexelGatherOffset` is the
  minimum offset value for the `Offset`, `ConstOffset`, or
  `ConstOffsets` image operands of any of the `OpImage*Gather` image
  instructions.

- [limits-maxTexelGatherOffset](#limits-maxTexelGatherOffset) `maxTexelGatherOffset` is the
  maximum offset value for the `Offset`, `ConstOffset`, or
  `ConstOffsets` image operands of any of the `OpImage*Gather` image
  instructions.

- [limits-minInterpolationOffset](#limits-minInterpolationOffset) `minInterpolationOffset` is the
  base minimum (inclusive) negative offset value for the `Offset`
  operand of the `InterpolateAtOffset` extended instruction.

- [limits-maxInterpolationOffset](#limits-maxInterpolationOffset) `maxInterpolationOffset` is the
  base maximum (inclusive) positive offset value for the `Offset`
  operand of the `InterpolateAtOffset` extended instruction.

- [limits-subPixelInterpolationOffsetBits](#limits-subPixelInterpolationOffsetBits)

  `subPixelInterpolationOffsetBits` is the number of fractional bits
  that the `x` and `y` offsets to the `InterpolateAtOffset`
  extended instruction :normative{type="may"} be rounded to as fixed-point values.

- [limits-maxFramebufferWidth](#limits-maxFramebufferWidth) `maxFramebufferWidth` is the maximum
  width for a framebuffer.
  The `width` member of the [VkFramebufferCreateInfo](/man/VkFramebufferCreateInfo) structure
  :normative{type="must"} be less than or equal to this limit.

- [limits-maxFramebufferHeight](#limits-maxFramebufferHeight) `maxFramebufferHeight` is the
  maximum height for a framebuffer.
  The `height` member of the [VkFramebufferCreateInfo](/man/VkFramebufferCreateInfo) structure
  :normative{type="must"} be less than or equal to this limit.

- [limits-maxFramebufferLayers](#limits-maxFramebufferLayers) `maxFramebufferLayers` is the
  maximum layer count for a layered framebuffer.
  The `layers` member of the [VkFramebufferCreateInfo](/man/VkFramebufferCreateInfo) structure
  :normative{type="must"} be less than or equal to this limit.

- [limits-framebufferColorSampleCounts](#limits-framebufferColorSampleCounts)

  `framebufferColorSampleCounts` is a bitmask\<sup>1\</sup> of
  [VkSampleCountFlagBits](/man/VkSampleCountFlagBits) indicating the color sample counts that are
  supported for all framebuffer color attachments with floating- or
  fixed-point formats.
  There is no limit specifying the color sample counts that are supported
  for all color attachments with integer formats.

- [limits-framebufferDepthSampleCounts](#limits-framebufferDepthSampleCounts)

  `framebufferDepthSampleCounts` is a bitmask\<sup>1\</sup> of
  [VkSampleCountFlagBits](/man/VkSampleCountFlagBits) indicating the supported depth sample counts
  for all framebuffer depth/stencil attachments, when the format includes
  a depth component.

- [limits-framebufferStencilSampleCounts](#limits-framebufferStencilSampleCounts)

  `framebufferStencilSampleCounts` is a bitmask\<sup>1\</sup> of
  [VkSampleCountFlagBits](/man/VkSampleCountFlagBits) indicating the supported stencil sample
  counts for all framebuffer depth/stencil attachments, when the format
  includes a stencil component.

- [limits-framebufferNoAttachmentsSampleCounts](#limits-framebufferNoAttachmentsSampleCounts)

  `framebufferNoAttachmentsSampleCounts` is a bitmask\<sup>1\</sup> of
  [VkSampleCountFlagBits](/man/VkSampleCountFlagBits) indicating the supported sample counts for a
  subpass which uses no attachments.

- [limits-maxColorAttachments](#limits-maxColorAttachments) `maxColorAttachments` is the maximum
  number of color attachments that :normative{type="can"} be used by a subpass in a render
  pass.
  The `colorAttachmentCount` member of the `VkSubpassDescription`
  structure :normative{type="must"} be less than or equal to this limit.

- [limits-sampledImageColorSampleCounts](#limits-sampledImageColorSampleCounts)

  `sampledImageColorSampleCounts` is a bitmask\<sup>1\</sup> of
  [VkSampleCountFlagBits](/man/VkSampleCountFlagBits) indicating the sample counts supported for
  all 2D images created with `VK_IMAGE_TILING_OPTIMAL`, `usage`
  containing `VK_IMAGE_USAGE_SAMPLED_BIT`, and a non-integer color
  format.

- [limits-sampledImageIntegerSampleCounts](#limits-sampledImageIntegerSampleCounts)

  `sampledImageIntegerSampleCounts` is a bitmask\<sup>1\</sup> of
  [VkSampleCountFlagBits](/man/VkSampleCountFlagBits) indicating the sample counts supported for
  all 2D images created with `VK_IMAGE_TILING_OPTIMAL`, `usage`
  containing `VK_IMAGE_USAGE_SAMPLED_BIT`, and an integer color
  format.

- [limits-sampledImageDepthSampleCounts](#limits-sampledImageDepthSampleCounts)

  `sampledImageDepthSampleCounts` is a bitmask\<sup>1\</sup> of
  [VkSampleCountFlagBits](/man/VkSampleCountFlagBits) indicating the sample counts supported for
  all 2D images created with `VK_IMAGE_TILING_OPTIMAL`, `usage`
  containing `VK_IMAGE_USAGE_SAMPLED_BIT`, and a depth format.

- [limits-sampledImageStencilSampleCounts](#limits-sampledImageStencilSampleCounts)

  `sampledImageStencilSampleCounts` is a bitmask\<sup>1\</sup> of
  [VkSampleCountFlagBits](/man/VkSampleCountFlagBits) indicating the sample counts supported for
  all 2D images created with `VK_IMAGE_TILING_OPTIMAL`, `usage`
  containing `VK_IMAGE_USAGE_SAMPLED_BIT`, and a stencil format.

- [limits-storageImageSampleCounts](#limits-storageImageSampleCounts) `storageImageSampleCounts` is a
  bitmask\<sup>1\</sup> of [VkSampleCountFlagBits](/man/VkSampleCountFlagBits) indicating the sample counts
  supported for all 2D images created with `VK_IMAGE_TILING_OPTIMAL`,
  and `usage` containing `VK_IMAGE_USAGE_STORAGE_BIT`.

- [limits-maxSampleMaskWords](#limits-maxSampleMaskWords) `maxSampleMaskWords` is the maximum
  number of array elements of a variable decorated with the
  `SampleMask` built-in decoration.

- [limits-timestampComputeAndGraphics](#limits-timestampComputeAndGraphics) `timestampComputeAndGraphics`
  specifies support for timestamps on all graphics and compute queues.
  If this limit is set to `VK_TRUE`, all queues that advertise the
  `VK_QUEUE_GRAPHICS_BIT` or `VK_QUEUE_COMPUTE_BIT` in the
  `VkQueueFamilyProperties`::`queueFlags` support
  `VkQueueFamilyProperties`::`timestampValidBits` of at least 36.
  See Timestamp Queries.

- [limits-timestampPeriod](#limits-timestampPeriod) `timestampPeriod` is the number of
  nanoseconds :normative{type="required"} for a timestamp query to be incremented by 1.
  See Timestamp Queries.

- [limits-maxClipDistances](#limits-maxClipDistances) `maxClipDistances` is the maximum number
  of clip distances that :normative{type="can"} be used in a single shader stage.
  The size of any array declared with the `ClipDistance` built-in
  decoration in a shader module :normative{type="must"} be less than or equal to this limit.

- [limits-maxCullDistances](#limits-maxCullDistances) `maxCullDistances` is the maximum number
  of cull distances that :normative{type="can"} be used in a single shader stage.
  The size of any array declared with the `CullDistance` built-in
  decoration in a shader module :normative{type="must"} be less than or equal to this limit.

- [limits-maxCombinedClipAndCullDistances](#limits-maxCombinedClipAndCullDistances)

  `maxCombinedClipAndCullDistances` is the maximum combined number of
  clip and cull distances that :normative{type="can"} be used in a single shader stage.
  The sum of the sizes of any pair of arrays declared with the
  `ClipDistance` and `CullDistance` built-in decoration used by a
  single shader stage in a shader module :normative{type="must"} be less than or equal to
  this limit.

- [limits-discreteQueuePriorities](#limits-discreteQueuePriorities) `discreteQueuePriorities` is the
  number of discrete priorities that :normative{type="can"} be assigned to a queue based on
  the value of each member of
  [VkDeviceQueueCreateInfo](/man/VkDeviceQueueCreateInfo)::`pQueuePriorities`.
  This :normative{type="must"} be at least 2, and levels :normative{type="must"} be spread evenly over the
  range, with at least one level at 1.0, and another at 0.0.
  See .

- [limits-pointSizeRange](#limits-pointSizeRange) `pointSizeRange`\[2] is the range
  \[`minimum`,`maximum`] of supported sizes for points.
  Values written to variables decorated with the `PointSize` built-in
  decoration are clamped to this range.

- [limits-lineWidthRange](#limits-lineWidthRange) `lineWidthRange`\[2] is the range
  \[`minimum`,`maximum`] of supported widths for lines.
  Values specified by the `lineWidth` member of the
  [VkPipelineRasterizationStateCreateInfo](/man/VkPipelineRasterizationStateCreateInfo) or the `lineWidth`
  parameter to `vkCmdSetLineWidth` are clamped to this range.

- [limits-pointSizeGranularity](#limits-pointSizeGranularity) `pointSizeGranularity` is the
  granularity of supported point sizes.
  Not all point sizes in the range defined by `pointSizeRange` are
  supported.
  This limit specifies the granularity (or increment) between successive
  supported point sizes.

- [limits-lineWidthGranularity](#limits-lineWidthGranularity) `lineWidthGranularity` is the
  granularity of supported line widths.
  Not all line widths in the range defined by `lineWidthRange` are
  supported.
  This limit specifies the granularity (or increment) between successive
  supported line widths.

- [limits-strictLines](#limits-strictLines) `strictLines` specifies whether lines are
  rasterized according to the preferred method of rasterization.
  If set to `VK_FALSE`, lines :normative{type="may"} be rasterized under a relaxed set
  of rules.
  If set to `VK_TRUE`, lines are rasterized as per the strict
  definition.
  See Basic Line Segment Rasterization.

- [limits-standardSampleLocations](#limits-standardSampleLocations) `standardSampleLocations`
  specifies whether rasterization uses the standard sample locations as
  documented in Multisampling.
  If set to `VK_TRUE`, the implementation uses the documented sample
  locations.
  If set to `VK_FALSE`, the implementation :normative{type="may"} use different sample
  locations.

- [limits-optimalBufferCopyOffsetAlignment](#limits-optimalBufferCopyOffsetAlignment)

  `optimalBufferCopyOffsetAlignment` is the optimal buffer offset
  alignment in bytes for
  [vkCmdCopyBufferToImage](/man/vkCmdCopyBufferToImage) and [vkCmdCopyImageToBuffer](/man/vkCmdCopyImageToBuffer).
  The per texel alignment requirements are enforced, but applications
  :normative{type="should"} use the optimal alignment for optimal performance and power use.
  The value :normative{type="must"} be a power of two.

- [limits-optimalBufferCopyRowPitchAlignment](#limits-optimalBufferCopyRowPitchAlignment)

  `optimalBufferCopyRowPitchAlignment` is the optimal buffer row pitch
  alignment in bytes for
  [vkCmdCopyBufferToImage](/man/vkCmdCopyBufferToImage) and [vkCmdCopyImageToBuffer](/man/vkCmdCopyImageToBuffer).
  Row pitch is the number of bytes between texels with the same X
  coordinate in adjacent rows (Y coordinates differ by one).
  The per texel alignment requirements are enforced, but applications
  :normative{type="should"} use the optimal alignment for optimal performance and power use.
  The value :normative{type="must"} be a power of two.

- [limits-nonCoherentAtomSize](#limits-nonCoherentAtomSize) `nonCoherentAtomSize` is the size and
  alignment in bytes that bounds concurrent access to
  host-mapped device memory.
  The value :normative{type="must"} be a power of two.





Bits which :normative{type="may"} be set in the sample count limits returned by
[VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits), as well as in other queries and structures
representing image sample counts, are:

[{generated}/api/enums/VkSampleCountFlagBits.adoc]({generated}/api/enums/VkSampleCountFlagBits.adoc)

- `VK_SAMPLE_COUNT_1_BIT` specifies an image with one sample per
  pixel.

- `VK_SAMPLE_COUNT_2_BIT` specifies an image with 2 samples per pixel.

- `VK_SAMPLE_COUNT_4_BIT` specifies an image with 4 samples per pixel.

- `VK_SAMPLE_COUNT_8_BIT` specifies an image with 8 samples per pixel.

- `VK_SAMPLE_COUNT_16_BIT` specifies an image with 16 samples per
  pixel.

- `VK_SAMPLE_COUNT_32_BIT` specifies an image with 32 samples per
  pixel.

- `VK_SAMPLE_COUNT_64_BIT` specifies an image with 64 samples per
  pixel.

[{generated}/api/flags/VkSampleCountFlags.adoc]({generated}/api/flags/VkSampleCountFlags.adoc)

`VkSampleCountFlags` is a bitmask type for setting a mask of zero or
more [VkSampleCountFlagBits](/man/VkSampleCountFlagBits).



## Limit Requirements

The following table specifies the :normative{type="required"} minimum/maximum for all Vulkan
graphics implementations.
Where a limit corresponds to a fine-grained device feature which is
:normative{type="optional"}, the feature name is listed with two :normative{type="required"} limits, one when
the feature is supported and one when it is not supported.
If an implementation supports a feature, the limits reported are the same
whether or not the feature is enabled.













# Formats

Supported buffer and image formats :normative{type="may"} vary across implementations.
A minimum set of format features are guaranteed, but others :normative{type="must"} be
explicitly queried before use to ensure they are supported by the
implementation.

The features for the set of formats ([VkFormat](/man/VkFormat)) supported by the
implementation are queried individually using the
[vkGetPhysicalDeviceFormatProperties](/man/vkGetPhysicalDeviceFormatProperties) command.



## Format Definition

The following image formats :normative{type="can"} be passed to, and :normative{type="may"} be returned from
Vulkan commands.
The memory required to store each format is discussed with that format, and
also summarized in the Representation and Texel Block
Size section and the Compatible formats table.

[{generated}/api/enums/VkFormat.adoc]({generated}/api/enums/VkFormat.adoc)

- `VK_FORMAT_UNDEFINED` specifies that the format is not specified.

- `VK_FORMAT_R4G4_UNORM_PACK8` specifies a two-component, 8-bit packed
  unsigned normalized format that has a 4-bit R component in bits 4..7,
  and a 4-bit G component in bits 0..3.

- `VK_FORMAT_R4G4B4A4_UNORM_PACK16` specifies a four-component, 16-bit
  packed unsigned normalized format that has a 4-bit R component in bits
  12..15, a 4-bit G component in bits 8..11, a 4-bit B component in bits
  4..7, and a 4-bit A component in bits 0..3.

- `VK_FORMAT_B4G4R4A4_UNORM_PACK16` specifies a four-component, 16-bit
  packed unsigned normalized format that has a 4-bit B component in bits
  12..15, a 4-bit G component in bits 8..11, a 4-bit R component in bits
  4..7, and a 4-bit A component in bits 0..3.

- `VK_FORMAT_R5G6B5_UNORM_PACK16` specifies a three-component, 16-bit
  packed unsigned normalized format that has a 5-bit R component in bits
  11..15, a 6-bit G component in bits 5..10, and a 5-bit B component in
  bits 0..4.

- `VK_FORMAT_B5G6R5_UNORM_PACK16` specifies a three-component, 16-bit
  packed unsigned normalized format that has a 5-bit B component in bits
  11..15, a 6-bit G component in bits 5..10, and a 5-bit R component in
  bits 0..4.

- `VK_FORMAT_R5G5B5A1_UNORM_PACK16` specifies a four-component, 16-bit
  packed unsigned normalized format that has a 5-bit R component in bits
  11..15, a 5-bit G component in bits 6..10, a 5-bit B component in bits
  1..5, and a 1-bit A component in bit 0.

- `VK_FORMAT_B5G5R5A1_UNORM_PACK16` specifies a four-component, 16-bit
  packed unsigned normalized format that has a 5-bit B component in bits
  11..15, a 5-bit G component in bits 6..10, a 5-bit R component in bits
  1..5, and a 1-bit A component in bit 0.

- `VK_FORMAT_A1R5G5B5_UNORM_PACK16` specifies a four-component, 16-bit
  packed unsigned normalized format that has a 1-bit A component in bit
  15, a 5-bit R component in bits 10..14, a 5-bit G component in bits
  5..9, and a 5-bit B component in bits 0..4.

- `VK_FORMAT_R8_UNORM` specifies a one-component, 8-bit unsigned
  normalized format that has a single 8-bit R component.

- `VK_FORMAT_R8_SNORM` specifies a one-component, 8-bit signed
  normalized format that has a single 8-bit R component.

- `VK_FORMAT_R8_USCALED` specifies a one-component, 8-bit unsigned
  scaled integer format that has a single 8-bit R component.

- `VK_FORMAT_R8_SSCALED` specifies a one-component, 8-bit signed
  scaled integer format that has a single 8-bit R component.

- `VK_FORMAT_R8_UINT` specifies a one-component, 8-bit unsigned
  integer format that has a single 8-bit R component.

- `VK_FORMAT_R8_SINT` specifies a one-component, 8-bit signed integer
  format that has a single 8-bit R component.

- `VK_FORMAT_R8_SRGB` specifies a one-component, 8-bit unsigned
  normalized format that has a single 8-bit R component stored with sRGB
  nonlinear encoding.

- `VK_FORMAT_R8G8_UNORM` specifies a two-component, 16-bit unsigned
  normalized format that has an 8-bit R component in byte 0, and an 8-bit
  G component in byte 1.

- `VK_FORMAT_R8G8_SNORM` specifies a two-component, 16-bit signed
  normalized format that has an 8-bit R component in byte 0, and an 8-bit
  G component in byte 1.

- `VK_FORMAT_R8G8_USCALED` specifies a two-component, 16-bit unsigned
  scaled integer format that has an 8-bit R component in byte 0, and an
  8-bit G component in byte 1.

- `VK_FORMAT_R8G8_SSCALED` specifies a two-component, 16-bit signed
  scaled integer format that has an 8-bit R component in byte 0, and an
  8-bit G component in byte 1.

- `VK_FORMAT_R8G8_UINT` specifies a two-component, 16-bit unsigned
  integer format that has an 8-bit R component in byte 0, and an 8-bit G
  component in byte 1.

- `VK_FORMAT_R8G8_SINT` specifies a two-component, 16-bit signed
  integer format that has an 8-bit R component in byte 0, and an 8-bit G
  component in byte 1.

- `VK_FORMAT_R8G8_SRGB` specifies a two-component, 16-bit unsigned
  normalized format that has an 8-bit R component stored with sRGB
  nonlinear encoding in byte 0, and an 8-bit G component stored with sRGB
  nonlinear encoding in byte 1.

- `VK_FORMAT_R8G8B8_UNORM` specifies a three-component, 24-bit
  unsigned normalized format that has an 8-bit R component in byte 0, an
  8-bit G component in byte 1, and an 8-bit B component in byte 2.

- `VK_FORMAT_R8G8B8_SNORM` specifies a three-component, 24-bit signed
  normalized format that has an 8-bit R component in byte 0, an 8-bit G
  component in byte 1, and an 8-bit B component in byte 2.

- `VK_FORMAT_R8G8B8_USCALED` specifies a three-component, 24-bit
  unsigned scaled format that has an 8-bit R component in byte 0, an 8-bit
  G component in byte 1, and an 8-bit B component in byte 2.

- `VK_FORMAT_R8G8B8_SSCALED` specifies a three-component, 24-bit
  signed scaled format that has an 8-bit R component in byte 0, an 8-bit G
  component in byte 1, and an 8-bit B component in byte 2.

- `VK_FORMAT_R8G8B8_UINT` specifies a three-component, 24-bit unsigned
  integer format that has an 8-bit R component in byte 0, an 8-bit G
  component in byte 1, and an 8-bit B component in byte 2.

- `VK_FORMAT_R8G8B8_SINT` specifies a three-component, 24-bit signed
  integer format that has an 8-bit R component in byte 0, an 8-bit G
  component in byte 1, and an 8-bit B component in byte 2.

- `VK_FORMAT_R8G8B8_SRGB` specifies a three-component, 24-bit unsigned
  normalized format that has an 8-bit R component stored with sRGB
  nonlinear encoding in byte 0, an 8-bit G component stored with sRGB
  nonlinear encoding in byte 1, and an 8-bit B component stored with sRGB
  nonlinear encoding in byte 2.

- `VK_FORMAT_B8G8R8_UNORM` specifies a three-component, 24-bit
  unsigned normalized format that has an 8-bit B component in byte 0, an
  8-bit G component in byte 1, and an 8-bit R component in byte 2.

- `VK_FORMAT_B8G8R8_SNORM` specifies a three-component, 24-bit signed
  normalized format that has an 8-bit B component in byte 0, an 8-bit G
  component in byte 1, and an 8-bit R component in byte 2.

- `VK_FORMAT_B8G8R8_USCALED` specifies a three-component, 24-bit
  unsigned scaled format that has an 8-bit B component in byte 0, an 8-bit
  G component in byte 1, and an 8-bit R component in byte 2.

- `VK_FORMAT_B8G8R8_SSCALED` specifies a three-component, 24-bit
  signed scaled format that has an 8-bit B component in byte 0, an 8-bit G
  component in byte 1, and an 8-bit R component in byte 2.

- `VK_FORMAT_B8G8R8_UINT` specifies a three-component, 24-bit unsigned
  integer format that has an 8-bit B component in byte 0, an 8-bit G
  component in byte 1, and an 8-bit R component in byte 2.

- `VK_FORMAT_B8G8R8_SINT` specifies a three-component, 24-bit signed
  integer format that has an 8-bit B component in byte 0, an 8-bit G
  component in byte 1, and an 8-bit R component in byte 2.

- `VK_FORMAT_B8G8R8_SRGB` specifies a three-component, 24-bit unsigned
  normalized format that has an 8-bit B component stored with sRGB
  nonlinear encoding in byte 0, an 8-bit G component stored with sRGB
  nonlinear encoding in byte 1, and an 8-bit R component stored with sRGB
  nonlinear encoding in byte 2.

- `VK_FORMAT_R8G8B8A8_UNORM` specifies a four-component, 32-bit
  unsigned normalized format that has an 8-bit R component in byte 0, an
  8-bit G component in byte 1, an 8-bit B component in byte 2, and an
  8-bit A component in byte 3.

- `VK_FORMAT_R8G8B8A8_SNORM` specifies a four-component, 32-bit signed
  normalized format that has an 8-bit R component in byte 0, an 8-bit G
  component in byte 1, an 8-bit B component in byte 2, and an 8-bit A
  component in byte 3.

- `VK_FORMAT_R8G8B8A8_USCALED` specifies a four-component, 32-bit
  unsigned scaled format that has an 8-bit R component in byte 0, an 8-bit
  G component in byte 1, an 8-bit B component in byte 2, and an 8-bit A
  component in byte 3.

- `VK_FORMAT_R8G8B8A8_SSCALED` specifies a four-component, 32-bit
  signed scaled format that has an 8-bit R component in byte 0, an 8-bit G
  component in byte 1, an 8-bit B component in byte 2, and an 8-bit A
  component in byte 3.

- `VK_FORMAT_R8G8B8A8_UINT` specifies a four-component, 32-bit
  unsigned integer format that has an 8-bit R component in byte 0, an
  8-bit G component in byte 1, an 8-bit B component in byte 2, and an
  8-bit A component in byte 3.

- `VK_FORMAT_R8G8B8A8_SINT` specifies a four-component, 32-bit signed
  integer format that has an 8-bit R component in byte 0, an 8-bit G
  component in byte 1, an 8-bit B component in byte 2, and an 8-bit A
  component in byte 3.

- `VK_FORMAT_R8G8B8A8_SRGB` specifies a four-component, 32-bit
  unsigned normalized format that has an 8-bit R component stored with
  sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB
  nonlinear encoding in byte 1, an 8-bit B component stored with sRGB
  nonlinear encoding in byte 2, and an 8-bit A component in byte 3.

- `VK_FORMAT_B8G8R8A8_UNORM` specifies a four-component, 32-bit
  unsigned normalized format that has an 8-bit B component in byte 0, an
  8-bit G component in byte 1, an 8-bit R component in byte 2, and an
  8-bit A component in byte 3.

- `VK_FORMAT_B8G8R8A8_SNORM` specifies a four-component, 32-bit signed
  normalized format that has an 8-bit B component in byte 0, an 8-bit G
  component in byte 1, an 8-bit R component in byte 2, and an 8-bit A
  component in byte 3.

- `VK_FORMAT_B8G8R8A8_USCALED` specifies a four-component, 32-bit
  unsigned scaled format that has an 8-bit B component in byte 0, an 8-bit
  G component in byte 1, an 8-bit R component in byte 2, and an 8-bit A
  component in byte 3.

- `VK_FORMAT_B8G8R8A8_SSCALED` specifies a four-component, 32-bit
  signed scaled format that has an 8-bit B component in byte 0, an 8-bit G
  component in byte 1, an 8-bit R component in byte 2, and an 8-bit A
  component in byte 3.

- `VK_FORMAT_B8G8R8A8_UINT` specifies a four-component, 32-bit
  unsigned integer format that has an 8-bit B component in byte 0, an
  8-bit G component in byte 1, an 8-bit R component in byte 2, and an
  8-bit A component in byte 3.

- `VK_FORMAT_B8G8R8A8_SINT` specifies a four-component, 32-bit signed
  integer format that has an 8-bit B component in byte 0, an 8-bit G
  component in byte 1, an 8-bit R component in byte 2, and an 8-bit A
  component in byte 3.

- `VK_FORMAT_B8G8R8A8_SRGB` specifies a four-component, 32-bit
  unsigned normalized format that has an 8-bit B component stored with
  sRGB nonlinear encoding in byte 0, an 8-bit G component stored with sRGB
  nonlinear encoding in byte 1, an 8-bit R component stored with sRGB
  nonlinear encoding in byte 2, and an 8-bit A component in byte 3.

- `VK_FORMAT_A8B8G8R8_UNORM_PACK32` specifies a four-component, 32-bit
  packed unsigned normalized format that has an 8-bit A component in bits
  24..31, an 8-bit B component in bits 16..23, an 8-bit G component in
  bits 8..15, and an 8-bit R component in bits 0..7.

- `VK_FORMAT_A8B8G8R8_SNORM_PACK32` specifies a four-component, 32-bit
  packed signed normalized format that has an 8-bit A component in bits
  24..31, an 8-bit B component in bits 16..23, an 8-bit G component in
  bits 8..15, and an 8-bit R component in bits 0..7.

- `VK_FORMAT_A8B8G8R8_USCALED_PACK32` specifies a four-component,
  32-bit packed unsigned scaled integer format that has an 8-bit A
  component in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit
  G component in bits 8..15, and an 8-bit R component in bits 0..7.

- `VK_FORMAT_A8B8G8R8_SSCALED_PACK32` specifies a four-component,
  32-bit packed signed scaled integer format that has an 8-bit A component
  in bits 24..31, an 8-bit B component in bits 16..23, an 8-bit G
  component in bits 8..15, and an 8-bit R component in bits 0..7.

- `VK_FORMAT_A8B8G8R8_UINT_PACK32` specifies a four-component, 32-bit
  packed unsigned integer format that has an 8-bit A component in bits
  24..31, an 8-bit B component in bits 16..23, an 8-bit G component in
  bits 8..15, and an 8-bit R component in bits 0..7.

- `VK_FORMAT_A8B8G8R8_SINT_PACK32` specifies a four-component, 32-bit
  packed signed integer format that has an 8-bit A component in bits
  24..31, an 8-bit B component in bits 16..23, an 8-bit G component in
  bits 8..15, and an 8-bit R component in bits 0..7.

- `VK_FORMAT_A8B8G8R8_SRGB_PACK32` specifies a four-component, 32-bit
  packed unsigned normalized format that has an 8-bit A component in bits
  24..31, an 8-bit B component stored with sRGB nonlinear encoding in bits
  16..23, an 8-bit G component stored with sRGB nonlinear encoding in bits
  8..15, and an 8-bit R component stored with sRGB nonlinear encoding in
  bits 0..7.

- `VK_FORMAT_A2R10G10B10_UNORM_PACK32` specifies a four-component,
  32-bit packed unsigned normalized format that has a 2-bit A component in
  bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component
  in bits 10..19, and a 10-bit B component in bits 0..9.

- `VK_FORMAT_A2R10G10B10_SNORM_PACK32` specifies a four-component,
  32-bit packed signed normalized format that has a 2-bit A component in
  bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component
  in bits 10..19, and a 10-bit B component in bits 0..9.

- `VK_FORMAT_A2R10G10B10_USCALED_PACK32` specifies a four-component,
  32-bit packed unsigned scaled integer format that has a 2-bit A
  component in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit
  G component in bits 10..19, and a 10-bit B component in bits 0..9.

- `VK_FORMAT_A2R10G10B10_SSCALED_PACK32` specifies a four-component,
  32-bit packed signed scaled integer format that has a 2-bit A component
  in bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G
  component in bits 10..19, and a 10-bit B component in bits 0..9.

- `VK_FORMAT_A2R10G10B10_UINT_PACK32` specifies a four-component,
  32-bit packed unsigned integer format that has a 2-bit A component in
  bits 30..31, a 10-bit R component in bits 20..29, a 10-bit G component
  in bits 10..19, and a 10-bit B component in bits 0..9.

- `VK_FORMAT_A2R10G10B10_SINT_PACK32` specifies a four-component,
  32-bit packed signed integer format that has a 2-bit A component in bits
  30..31, a 10-bit R component in bits 20..29, a 10-bit G component in
  bits 10..19, and a 10-bit B component in bits 0..9.

- `VK_FORMAT_A2B10G10R10_UNORM_PACK32` specifies a four-component,
  32-bit packed unsigned normalized format that has a 2-bit A component in
  bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component
  in bits 10..19, and a 10-bit R component in bits 0..9.

- `VK_FORMAT_A2B10G10R10_SNORM_PACK32` specifies a four-component,
  32-bit packed signed normalized format that has a 2-bit A component in
  bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component
  in bits 10..19, and a 10-bit R component in bits 0..9.

- `VK_FORMAT_A2B10G10R10_USCALED_PACK32` specifies a four-component,
  32-bit packed unsigned scaled integer format that has a 2-bit A
  component in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit
  G component in bits 10..19, and a 10-bit R component in bits 0..9.

- `VK_FORMAT_A2B10G10R10_SSCALED_PACK32` specifies a four-component,
  32-bit packed signed scaled integer format that has a 2-bit A component
  in bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G
  component in bits 10..19, and a 10-bit R component in bits 0..9.

- `VK_FORMAT_A2B10G10R10_UINT_PACK32` specifies a four-component,
  32-bit packed unsigned integer format that has a 2-bit A component in
  bits 30..31, a 10-bit B component in bits 20..29, a 10-bit G component
  in bits 10..19, and a 10-bit R component in bits 0..9.

- `VK_FORMAT_A2B10G10R10_SINT_PACK32` specifies a four-component,
  32-bit packed signed integer format that has a 2-bit A component in bits
  30..31, a 10-bit B component in bits 20..29, a 10-bit G component in
  bits 10..19, and a 10-bit R component in bits 0..9.

- `VK_FORMAT_R16_UNORM` specifies a one-component, 16-bit unsigned
  normalized format that has a single 16-bit R component.

- `VK_FORMAT_R16_SNORM` specifies a one-component, 16-bit signed
  normalized format that has a single 16-bit R component.

- `VK_FORMAT_R16_USCALED` specifies a one-component, 16-bit unsigned
  scaled integer format that has a single 16-bit R component.

- `VK_FORMAT_R16_SSCALED` specifies a one-component, 16-bit signed
  scaled integer format that has a single 16-bit R component.

- `VK_FORMAT_R16_UINT` specifies a one-component, 16-bit unsigned
  integer format that has a single 16-bit R component.

- `VK_FORMAT_R16_SINT` specifies a one-component, 16-bit signed
  integer format that has a single 16-bit R component.

- `VK_FORMAT_R16_SFLOAT` specifies a one-component, 16-bit signed
  floating-point format that has a single 16-bit R component.

- `VK_FORMAT_R16G16_UNORM` specifies a two-component, 32-bit unsigned
  normalized format that has a 16-bit R component in bytes 0..1, and a
  16-bit G component in bytes 2..3.

- `VK_FORMAT_R16G16_SNORM` specifies a two-component, 32-bit signed
  normalized format that has a 16-bit R component in bytes 0..1, and a
  16-bit G component in bytes 2..3.

- `VK_FORMAT_R16G16_USCALED` specifies a two-component, 32-bit
  unsigned scaled integer format that has a 16-bit R component in bytes
  0..1, and a 16-bit G component in bytes 2..3.

- `VK_FORMAT_R16G16_SSCALED` specifies a two-component, 32-bit signed
  scaled integer format that has a 16-bit R component in bytes 0..1, and a
  16-bit G component in bytes 2..3.

- `VK_FORMAT_R16G16_UINT` specifies a two-component, 32-bit unsigned
  integer format that has a 16-bit R component in bytes 0..1, and a 16-bit
  G component in bytes 2..3.

- `VK_FORMAT_R16G16_SINT` specifies a two-component, 32-bit signed
  integer format that has a 16-bit R component in bytes 0..1, and a 16-bit
  G component in bytes 2..3.

- `VK_FORMAT_R16G16_SFLOAT` specifies a two-component, 32-bit signed
  floating-point format that has a 16-bit R component in bytes 0..1, and a
  16-bit G component in bytes 2..3.

- `VK_FORMAT_R16G16B16_UNORM` specifies a three-component, 48-bit
  unsigned normalized format that has a 16-bit R component in bytes 0..1,
  a 16-bit G component in bytes 2..3, and a 16-bit B component in bytes
  4..5.

- `VK_FORMAT_R16G16B16_SNORM` specifies a three-component, 48-bit
  signed normalized format that has a 16-bit R component in bytes 0..1, a
  16-bit G component in bytes 2..3, and a 16-bit B component in bytes
  4..5.

- `VK_FORMAT_R16G16B16_USCALED` specifies a three-component, 48-bit
  unsigned scaled integer format that has a 16-bit R component in bytes
  0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in
  bytes 4..5.

- `VK_FORMAT_R16G16B16_SSCALED` specifies a three-component, 48-bit
  signed scaled integer format that has a 16-bit R component in bytes
  0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in
  bytes 4..5.

- `VK_FORMAT_R16G16B16_UINT` specifies a three-component, 48-bit
  unsigned integer format that has a 16-bit R component in bytes 0..1, a
  16-bit G component in bytes 2..3, and a 16-bit B component in bytes
  4..5.

- `VK_FORMAT_R16G16B16_SINT` specifies a three-component, 48-bit
  signed integer format that has a 16-bit R component in bytes 0..1, a
  16-bit G component in bytes 2..3, and a 16-bit B component in bytes
  4..5.

- `VK_FORMAT_R16G16B16_SFLOAT` specifies a three-component, 48-bit
  signed floating-point format that has a 16-bit R component in bytes
  0..1, a 16-bit G component in bytes 2..3, and a 16-bit B component in
  bytes 4..5.

- `VK_FORMAT_R16G16B16A16_UNORM` specifies a four-component, 64-bit
  unsigned normalized format that has a 16-bit R component in bytes 0..1,
  a 16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5,
  and a 16-bit A component in bytes 6..7.

- `VK_FORMAT_R16G16B16A16_SNORM` specifies a four-component, 64-bit
  signed normalized format that has a 16-bit R component in bytes 0..1, a
  16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5,
  and a 16-bit A component in bytes 6..7.

- `VK_FORMAT_R16G16B16A16_USCALED` specifies a four-component, 64-bit
  unsigned scaled integer format that has a 16-bit R component in bytes
  0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes
  4..5, and a 16-bit A component in bytes 6..7.

- `VK_FORMAT_R16G16B16A16_SSCALED` specifies a four-component, 64-bit
  signed scaled integer format that has a 16-bit R component in bytes
  0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes
  4..5, and a 16-bit A component in bytes 6..7.

- `VK_FORMAT_R16G16B16A16_UINT` specifies a four-component, 64-bit
  unsigned integer format that has a 16-bit R component in bytes 0..1, a
  16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5,
  and a 16-bit A component in bytes 6..7.

- `VK_FORMAT_R16G16B16A16_SINT` specifies a four-component, 64-bit
  signed integer format that has a 16-bit R component in bytes 0..1, a
  16-bit G component in bytes 2..3, a 16-bit B component in bytes 4..5,
  and a 16-bit A component in bytes 6..7.

- `VK_FORMAT_R16G16B16A16_SFLOAT` specifies a four-component, 64-bit
  signed floating-point format that has a 16-bit R component in bytes
  0..1, a 16-bit G component in bytes 2..3, a 16-bit B component in bytes
  4..5, and a 16-bit A component in bytes 6..7.

- `VK_FORMAT_R32_UINT` specifies a one-component, 32-bit unsigned
  integer format that has a single 32-bit R component.

- `VK_FORMAT_R32_SINT` specifies a one-component, 32-bit signed
  integer format that has a single 32-bit R component.

- `VK_FORMAT_R32_SFLOAT` specifies a one-component, 32-bit signed
  floating-point format that has a single 32-bit R component.

- `VK_FORMAT_R32G32_UINT` specifies a two-component, 64-bit unsigned
  integer format that has a 32-bit R component in bytes 0..3, and a 32-bit
  G component in bytes 4..7.

- `VK_FORMAT_R32G32_SINT` specifies a two-component, 64-bit signed
  integer format that has a 32-bit R component in bytes 0..3, and a 32-bit
  G component in bytes 4..7.

- `VK_FORMAT_R32G32_SFLOAT` specifies a two-component, 64-bit signed
  floating-point format that has a 32-bit R component in bytes 0..3, and a
  32-bit G component in bytes 4..7.

- `VK_FORMAT_R32G32B32_UINT` specifies a three-component, 96-bit
  unsigned integer format that has a 32-bit R component in bytes 0..3, a
  32-bit G component in bytes 4..7, and a 32-bit B component in bytes
  8..11.

- `VK_FORMAT_R32G32B32_SINT` specifies a three-component, 96-bit
  signed integer format that has a 32-bit R component in bytes 0..3, a
  32-bit G component in bytes 4..7, and a 32-bit B component in bytes
  8..11.

- `VK_FORMAT_R32G32B32_SFLOAT` specifies a three-component, 96-bit
  signed floating-point format that has a 32-bit R component in bytes
  0..3, a 32-bit G component in bytes 4..7, and a 32-bit B component in
  bytes 8..11.

- `VK_FORMAT_R32G32B32A32_UINT` specifies a four-component, 128-bit
  unsigned integer format that has a 32-bit R component in bytes 0..3, a
  32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11,
  and a 32-bit A component in bytes 12..15.

- `VK_FORMAT_R32G32B32A32_SINT` specifies a four-component, 128-bit
  signed integer format that has a 32-bit R component in bytes 0..3, a
  32-bit G component in bytes 4..7, a 32-bit B component in bytes 8..11,
  and a 32-bit A component in bytes 12..15.

- `VK_FORMAT_R32G32B32A32_SFLOAT` specifies a four-component, 128-bit
  signed floating-point format that has a 32-bit R component in bytes
  0..3, a 32-bit G component in bytes 4..7, a 32-bit B component in bytes
  8..11, and a 32-bit A component in bytes 12..15.

- `VK_FORMAT_R64_UINT` specifies a one-component, 64-bit unsigned
  integer format that has a single 64-bit R component.

- `VK_FORMAT_R64_SINT` specifies a one-component, 64-bit signed
  integer format that has a single 64-bit R component.

- `VK_FORMAT_R64_SFLOAT` specifies a one-component, 64-bit signed
  floating-point format that has a single 64-bit R component.

- `VK_FORMAT_R64G64_UINT` specifies a two-component, 128-bit unsigned
  integer format that has a 64-bit R component in bytes 0..7, and a 64-bit
  G component in bytes 8..15.

- `VK_FORMAT_R64G64_SINT` specifies a two-component, 128-bit signed
  integer format that has a 64-bit R component in bytes 0..7, and a 64-bit
  G component in bytes 8..15.

- `VK_FORMAT_R64G64_SFLOAT` specifies a two-component, 128-bit signed
  floating-point format that has a 64-bit R component in bytes 0..7, and a
  64-bit G component in bytes 8..15.

- `VK_FORMAT_R64G64B64_UINT` specifies a three-component, 192-bit
  unsigned integer format that has a 64-bit R component in bytes 0..7, a
  64-bit G component in bytes 8..15, and a 64-bit B component in bytes
  16..23.

- `VK_FORMAT_R64G64B64_SINT` specifies a three-component, 192-bit
  signed integer format that has a 64-bit R component in bytes 0..7, a
  64-bit G component in bytes 8..15, and a 64-bit B component in bytes
  16..23.

- `VK_FORMAT_R64G64B64_SFLOAT` specifies a three-component, 192-bit
  signed floating-point format that has a 64-bit R component in bytes
  0..7, a 64-bit G component in bytes 8..15, and a 64-bit B component in
  bytes 16..23.

- `VK_FORMAT_R64G64B64A64_UINT` specifies a four-component, 256-bit
  unsigned integer format that has a 64-bit R component in bytes 0..7, a
  64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23,
  and a 64-bit A component in bytes 24..31.

- `VK_FORMAT_R64G64B64A64_SINT` specifies a four-component, 256-bit
  signed integer format that has a 64-bit R component in bytes 0..7, a
  64-bit G component in bytes 8..15, a 64-bit B component in bytes 16..23,
  and a 64-bit A component in bytes 24..31.

- `VK_FORMAT_R64G64B64A64_SFLOAT` specifies a four-component, 256-bit
  signed floating-point format that has a 64-bit R component in bytes
  0..7, a 64-bit G component in bytes 8..15, a 64-bit B component in bytes
  16..23, and a 64-bit A component in bytes 24..31.

- `VK_FORMAT_B10G11R11_UFLOAT_PACK32` specifies a three-component,
  32-bit packed unsigned floating-point format that has a 10-bit B
  component in bits 22..31, an 11-bit G component in bits 11..21, an
  11-bit R component in bits 0..10.
  See  and .

- `VK_FORMAT_E5B9G9R9_UFLOAT_PACK32` specifies a three-component,
  32-bit packed unsigned floating-point format that has a 5-bit shared
  exponent in bits 27..31, a 9-bit B component mantissa in bits 18..26, a
  9-bit G component mantissa in bits 9..17, and a 9-bit R component
  mantissa in bits 0..8.

- `VK_FORMAT_D16_UNORM` specifies a one-component, 16-bit unsigned
  normalized format that has a single 16-bit depth component.

- `VK_FORMAT_X8_D24_UNORM_PACK32` specifies a two-component, 32-bit
  format that has 24 unsigned normalized bits in the depth component and,
  :normative{type="optionally"}, 8 bits that are unused.

- `VK_FORMAT_D32_SFLOAT` specifies a one-component, 32-bit signed
  floating-point format that has 32 bits in the depth component.

- `VK_FORMAT_S8_UINT` specifies a one-component, 8-bit unsigned
  integer format that has 8 bits in the stencil component.

- `VK_FORMAT_D16_UNORM_S8_UINT` specifies a two-component, 24-bit
  format that has 16 unsigned normalized bits in the depth component and 8
  unsigned integer bits in the stencil component.

- `VK_FORMAT_D24_UNORM_S8_UINT` specifies a two-component, 32-bit
  packed format that has 8 unsigned integer bits in the stencil component,
  and 24 unsigned normalized bits in the depth component.

- `VK_FORMAT_D32_SFLOAT_S8_UINT` specifies a two-component format that
  has 32 signed float bits in the depth component and 8 unsigned integer
  bits in the stencil component.
  There are :normative{type="optionally"} 24 bits that are unused.

- `VK_FORMAT_BC1_RGB_UNORM_BLOCK` specifies a three-component,
  block-compressed format where each 64-bit compressed texel block encodes
  a 4×4 rectangle of unsigned normalized RGB texel data.
  This format has no alpha and is considered opaque.

- `VK_FORMAT_BC1_RGB_SRGB_BLOCK` specifies a three-component,
  block-compressed format where each 64-bit compressed texel block encodes
  a 4×4 rectangle of unsigned normalized RGB texel data with sRGB
  nonlinear encoding.
  This format has no alpha and is considered opaque.

- `VK_FORMAT_BC1_RGBA_UNORM_BLOCK` specifies a four-component,
  block-compressed format where each 64-bit compressed texel block encodes
  a 4×4 rectangle of unsigned normalized RGB texel data, and
  provides 1 bit of alpha.

- `VK_FORMAT_BC1_RGBA_SRGB_BLOCK` specifies a four-component,
  block-compressed format where each 64-bit compressed texel block encodes
  a 4×4 rectangle of unsigned normalized RGB texel data with sRGB
  nonlinear encoding, and provides 1 bit of alpha.

- `VK_FORMAT_BC2_UNORM_BLOCK` specifies a four-component,
  block-compressed format where each 128-bit compressed texel block
  encodes a 4×4 rectangle of unsigned normalized RGBA texel data
  with the first 64 bits encoding alpha values followed by 64 bits
  encoding RGB values.

- `VK_FORMAT_BC2_SRGB_BLOCK` specifies a four-component,
  block-compressed format where each 128-bit compressed texel block
  encodes a 4×4 rectangle of unsigned normalized RGBA texel data
  with the first 64 bits encoding alpha values followed by 64 bits
  encoding RGB values with sRGB nonlinear encoding.

- `VK_FORMAT_BC3_UNORM_BLOCK` specifies a four-component,
  block-compressed format where each 128-bit compressed texel block
  encodes a 4×4 rectangle of unsigned normalized RGBA texel data
  with the first 64 bits encoding alpha values followed by 64 bits
  encoding RGB values.

- `VK_FORMAT_BC3_SRGB_BLOCK` specifies a four-component,
  block-compressed format where each 128-bit compressed texel block
  encodes a 4×4 rectangle of unsigned normalized RGBA texel data
  with the first 64 bits encoding alpha values followed by 64 bits
  encoding RGB values with sRGB nonlinear encoding.

- `VK_FORMAT_BC4_UNORM_BLOCK` specifies a one-component,
  block-compressed format where each 64-bit compressed texel block encodes
  a 4×4 rectangle of unsigned normalized red texel data.

- `VK_FORMAT_BC4_SNORM_BLOCK` specifies a one-component,
  block-compressed format where each 64-bit compressed texel block encodes
  a 4×4 rectangle of signed normalized red texel data.

- `VK_FORMAT_BC5_UNORM_BLOCK` specifies a two-component,
  block-compressed format where each 128-bit compressed texel block
  encodes a 4×4 rectangle of unsigned normalized RG texel data with
  the first 64 bits encoding red values followed by 64 bits encoding green
  values.

- `VK_FORMAT_BC5_SNORM_BLOCK` specifies a two-component,
  block-compressed format where each 128-bit compressed texel block
  encodes a 4×4 rectangle of signed normalized RG texel data with
  the first 64 bits encoding red values followed by 64 bits encoding green
  values.

- `VK_FORMAT_BC6H_UFLOAT_BLOCK` specifies a three-component,
  block-compressed format where each 128-bit compressed texel block
  encodes a 4×4 rectangle of unsigned floating-point RGB texel data.

- `VK_FORMAT_BC6H_SFLOAT_BLOCK` specifies a three-component,
  block-compressed format where each 128-bit compressed texel block
  encodes a 4×4 rectangle of signed floating-point RGB texel data.

- `VK_FORMAT_BC7_UNORM_BLOCK` specifies a four-component,
  block-compressed format where each 128-bit compressed texel block
  encodes a 4×4 rectangle of unsigned normalized RGBA texel data.

- `VK_FORMAT_BC7_SRGB_BLOCK` specifies a four-component,
  block-compressed format where each 128-bit compressed texel block
  encodes a 4×4 rectangle of unsigned normalized RGBA texel data
  with sRGB nonlinear encoding applied to the RGB components.

- `VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK` specifies a three-component,
  ETC2 compressed format where each 64-bit compressed texel block encodes
  a 4×4 rectangle of unsigned normalized RGB texel data.
  This format has no alpha and is considered opaque.

- `VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK` specifies a three-component, ETC2
  compressed format where each 64-bit compressed texel block encodes a
  4×4 rectangle of unsigned normalized RGB texel data with sRGB
  nonlinear encoding.
  This format has no alpha and is considered opaque.

- `VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK` specifies a four-component,
  ETC2 compressed format where each 64-bit compressed texel block encodes
  a 4×4 rectangle of unsigned normalized RGB texel data, and
  provides 1 bit of alpha.

- `VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK` specifies a four-component,
  ETC2 compressed format where each 64-bit compressed texel block encodes
  a 4×4 rectangle of unsigned normalized RGB texel data with sRGB
  nonlinear encoding, and provides 1 bit of alpha.

- `VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK` specifies a four-component,
  ETC2 compressed format where each 128-bit compressed texel block encodes
  a 4×4 rectangle of unsigned normalized RGBA texel data with the
  first 64 bits encoding alpha values followed by 64 bits encoding RGB
  values.

- `VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK` specifies a four-component,
  ETC2 compressed format where each 128-bit compressed texel block encodes
  a 4×4 rectangle of unsigned normalized RGBA texel data with the
  first 64 bits encoding alpha values followed by 64 bits encoding RGB
  values with sRGB nonlinear encoding applied.

- `VK_FORMAT_EAC_R11_UNORM_BLOCK` specifies a one-component, ETC2
  compressed format where each 64-bit compressed texel block encodes a
  4×4 rectangle of unsigned normalized red texel data.

- `VK_FORMAT_EAC_R11_SNORM_BLOCK` specifies a one-component, ETC2
  compressed format where each 64-bit compressed texel block encodes a
  4×4 rectangle of signed normalized red texel data.

- `VK_FORMAT_EAC_R11G11_UNORM_BLOCK` specifies a two-component, ETC2
  compressed format where each 128-bit compressed texel block encodes a
  4×4 rectangle of unsigned normalized RG texel data with the first
  64 bits encoding red values followed by 64 bits encoding green values.

- `VK_FORMAT_EAC_R11G11_SNORM_BLOCK` specifies a two-component, ETC2
  compressed format where each 128-bit compressed texel block encodes a
  4×4 rectangle of signed normalized RG texel data with the first 64
  bits encoding red values followed by 64 bits encoding green values.

- `VK_FORMAT_ASTC_4x4_UNORM_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes a
  4×4 rectangle of unsigned normalized RGBA texel data.

- `VK_FORMAT_ASTC_4x4_SRGB_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes a
  4×4 rectangle of unsigned normalized RGBA texel data with sRGB
  nonlinear encoding applied to the RGB components.

- `VK_FORMAT_ASTC_5x4_UNORM_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes a
  5×4 rectangle of unsigned normalized RGBA texel data.

- `VK_FORMAT_ASTC_5x4_SRGB_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes a
  5×4 rectangle of unsigned normalized RGBA texel data with sRGB
  nonlinear encoding applied to the RGB components.

- `VK_FORMAT_ASTC_5x5_UNORM_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes a
  5×5 rectangle of unsigned normalized RGBA texel data.

- `VK_FORMAT_ASTC_5x5_SRGB_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes a
  5×5 rectangle of unsigned normalized RGBA texel data with sRGB
  nonlinear encoding applied to the RGB components.

- `VK_FORMAT_ASTC_6x5_UNORM_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes a
  6×5 rectangle of unsigned normalized RGBA texel data.

- `VK_FORMAT_ASTC_6x5_SRGB_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes a
  6×5 rectangle of unsigned normalized RGBA texel data with sRGB
  nonlinear encoding applied to the RGB components.

- `VK_FORMAT_ASTC_6x6_UNORM_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes a
  6×6 rectangle of unsigned normalized RGBA texel data.

- `VK_FORMAT_ASTC_6x6_SRGB_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes a
  6×6 rectangle of unsigned normalized RGBA texel data with sRGB
  nonlinear encoding applied to the RGB components.

- `VK_FORMAT_ASTC_8x5_UNORM_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes an
  8×5 rectangle of unsigned normalized RGBA texel data.

- `VK_FORMAT_ASTC_8x5_SRGB_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes an
  8×5 rectangle of unsigned normalized RGBA texel data with sRGB
  nonlinear encoding applied to the RGB components.

- `VK_FORMAT_ASTC_8x6_UNORM_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes an
  8×6 rectangle of unsigned normalized RGBA texel data.

- `VK_FORMAT_ASTC_8x6_SRGB_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes an
  8×6 rectangle of unsigned normalized RGBA texel data with sRGB
  nonlinear encoding applied to the RGB components.

- `VK_FORMAT_ASTC_8x8_UNORM_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes an
  8×8 rectangle of unsigned normalized RGBA texel data.

- `VK_FORMAT_ASTC_8x8_SRGB_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes an
  8×8 rectangle of unsigned normalized RGBA texel data with sRGB
  nonlinear encoding applied to the RGB components.

- `VK_FORMAT_ASTC_10x5_UNORM_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes a
  10×5 rectangle of unsigned normalized RGBA texel data.

- `VK_FORMAT_ASTC_10x5_SRGB_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes a
  10×5 rectangle of unsigned normalized RGBA texel data with sRGB
  nonlinear encoding applied to the RGB components.

- `VK_FORMAT_ASTC_10x6_UNORM_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes a
  10×6 rectangle of unsigned normalized RGBA texel data.

- `VK_FORMAT_ASTC_10x6_SRGB_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes a
  10×6 rectangle of unsigned normalized RGBA texel data with sRGB
  nonlinear encoding applied to the RGB components.

- `VK_FORMAT_ASTC_10x8_UNORM_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes a
  10×8 rectangle of unsigned normalized RGBA texel data.

- `VK_FORMAT_ASTC_10x8_SRGB_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes a
  10×8 rectangle of unsigned normalized RGBA texel data with sRGB
  nonlinear encoding applied to the RGB components.

- `VK_FORMAT_ASTC_10x10_UNORM_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes a
  10×10 rectangle of unsigned normalized RGBA texel data.

- `VK_FORMAT_ASTC_10x10_SRGB_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes a
  10×10 rectangle of unsigned normalized RGBA texel data with sRGB
  nonlinear encoding applied to the RGB components.

- `VK_FORMAT_ASTC_12x10_UNORM_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes a
  12×10 rectangle of unsigned normalized RGBA texel data.

- `VK_FORMAT_ASTC_12x10_SRGB_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes a
  12×10 rectangle of unsigned normalized RGBA texel data with sRGB
  nonlinear encoding applied to the RGB components.

- `VK_FORMAT_ASTC_12x12_UNORM_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes a
  12×12 rectangle of unsigned normalized RGBA texel data.

- `VK_FORMAT_ASTC_12x12_SRGB_BLOCK` specifies a four-component, ASTC
  compressed format where each 128-bit compressed texel block encodes a
  12×12 rectangle of unsigned normalized RGBA texel data with sRGB
  nonlinear encoding applied to the RGB components.



### Multi-planar Format Image Aspect

When using [VkImageAspectFlagBits](/man/VkImageAspectFlagBits) to select a plane of a multi-planar
format, the following are the valid options:

- Two planes





  * `VK_IMAGE_ASPECT_PLANE_0_BIT`

  * `VK_IMAGE_ASPECT_PLANE_1_BIT`

- Three planes





  * `VK_IMAGE_ASPECT_PLANE_0_BIT`

  * `VK_IMAGE_ASPECT_PLANE_1_BIT`

  * `VK_IMAGE_ASPECT_PLANE_2_BIT`





### Packed Formats

For the purposes of address alignment when accessing buffer memory
containing vertex attribute or texel data, the following formats are
considered *packed* - components of the texels or attributes are stored in
bitfields packed into one or more 8-, 16-, or 32-bit fundamental data type.

[{generated}/formats/packed.adoc]({generated}/formats/packed.adoc)





### Identification of Formats

A > format is represented by a single enum value.
The name of a format is usually built up by using the following pattern:



The component-format indicates either the size of the R, G, B, and A
components (if they are present) in the case of a color format, or the size
of the depth (D) and stencil (S) components (if they are present) in the
case of a depth/stencil format (see below).
An X indicates a component that is unused, but :normative{type="may"} be present for padding.





The suffix `_PACKnn` indicates that the format is packed into an
underlying type with `nn` bits.

The suffix `_BLOCK` indicates that the format is a block-compressed
format, with the representation of multiple pixels encoded interdependently
within a region.







### Representation and Texel Block Size

Color formats :normative{type="must"} be represented in memory in exactly the form indicated
by the format’s name.
This means that promoting one format to another with more bits per component
and/or additional components :normative{type="must"} not occur for color formats.
Depth/stencil formats have more relaxed requirements as discussed
below.

Each format has a *texel block size*, the number of bytes used to store one
*texel block* (a single addressable element of an uncompressed image, or a
single compressed block of a compressed image).
The texel block size for each format is shown in the
Compatible formats table.

The representation of non-packed formats is that the first component
specified in the name of the format is in the lowest memory addresses and
the last component specified is in the highest memory addresses.
See Byte mappings for non-packed/compressed color
formats.
The in-memory ordering of bytes within a component is determined by the host
endianness.



Packed formats store multiple components within one underlying type.
The bit representation is that the first component specified in the name of
the format is in the most-significant bits and the last component specified
is in the least-significant bits of the underlying type.
The in-memory ordering of bytes comprising the underlying type is determined
by the host endianness.











### Depth/Stencil Formats

Depth/stencil formats are considered opaque and need not be stored in the
exact number of bits per texel or component ordering indicated by the format
enum.
However, implementations :normative{type="must"} not substitute a different depth or stencil
precision than is described in the format (e.g. D16 :normative{type="must"} not be implemented
as D24 or D32).





### Format Compatibility Classes

Uncompressed color formats are *compatible* with each other if they occupy
the same number of bits per texel block
.
Compressed color formats are compatible with each other if the only
difference between them is the numeric format of
the uncompressed pixels.
Each depth/stencil format is only compatible with itself.
In the following table, all the formats in the
same row are compatible.
Each format has a defined *texel block extent* specifying how many texels
each texel block represents in each dimension.





#### Size Compatibility

Color formats with the same texel block size are considered
*size-compatible*.
If two size-compatible formats have different block extents (i.e. for
compressed formats), then an image with size A × B × C in
one format with a block extent of a × b × c can be
represented as an image with size X × Y × Z in the other
format with block extent x × y × z at the ratio between
the block extents for each format, where




::note
For example, a 7x3 image in the `VK_FORMAT_ASTC_8x5_UNORM_BLOCK` format
can be represented as a 1x1 `VK_FORMAT_R64G64_UINT` image.
::


Copy operations are able to copy between size-compatible formats in
different resources to enable manipulation of data in different formats.
The extent used in these copy operations always matches the source image,
and is resized to the expectations of the block extents noted above for the
destination image.









## Format Properties

To query supported format features which are properties of the physical
device, call:

[{generated}/api/protos/vkGetPhysicalDeviceFormatProperties.adoc]({generated}/api/protos/vkGetPhysicalDeviceFormatProperties.adoc)

- `physicalDevice` is the physical device from which to query the
  format properties.

- `format` is the format whose properties are queried.

- `pFormatProperties` is a pointer to a [VkFormatProperties](/man/VkFormatProperties)
  structure in which physical device properties for `format` are
  returned.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkGetPhysicalDeviceFormatProperties-physicalDevice-parameter"}
 `physicalDevice` :normative{type="must"} be a valid [VkPhysicalDevice](/man/VkPhysicalDevice) handle
::

::validity-field{name="VUID-vkGetPhysicalDeviceFormatProperties-format-parameter"}
 `format` :normative{type="must"} be a valid [VkFormat](/man/VkFormat) value
::

::validity-field{name="VUID-vkGetPhysicalDeviceFormatProperties-pFormatProperties-parameter"}
 `pFormatProperties` :normative{type="must"} be a valid pointer to a [VkFormatProperties](/man/VkFormatProperties) structure
::

::


The `VkFormatProperties` structure is defined as:

[{generated}/api/structs/VkFormatProperties.adoc]({generated}/api/structs/VkFormatProperties.adoc)

- `linearTilingFeatures` is a bitmask of [VkFormatFeatureFlagBits](/man/VkFormatFeatureFlagBits)
  specifying features supported by images created with a `tiling`
  parameter of `VK_IMAGE_TILING_LINEAR`.

- `optimalTilingFeatures` is a bitmask of
  [VkFormatFeatureFlagBits](/man/VkFormatFeatureFlagBits) specifying features supported by images
  created with a `tiling` parameter of `VK_IMAGE_TILING_OPTIMAL`.

- `bufferFeatures` is a bitmask of [VkFormatFeatureFlagBits](/man/VkFormatFeatureFlagBits)
  specifying features supported by buffers.


::note
If no format feature flags are supported, then the only possible use would
be image transfers - which alone are not useful.
As such, if no format feature flags are supported, the format itself is not
supported, and images of that format cannot be created.
::


If `format` is a block-compressed format, then `bufferFeatures`
:normative{type="must"} not support any features for the format.

Bits which :normative{type="can"} be set in the [VkFormatProperties](/man/VkFormatProperties) features
`linearTilingFeatures`, `optimalTilingFeatures`,
and `bufferFeatures` are:

[{generated}/api/enums/VkFormatFeatureFlagBits.adoc]({generated}/api/enums/VkFormatFeatureFlagBits.adoc)

These values
:normative{type="may"} be set in
`linearTilingFeatures` and `optimalTilingFeatures`,
specifying that the features are supported by images or
image views
created with the queried
[vkGetPhysicalDeviceFormatProperties](/man/vkGetPhysicalDeviceFormatProperties)::`format`:

- `VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT` specifies that an image view
  :normative{type="can"} be sampled from.

- `VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT` specifies that an image view
  :normative{type="can"} be used as a storage image.

- `VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT` specifies that an image
  view :normative{type="can"} be used as storage image that supports atomic operations.

- `VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT` specifies that an image
  view :normative{type="can"} be used as a framebuffer color attachment and as an input
  attachment.

- `VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT` specifies that an
  image view :normative{type="can"} be used as a framebuffer color attachment that supports
  blending.

- `VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT` specifies that an
  image view :normative{type="can"} be used as a framebuffer depth/stencil attachment and as
  an input attachment.

- `VK_FORMAT_FEATURE_BLIT_SRC_BIT` specifies that an image :normative{type="can"} be
  used as `srcImage` for the
  `vkCmdBlitImage` command.

- `VK_FORMAT_FEATURE_BLIT_DST_BIT` specifies that an image :normative{type="can"} be
  used as `dstImage` for the
  `vkCmdBlitImage` command.

- `VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT` specifies that
  if `VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT` is also set, an image view
  :normative{type="can"} be used with a sampler that has either of `magFilter` or
  `minFilter` set to `VK_FILTER_LINEAR`, or `mipmapMode` set
  to `VK_SAMPLER_MIPMAP_MODE_LINEAR`.
  If `VK_FORMAT_FEATURE_BLIT_SRC_BIT` is also set, an image can be
  used as the `srcImage` to
  `vkCmdBlitImage`
  with a `filter` of `VK_FILTER_LINEAR`.
  This bit :normative{type="must"} only be exposed for formats that also support the
  `VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT` or
  `VK_FORMAT_FEATURE_BLIT_SRC_BIT`.





  If the format being queried is a depth/stencil format, this bit only
  specifies that the depth aspect (not the stencil aspect) of an image of this
  format supports linear filtering, and that linear filtering of the depth
  aspect is supported whether depth compare is enabled in the sampler or not.
  Where depth comparison is supported it :normative{type="may"} be linear filtered whether this
  bit is present or not, but where this bit is not present the filtered value
  :normative{type="may"} be computed in an implementation-dependent manner which differs from
  the normal rules of linear filtering.
  The resulting value :normative{type="must"} be in the range \[0,1] and :normative{type="should"} be
  proportional to, or a weighted average of, the number of comparison passes
  or failures.

The following bits :normative{type="may"} be set in `bufferFeatures`, specifying that the
features are supported by buffers or buffer
views created with the queried
[vkGetPhysicalDeviceFormatProperties](/man/vkGetPhysicalDeviceFormatProperties)::`format`:

- `VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT` specifies that the
  format :normative{type="can"} be used to create a buffer view that :normative{type="can"} be bound to a
  `VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER` descriptor.

- `VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT` specifies that the
  format :normative{type="can"} be used to create a buffer view that :normative{type="can"} be bound to a
  `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` descriptor.

- `VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT` specifies that
  atomic operations are supported on
  `VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER` with this format.

- `VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT` specifies that the format :normative{type="can"}
  be used as a vertex attribute format
  (`VkVertexInputAttributeDescription`::`format`).


::note
`VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT` and
`VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT` are only intended to
be advertised for single-component formats, since SPIR-V atomic operations
require a scalar type.
::


[{generated}/api/flags/VkFormatFeatureFlags.adoc]({generated}/api/flags/VkFormatFeatureFlags.adoc)

`VkFormatFeatureFlags` is a bitmask type for setting a mask of zero or
more [VkFormatFeatureFlagBits](/man/VkFormatFeatureFlagBits).



### Potential Format Features

Some valid usage conditions depend on the format
features supported by a [VkImage](/man/VkImage) whose [VkImageTiling](/man/VkImageTiling) is unknown.
In such cases the exact [VkFormatFeatureFlagBits](/man/VkFormatFeatureFlagBits) supported by the
[VkImage](/man/VkImage) cannot be determined, so the valid usage conditions are
expressed in terms of the *potential format features* of the [VkImage](/man/VkImage)
format.

The *potential format features* of a [VkFormat](/man/VkFormat) are defined as follows:

- The union of [VkFormatFeatureFlagBits](/man/VkFormatFeatureFlagBits)
  supported when the [VkImageTiling](/man/VkImageTiling) is `VK_IMAGE_TILING_OPTIMAL`
  or `VK_IMAGE_TILING_LINEAR`







## Required Format Support

Implementations :normative{type="must"} support at least the following set of features on the
listed formats.
For images, these features :normative{type="must"} be supported for every [VkImageType](/man/VkImageType)
(including arrayed and cube variants) unless otherwise noted.
These features are supported on existing formats without needing to
advertise an extension or needing to explicitly enable them.
Support for additional functionality beyond the requirements listed here is
queried using the [vkGetPhysicalDeviceFormatProperties](/man/vkGetPhysicalDeviceFormatProperties) command.


::note
Unless otherwise excluded below, the required formats are supported for all
[VkImageCreateFlags](/man/VkImageCreateFlags) values as long as those flag values are otherwise
allowed.
::


The following tables show which feature bits :normative{type="must"} be supported for each
format.





















































### Formats Without Shader Storage Format

The device-level features for using a storage image or a storage texel
buffer with an image format of `Unknown`,
`shaderStorageImageReadWithoutFormat` and
`shaderStorageImageWriteWithoutFormat`, only apply to the following
formats:

- `VK_FORMAT_R8G8B8A8_UNORM`

- `VK_FORMAT_R8G8B8A8_SNORM`

- `VK_FORMAT_R8G8B8A8_UINT`

- `VK_FORMAT_R8G8B8A8_SINT`

- `VK_FORMAT_R32_UINT`

- `VK_FORMAT_R32_SINT`

- `VK_FORMAT_R32_SFLOAT`

- `VK_FORMAT_R32G32_UINT`

- `VK_FORMAT_R32G32_SINT`

- `VK_FORMAT_R32G32_SFLOAT`

- `VK_FORMAT_R32G32B32A32_UINT`

- `VK_FORMAT_R32G32B32A32_SINT`

- `VK_FORMAT_R32G32B32A32_SFLOAT`

- `VK_FORMAT_R16G16B16A16_UINT`

- `VK_FORMAT_R16G16B16A16_SINT`

- `VK_FORMAT_R16G16B16A16_SFLOAT`

- `VK_FORMAT_R16G16_SFLOAT`

- `VK_FORMAT_B10G11R11_UFLOAT_PACK32`

- `VK_FORMAT_R16_SFLOAT`

- `VK_FORMAT_R16G16B16A16_UNORM`

- `VK_FORMAT_A2B10G10R10_UNORM_PACK32`

- `VK_FORMAT_R16G16_UNORM`

- `VK_FORMAT_R8G8_UNORM`

- `VK_FORMAT_R16_UNORM`

- `VK_FORMAT_R8_UNORM`

- `VK_FORMAT_R16G16B16A16_SNORM`

- `VK_FORMAT_R16G16_SNORM`

- `VK_FORMAT_R8G8_SNORM`

- `VK_FORMAT_R16_SNORM`

- `VK_FORMAT_R8_SNORM`

- `VK_FORMAT_R16G16_SINT`

- `VK_FORMAT_R8G8_SINT`

- `VK_FORMAT_R16_SINT`

- `VK_FORMAT_R8_SINT`

- `VK_FORMAT_A2B10G10R10_UINT_PACK32`

- `VK_FORMAT_R16G16_UINT`

- `VK_FORMAT_R8G8_UINT`

- `VK_FORMAT_R16_UINT`

- `VK_FORMAT_R8_UINT`


::note
This list of formats is the union of required storage formats from
Required Format Support section and
formats listed in `shaderStorageImageExtendedFormats`.
::






### Format Feature Dependent Usage Flags

Certain resource usage flags depend on support for the corresponding format
feature flag for the format in question.
The following tables list the [VkBufferUsageFlagBits](/man/VkBufferUsageFlagBits) and
[VkImageUsageFlagBits](/man/VkImageUsageFlagBits) that have such dependencies, and the format
feature flags they depend on.
Additional restrictions, including, but not limited to, further required
format feature flags specific to the particular use of the resource :normative{type="may"}
apply, as described in the respective sections of this specification.













# Additional Capabilities

This chapter describes additional capabilities beyond the minimum
capabilities described in the Limits and Formats
chapters, including:

- Additional Image Capabilities



## Additional Image Capabilities

Additional image capabilities, such as larger dimensions or additional
sample counts for certain image types, or additional capabilities for
*linear* tiling format images, are described in this section.

To query additional capabilities specific to image types, call:

[{generated}/api/protos/vkGetPhysicalDeviceImageFormatProperties.adoc]({generated}/api/protos/vkGetPhysicalDeviceImageFormatProperties.adoc)

- `physicalDevice` is the physical device from which to query the
  image capabilities.

- `format` is a [VkFormat](/man/VkFormat) value specifying the image format,
  corresponding to [VkImageCreateInfo](/man/VkImageCreateInfo)::`format`.

- `type` is a [VkImageType](/man/VkImageType) value specifying the image type,
  corresponding to [VkImageCreateInfo](/man/VkImageCreateInfo)::`imageType`.

- `tiling` is a [VkImageTiling](/man/VkImageTiling) value specifying the image tiling,
  corresponding to [VkImageCreateInfo](/man/VkImageCreateInfo)::`tiling`.

- `usage` is a bitmask of [VkImageUsageFlagBits](/man/VkImageUsageFlagBits) specifying the
  intended usage of the image, corresponding to
  [VkImageCreateInfo](/man/VkImageCreateInfo)::`usage`.

- `flags` is a bitmask of [VkImageCreateFlagBits](/man/VkImageCreateFlagBits) specifying
  additional parameters of the image, corresponding to
  [VkImageCreateInfo](/man/VkImageCreateInfo)::`flags`.

- `pImageFormatProperties` is a pointer to a
  [VkImageFormatProperties](/man/VkImageFormatProperties) structure in which capabilities are
  returned.

The `format`, `type`, `tiling`, `usage`, and `flags`
parameters correspond to parameters that would be consumed by
[vkCreateImage](/man/vkCreateImage) (as members of [VkImageCreateInfo](/man/VkImageCreateInfo)).

If `format` is not a supported image format, or if the combination of
`format`, `type`, `tiling`, `usage`, and `flags` is not
supported for images, then `vkGetPhysicalDeviceImageFormatProperties`
returns `VK_ERROR_FORMAT_NOT_SUPPORTED`.

The limitations on an image format that are reported by
`vkGetPhysicalDeviceImageFormatProperties` have the following property:
if `usage1` and `usage2` of type [VkImageUsageFlags](/man/VkImageUsageFlags) are such that
the bits set in `usage1` are a subset of the bits set in `usage2`, and
`flags1` and `flags2` of type [VkImageCreateFlags](/man/VkImageCreateFlags) are such that
the bits set in `flags1` are a subset of the bits set in `flags2`,
then the limitations for `usage1` and `flags1` :normative{type="must"} be no more strict
than the limitations for `usage2` and `flags2`, for all values of
`format`, `type`, and `tiling`.


::validity-group{name="Valid Usage (Implicit)"}

::validity-field{name="VUID-vkGetPhysicalDeviceImageFormatProperties-physicalDevice-parameter"}
 `physicalDevice` :normative{type="must"} be a valid [VkPhysicalDevice](/man/VkPhysicalDevice) handle
::

::validity-field{name="VUID-vkGetPhysicalDeviceImageFormatProperties-format-parameter"}
 `format` :normative{type="must"} be a valid [VkFormat](/man/VkFormat) value
::

::validity-field{name="VUID-vkGetPhysicalDeviceImageFormatProperties-type-parameter"}
 `type` :normative{type="must"} be a valid [VkImageType](/man/VkImageType) value
::

::validity-field{name="VUID-vkGetPhysicalDeviceImageFormatProperties-tiling-parameter"}
 `tiling` :normative{type="must"} be a valid [VkImageTiling](/man/VkImageTiling) value
::

::validity-field{name="VUID-vkGetPhysicalDeviceImageFormatProperties-usage-parameter"}
 `usage` :normative{type="must"} be a valid combination of [VkImageUsageFlagBits](/man/VkImageUsageFlagBits) values
::

::validity-field{name="VUID-vkGetPhysicalDeviceImageFormatProperties-usage-requiredbitmask"}
 `usage` :normative{type="must"} not be `0`
::

::validity-field{name="VUID-vkGetPhysicalDeviceImageFormatProperties-flags-parameter"}
 `flags` :normative{type="must"} be a valid combination of [VkImageCreateFlagBits](/man/VkImageCreateFlagBits) values
::

::validity-field{name="VUID-vkGetPhysicalDeviceImageFormatProperties-pImageFormatProperties-parameter"}
 `pImageFormatProperties` :normative{type="must"} be a valid pointer to a [VkImageFormatProperties](/man/VkImageFormatProperties) structure
::

::




The `VkImageFormatProperties` structure is defined as:

[{generated}/api/structs/VkImageFormatProperties.adoc]({generated}/api/structs/VkImageFormatProperties.adoc)

- `maxExtent` are the maximum image dimensions.
  See the Allowed Extent Values section
  below for how these values are constrained by `type`.

- `maxMipLevels` is the maximum number of mipmap levels.
  `maxMipLevels` :normative{type="must"} be equal to the number of levels in the
  complete mipmap chain based on the `maxExtent.width`,
  `maxExtent.height`, and `maxExtent.depth`, except
  when one of the following conditions is true, in which case it :normative{type="may"}
  instead be `1`:





  * `vkGetPhysicalDeviceImageFormatProperties`::`tiling` was
    `VK_IMAGE_TILING_LINEAR`

- `maxArrayLayers` is the maximum number of array layers.
  `maxArrayLayers` :normative{type="must"} be no less than
  [VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits)::`maxImageArrayLayers`, except when one
  of the following conditions is true, in which case it :normative{type="may"} instead be
  `1`:





  * `tiling` is `VK_IMAGE_TILING_LINEAR`

  * `tiling` is `VK_IMAGE_TILING_OPTIMAL` and `type` is
    `VK_IMAGE_TYPE_3D`

- `sampleCounts` is a bitmask of [VkSampleCountFlagBits](/man/VkSampleCountFlagBits)
  specifying all the supported sample counts for this image as described
  below.

- `maxResourceSize` is an upper bound on the total image size in
  bytes, inclusive of all image subresources.
  Implementations :normative{type="may"} have an address space limit on total size of a
  resource, which is advertised by this property.
  `maxResourceSize` :normative{type="must"} be at least 2\<sup>31\</sup>.


::note
There is no mechanism to query the size of an image before creating it, to
compare that size against `maxResourceSize`.
If an application attempts to create an image that exceeds this limit, the
creation will fail and [vkCreateImage](/man/vkCreateImage) will return
`VK_ERROR_OUT_OF_DEVICE_MEMORY`.
While the advertised limit :normative{type="must"} be at least 2\<sup>31\</sup>, it :normative{type="may"} not be possible
to create an image that approaches that size, particularly for
`VK_IMAGE_TYPE_1D`.
::


If the combination of parameters to
`vkGetPhysicalDeviceImageFormatProperties` is not supported by the
implementation for use in [vkCreateImage](/man/vkCreateImage), then all members of
`VkImageFormatProperties` will be filled with zero.


::note
Filling `VkImageFormatProperties` with zero for unsupported formats is
an exception to the usual rule that output structures have undefined:
contents on error.
This exception was unintentional, but is preserved for backwards
compatibility.
::




### Supported Sample Counts

`vkGetPhysicalDeviceImageFormatProperties` returns a bitmask of
[VkSampleCountFlagBits](/man/VkSampleCountFlagBits) in `sampleCounts` specifying the supported
sample counts for the image parameters.

`sampleCounts` will be set to `VK_SAMPLE_COUNT_1_BIT` if at least
one of the following conditions is true:

- `tiling` is `VK_IMAGE_TILING_LINEAR`

- `type` is not `VK_IMAGE_TYPE_2D`

- `flags` contains `VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT`

- Neither the `VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT` flag nor the
  `VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT` flag in
  `VkFormatProperties`::`optimalTilingFeatures` returned by
  [vkGetPhysicalDeviceFormatProperties](/man/vkGetPhysicalDeviceFormatProperties) is set

Otherwise, the bits set in `sampleCounts` will be the sample counts
supported for the specified values of `usage` and `format`.
For each bit set in `usage`, the supported sample counts relate to the
limits in `VkPhysicalDeviceLimits` as follows:

- If `usage` includes `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT` and
  `format` is a floating- or fixed-point color format, a superset of
  `VkPhysicalDeviceLimits`::`framebufferColorSampleCounts`

- If `usage` includes
  `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`, and `format`
  includes a depth component, a superset of
  `VkPhysicalDeviceLimits`::`framebufferDepthSampleCounts`

- If `usage` includes
  `VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT`, and `format`
  includes a stencil component, a superset of
  `VkPhysicalDeviceLimits`::`framebufferStencilSampleCounts`

- If `usage` includes `VK_IMAGE_USAGE_SAMPLED_BIT`, and
  `format` includes a color component, a superset of
  `VkPhysicalDeviceLimits`::`sampledImageColorSampleCounts`

- If `usage` includes `VK_IMAGE_USAGE_SAMPLED_BIT`, and
  `format` includes a depth component, a superset of
  `VkPhysicalDeviceLimits`::`sampledImageDepthSampleCounts`

- If `usage` includes `VK_IMAGE_USAGE_SAMPLED_BIT`, and
  `format` is an integer format, a superset of
  `VkPhysicalDeviceLimits`::`sampledImageIntegerSampleCounts`

- If `usage` includes `VK_IMAGE_USAGE_STORAGE_BIT`, a superset of
  `VkPhysicalDeviceLimits`::`storageImageSampleCounts`

If multiple bits are set in `usage`, `sampleCounts` will be the
intersection of the per-usage values described above.

If none of the bits described above are set in `usage`, then there is no
corresponding limit in `VkPhysicalDeviceLimits`.
In this case, `sampleCounts` :normative{type="must"} include at least
`VK_SAMPLE_COUNT_1_BIT`.





### Allowed Extent Values Based on Image Type

Implementations :normative{type="may"} support extent values larger than the required minimum/maximum values for certain types of images.
[VkImageFormatProperties](/man/VkImageFormatProperties)::`maxExtent` for each type is subject to
the constraints below.


::note
Implementations :normative{type="must"} support images with dimensions up to the
required minimum/maximum values for all types of images.
It follows that the query for additional capabilities :normative{type="must"} return extent
values that are at least as large as the required values.
::


For `VK_IMAGE_TYPE_1D`:

- `maxExtent.width` ≥
  [VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits)::`maxImageDimension1D`

- `maxExtent.height` = 1

- `maxExtent.depth` = 1

For `VK_IMAGE_TYPE_2D` when `flags` does not contain
`VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT`:

- `maxExtent.width` ≥
  [VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits)::`maxImageDimension2D`

- `maxExtent.height` ≥
  [VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits)::`maxImageDimension2D`

- `maxExtent.depth` = 1

For `VK_IMAGE_TYPE_2D` when `flags` contains
`VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT`:

- `maxExtent.width` ≥
  [VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits)::`maxImageDimensionCube`

- `maxExtent.height` ≥
  [VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits)::`maxImageDimensionCube`

- `maxExtent.depth` = 1

For `VK_IMAGE_TYPE_3D`:

- `maxExtent.width` ≥
  [VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits)::`maxImageDimension3D`

- `maxExtent.height` ≥
  [VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits)::`maxImageDimension3D`

- `maxExtent.depth` ≥
  [VkPhysicalDeviceLimits](/man/VkPhysicalDeviceLimits)::`maxImageDimension3D`









# Debugging

To aid developers in tracking down errors in the application’s use of
Vulkan, particularly in combination with an external debugger or profiler,
*debugging extensions* may be available.

The [VkObjectType](/man/VkObjectType) enumeration defines values, each of which corresponds
to a specific Vulkan handle type.
These values :normative{type="can"} be used to associate debug information with a particular
type of object through one or more extensions.

[{generated}/api/enums/VkObjectType.adoc]({generated}/api/enums/VkObjectType.adoc)



If this Specification was generated with any such extensions included, they
will be described in the remainder of this chapter.

[{appendices}/spirvenv.adoc]({appendices}/spirvenv.adoc)

[{appendices}/compressedtex.adoc]({appendices}/compressedtex.adoc)

[{appendices}/versions.adoc]({appendices}/versions.adoc)

[{appendices}/extensions.adoc]({appendices}/extensions.adoc)

[{appendices}/boilerplate.adoc]({appendices}/boilerplate.adoc)

[{appendices}/invariance.adoc]({appendices}/invariance.adoc)

[{appendices}/glossary.adoc]({appendices}/glossary.adoc)

[{appendices}/credits.adoc]({appendices}/credits.adoc)



